<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>TSTNDA.DELIUS_APP_SCHEMA</title>
        <!-- Tell the browser to be responsive to screen width -->
        <meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport">
        <link rel="icon" type="image/png" sizes="16x16" href="../favicon.png">
        <!-- Bootstrap 3.3.5 -->
        <link rel="stylesheet" href="../bower/admin-lte/bootstrap/css/bootstrap.min.css">
        <!-- Font Awesome -->
        <link rel="stylesheet" href="../bower/font-awesome/css/font-awesome.min.css">
        <!-- Ionicons -->
        <link rel="stylesheet" href="../bower/ionicons/css/ionicons.min.css">
        <!-- DataTables -->
        <link rel="stylesheet" href="../bower/datatables.net-bs/css/dataTables.bootstrap.min.css">
        <link rel="stylesheet" href="../bower/datatables.net-buttons-bs/css/buttons.bootstrap.min.css">
        <!-- Code Mirror -->
        <link rel="stylesheet" href="../bower/codemirror/codemirror.css">
        <!-- Fonts -->
        <link href='../fonts/indieflower/indie-flower.css' rel='stylesheet' type='text/css'>
        <link href='../fonts/source-sans-pro/source-sans-pro.css' rel='stylesheet' type='text/css'>

        <!-- Theme style -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/AdminLTE.min.css">
        <!-- Salvattore -->
        <link rel="stylesheet" href="../bower/salvattore/salvattore.css">
        <!-- AdminLTE Skins. Choose a skin from the css/skins
           folder instead of downloading all of them to reduce the load. -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/skins/_all-skins.min.css">
        <!-- SchemaSpy -->
        <link rel="stylesheet" href="../schemaSpy.css">

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
        <script src="../bower/html5shiv/html5shiv.min.js"></script>
        <script src="../bower/respond/respond.min.js"></script>
        <![endif]-->
    </head>
    <!-- ADD THE CLASS layout-top-nav TO REMOVE THE SIDEBAR. -->
    <body class="hold-transition skin-blue layout-top-nav">
        <div class="wrapper">
            <header class="main-header">
                <nav class="navbar navbar-static-top">
                    <div class="container">
                        <div class="navbar-header">
                            <a href="../index.html" class="navbar-brand"><b>TSTNDA</b></a><span class="navbar-brand" style="padding-left: 0">.DELIUS_APP_SCHEMA</span>
                            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse"><i class="fa fa-bars"></i></button>
                        </div>

                        <!-- Collect the nav links, forms, and other content for toggling -->
                        <div class="collapse navbar-collapse pull-left" id="navbar-collapse">
                            <ul class="nav navbar-nav">
                                <li><a href="../index.html">Tables <span class="sr-only">(current)</span></a></li>
                                <li><a href="../columns.html" title="All of the columns in the schema">Columns</a></li>
                                <li><a href="../constraints.html" title="Useful for diagnosing error messages that just give constraint name or number">Constraints</a></li>
                                <li><a href="../relationships.html" title="Diagram of table relationships">Relationships</a></li>
                                <li><a href="../orphans.html" title="View of tables with neither parents nor children">Orphan&nbsp;Tables</a></li>
                                <li><a href="../anomalies.html" title="Things that might not be quite right">Anomalies</a></li>
                                <li><a href="../routines.html" title="Procedures and functions">Routines</a></li>
                            </ul>
                        </div>
                        <!-- /.navbar-collapse -->
                        <!-- Navbar Right Menu -->
                    </div>
                    <!-- /.container-fluid -->
                </nav>
            </header>
            <!-- Main content -->
            <!-- Full Width Column -->
            <div class="content-wrapper">
                <!-- Content Header (Page header) -->
                <section class="content-header">
                    <h1>DELIUS_APP_SCHEMA.PKG_PERF_COLLECTOR</h1><br />
                </section>
                <!-- Main content -->
                <section class="content">
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <span class="glyphicon glyphicon-list-alt" aria-hidden="true"></span>
                            <h3 id="Columns" class="box-title">Parameters</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <table id="standard_table" class="table table-bordered table-striped dataTable" role="grid">
                                <thead align='left'>
                                <tr>
                                    <th>Name</th>
                                    <th>Type</th>
                                    <th>Mode</th>
                                </tr>
                                </thead>
                                <tbody>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <i class="fa fa-file-code-o"></i>
                            <h3 id="RoutineDefinition" class="box-title">Definition</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <textarea id="sql-script-codemirror" name="sql-script-codemirror" rows="" style="display: none;">PACKAGE BODY PKG_PERF_COLLECTOR&#10;AS&#10;--&#10;&#10;--&#10;-- Package variables - used in information and error messaging&#10;--&#10;g_package_version CONSTANT VARCHAR2(30) :&#61; GC_VERSION;&#10;g_component_code  CONSTANT VARCHAR2(3)  :&#61; &#39;PRF&#39;;&#10;g_package_name    CONSTANT VARCHAR2(30) :&#61; &#39;PKG_PERF_COLLECTOR&#39;;&#10;g_instance_id     INTEGER :&#61; 0;&#10;--&#10;g_procedure_name  VARCHAR2(30)  :&#61; &#39;initial_value&#39;;&#10;g_label           VARCHAR2(6)   :&#61; &#39;000000&#39;;&#10;&#10;--&#10;-- message type&#10;mt_information    CONSTANT NUMBER :&#61; 1;&#10;mt_warning        CONSTANT NUMBER :&#61; 2;&#10;mt_error          CONSTANT NUMBER :&#61; 3;&#10;mt_fatal_error    CONSTANT NUMBER :&#61; 4;&#10;--&#10;&#10;--&#10;FUNCTION get_version RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN g_package_name || &#39;[version &#61;&gt; &#39; || g_package_version || &#39;]&#39;;&#10;END get_version;&#10;--***************************************************&#10;-- PKG_DEBUG wrappers                               *&#10;--***************************************************&#10;PROCEDURE procDebug(p_msg CLOB, p_print_flag VARCHAR2 DEFAULT &#39;N&#39;) IS&#10;BEGIN&#10;    PKG_Debug.procDebug(p_msg, p_print_flag);&#10;END procDebug;&#10;&#10;FUNCTION funcgetDebugMode RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Debug.funcgetDebugMode;&#10;END funcgetDebugMode;&#10;--&#10;&#10;--***************************************************&#10;-- PKG_COMMON wrappers                              *&#10;--***************************************************&#10;FUNCTION is_str_empty(p_str VARCHAR2, p_ignore_spaces_and_zeroes VARCHAR2 DEFAULT &#39;N&#39;) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.is_str_empty( p_str, p_ignore_spaces_and_zeroes );&#10;END is_str_empty;&#10;--&#10;FUNCTION empty2null(p_str VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.empty2null(p_str);&#10;END empty2null;&#10;&#10;FUNCTION nvlstr(p_str1 VARCHAR2, p_str2 VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;   RETURN PKG_Common.NVLSTR(p_str1 &#61;&gt; p_str1, p_str2 &#61;&gt; p_str2);&#10;END nvlstr;&#10;--&#10;--&#10;PROCEDURE raise_error(&#10;    error_code_in    IN PLS_INTEGER DEFAULT NULL,&#10;    error_message_in IN VARCHAR2 DEFAULT NULL)&#10;IS&#10;    l_error_code    PLS_INTEGER :&#61; NVL(error_code_in, SQLCODE);&#10;    l_error_message VARCHAR2(4000) :&#61; SUBSTR(NVLSTR(error_message_in, SQLERRM), 1, 4000);&#10;BEGIN&#10;    g_procedure_name :&#61; &#39;raise_error&#39;;&#10;    IF l_error_code BETWEEN -20999 AND -20000 THEN&#10;        RAISE_APPLICATION_ERROR (l_error_code, l_error_message);&#10;    ELSIF l_error_code &gt; 0 AND l_error_code NOT IN (1,100) THEN&#10;        RAISE_APPLICATION_ERROR (-20000, l_error_code||&#39; - &#39;||l_error_message);&#10;    ELSIF l_error_code IN (100, -1403) THEN&#10;        RAISE_APPLICATION_ERROR (-20000, l_error_code||&#39; - &#39;||l_error_message);&#10;    ELSIF l_error_code &lt;&gt; 0 THEN&#10;        RAISE_APPLICATION_ERROR(-20000, &#39;INTERNAL ERROR: An unexpected error in PL/SQL&#39;);&#10;    END IF;&#10;END raise_error;&#10;--&#10;--&#10;--***************************************************&#10;-- Helpers                                          *&#10;--***************************************************&#10;--&#10;-- Used to populate mtt_message_log with information type message&#10;PROCEDURE info (message_in VARCHAR2)&#10;IS&#10;BEGIN&#10;    IF SPGConfig.SPGInfoActive THEN&#10;        SPGConfig.insert_message_log(&#10;            message_type_id_in  &#61;&gt; mt_information,&#10;            component_code_in   &#61;&gt; g_component_code,&#10;            package_name_in     &#61;&gt; g_package_name,&#10;            procedure_name_in   &#61;&gt; g_procedure_name,&#10;            label_in            &#61;&gt; g_label,&#10;            message_text_in     &#61;&gt; message_in );&#10;    END IF;&#10;END info;&#10;--&#10;-- Will populate mtt_message_log with warning message - will populate mtt_error_log if result of exception&#10;PROCEDURE warn(message_in VARCHAR2) IS&#10;BEGIN&#10;    IF SPGConfig.SPGWarnActive THEN&#10;        SPGConfig.record_error(&#10;            message_type_id_in    &#61;&gt; mt_warning,&#10;            component_code_in     &#61;&gt; g_component_code,&#10;            package_name_in       &#61;&gt; g_package_name,&#10;            procedure_name_in     &#61;&gt; g_procedure_name,&#10;            label_in              &#61;&gt; g_label,&#10;            message_text_in       &#61;&gt; message_in );&#10;    END IF;&#10;END warn;&#10;--&#10;-- Will populate mtt_message_log with error message and populate mtt_error_log with exception - used for log and continue&#10;PROCEDURE error (message_in VARCHAR2)&#10;IS&#10;BEGIN&#10;    SPGConfig.record_error(&#10;        message_type_id_in    &#61;&gt; mt_error,&#10;        component_code_in     &#61;&gt; g_component_code,&#10;        package_name_in       &#61;&gt; g_package_name,&#10;        procedure_name_in     &#61;&gt; g_procedure_name,&#10;        label_in              &#61;&gt; g_label,&#10;        message_text_in       &#61;&gt; message_in);&#10;END error;&#10;--&#10;-- Will populate mtt_message_log, mtt_error_log with error message and raise exception - used for log and halt&#10;PROCEDURE fatal (message_in VARCHAR2)&#10;IS&#10;BEGIN&#10;    SPGConfig.record_error(&#10;        message_type_id_in    &#61;&gt; mt_fatal_error,&#10;        component_code_in     &#61;&gt; g_component_code,&#10;        package_name_in       &#61;&gt; g_package_name,&#10;        procedure_name_in     &#61;&gt; g_procedure_name,&#10;        label_in              &#61;&gt; g_label,&#10;        message_text_in       &#61;&gt; message_in,&#10;        raise_error_in        &#61;&gt; TRUE );&#10;END fatal;&#10;--&#10;PROCEDURE debug_msg(p_msg VARCHAR2) IS&#10;BEGIN&#10;    --DBMS_OUTPUT.put_line(p_msg);&#10;    info(p_msg);&#10;END debug_msg;&#10;&#10;--&#10;--***************************************************&#10;-- Package initialisation block                              *&#10;--***************************************************&#10;PROCEDURE do_init_vars IS&#10;BEGIN&#10;    --PKG_DynSQL.init_tab_info(p_reset_flag &#61;&gt; &#39;Y&#39;);&#10;    NULL;&#10;END do_init_vars;&#10;--&#10;--&#10;--***************************************************&#10;-- Main procedures and functions                    *&#10;--***************************************************&#10;FUNCTION strip_space( characters_in CLOB) RETURN CLOB&#10;IS&#10;BEGIN&#10;  RETURN REGEXP_REPLACE(characters_in, &#39;[[:space:]]+&#39;,&#39; &#39;);&#10;END strip_space;&#10;--&#10;--&#10;--&#10;&#10;&#10;--&#10;-- Custom Multi-threading support (using PKG_MThread) subroutines&#10;--&#10;PROCEDURE PRF_MT_stop_workers(p_component_id NUMBER DEFAULT GC_MASTER_COMPONENT_ID)&#10;IS&#10;    PRAGMA AUTONOMOUS_TRANSACTION;&#10;BEGIN&#10;    --&#10;    IF p_component_id NOT BETWEEN GC_MASTER_COMPONENT_ID AND GC_MASTER_COMPONENT_ID+0 THEN&#10;        raise_application_error(-20001, &#39;ERROR in PRF_MT_stop_workers: invalid P_COMPONENT_ID [&#39; || p_component_id || &#39;]&#39;);&#10;    END IF;&#10;    --&#10;    FOR l_i IN GC_MASTER_COMPONENT_ID..GC_MASTER_COMPONENT_ID+0 LOOP&#10;        IF NVL(p_component_id, l_i) &#61; l_i THEN&#10;            MERGE INTO pdt_semaphore t0&#10;            USING (&#10;              SELECT l_i AS component_code, &#39;STOP&#39; AS signal FROM dual&#10;            ) t1&#10;            ON (t0.component_code &#61; t1.component_code)&#10;            WHEN MATCHED     THEN UPDATE SET t0.signal &#61; t1.signal&#10;            WHEN NOT MATCHED THEN INSERT (component_code   , signal   ) VALUES&#10;                                         (t1.component_code, t1.signal);&#10;        END IF;&#10;    END LOOP;&#10;    COMMIT;&#10;END PRF_MT_stop_workers;&#10;--&#10;PROCEDURE PRF_MT_clear_stop_flags(p_component_id NUMBER DEFAULT GC_MASTER_COMPONENT_ID)&#10;IS&#10;    --&#10;    CURSOR cs IS&#10;      SELECT DISTINCT component_id, thread_id&#10;      FROM pdt_thread&#10;      WHERE status &#61; 2&#10;        AND component_id BETWEEN GC_MASTER_COMPONENT_ID AND GC_MASTER_COMPONENT_ID+0&#10;        AND NVL(p_component_id, component_id) &#61; component_id;&#10;    l_rec cs%ROWTYPE;&#10;    --&#10;    PRAGMA AUTONOMOUS_TRANSACTION;&#10;    --&#10;BEGIN&#10;    --&#10;    IF p_component_id NOT BETWEEN GC_MASTER_COMPONENT_ID AND GC_MASTER_COMPONENT_ID+0 THEN&#10;        raise_application_error(-20001, &#39;ERROR in PRF_MT_clear_stop_flags: invalid P_COMPONENT_ID [&#39; || p_component_id || &#39;]&#39;);&#10;    END IF;&#10;    --&#10;    DELETE FROM pdt_semaphore&#10;    WHERE component_code BETWEEN GC_MASTER_COMPONENT_ID AND GC_MASTER_COMPONENT_ID+0&#10;      AND ( component_code &#61; GC_MASTER_COMPONENT_ID OR&#10;            NVL(TO_CHAR(p_component_id), component_code) &#61; component_code&#10;          )&#10;    ;&#10;    COMMIT;&#10;    --&#10;    OPEN cs;&#10;    LOOP&#10;        FETCH cs INTO l_rec;&#10;        EXIT WHEN cs%NOTFOUND;&#10;        --&#10;        -- COMMIT will be implicitly issued from within the PKG_MThread.reset_threads API call&#10;        PKG_MThread.reset_threads(p_component_id&#61;&gt;l_rec.component_id, p_thread_id&#61;&gt;l_rec.thread_id, p_autonomous_trx&#61;&gt;&#39;N&#39;);&#10;        --&#10;    END LOOP;&#10;    CLOSE cs;&#10;    --&#10;    --COMMIT;&#10;    --&#10;END PRF_MT_clear_stop_flags;&#10;--&#10;PROCEDURE PRF_MT_create_scheduler_job(p_instance_number INTEGER DEFAULT NULL, p_DROP_ONLY_FLAG VARCHAR2 DEFAULT &#39;N&#39;)&#10;IS&#10;    --&#10;    l_job_name          CONSTANT VARCHAR2(30) :&#61; &#39;PRF_COLL_JOB&#39;;&#10;    l_program_name      CONSTANT VARCHAR2(30) :&#61; &#39;PRF_COLL_PROGRAM&#39;;&#10;    l_schedule_name     CONSTANT VARCHAR2(30) :&#61; &#39;PRF_COLL_SCHEDULE&#39;;&#10;    l_schedule_interval CONSTANT INTEGER      :&#61; 1; --LEAST( PKG_Lookups.funcgetNDParameterValue(GC_MT_prf_coll_INTERVAL, 1), 59); -- default 1 second; max 59 seconds&#10;    --&#10;    --PRAGMA AUTONOMOUS_TRANSACTION;&#10;    --&#10;    --&#10;BEGIN&#10;    --&#10;    PRF_MT_stop_workers;&#10;    DBMS_LOCK.sleep(10);&#10;    --&#10;    BEGIN&#10;        DBMS_SCHEDULER.drop_job(job_name &#61;&gt; l_job_name, force &#61;&gt; FALSE);&#10;    EXCEPTION WHEN OTHERS THEN&#10;        warn(&#39;Error dropping job [&#39; || l_job_name|| &#39;] &#39; || SQLERRM || &#39;[&#39; || SQLCODE || &#39;]&#39;);&#10;    END;&#10;    --&#10;    BEGIN&#10;        DBMS_SCHEDULER.drop_program(program_name &#61;&gt; l_program_name, force &#61;&gt; FALSE);&#10;    EXCEPTION WHEN OTHERS THEN&#10;        warn(&#39;Error dropping program [&#39;||l_program_name||&#39;] &#39;|| SQLERRM || &#39;[&#39; || SQLCODE || &#39;]&#39;);&#10;    END;&#10;    --&#10;    BEGIN&#10;        DBMS_SCHEDULER.drop_schedule(schedule_name &#61;&gt; l_schedule_name, force &#61;&gt; FALSE);&#10;    EXCEPTION WHEN OTHERS THEN&#10;        warn(&#39;Error dropping schedule [&#39; || l_schedule_name|| &#39;] &#39; || SQLERRM || &#39;[&#39; || SQLCODE || &#39;]&#39;);&#10;    END;&#10;    --&#10;    IF p_DROP_ONLY_FLAG &#61; &#39;Y&#39; THEN&#10;        PRF_MT_clear_stop_flags;&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    DBMS_SCHEDULER.CREATE_SCHEDULE(&#10;        schedule_name   &#61;&gt; l_schedule_name,&#10;        start_date      &#61;&gt; SYSDATE,&#10;        repeat_interval &#61;&gt; &#39;FREQ&#61;SECONDLY;INTERVAL&#61;&#39; || l_schedule_interval,&#10;        end_date        &#61;&gt; NULL,&#10;        comments        &#61;&gt; &#39;PRF Collector Schedule&#39; );&#10;    --&#10;    IF 1&#61;1 /*SPGConfig.PRFMultiThreadActive*/ THEN&#10;        --&#10;        DBMS_SCHEDULER.create_program(&#10;            program_name        &#61;&gt; l_program_name,&#10;            program_action      &#61;&gt; &#39;PKG_PERF_COLLECTOR.perf_collector_master&#39;,&#10;            program_type        &#61;&gt; &#39;stored_procedure&#39;,&#10;            number_of_arguments &#61;&gt; 0,&#10;            enabled             &#61;&gt; FALSE );&#10;        --&#10;--        DBMS_SCHEDULER.define_program_argument(&#10;--            program_name      &#61;&gt; l_program_name,&#10;--            argument_name     &#61;&gt; &#39;maxthreads_in&#39;,&#10;--            argument_position &#61;&gt; 1,&#10;--            argument_type     &#61;&gt; &#39;NUMBER&#39; );&#10;        --&#10;        DBMS_SCHEDULER.enable(name &#61;&gt; l_program_name);&#10;        --&#10;--  job_name                IN VARCHAR2,&#10;--  program_name            IN VARCHAR2,&#10;--  schedule_name           IN VARCHAR2,&#10;--  job_class               IN VARCHAR2              DEFAULT &#39;DEFAULT_JOB_CLASS&#39;,&#10;--  enabled                 IN BOOLEAN                  DEFAULT FALSE,&#10;--  auto_drop               IN BOOLEAN                  DEFAULT TRUE,&#10;--  comments                 IN VARCHAR2                 DEFAULT NULL,&#10;--  job_style               IN VARCHAR2                 DEFAULT &#39;REGULAR&#39;,&#10;--  credential_name         IN VARCHAR2                 DEFAULT NULL,&#10;--  destination_name        IN VARCHAR2                 DEFAULT NULL);&#10;&#10;        DBMS_SCHEDULER.create_job(&#10;            job_name      &#61;&gt; l_job_name,&#10;            program_name  &#61;&gt; l_program_name,&#10;            schedule_name &#61;&gt; l_schedule_name,&#10;            --job_type      &#61;&gt; &#39;PLSQL_BLOCK&#39;,&#10;            --start_date    &#61;&gt; SYSDATE,&#10;            enabled       &#61;&gt; FALSE,&#10;            auto_drop     &#61;&gt; TRUE,&#10;            comments      &#61;&gt; &#39;PERF_COLLECTOR_JOB&#39; );&#10;        --&#10;        IF p_instance_number IS NOT NULL THEN&#10;            -- Set job attribute to single instance number&#10;            DBMS_SCHEDULER.set_attribute(&#10;                name      &#61;&gt; l_job_name,&#10;                attribute &#61;&gt; &#39;instance_id&#39;,&#10;                value     &#61;&gt; p_instance_number );&#10;        END IF;&#10;        --&#10;        DBMS_SCHEDULER.set_attribute(&#10;            name      &#61;&gt; l_job_name,&#10;            attribute &#61;&gt; &#39;parallel_instances&#39;,&#10;            value     &#61;&gt; FALSE );&#10;        --&#10;    END IF;&#10;    --&#10;    /* YF: PG version only&#10;    UPDATE PGAGENT.pga_jobstep SET&#10;      jstonerror &#61; &#39;s&#39;&#10;    WHERE jstjobid &#61; ( SELECT jobid FROM PGAGENT.pga_job WHERE jobname &#61; l_job_name );&#10;    */&#10;    --&#10;    COMMIT;&#10;    --&#10;    DBMS_SCHEDULER.enable(l_job_name);&#10;    --&#10;    PRF_MT_clear_stop_flags;&#10;    --&#10;    --&#10;END PRF_MT_create_scheduler_job;&#10;--&#10;PROCEDURE PRF_MT_config(&#10;    p_MASTER_INTERVAL   NUMBER DEFAULT NULL,&#10;    p_MASTER_ITERATIONS INTEGER DEFAULT NULL,&#10;    --&#10;    p_STATS_FLAG_1      SMALLINT DEFAULT NULL,&#10;    p_STATS_FLAG_2      SMALLINT DEFAULT NULL,&#10;    p_STATS_FLAG_3      SMALLINT DEFAULT NULL,&#10;    p_STATS_FLAG_4      SMALLINT DEFAULT NULL,&#10;    --&#10;    p_STATS_THRESHOLD_1 NUMBER DEFAULT NULL,&#10;    p_STATS_THRESHOLD_2 NUMBER DEFAULT NULL,&#10;    p_STATS_THRESHOLD_3 NUMBER DEFAULT NULL,&#10;    p_STATS_THRESHOLD_4 NUMBER DEFAULT NULL,&#10;    --&#10;    p_DATA_RETENTION    NUMBER DEFAULT NULL,&#10;    p_DATA_SAMPLE_SIZE  INTEGER DEFAULT NULL )&#10;IS&#10;    --&#10;    PRAGMA AUTONOMOUS_TRANSACTION;&#10;    --&#10;    PROCEDURE do_set_nd_param(p_param VARCHAR2, p_value NUMBER) IS&#10;    BEGIN&#10;        IF p_value &gt;&#61; 0 THEN&#10;            MERGE INTO ND_PARAMETER t0&#10;            USING (&#10;                    SELECT UPPER(TRIM(p_param)) AS nd_parameter, p_value AS nd_value FROM dual&#10;                  ) t1&#10;            ON (t0.nd_parameter &#61; t1.nd_parameter)&#10;            WHEN MATCHED     THEN UPDATE SET t0.nd_value &#61; t1.nd_value&#10;            WHEN NOT MATCHED THEN INSERT (nd_parameter_id            , nd_parameter   , nd_value) VALUES&#10;                                         (nd_parameter_id_SEQ.nextval, t1.nd_parameter, t1.nd_value);&#10;        END IF;&#10;    END do_set_nd_param;&#10;    --&#10;    PROCEDURE do_set_nd_param(p_param VARCHAR2, p_value_str VARCHAR2) IS&#10;    BEGIN&#10;        IF p_value_str IS NOT NULL THEN&#10;            MERGE INTO ND_PARAMETER t0&#10;            USING (&#10;                    SELECT UPPER(TRIM(p_param)) AS nd_parameter, p_value_str AS nd_value_string FROM dual&#10;                  ) t1&#10;            ON (t0.nd_parameter &#61; t1.nd_parameter)&#10;            WHEN MATCHED     THEN UPDATE SET t0.nd_value_string &#61; t1.nd_value_string&#10;            WHEN NOT MATCHED THEN INSERT (nd_parameter_id            , nd_parameter   , nd_value_string) VALUES&#10;                                         (nd_parameter_id_SEQ.nextval, t1.nd_parameter, t1.nd_value_string);&#10;        END IF;&#10;    END do_set_nd_param;&#10;    --&#10;BEGIN&#10;    --&#10;    DELETE FROM nd_parameter WHERE nd_parameter IN (&#39;PRF_PURGE_RETENTION&#39;, &#39;PRF_MT_MASTER_WAIT&#39;);&#10;    DELETE FROM nd_parameter WHERE nd_parameter LIKE &#39;PRF_PRF%&#39;;&#10;    --&#10;    do_set_nd_param(GC_MT_PRF_COLL_INTERVAL  , p_MASTER_INTERVAL);&#10;    do_set_nd_param(GC_MT_PRF_COLL_ITERATIONS, p_MASTER_ITERATIONS);&#10;    --&#10;    do_set_nd_param(GC_MT_PRF_STATS_FLAG_1, p_STATS_FLAG_1);&#10;    do_set_nd_param(GC_MT_PRF_STATS_FLAG_2, p_STATS_FLAG_2);&#10;    do_set_nd_param(GC_MT_PRF_STATS_FLAG_3, p_STATS_FLAG_3);&#10;    do_set_nd_param(GC_MT_PRF_STATS_FLAG_4, p_STATS_FLAG_4);&#10;    --&#10;    do_set_nd_param(GC_PRF_STATS_THRESHOLD_1, p_STATS_THRESHOLD_1);&#10;    do_set_nd_param(GC_PRF_STATS_THRESHOLD_2, p_STATS_THRESHOLD_2);&#10;    do_set_nd_param(GC_PRF_STATS_THRESHOLD_3, p_STATS_THRESHOLD_3);&#10;    do_set_nd_param(GC_PRF_STATS_THRESHOLD_4, p_STATS_THRESHOLD_4);&#10;    --&#10;    do_set_nd_param(GC_PRF_DATA_SAMPLE_SIZE, p_DATA_SAMPLE_SIZE);&#10;    do_set_nd_param(GC_PRF_DATA_RETENTION  , p_DATA_RETENTION);&#10;    --&#10;    COMMIT;&#10;    --&#10;END PRF_MT_config;&#10;&#10;--&#10;-- PRF Master Process&#10;--&#10;&#10;--&#10;FUNCTION get_max_threads RETURN INTEGER IS&#10;BEGIN&#10;    --&#10;    RETURN GC_MASTER_MAX_THREADS;&#10;    --&#10;END get_max_threads;&#10;--&#10;FUNCTION get_max_perf_run_id(l_stats_type VARCHAR2) RETURN NUMBER&#10;IS&#10;    l_prev_prf_collector_run_id NUMBER;&#10;BEGIN&#10;    SELECT MAX(prf_collector_run_id) INTO l_prev_prf_collector_run_id&#10;    FROM prf_collector&#10;    WHERE stats_type &#61; l_stats_type;&#10;    --&#10;    RETURN NVL(l_prev_prf_collector_run_id, -1);&#10;EXCEPTION WHEN NO_DATA_FOUND THEN&#10;    RETURN -1;&#10;END get_max_perf_run_id;&#10;--&#10;PROCEDURE perf_collector_master&#10;IS&#10;    --&#10;    l_procedure_name VARCHAR2(30) :&#61; g_procedure_name;&#10;    --&#10;    l_lock_name   VARCHAR2(30) :&#61; &#39;PERF_COLLECTOR_MASTER_LOCK&#39;;&#10;    l_lock_handle VARCHAR2(128);&#10;    l_dummy       PLS_INTEGER;&#10;    --&#10;    l_wait              INTEGER :&#61; LEAST( PKG_Lookups.funcgetNDParameterValue(GC_MT_PRF_COLL_INTERVAL, 0), 3600/2);   -- default 0 second; max 30 minutes&#10;    l_stats_1_flag      BOOLEAN;&#10;    l_stats_2_flag      BOOLEAN;&#10;    l_stats_3_flag      BOOLEAN;&#10;    l_stats_4_flag      BOOLEAN;&#10;    --&#10;    l_max_iterations       INTEGER :&#61; LEAST( PKG_Lookups.funcgetNDParameterValue(GC_MT_PRF_COLL_ITERATIONS, 5), 1000);   -- default 5 iterations; max 1000&#10;    l_iteration            INTEGER :&#61; 0;&#10;    --&#10;    l_thread_id            INTEGER;&#10;    l_thread_status        INTEGER;&#10;    l_all_threads_finished BOOLEAN;&#10;    l_thread_label         VARCHAR2(30);&#10;    --&#10;    l_action_id            SMALLINT;&#10;    --&#10;    l_max_threads          INTEGER;&#10;    l_program_action       VARCHAR2(512);&#10;    --&#10;    PROCEDURE do_allocate_soft_lock IS&#10;    BEGIN&#10;        DBMS_LOCK.allocate_unique(l_lock_name, l_lock_handle);&#10;        l_dummy :&#61; DBMS_LOCK.request(l_lock_handle, DBMS_LOCK.x_mode, DBMS_LOCK.maxwait, FALSE);&#10;    END do_allocate_soft_lock;&#10;    --&#10;    PROCEDURE do_release_soft_lock IS&#10;    BEGIN&#10;        l_dummy :&#61; DBMS_LOCK.release(l_lock_handle);&#10;    END do_release_soft_lock;&#10;    --&#10;BEGIN&#10;    --&#10;    g_procedure_name :&#61; &#39;perf_collector_master&#39;;&#10;    --&#10;    IF NOT SPGConfig.PRFMultiThreadActive THEN&#10;        info(&#39;perf_collector_master: SPGConfig.PRFMultiThreadActive is set to FALSE&#39;);&#10;        RETURN;&#10;    END IF;&#10;    IF PKG_MTHREAD.check_semaphore( p_component_code&#61;&gt;TO_CHAR(GC_MASTER_COMPONENT_ID), p_signal&#61;&gt;&#39;STOP&#39; ) &#61; &#39;Y&#39; THEN&#10;        info(&#39;perf_collector_master: PRF Run semaphore is set to STOP&#39;);&#10;        RETURN;&#10;    END IF;&#10;    IF NVL(l_wait, 0) &lt;&#61; 0 THEN&#10;        info(&#39;perf_collector_master: GC_MT_PRF_COLL_INTERVAL parameter is set to &lt;&#61; 0 value&#39;);&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    do_allocate_soft_lock;&#10;    --&#10;    l_stats_1_flag :&#61; (PKG_Lookups.funcgetNDParameterValue(GC_MT_PRF_STATS_FLAG_1, 1) &lt;&gt; 0);&#10;    l_stats_2_flag :&#61; (PKG_Lookups.funcgetNDParameterValue(GC_MT_PRF_STATS_FLAG_2, 1) &lt;&gt; 0);&#10;    l_stats_3_flag :&#61; (PKG_Lookups.funcgetNDParameterValue(GC_MT_PRF_STATS_FLAG_3, 1) &lt;&gt; 0);&#10;    l_stats_4_flag :&#61; (PKG_Lookups.funcgetNDParameterValue(GC_MT_PRF_STATS_FLAG_4, 1) &lt;&gt; 0);&#10;    --&#10;    l_max_threads :&#61; get_max_threads;&#10;    --&#10;    info(&#39;perf_collector_master: &#39; ||&#10;        &#39;[max_threads&#61;&#39; || l_max_threads || &#39;]&#39; ||&#10;        &#39;[stats_1&#61;&#39; || PKG_Common.bool_2_char(l_stats_1_flag) || &#39;]&#39; ||&#10;        &#39;[stats_2&#61;&#39; || PKG_Common.bool_2_char(l_stats_2_flag) || &#39;]&#39; ||&#10;        &#39;[stats_3&#61;&#39; || PKG_Common.bool_2_char(l_stats_3_flag) || &#39;]&#39; ||&#10;        &#39;[stats_4&#61;&#39; || PKG_Common.bool_2_char(l_stats_4_flag) || &#39;]&#39; );&#10;    --&#10;    LOOP&#10;        --&#10;        IF SPGConfig.SPGInfoActive THEN&#10;            PKG_Debug.procrecordDbStats_START;&#10;        END IF;&#10;        --&#10;        IF l_iteration &#61; 0 THEN&#10;            IF l_wait &gt; 1 THEN&#10;                SYS.DBMS_LOCK.sleep(l_wait-1); -- 1 second has already been waited for (by DBMS_SCHEDULER job)&#10;            END IF;&#10;        ELSE&#10;            SYS.DBMS_LOCK.sleep(l_wait);&#10;        END IF;&#10;        l_all_threads_finished :&#61; TRUE;&#10;        --&#10;        FOR l_thread_id IN 1..l_max_threads LOOP&#10;            --&#10;            --&#10;            --PKG_MThread.wait_for_threads_to_finish( p_component_id&#61;&gt;GC_MASTER_COMPONENT_ID, p_thread_id&#61;&gt;l_thread_id, p_wait&#61;&gt;0.5 );&#10;            --&#10;            l_action_id :&#61; l_thread_id - 1; -- 0-PRF Purge Job; PRF Collect (1-BUFF GETS; 2-CPU Wait; 3-I/O&#10;            --&#10;            IF NOT ( ( l_action_id &#61; 1 AND l_stats_1_flag ) OR&#10;                     ( l_action_id &#61; 2 AND l_stats_2_flag ) OR&#10;                     ( l_action_id &#61; 3 AND l_stats_3_flag ) OR&#10;                     ( l_action_id &#61; 4 AND l_stats_4_flag ) OR&#10;                     ( l_action_id &#61; 0)&#10;                    )&#10;            THEN&#10;                --info(&#39;PKG_PERF_COLLECTOR.perf_collector_master[&#39; || GC_MASTER_COMPONENT_ID || &#39;][&#39; || l_thread_id || &#39;] thread is DISABLED&#39;);&#10;                NULL;&#10;            ELSE&#10;                --&#10;                l_thread_status :&#61; PKG_MThread.get_thread_status( GC_MASTER_COMPONENT_ID, l_thread_id );&#10;                --&#10;                IF l_thread_status &#61; 1 THEN&#10;                    -- Master Thread is still running&#10;                    --PKG_MTHREAD.check_heartbeat_ALL(GC_MASTER_COMPONENT_ID, l_thread_id);&#10;                    --&#10;                    l_all_threads_finished :&#61; FALSE;&#10;                ELSIF l_thread_status IN( -1, 3 ) THEN -- Completed successfully&#10;                    --&#10;                    l_all_threads_finished :&#61; FALSE;&#10;                    --&#10;                    l_program_action :&#61;&#10;                       &#39;BEGIN&#10;                            PKG_PERF_COLLECTOR.perf_collector_worker(&#10;                                p_component_id&#61;&gt;&#39; || GC_MASTER_COMPONENT_ID || &#39;,&#10;                                p_thread_id&#61;&gt;&#39; || l_thread_id || &#39;,&#10;                                p_action_id&#61;&gt;&#39; || l_action_id || &#39;);&#10;                        END;&#39;;&#10;                    --&#10;                    l_thread_label :&#61; CASE WHEN l_action_id&#61;0 THEN &#39;PRF_PURGE&#39; ELSE &#39;PRF_COLLECT_&#39; || l_action_id END;&#10;                    --&#10;                    --debug_msg(&#39;submit the [&#39; || l_thread_label || &#39;] worker job&#39;);&#10;                    --&#10;                    PKG_MTHREAD.create_thread_process(&#10;                        p_component_id      &#61;&gt; GC_MASTER_COMPONENT_ID,&#10;                        p_thread_id         &#61;&gt; l_thread_id,&#10;                        p_program_action    &#61;&gt; l_program_action,&#10;                        p_job_name          &#61;&gt; &#39;PRF Collector Master Worker (&#39; || l_thread_label || &#39;)&#39;,&#10;                        p_thread_label      &#61;&gt; l_thread_label,&#10;                        p_instance_number   &#61;&gt; 1 );&#10;                    --&#10;                ELSIF l_thread_status &#61; 2 THEN -- Completed with ERROR&#10;                    warn(&#10;                        &#39;PKG_PERF_COLLECTOR.perf_collector_master[&#39; || GC_MASTER_COMPONENT_ID || &#39;][&#39; || l_thread_id || &#39;] thread status &#61; 2 detected: &#39; || CHR(10) ||&#10;                        PKG_Lookups.funcgetTabRecord(&#10;                            p_table &#61;&gt; &#39;PDT_THREAD&#39;,&#10;                            p_ref_col     &#61;&gt; &#39;component_id&#39;,&#10;                            p_ref_val     &#61;&gt; TO_CHAR(GC_MASTER_COMPONENT_ID),&#10;                            p_where       &#61;&gt; &#39;thread_id &#61; TO_NUMBER(:p_thread_id)&#39;,&#10;                            p_bind_var1   &#61;&gt; TO_CHAR(l_thread_id),&#10;                            p_data_fld    &#61;&gt; &#39;SUBSTR(&#39;&#39;[INFO&#61;&#39;&#39; || info_message || &#39;&#39;][ERRM&#61;&#39;&#39; || error_message || &#39;&#39;]&#39;&#39;, 1, 4000)&#39; ) );&#10;                END IF;&#10;                --&#10;            END IF;&#10;            --&#10;        END LOOP;&#10;        --&#10;        --EXIT WHEN l_all_threads_finished &#61; TRUE;&#10;        --&#10;        IF SPGConfig.SPGInfoActive THEN&#10;            info(&#39;perf_collector_master: iteration &#39; || l_iteration || &#39; completed (&#39; || PKG_Debug.funcgetDbStats || &#39;)&#39;);&#10;        END IF;&#10;        --&#10;        l_iteration :&#61; l_iteration + 1;&#10;        --&#10;        EXIT WHEN l_iteration &gt; l_max_iterations;&#10;        EXIT WHEN PKG_MTHREAD.check_semaphore( p_component_code&#61;&gt;TO_CHAR(GC_MASTER_COMPONENT_ID), p_signal&#61;&gt;&#39;STOP&#39; ) &#61; &#39;Y&#39;;&#10;        --&#10;    END LOOP;&#10;    --&#10;    info(&#39;perf_collector_master: PRF Collector Master Process has completed [max iterations&#61;&#39; || l_max_iterations || &#39;]&#39;);&#10;    --&#10;    do_release_soft_lock;&#10;    --&#10;    g_procedure_name :&#61; l_procedure_name;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    --&#10;    do_release_soft_lock;&#10;    --&#10;    g_procedure_name :&#61; l_procedure_name;&#10;    --&#10;    RAISE;&#10;    --&#10;END perf_collector_master;&#10;--&#10;PROCEDURE perf_collector_worker(&#10;    p_component_id PDT_THREAD.component_id%TYPE,&#10;    p_thread_id    PDT_THREAD.thread_id%TYPE,&#10;    p_action_id    SMALLINT )&#10;IS&#10;    --&#10;    l_procedure_name VARCHAR2(30) :&#61; g_procedure_name;&#10;    --&#10;    l_lock_name   VARCHAR2(30) :&#61; &#39;PERF_COLLECTOR_WORKER_LOCK_&#39; || p_thread_id;&#10;    l_lock_handle VARCHAR2(128);&#10;    l_dummy       PLS_INTEGER;&#10;    --&#10;    PROCEDURE do_allocate_soft_lock IS&#10;    BEGIN&#10;        DBMS_LOCK.allocate_unique(l_lock_name, l_lock_handle);&#10;        l_dummy :&#61; DBMS_LOCK.request(l_lock_handle, DBMS_LOCK.x_mode, DBMS_LOCK.maxwait, FALSE);&#10;    END do_allocate_soft_lock;&#10;    --&#10;    PROCEDURE do_release_soft_lock IS&#10;    BEGIN&#10;        l_dummy :&#61; DBMS_LOCK.release(l_lock_handle);&#10;    END do_release_soft_lock;&#10;    --&#10;    PROCEDURE do_purge_old_data&#10;    IS&#10;        --&#10;        l_procedure_name1 VARCHAR2(30) :&#61; g_procedure_name;&#10;        --&#10;        l_data_retention NUMBER :&#61; LEAST( PKG_Lookups.funcgetNDParameterValue(GC_PRF_DATA_RETENTION, 3), 30);   -- default 3 days; max 30 days&#10;        --&#10;        l_rows     INTEGER :&#61; 0;&#10;        l_rows_tot INTEGER :&#61; 0;&#10;        --&#10;        FUNCTION get_retention_char(p_val NUMBER, p_unit VARCHAR2) RETURN VARCHAR2&#10;        IS&#10;            l_str VARCHAR2(100);&#10;        BEGIN&#10;            l_str :&#61; TO_CHAR(p_val);&#10;            RETURN&#10;                CASE WHEN NOT ( l_str &#61; &#39;0&#39; OR SUBSTR(l_str, 1, 1) &#61; &#39;.&#39; )&#10;                    THEN l_str || p_unit&#10;                END;&#10;        END get_retention_char;&#10;        --&#10;    BEGIN&#10;        --&#10;        g_procedure_name :&#61; &#39;do_purge_old_data&#39;;&#10;        --&#10;        info(&#39;start: data retention &#61; &#39; ||&#10;            PKG_LstUtl.concat(&#10;                get_retention_char(ROUND(l_data_retention*24*60*60, 2), &#39;sec&#39;),&#10;                get_retention_char(ROUND(l_data_retention*24*60   , 2), &#39;min&#39;),&#10;                get_retention_char(ROUND(l_data_retention*24      , 2), &#39;hr&#39;),&#10;                get_retention_char(ROUND(l_data_retention         , 2), &#39;d&#39;),&#10;                p_delim &#61;&gt; &#39; / &#39; )&#10;        );&#10;        --&#10;        LOOP&#10;            --&#10;            DELETE FROM prf_collector&#10;            WHERE created_datetime &lt; SYSDATE - l_data_retention&#10;              AND ROWNUM &lt;&#61; 100;&#10;            l_rows :&#61; NVL(SQL%ROWCOUNT, 0);&#10;            COMMIT;&#10;            --&#10;            l_rows_tot :&#61; l_rows_tot + l_rows;&#10;            --&#10;            PKG_MTHREAD.update_thread_progress(&#10;                p_component_id   &#61;&gt; p_component_id,&#10;                p_thread_id      &#61;&gt; p_thread_id,&#10;                p_info_msg       &#61;&gt; &#39;Total Rows deleted: [&#39; || l_rows_tot,&#10;                p_current_id_val &#61;&gt; p_action_id );&#10;            --&#10;            EXIT WHEN l_rows &lt;&#61; 0;&#10;            --&#10;        END LOOP;&#10;        --&#10;        info(l_rows_tot || &#39; rows deleted from PRF_COLLECTOR table&#39;);&#10;        -- Temp: Wait for 5 seconds&#10;        --SYS.DBMS_LOCK.sleep(5);&#10;        --&#10;        g_procedure_name :&#61; l_procedure_name1;&#10;        --&#10;    END do_purge_old_data;&#10;    --&#10;    PROCEDURE do_gather_perf_stats&#10;    IS&#10;        --&#10;        l_procedure_name1 VARCHAR2(30) :&#61; g_procedure_name;&#10;        --&#10;        l_data_sample_size  NUMBER :&#61; LEAST( PKG_Lookups.funcgetNDParameterValue(GC_PRF_DATA_SAMPLE_SIZE, 10), 100 );   -- default 10 records; max 10 records&#10;        --&#10;        l_prf_collector_run_id      NUMBER;&#10;        l_prev_prf_collector_run_id NUMBER;&#10;        l_stats_type prf_collector.stats_type%TYPE :&#61;&#10;            CASE&#10;                WHEN p_action_id &#61; 1 THEN &#39;GETS&#39;&#10;                WHEN p_action_id &#61; 2 THEN &#39;CPU&#39;&#10;                WHEN p_action_id &#61; 3 THEN &#39;I/O&#39;&#10;                WHEN p_action_id &#61; 4 THEN &#39;DISK&#39;&#10;                ELSE &#39;U&#39;&#10;            END;&#10;        --&#10;        l_created_datetime DATE :&#61; SYSDATE;&#10;        --&#10;        l_threshold NUMBER;&#10;        --&#10;    BEGIN&#10;        --&#10;        g_procedure_name :&#61; &#39;do_gather_perf_stats(&#39; || p_action_id || &#39;)&#39;;&#10;        --&#10;        g_label :&#61; &#39;100000&#39;;&#10;        --&#10;        l_threshold :&#61;&#10;            PKG_Lookups.funcgetNDParameterValue(&#10;                CASE&#10;                    WHEN p_action_id &#61; 1 THEN GC_PRF_STATS_THRESHOLD_1&#10;                    WHEN p_action_id &#61; 2 THEN GC_PRF_STATS_THRESHOLD_2&#10;                    WHEN p_action_id &#61; 3 THEN GC_PRF_STATS_THRESHOLD_3&#10;                    WHEN p_action_id &#61; 4 THEN GC_PRF_STATS_THRESHOLD_4&#10;                END,&#10;                0 );&#10;        --&#10;        info(&#39;start [action ID&#61;&#39; || p_action_id || &#39;][component_id&#61;&#39; || p_component_id || &#39;][thread_id&#61;&#39; || p_thread_id || &#39;][stats threshold&#61;&#39; || l_threshold || &#39;]&#39;);&#10;        --&#10;        PKG_MTHREAD.update_thread_progress(&#10;            p_component_id    &#61;&gt; p_component_id,&#10;            p_thread_id       &#61;&gt; p_thread_id,&#10;            p_info_msg        &#61;&gt; &#39;Submitting [&#39; || p_action_id || &#39;]&#39;,&#10;            p_current_id_val  &#61;&gt; p_action_id );&#10;        --&#10;        l_prev_prf_collector_run_id :&#61; get_max_perf_run_id(l_stats_type);&#10;        l_prf_collector_run_id      :&#61; prf_collector_run_id_SEQ.nextval;&#10;        --&#10;        INSERT INTO prf_collector(&#10;          prf_collector_ID,&#10;          prf_collector_run_id,&#10;          prev_prf_collector_run_id,&#10;          row_num,&#10;          stats_type,&#10;          created_datetime,&#10;          --&#10;          /*01*/ sid,&#10;          /*02*/ serial#,&#10;          /*03*/ executions,&#10;          /*04*/ users_executing,&#10;          /*05*/ disk_reads,&#10;          /*06*/ buffer_gets,&#10;          /*07*/ cpu_time,&#10;          /*08*/ user_io_wait_time,&#10;          /*09*/ rows_processed,&#10;          /*10*/ fetches,&#10;          /*11*/ invalidations,&#10;          /*12*/ kept_versions,&#10;          /*13*/ loaded_versions,&#10;          /*14*/ version_count,&#10;          --&#10;          /*15*/ machine,&#10;          /*16*/ osuser,&#10;          /*17*/ module,&#10;          /*18*/ program,&#10;          /*19*/ username,&#10;          /*20*/ client_identifier,&#10;          /*21*/ sql_id,&#10;          /*22*/ address,&#10;          /*23*/ hash_value,&#10;          /*24*/ old_hash_value,&#10;          /*25*/ plan_hash_value,&#10;          /*26*/ plsql_exec_time,&#10;          /*27*/ parse_calls,&#10;          /*28*/ runtime_mem,&#10;          /*29*/ sql_profile,&#10;          --&#10;          /*30*/ sql_text )&#10;        --&#10;        WITH T AS (&#10;          SELECT&#10;            /*01*/ S.sid,&#10;            /*02*/ S.serial#,&#10;            /*03*/ SA.executions,&#10;            /*04*/ SA.users_executing,&#10;            /*05*/ SA.disk_reads,&#10;            /*06*/ SA.buffer_gets,&#10;            /*07*/ SA.cpu_time,&#10;            /*08*/ SA.user_io_wait_time,&#10;            /*09*/ SA.rows_processed,&#10;            /*10*/ SA.fetches,&#10;            /*11*/ SA.invalidations,&#10;            /*12*/ SA.kept_versions,&#10;            /*13*/ SA.loaded_versions,&#10;            /*14*/ SA.version_count,&#10;            --&#10;            /*15*/ S.machine,&#10;            /*16*/ S.osuser,&#10;            /*17*/ S.module,&#10;            /*18*/ S.program,&#10;            /*19*/ SUBSTR(S.username, 1, 128) AS username,&#10;            /*20*/ S.client_identifier,&#10;            /*21*/ SA.sql_id,&#10;            /*22*/ SA.address,&#10;            /*23*/ SA.hash_value,&#10;            /*24*/ SA.old_hash_value,&#10;            /*25*/ SA.plan_hash_value,&#10;            /*26*/ SA.plsql_exec_time,&#10;            /*27*/ SA.parse_calls,&#10;            /*28*/ SA.runtime_mem,&#10;            /*29*/ SA.sql_profile,&#10;            --&#10;            /*30*/ SA.sql_text&#10;          FROM&#10;            gv$sqlarea SA,&#10;            gv$session S&#10;          WHERE S.sql_address(+) &#61; SA.address&#10;            AND SA.users_executing &gt; 0&#10;            --AND S.sid &lt;&gt; SYS_CONTEXT(&#39;USERENV&#39;, &#39;SID&#39;)&#10;            AND ( l_threshold &lt;&#61; 0 OR&#10;                  ( l_threshold &gt; 0 AND&#10;                    CASE&#10;                        WHEN p_action_id &#61; 1 THEN buffer_gets/DECODE(executions, 0, 1, executions)&#10;                        WHEN p_action_id &#61; 2 THEN cpu_time/DECODE(executions, 0, 1, executions)&#10;                        WHEN p_action_id &#61; 3 THEN user_io_wait_time/DECODE(executions, 0, 1, executions)&#10;                        WHEN p_action_id &#61; 4 THEN disk_reads/DECODE(executions, 0, 1, executions)&#10;                        ELSE -1&#10;                    END &gt;&#61; l_threshold&#10;                  )&#10;                )&#10;          ORDER BY&#10;            DECODE(p_action_id,&#10;                1, buffer_gets/DECODE(executions, 0, 1, executions),&#10;                2, cpu_time/DECODE(executions, 0, 1, executions),&#10;                3, user_io_wait_time/DECODE(executions, 0, 1, executions),&#10;                4, disk_reads/DECODE(executions, 0, 1, executions),&#10;                (cpu_time+user_io_wait_time)/DECODE(executions, 0, 1, executions)&#10;            ) DESC&#10;        )&#10;        SELECT&#10;          prf_collector_ID_SEQ.nextval,&#10;          l_prf_collector_run_id,&#10;          NVL(l_prev_prf_collector_run_id, -1),&#10;          ROWNUM,&#10;          l_stats_type,&#10;          l_created_datetime,&#10;          --&#10;          /*01*/ sid,&#10;          /*02*/ serial#,&#10;          /*03*/ executions,&#10;          /*04*/ users_executing,&#10;          /*05*/ disk_reads,&#10;          /*06*/ buffer_gets,&#10;          /*07*/ cpu_time,&#10;          /*08*/ user_io_wait_time,&#10;          /*09*/ rows_processed,&#10;          /*10*/ fetches,&#10;          /*11*/ invalidations,&#10;          /*12*/ kept_versions,&#10;          /*13*/ loaded_versions,&#10;          /*14*/ version_count,&#10;          --&#10;          /*15*/ machine,&#10;          /*16*/ osuser,&#10;          /*17*/ module,&#10;          /*18*/ program,&#10;          /*19*/ username,&#10;          /*20*/ client_identifier,&#10;          /*21*/ sql_id,&#10;          /*22*/ address,&#10;          /*23*/ hash_value,&#10;          /*24*/ old_hash_value,&#10;          /*25*/ plan_hash_value,&#10;          /*26*/ plsql_exec_time,&#10;          /*27*/ parse_calls,&#10;          /*28*/ runtime_mem,&#10;          /*29*/ sql_profile,&#10;          --&#10;          /*30*/ sql_text&#10;        FROM T&#10;        WHERE ROWNUM &lt;&#61; l_data_sample_size;&#10;        --&#10;        info(SQL%ROWCOUNT || &#39; rows inserted into PRF_COLLECTOR table&#39;);&#10;        --&#10;        COMMIT;&#10;        --&#10;        PKG_MTHREAD.update_thread_progress(&#10;            p_component_id    &#61;&gt; p_component_id,&#10;            p_thread_id       &#61;&gt; p_thread_id,&#10;            p_info_msg        &#61;&gt; &#39;Completed [&#39; || p_action_id || &#39;]&#39;,&#10;            p_current_id_val  &#61;&gt; p_action_id );&#10;        --&#10;        g_procedure_name :&#61; l_procedure_name1;&#10;        --&#10;    END do_gather_perf_stats;&#10;    --&#10;BEGIN&#10;    --&#10;    g_procedure_name :&#61; &#39;perf_collector_worker&#39;;&#10;    --&#10;    IF SPGConfig.SPGInfoActive THEN&#10;        PKG_Debug.procrecordDbStats_START;&#10;    END IF;&#10;    --&#10;    IF NVL(p_action_id, -1) NOT IN (0, 1, 2, 3, 4) THEN&#10;        --&#10;        warn( &#39;WARNING: P_ACTION_ID [&#39; || p_action_id || &#39;] is expected to be set to a value within the [0-4] range&#39; );&#10;        PKG_MTHREAD.update_thread_progress(&#10;            p_component_id    &#61;&gt; p_component_id,&#10;            p_thread_id       &#61;&gt; p_thread_id,&#10;            p_info_msg        &#61;&gt; &#39;Completed with WARNING: P_ACTION_ID [&#39; || p_action_id || &#39;] is expected to be set to a value within the [0-5] range&#39;,&#10;            p_current_id_val  &#61;&gt; p_action_id );&#10;    ELSE&#10;        PKG_MTHREAD.update_thread_status(&#10;            p_component_id  &#61;&gt; p_component_id,&#10;            p_thread_id     &#61;&gt; p_thread_id,&#10;            p_status        &#61;&gt; 1,&#10;            p_info_msg      &#61;&gt; &#39;Worker Commenced [&#39; || TO_CHAR(p_action_id) || &#39;]&#39; );&#10;        --&#10;        IF p_action_id &#61; 0 THEN&#10;            do_purge_old_data;&#10;        ELSE&#10;            do_gather_perf_stats;&#10;        END IF;&#10;        --&#10;        PKG_MTHREAD.update_thread_status(&#10;            p_component_id  &#61;&gt; p_component_id,&#10;            p_thread_id     &#61;&gt; p_thread_id,&#10;            p_status        &#61;&gt; 3,&#10;            p_info_msg      &#61;&gt; &#39;Worker Completed [&#39; || TO_CHAR(p_action_id) || &#39;]&#39; );&#10;        --&#10;    END IF;&#10;    --&#10;    IF SPGConfig.SPGInfoActive THEN&#10;        info(&#39;PRF Worker &#39; || p_action_id || &#39; completed (&#39; || PKG_Debug.funcgetDbStats || &#39;)&#39;);&#10;    END IF;&#10;    --&#10;    g_procedure_name :&#61; l_procedure_name;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    --&#10;    warn(&#10;        &#39;ERROR [action ID&#61;&#39; || p_action_id || &#39;][component_id&#61;&#39; || p_component_id || &#39;][thread_id&#61;&#39; || p_thread_id || &#39;]: &#39; ||&#10;        SUBSTRB(SQLERRM || CHR(10) || DBMS_UTILITY.format_error_backtrace, 1, 4000) );&#10;    --&#10;    PKG_MTHREAD.update_thread_status(&#10;        p_component_id  &#61;&gt; p_component_id,&#10;        p_thread_id     &#61;&gt; p_thread_id,&#10;        p_status        &#61;&gt; 2,&#10;        p_err_msg       &#61;&gt; SUBSTRB(SQLERRM || CHR(10) || DBMS_UTILITY.format_error_backtrace, 1, 4000),&#10;        p_info_msg      &#61;&gt; &#39;Worker Error [&#39; || TO_CHAR(p_action_id) || &#39;]&#39;,&#10;        p_run_fixit_job &#61;&gt; &#39;N&#39; );&#10;    --&#10;    g_procedure_name :&#61; l_procedure_name;&#10;    --&#10;END perf_collector_worker;&#10;--&#10;&#10;--&#10;--&#10;-- PLSQL package Initialisation block&#10;--&#10;BEGIN&#10;    --&#10;    PKG_Global.do_init;&#10;    --&#10;    do_init_vars;&#10;    --&#10;END PKG_PERF_COLLECTOR;</textarea>
                        </div>
                    </div>
                </section>
            </div>
            <!-- /.content-wrapper -->
            <footer class="main-footer">
                <div>
                    <div class="pull-right hidden-xs">
                        <a href="https://github.com/schemaspy/schemaspy" title="GitHub for SchemaSpy"><i class="fa fa-github-square fa-2x"></i></a>
                        <a href="http://stackoverflow.com/questions/tagged/schemaspy" title="StackOverflow for SchemaSpy"><i class="fa fa-stack-overflow fa-2x"></i></a>
                    </div>
                    <strong>Generated by <a href="http://schemaspy.org/" class="logo-text"><i class="fa fa-database"></i> SchemaSpy 6.2.4</a></strong>
                </div>
                <!-- /.container -->
            </footer>
        </div>
        <!-- ./wrapper -->

        <!-- jQuery 2.2.3 -->
        <script src="../bower/admin-lte/plugins/jQuery/jquery-2.2.3.min.js"></script>
        <script src="../bower/admin-lte/plugins/jQueryUI/jquery-ui.min.js"></script>
        <!-- Bootstrap 3.3.5 -->
        <script src="../bower/admin-lte/bootstrap/js/bootstrap.min.js"></script>
        <!-- DataTables -->
        <script src="../bower/datatables.net/jquery.dataTables.min.js"></script>
        <script src="../bower/datatables.net-bs/js/dataTables.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/dataTables.buttons.min.js"></script>
        <script src="../bower/datatables.net-buttons-bs/js/buttons.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.html5.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.print.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.colVis.min.js"></script>
        <!-- SheetJS -->
        <script src="../bower/js-xlsx/xlsx.full.min.js"></script>
        <!-- pdfmake -->
        <script src="../bower/pdfmake/pdfmake.min.js"></script>
        <script src="../bower/pdfmake/vfs_fonts.js"></script>
        <!-- SlimScroll -->
        <script src="../bower/admin-lte/plugins/slimScroll/jquery.slimscroll.min.js"></script>
        <!-- FastClick -->
        <script src="../bower/admin-lte/plugins/fastclick/fastclick.js"></script>
        <!-- Salvattore -->
        <script src="../bower/salvattore/salvattore.min.js"></script>
        <!-- AnchorJS -->
        <script src="../bower/anchor-js/anchor.min.js"></script>
        <!-- CodeMirror -->
        <script src="../bower/codemirror/codemirror.js"></script>
        <script src="../bower/codemirror/sql.js"></script>
        <!-- AdminLTE App -->
        <script src="../bower/admin-lte/dist/js/app.min.js"></script>
        <script src="routine.js"></script>
        <script src="../schemaSpy.js"></script>
    </body>
</html>