<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>TSTNDA.DELIUS_APP_SCHEMA</title>
        <!-- Tell the browser to be responsive to screen width -->
        <meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport">
        <link rel="icon" type="image/png" sizes="16x16" href="../favicon.png">
        <!-- Bootstrap 3.3.5 -->
        <link rel="stylesheet" href="../bower/admin-lte/bootstrap/css/bootstrap.min.css">
        <!-- Font Awesome -->
        <link rel="stylesheet" href="../bower/font-awesome/css/font-awesome.min.css">
        <!-- Ionicons -->
        <link rel="stylesheet" href="../bower/ionicons/css/ionicons.min.css">
        <!-- DataTables -->
        <link rel="stylesheet" href="../bower/datatables.net-bs/css/dataTables.bootstrap.min.css">
        <link rel="stylesheet" href="../bower/datatables.net-buttons-bs/css/buttons.bootstrap.min.css">
        <!-- Code Mirror -->
        <link rel="stylesheet" href="../bower/codemirror/codemirror.css">
        <!-- Fonts -->
        <link href='../fonts/indieflower/indie-flower.css' rel='stylesheet' type='text/css'>
        <link href='../fonts/source-sans-pro/source-sans-pro.css' rel='stylesheet' type='text/css'>

        <!-- Theme style -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/AdminLTE.min.css">
        <!-- Salvattore -->
        <link rel="stylesheet" href="../bower/salvattore/salvattore.css">
        <!-- AdminLTE Skins. Choose a skin from the css/skins
           folder instead of downloading all of them to reduce the load. -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/skins/_all-skins.min.css">
        <!-- SchemaSpy -->
        <link rel="stylesheet" href="../schemaSpy.css">

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
        <script src="../bower/html5shiv/html5shiv.min.js"></script>
        <script src="../bower/respond/respond.min.js"></script>
        <![endif]-->
    </head>
    <!-- ADD THE CLASS layout-top-nav TO REMOVE THE SIDEBAR. -->
    <body class="hold-transition skin-blue layout-top-nav">
        <div class="wrapper">
            <header class="main-header">
                <nav class="navbar navbar-static-top">
                    <div class="container">
                        <div class="navbar-header">
                            <a href="../index.html" class="navbar-brand"><b>TSTNDA</b></a><span class="navbar-brand" style="padding-left: 0">.DELIUS_APP_SCHEMA</span>
                            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse"><i class="fa fa-bars"></i></button>
                        </div>

                        <!-- Collect the nav links, forms, and other content for toggling -->
                        <div class="collapse navbar-collapse pull-left" id="navbar-collapse">
                            <ul class="nav navbar-nav">
                                <li><a href="../index.html">Tables <span class="sr-only">(current)</span></a></li>
                                <li><a href="../columns.html" title="All of the columns in the schema">Columns</a></li>
                                <li><a href="../constraints.html" title="Useful for diagnosing error messages that just give constraint name or number">Constraints</a></li>
                                <li><a href="../relationships.html" title="Diagram of table relationships">Relationships</a></li>
                                <li><a href="../orphans.html" title="View of tables with neither parents nor children">Orphan&nbsp;Tables</a></li>
                                <li><a href="../anomalies.html" title="Things that might not be quite right">Anomalies</a></li>
                                <li><a href="../routines.html" title="Procedures and functions">Routines</a></li>
                            </ul>
                        </div>
                        <!-- /.navbar-collapse -->
                        <!-- Navbar Right Menu -->
                    </div>
                    <!-- /.container-fluid -->
                </nav>
            </header>
            <!-- Main content -->
            <!-- Full Width Column -->
            <div class="content-wrapper">
                <!-- Content Header (Page header) -->
                <section class="content-header">
                    <h1>DELIUS_APP_SCHEMA.DOCMIGRATIONSUPPORT</h1><br />
                </section>
                <!-- Main content -->
                <section class="content">
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <span class="glyphicon glyphicon-list-alt" aria-hidden="true"></span>
                            <h3 id="Columns" class="box-title">Parameters</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <table id="standard_table" class="table table-bordered table-striped dataTable" role="grid">
                                <thead align='left'>
                                <tr>
                                    <th>Name</th>
                                    <th>Type</th>
                                    <th>Mode</th>
                                </tr>
                                </thead>
                                <tbody>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <i class="fa fa-file-code-o"></i>
                            <h3 id="RoutineDefinition" class="box-title">Definition</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <textarea id="sql-script-codemirror" name="sql-script-codemirror" rows="" style="display: none;">PACKAGE BODY DocMigrationSupport&#10;AS&#10;--&#10;--&#10;-- Package variables - used in information and error messaging&#10;--&#10;    g_package_version     CONSTANT VARCHAR2(30) :&#61; GC_VERSION;&#10;    g_component_code      CONSTANT VARCHAR2(3)  :&#61; &#39;MIG&#39;;&#10;    g_package_name        CONSTANT VARCHAR2(30) :&#61; &#39;DocMigrationSupport&#39;;&#10;    g_default_user        CONSTANT VARCHAR2(30) :&#61; &#39;DELIUS_SYSTEM_USER&#39;;&#10;    g_instance_id         INTEGER :&#61; 0;&#10;    g_log_table           CONSTANT VARCHAR2(30) :&#61; &#39;DMS_MESSAGE_LOG&#39;;&#10;    g_alfresco_pkg        CONSTANT VARCHAR2(100):&#61; &#39;AlfrescoSupport[version &#61;&gt; 1.36]&#39;;&#10;    g_doc_migration_type  DOC_MIGRATION_TYPE;&#10;    --&#10;    g_procedure_name  VARCHAR2(30)  :&#61; &#39;initial_value&#39;;&#10;    g_label           VARCHAR2(6)   :&#61; &#39;000000&#39;;&#10;    g_padding         CONSTANT VARCHAR2(30) :&#61; &#39;##&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;##&#39;;&#10;    g_pdm             NUMBER;&#10;    g_unit_test       BOOLEAN       :&#61; FALSE;&#10;    --&#10;    -- message type&#10;    mt_information    CONSTANT NUMBER :&#61; 1;&#10;    mt_warning        CONSTANT NUMBER :&#61; 2;&#10;    mt_error          CONSTANT NUMBER :&#61; 3;&#10;    mt_fatal_error    CONSTANT NUMBER :&#61; 4;&#10;    --&#10;    -- status&#10;    dms_fatalerror    CONSTANT NUMBER :&#61; -1;&#10;    dms_unknown       CONSTANT NUMBER :&#61; 0;&#10;    dms_pending       CONSTANT NUMBER :&#61; 1;&#10;    dms_commenced     CONSTANT NUMBER :&#61; 2;&#10;    dms_paused        CONSTANT NUMBER :&#61; 3;&#10;    dms_completederr  CONSTANT NUMBER :&#61; 4;&#10;    dms_completed     CONSTANT NUMBER :&#61; 5;&#10;    --&#10;    invalid_location_format EXCEPTION;&#10;    PRAGMA EXCEPTION_INIT(invalid_location_format, -20104);&#10;    --&#10;    pending_offenders   t_tab_ORGANISATIONS :&#61; t_tab_ORGANISATIONS();&#10;    --&#10;    alfresco_rest_url_base    VARCHAR2(255) :&#61; SPGCONFIG.get_alfresco_url;&#10;    alfresco_user             VARCHAR2(100) :&#61; SPGCONFIG.get_alfresco_user;&#10;    TYPE tableOfStrings IS TABLE OF VARCHAR2(32767);&#10;--&#10;--&#10;FUNCTION get_version RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN g_package_name || &#39;[version &#61;&gt; &#39; || g_package_version || &#39;]&#39;;&#10;END get_version;&#10;--***************************************************&#10;-- PKG_DEBUG wrappers                               *&#10;--***************************************************&#10;PROCEDURE procDebug(p_msg CLOB, p_print_flag VARCHAR2 DEFAULT &#39;N&#39;) IS&#10;BEGIN&#10;    PKG_Debug.procDebug(p_msg, p_print_flag);&#10;END procDebug;&#10;&#10;FUNCTION funcgetDebugMode RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Debug.funcgetDebugMode;&#10;END funcgetDebugMode;&#10;--&#10;PROCEDURE message(p_msg VARCHAR2, p_trace_level INTEGER DEFAULT 0) IS&#10;BEGIN&#10;    procDebug(&#39;[&#39; || g_label || &#39;] &#39; || p_msg, p_print_flag &#61;&gt; &#39;Y&#39;);&#10;END message;&#10;--***************************************************&#10;-- PKG_COMMON wrappers                              *&#10;--***************************************************&#10;PROCEDURE raise_error(&#10;    error_code_in   IN PLS_INTEGER DEFAULT NULL,&#10;    error_message_in    VARCHAR2 DEFAULT NULL)&#10;IS&#10;    l_error_code    PLS_INTEGER :&#61; NVL(error_code_in, SQLCODE);&#10;    l_error_message     VARCHAR2(4000) :&#61; SUBSTR(NVL(error_message_in, SQLERRM), 1, 4000);&#10;BEGIN&#10;    g_procedure_name :&#61; &#39;raise_error&#39;;&#10;    IF l_error_code BETWEEN -20999 AND -20000 THEN&#10;        RAISE_APPLICATION_ERROR (l_error_code, l_error_message);&#10;    ELSIF l_error_code &gt; 0 AND l_error_code NOT IN (1,100) THEN&#10;        RAISE_APPLICATION_ERROR (-20000, l_error_code||&#39; - &#39;||l_error_message);&#10;    ELSIF l_error_code IN (100, -1403) THEN&#10;        RAISE_APPLICATION_ERROR (-20000, l_error_code||&#39; - &#39;||l_error_message);&#10;    ELSIF l_error_code &lt;&gt; 0 THEN&#10;        RAISE_APPLICATION_ERROR(-20000, &#39;INTERNAL ERROR: An unexpected error in PL/SQL&#39;);&#10;    END IF;&#10;END raise_error;&#10;--&#10;--&#10;FUNCTION is_str_empty(p_str VARCHAR2, p_ignore_spaces_and_zeroes VARCHAR2 DEFAULT &#39;N&#39;) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.is_str_empty( p_str, p_ignore_spaces_and_zeroes );&#10;END is_str_empty;&#10;--&#10;FUNCTION empty2null(p_str VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.empty2null(p_str);&#10;END empty2null;&#10;&#10;FUNCTION nvlstr(p_str1 VARCHAR2, p_str2 VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.nvl2(empty2null(p_str1), empty2null(p_str2));&#10;END nvlstr;&#10;--&#10;--&#10;FUNCTION check_alfresco_support RETURN BOOLEAN IS&#10;BEGIN&#10;  RETURN ( ALFRESCOSUPPORT.get_version &#61; g_alfresco_pkg );&#10;END check_alfresco_support;&#10;--&#10;--&#10;--***************************************************&#10;-- Helpers                                          *&#10;--***************************************************&#10;--&#10;-- Used to populate mtt_message_log with information type message&#10;PROCEDURE info(message_in VARCHAR2, procedure_in VARCHAR2 DEFAULT NULL) IS&#10;BEGIN&#10;    SPGConfig.insert_message_log(&#10;        message_type_id_in &#61;&gt; mt_information,&#10;        component_code_in  &#61;&gt; g_component_code,&#10;        package_name_in    &#61;&gt; g_package_name,&#10;        procedure_name_in  &#61;&gt; NVL(procedure_in, g_procedure_name),&#10;        label_in           &#61;&gt; g_label,&#10;        message_text_in    &#61;&gt; message_in,&#10;        log_table_name     &#61;&gt; g_log_table );&#10;END info;&#10;--&#10;-- Will populate mtt_message_log with warning message - will populate mtt_error_log if result of exception&#10;PROCEDURE warn (message_in VARCHAR2, procedure_in VARCHAR2 DEFAULT NULL) IS&#10;BEGIN&#10;    SPGConfig.record_error(&#10;        message_type_id_in &#61;&gt; mt_warning,&#10;        component_code_in  &#61;&gt; g_component_code,&#10;        package_name_in    &#61;&gt; g_package_name,&#10;        procedure_name_in  &#61;&gt; NVL(procedure_in, g_procedure_name),&#10;        label_in           &#61;&gt; g_label,&#10;        message_text_in    &#61;&gt; message_in,&#10;        log_table_name     &#61;&gt; g_log_table );&#10;END warn;&#10;--&#10;-- Will populate mtt_message_log with error message and populate mtt_error_log with exception - used for log and continue&#10;PROCEDURE error (message_in VARCHAR2, procedure_in VARCHAR2 DEFAULT NULL) IS&#10;BEGIN&#10;    SPGConfig.record_error(&#10;        message_type_id_in &#61;&gt; mt_error,&#10;        component_code_in  &#61;&gt; g_component_code,&#10;        package_name_in    &#61;&gt; g_package_name,&#10;        procedure_name_in  &#61;&gt; NVL(procedure_in, g_procedure_name),&#10;        label_in           &#61;&gt; g_label,&#10;        message_text_in    &#61;&gt; message_in,&#10;        log_table_name     &#61;&gt; g_log_table );&#10;END error;&#10;--&#10;-- Will populate mtt_message_log, mtt_error_log with error message and raise exception - used for log and halt&#10;PROCEDURE fatal (message_in VARCHAR2, procedure_in VARCHAR2 DEFAULT NULL) IS&#10;BEGIN&#10;    SPGConfig.record_error(&#10;        message_type_id_in &#61;&gt; mt_fatal_error,&#10;        component_code_in  &#61;&gt; g_component_code,&#10;        package_name_in    &#61;&gt; g_package_name,&#10;        procedure_name_in  &#61;&gt; NVL(procedure_in, g_procedure_name),&#10;        label_in           &#61;&gt; g_label,&#10;        message_text_in    &#61;&gt; message_in,&#10;        raise_error_in     &#61;&gt; TRUE,&#10;        log_table_name     &#61;&gt; g_log_table );&#10;END fatal;&#10;--&#10;--&#10;--***************************************************&#10;-- Package initialisation block                     *&#10;--***************************************************&#10;PROCEDURE do_init_vars IS&#10;BEGIN&#10;    --PKG_DynSQL.init_tab_info(p_reset_flag &#61;&gt; &#39;Y&#39;);&#10;    NULL;&#10;END do_init_vars;&#10;--&#10;--&#10;--***************************************************&#10;-- Main procedures and functions                    *&#10;--***************************************************&#10;&#10;PROCEDURE seed_dms_batch IS&#10;BEGIN&#10;    g_label :&#61; &#39;100000&#39;;&#10;    g_procedure_name :&#61; &#39;seed_dms_batch&#39;;&#10;    info(g_padding);&#10;    info(&#39;Commence seed to dms_batch&#39;);&#10;    --&#10;    g_label :&#61; &#39;100010&#39;;&#10;    INSERT INTO dms_batch(&#10;      probation_area_id,&#10;      batch_name,&#10;      folder_create_status_id,&#10;      document_create_status_id )&#10;    SELECT&#10;      probation_area_id,&#10;      &#39;Batch for provider &#39; || code batch_name,&#10;      0 folder_create_status_id,&#10;      0 document_create_status_id&#10;    FROM dms_offender_cohort&#10;    WHERE&#10;      NOT EXISTS(&#10;        SELECT 1&#10;        FROM dms_batch&#10;        WHERE dms_batch.probation_area_id &#61; dms_offender_cohort.probation_area_id )&#10;    GROUP BY probation_area_id, code, 0;&#10;    --&#10;    info(SQL%ROWCOUNT || &#39; rows added to dms_batch&#39;);&#10;    --&#10;    g_label :&#61; &#39;100020&#39;;&#10;    COMMIT;&#10;    info(&#39;Completed seed to dms_batch&#39;);&#10;    info(g_padding);&#10;    --&#10;EXCEPTION  WHEN OTHERS THEN&#10;    error(&#39;Unexpected Error Raising: &#39; || SQLERRM);&#10;    RAISE;&#10;END seed_dms_batch;&#10;--&#10;--&#10;FUNCTION get_json_payload(offenderid_in NUMBER) RETURN VARCHAR2 RESULT_CACHE&#10;IS&#10;    l_ret   VARCHAR2(4000);&#10;BEGIN&#10;    g_label :&#61; &#39;200000&#39;;&#10;    --&#10;    SELECT &#39;{&quot;PROVIDERS&quot; : [&#39; || LISTAGG(&#39;{&quot;&#39; || area_code || &#39;&quot;:&quot;&#39; || alfresco_value || &#39;&quot;}&#39;, &#39;,&#39;) WITHIN GROUP (ORDER BY 1) || &#39;]}&#39;&#10;    INTO l_ret&#10;    FROM TABLE( ALFRESCOSUPPORT.get_alfresco_permissions(offenderid_in &#61;&gt; offenderid_in, noAccessFlag_in &#61;&gt; &#39;N&#39;) );&#10;    --&#10;    g_label :&#61; &#39;200010&#39;;&#10;    RETURN l_ret;&#10;    --&#10;END get_json_payload;&#10;--&#10;--&#10;PROCEDURE seed_dms_offender IS&#10;BEGIN&#10;    g_label :&#61; &#39;300000&#39;;&#10;    g_procedure_name :&#61; &#39;seed_dms_offender&#39;;&#10;    --&#10;    info(g_padding);&#10;    info(&#39;Commence seed to dms_offender&#39;);&#10;    --&#10;    g_label :&#61; &#39;300010&#39;;&#10;    INSERT INTO dms_offender(&#10;      dms_batch_id,&#10;      offender_id,&#10;      offender_active_flag,&#10;      folder_create_status_id )&#10;    SELECT&#10;      db.dms_batch_id,&#10;      oc.offender_id,&#10;      oc.offender_active_flag,&#10;      dms_pending folder_create_status_id&#10;    FROM&#10;      dms_offender_cohort oc&#10;        INNER JOIN dms_batch db ON oc.probation_area_id &#61; db.probation_area_id&#10;    WHERE&#10;      NOT EXISTS(&#10;        SELECT 1&#10;        FROM dms_offender&#10;        WHERE dms_offender.offender_id &#61; oc.offender_id );&#10;    --&#10;    info(SQL%ROWCOUNT || &#39; rows added to dms_offender&#39;);&#10;    --&#10;    g_label :&#61; &#39;300020&#39;;&#10;    UPDATE dms_batch SET folder_create_status_id &#61; dms_pending&#10;    WHERE&#10;      EXISTS(&#10;        SELECT 1&#10;        FROM dms_offender&#10;        WHERE folder_create_status_id &#61; dms_pending&#10;          AND dms_offender.dms_batch_id &#61; dms_batch.dms_batch_id );&#10;    --&#10;    info(SQL%ROWCOUNT || &#39; rows set to pending&#39;);&#10;    g_label :&#61; &#39;300030&#39;;&#10;    --&#10;    COMMIT;&#10;    info(&#39;Completed seed to dms_offender&#39;);&#10;    info(g_padding);&#10;    --&#10;EXCEPTION  WHEN OTHERS THEN&#10;    error(&#39;Unexpected Error Raising: &#39; || SQLERRM);&#10;    RAISE;&#10;END seed_dms_offender;&#10;--&#10;--&#10;PROCEDURE seed_dms_document IS&#10;BEGIN&#10;    g_label :&#61; &#39;400000&#39;;&#10;    g_procedure_name :&#61; &#39;seed_dms_document&#39;;&#10;    --&#10;    info(&#39;Commence seed to dms_document&#39;);&#10;    --&#10;    g_label :&#61; &#39;400010&#39;;&#10;    MERGE INTO dms_document t0&#10;    USING ( SELECT  do.dms_offender_id, &#39;OFFENDER&#39; source_table, o.offender_id source_table_key, dms_pending document_create_status_id, &#39;N&#39; document_locked&#10;            FROM&#10;              offender O&#10;                INNER JOIN document D ON D.offender_id &#61; O.offender_id&#10;                                     AND D.table_name &#61; &#39;OFFENDER&#39;&#10;                                     AND D.primary_key_id &#61; TO_CHAR(O.offender_id)&#10;                                     AND D.document_type &#61; &#39;PREVIOUS_CONVICTION&#39;&#10;                INNER JOIN dms_offender do ON o.offender_id &#61; do.offender_id&#10;            WHERE D.document_name IS NOT NULL&#10;              AND D.alfresco_document_id IS NULL ) t1&#10;    ON ( t0.dms_offender_id &#61; t1.dms_offender_id AND&#10;         t0.source_table &#61; t1.source_table AND&#10;         t0.source_table_key &#61; t1.source_table_key )&#10;    WHEN NOT MATCHED THEN&#10;      INSERT(&#10;        dms_offender_id,&#10;        source_table,&#10;        source_table_key,&#10;        document_create_status_id,&#10;        document_locked&#10;      ) VALUES (&#10;        t1.dms_offender_id,&#10;        t1.source_table,&#10;        t1.source_table_key,&#10;        t1.document_create_status_id,&#10;        t1.document_locked );&#10;    --&#10;    info(SQL%ROWCOUNT || &#39; rows from OFFENDER added to dms_document&#39;);&#10;    --&#10;    g_label :&#61; &#39;400020&#39;;&#10;    MERGE INTO dms_document t0&#10;    USING ( SELECT&#10;              do.dms_offender_id,&#10;              &#39;DOCUMENT&#39; source_table,&#10;              d.document_id source_table_key,&#10;              dms_pending document_create_status_id,&#10;              CASE d.status&#10;                  WHEN &#39;Y&#39; THEN &#39;Y&#39;&#10;                  ELSE &#39;N&#39;&#10;              END document_locked,&#10;              CASE d.work_in_progress&#10;                  WHEN &#39;Y&#39; THEN &#39;Y&#39;&#10;                  ELSE &#39;N&#39;&#10;              END document_checked_out&#10;            FROM&#10;              document d&#10;                INNER JOIN offender o ON d.offender_id &#61; o.offender_id&#10;                  INNER JOIN dms_offender do ON o.offender_id &#61; do.offender_id&#10;            WHERE d.alfresco_document_id IS NULL&#10;              AND d.soft_deleted &#61; 0 ) t1&#10;    ON ( t0.dms_offender_id &#61; t1.dms_offender_id AND&#10;         t0.source_table &#61; t1.source_table AND&#10;         t0.source_table_key &#61; t1.source_table_key )&#10;    WHEN NOT MATCHED THEN&#10;      INSERT (&#10;        dms_offender_id,&#10;        source_table,&#10;        source_table_key,&#10;        document_create_status_id,&#10;        document_locked,&#10;        document_checked_out&#10;      ) VALUES (&#10;        t1.dms_offender_id,&#10;        t1.source_table,&#10;        t1.source_table_key,&#10;        t1.document_create_status_id,&#10;        t1.document_locked,&#10;        t1.document_checked_out );&#10;    --&#10;    info(SQL%ROWCOUNT || &#39; rows from DOCUMENT added to dms_document&#39;);&#10;    --&#10;    g_label :&#61; &#39;400030&#39;;&#10;    MERGE INTO dms_document t0&#10;    USING ( SELECT&#10;              do.dms_offender_id,&#10;              &#39;EVENT&#39; source_table,&#10;              e.event_id source_table_key,&#10;              dms_pending document_create_status_id,&#10;              &#39;N&#39; document_locked&#10;            FROM&#10;              event e&#10;                INNER JOIN offender o ON e.offender_id &#61; o.offender_id&#10;                INNER JOIN document D ON D.offender_id &#61; E.offender_id&#10;                                     AND D.table_name &#61; &#39;EVENT&#39;&#10;                                     AND D.primary_key_id &#61; TO_CHAR(E.event_id)&#10;                                     AND D.document_type &#61; &#39;CPS_PACK&#39;&#10;                  INNER JOIN dms_offender do ON o.offender_id &#61; do.offender_id&#10;            WHERE D.document_name IS NOT NULL&#10;              AND D.alfresco_document_id IS NULL ) t1&#10;    ON ( t0.dms_offender_id &#61; t1.dms_offender_id AND&#10;         t0.source_table &#61; t1.source_table AND&#10;         t0.source_table_key &#61; t1.source_table_key )&#10;    WHEN NOT MATCHED THEN&#10;      INSERT(&#10;        dms_offender_id,&#10;        source_table,&#10;        source_table_key,&#10;        document_create_status_id,&#10;        document_locked&#10;      ) VALUES (&#10;        t1.dms_offender_id,&#10;        t1.source_table,&#10;        t1.source_table_key,&#10;        t1.document_create_status_id,&#10;        t1.document_locked );&#10;    --&#10;    info(SQL%ROWCOUNT || &#39; rows from EVENT added to dms_document&#39;);&#10;    --&#10;    g_label :&#61; &#39;400020&#39;;&#10;    UPDATE dms_batch SET document_create_status_id &#61; dms_pending;&#10;    g_label :&#61; &#39;400030&#39;;&#10;    COMMIT;&#10;    info(&#39;Completed seed to dms_document&#39;);&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    error(&#39;Unexpected Error Raising: &#39; || SQLERRM);&#10;    RAISE;&#10;END seed_dms_document;&#10;--&#10;--&#10;PROCEDURE migrateOffender(&#10;    dmsBatchID_in          NUMBER,&#10;    start_dmsOffenderID_in NUMBER,&#10;    end_dmsOffenderID_in   NUMBER,&#10;    componentID_in         NUMBER,&#10;    threadID_in            NUMBER )&#10;IS&#10;    --&#10;    l_status          VARCHAR2(32767);&#10;    l_response_string CLOB;&#10;    l_return_string   CLOB;&#10;    l_row_count       PLS_INTEGER :&#61; 0;&#10;    l_err_count       PLS_INTEGER :&#61; 0;&#10;    --&#10;    PROCEDURE update_thread_progress(p_rows INTEGER, p_info_msg VARCHAR2 DEFAULT NULL) IS&#10;    BEGIN&#10;        C08001_PDT_SUPPORT.update_thread_progress(&#10;            p_component_id &#61;&gt; componentID_in,&#10;            p_thread_id    &#61;&gt; threadID_in,&#10;            p_rows         &#61;&gt; p_rows,&#10;            p_info_msg     &#61;&gt; p_info_msg);&#10;    END update_thread_progress;&#10;    --&#10;    FUNCTION check_semaphore(p_component_code VARCHAR2) RETURN VARCHAR2 IS&#10;    BEGIN&#10;        RETURN C08001_PDT_SUPPORT.check_semaphore(p_component_code &#61;&gt; p_component_code);&#10;    END check_semaphore;&#10;    --&#10;BEGIN&#10;    g_label :&#61; &#39;500000&#39;;&#10;    g_procedure_name :&#61; &#39;migrateOffender&#39;;&#10;    --&#10;    IF check_alfresco_support THEN&#10;        info(&#39;Commence offender migration [thread &#61; &#39; || TO_CHAR(threadID_in) || &#39;]&#39;);&#10;        g_label :&#61; &#39;500010&#39;;&#10;        FOR each_offender IN (&#10;          SELECT&#10;            do.dms_offender_id,&#10;            do.dms_batch_id,&#10;            do.offender_id,&#10;            o.crn&#10;          FROM&#10;            dms_offender do&#10;              INNER JOIN offender o ON do.offender_id &#61; o.offender_id&#10;          WHERE do.dms_batch_id &#61; dmsBatchID_in&#10;            AND do.dms_offender_id BETWEEN start_dmsOffenderID_in AND end_dmsOffenderID_in&#10;            AND do.folder_create_status_id &lt;&#61; dms_completederr )&#10;        LOOP&#10;            g_label :&#61; &#39;500020&#39;;&#10;            l_row_count :&#61; l_row_count + 1;&#10;            l_status :&#61; ALFRESCOSUPPORT.assignOffender( offenderid_in &#61;&gt; each_offender.offender_id, responsestring_out &#61;&gt; l_response_string, returnstring_out &#61;&gt; l_return_string);&#10;            --&#10;            g_label :&#61; &#39;500030&#39;;&#10;            -- valid response from API update dms_offender record&#10;            IF l_status &#61; &#39;200&#39; THEN&#10;                g_label :&#61; &#39;500040&#39;;&#10;                UPDATE dms_offender SET&#10;                  folder_created &#61; 1,&#10;                  folder_create_datetime &#61; SYSDATE,&#10;                  folder_create_status_id &#61; dms_completed,&#10;                  api_response &#61; l_response_string,&#10;                  api_return &#61; l_return_string&#10;                WHERE dms_offender_id &#61; each_offender.dms_offender_id;&#10;                --&#10;            ELSE&#10;                -- invalid response update dms_offender as error&#10;                g_label :&#61; &#39;500050&#39;;&#10;                l_err_count :&#61; l_err_count + 1;&#10;                UPDATE dms_offender SET&#10;                  folder_created &#61; 0,&#10;                  folder_create_datetime &#61; SYSDATE,&#10;                  folder_create_status_id &#61; dms_completederr,&#10;                  api_response &#61; l_response_string,&#10;                  api_return &#61; l_return_string&#10;                WHERE dms_offender_id &#61; each_offender.dms_offender_id;&#10;                --&#10;            END IF;&#10;            COMMIT;&#10;            g_label :&#61; &#39;500060&#39;;&#10;            update_thread_progress(p_rows &#61;&gt; l_row_count, p_info_msg &#61;&gt; l_row_count || &#39; rows completed [&#39; || l_err_count || &#39; with errors]&#39; );&#10;            --&#10;            g_label :&#61; &#39;500070&#39;;&#10;            IF check_semaphore(TO_CHAR(componentId_in)) !&#61; &#39;0&#39; THEN&#10;                info(&#39;Semaphore signalled - stopping thread [componentID: &#39; || TO_CHAR(componentId_in));&#10;                EXIT;&#10;            END IF;&#10;            --&#10;        END LOOP;&#10;        --&#10;        info(l_row_count || &#39; rows completed [&#39; || l_err_count || &#39; with errors]&#39;);&#10;        IF check_semaphore(TO_CHAR(componentId_in)) !&#61; &#39;0&#39; THEN&#10;            info(&#39;Stop offender migration [componentID: &#39; || TO_CHAR(componentId_in) || &#39;][thread &#61; &#39; || TO_CHAR(threadID_in) || &#39;]&#39;);&#10;        ELSE&#10;            info(&#39;Completed offender migration [thread &#61; &#39; || TO_CHAR(threadID_in) || &#39;]&#39;);&#10;        END IF;&#10;        --&#10;    ELSE&#10;        --&#10;        UPDATE dms_offender SET folder_create_status_id &#61; dms_fatalerror&#10;        WHERE dms_batch_id &#61; dmsBatchID_in&#10;          AND dms_offender_id BETWEEN start_dmsOffenderID_in&#10;          AND end_dmsOffenderID_in;&#10;        --&#10;        COMMIT;&#10;        fatal(&#39;Unsupported version of Alfresco Support package&#39;);&#10;    END IF;&#10;   --&#10;EXCEPTION WHEN OTHERS THEN&#10;    error(&#39;Error captured in migrateOffender raising &#39; || SQLERRM);&#10;    RAISE;&#10;END migrateOffender;&#10;--&#10;--&#10;PROCEDURE migrateOffender(&#10;    batchID_in         NUMBER,&#10;    mainComponentID_in NUMBER,&#10;    mainThreadID_in    NUMBER,&#10;    numOfThreads_in    INTEGER DEFAULT -1 )&#10;IS&#10;    l_batch_id     INTEGER;&#10;    l_component_id INTEGER;&#10;    l_max_threads  INTEGER;&#10;    l_rows         INTEGER;&#10;    --&#10;    CURSOR cs IS&#10;      WITH buckets AS (&#10;        SELECT&#10;          NTILE(l_max_threads) OVER(ORDER BY dms_offender_id) AS bucket_num,&#10;          dms_offender_id&#10;        FROM dms_offender&#10;        WHERE dms_batch_id &#61; l_batch_id&#10;          AND folder_create_status_id &lt;&#61; dms_completederr )&#10;      SELECT bucket_num, min(dms_offender_id) min_dms_offender_id, max(dms_offender_id) max_dms_offender_id, COUNT(1) num_of_offenders&#10;      FROM buckets&#10;      GROUP BY bucket_num&#10;      ORDER BY 1;&#10;    --&#10;    l_thread_id      INTEGER;&#10;    l_failed_threads INTEGER;&#10;    --&#10;    l_bucket_num          INTEGER;&#10;    l_min_dms_offender_id DMS_OFFENDER.dms_offender_id%TYPE;&#10;    l_max_dms_offender_id DMS_OFFENDER.dms_offender_id%TYPE;&#10;    l_row_count           INTEGER;&#10;    l_status_id           DMS_STATUS.dms_status_id%TYPE;&#10;    l_stop_detected       BOOLEAN;&#10;    --&#10;    PROCEDURE create_thread_process(p_thread_id INTEGER, dmsBatchID_in NUMBER, min_dmsOffenderID_in NUMBER, max_dmsOffenderID_in NUMBER) IS&#10;    BEGIN&#10;        IF NOT p_thread_id BETWEEN 1 AND l_max_threads THEN&#10;            raise_application_error(-20001, &#39;WARNING: can not create the thread [&#39; || p_thread_id || &#39;] - thread# must be within the [1 .. &#39; || l_max_threads || &#39;] range&#39;);&#10;            RETURN;&#10;        END IF;&#10;        --&#10;        IF dmsBatchID_in IS NOT NULL AND min_dmsOffenderID_in IS NOT NULL AND max_dmsOffenderID_in IS NOT NULL THEN&#10;            C08001_PDT_SUPPORT.create_thread_process(&#10;                p_component_id &#61;&gt; l_component_id,&#10;                p_thread_id    &#61;&gt; p_thread_id,&#10;                p_min_id_val   &#61;&gt; min_dmsOffenderID_in,&#10;                p_max_id_val   &#61;&gt; max_dmsOffenderID_in,&#10;                p_thread_label &#61;&gt; &#39;Batch &#61;&gt; &#39; || TO_CHAR(dmsBatchID_in),&#10;                p_program_action &#61;&gt;&#10;                   &#39;DECLARE&#10;                        l_thread_id    INTEGER :&#61; &#39; || p_thread_id    || &#39;;&#10;                        l_component_id INTEGER :&#61; &#39; || l_component_id || &#39;;&#10;                        l_rows         INTEGER :&#61; &#39; || l_rows || &#39;;&#10;                        l_label        VARCHAR2(10) :&#61; &#39;&#39;000010&#39;&#39;;&#10;                        --&#10;                        PROCEDURE update_thread_status(p_status INTEGER, p_err_msg VARCHAR2 DEFAULT NULL) IS&#10;                        BEGIN&#10;                            C08001_PDT_SUPPORT.update_thread_status(&#10;                                p_component_id &#61;&gt; l_component_id,&#10;                                p_thread_id    &#61;&gt; l_thread_id,&#10;                                p_status       &#61;&gt; p_status,&#10;                                p_err_msg      &#61;&gt; p_err_msg);&#10;                        END update_thread_status;&#10;                        --&#10;                        PROCEDURE update_thread_progress(p_rows INTEGER, p_info_msg VARCHAR2 DEFAULT NULL) IS&#10;                        BEGIN&#10;                            C08001_PDT_SUPPORT.update_thread_progress(&#10;                                p_component_id &#61;&gt; l_component_id,&#10;                                p_thread_id    &#61;&gt; l_thread_id,&#10;                                p_rows         &#61;&gt; p_rows,&#10;                                p_info_msg     &#61;&gt; p_info_msg);&#10;                        END update_thread_progress;&#10;                        --&#10;                    BEGIN&#10;                        --&#10;                        l_label :&#61; &#39;&#39;000010&#39;&#39;;&#10;                        update_thread_status(1);&#10;                        l_label :&#61; &#39;&#39;000020&#39;&#39;;&#10;                        DOCMIGRATIONSUPPORT.migrateOffender(  dmsBatchID_in &#61;&gt; &#39; || dmsBatchID_in ||&#39;,&#10;                                                              start_dmsOffenderID_in &#61;&gt; &#39; || min_dmsOffenderID_in || &#39;,&#10;                                                              end_dmsOffenderID_in &#61;&gt; &#39; || max_dmsOffenderID_in || &#39;,&#10;                                                              componentID_in &#61;&gt; l_component_id,&#10;                                                              threadID_in &#61;&gt; l_thread_id);&#10;                        l_label :&#61; &#39;&#39;000030&#39;&#39;;&#10;                        update_thread_status(3);&#10;                    EXCEPTION WHEN OTHERS THEN&#10;                        update_thread_status(2, &#39;&#39;Fatal error exception [&#39;&#39; || l_label || &#39;&#39;]: &#39;&#39; || SQLERRM);&#10;                    END;&#39;&#10;            );&#10;        ELSE&#10;            raise_application_error(-20001,&#10;                &#39;WARNING: THREAD# &#39; || p_thread_id ||&#10;                &#39; can not be initialised due to incorrect Contact ID range [&#39; || min_dmsOffenderID_in || &#39;][&#39; || max_dmsOffenderID_in || &#39;]&#39;);&#10;        END IF;&#10;        --&#10;    END create_thread_process;&#10;    --&#10;    PROCEDURE reset_threads(p_component_id INTEGER, p_thread_id INTEGER DEFAULT NULL) IS&#10;    BEGIN&#10;        C08001_PDT_SUPPORT.reset_threads(p_component_id &#61;&gt; p_component_id, p_thread_id &#61;&gt; p_thread_id);&#10;    END reset_threads;&#10;    --&#10;    FUNCTION get_num_of_failed_threads RETURN INTEGER&#10;    IS&#10;        l_ret INTEGER;&#10;    BEGIN&#10;        IF l_max_threads &gt; 1 THEN&#10;            l_ret :&#61; C08001_PDT_SUPPORT.get_num_of_failed_threads(p_component_id &#61;&gt; l_component_id);&#10;        ELSE&#10;            l_ret :&#61; 0;&#10;        END IF;&#10;        --&#10;        RETURN l_ret;&#10;    END get_num_of_failed_threads;&#10;    --&#10;    FUNCTION get_available_thread RETURN INTEGER IS&#10;    BEGIN&#10;        RETURN&#10;            C08001_PDT_SUPPORT.get_available_thread(&#10;                p_component_id &#61;&gt; l_component_id,&#10;                p_wait         &#61;&gt; 5,&#10;                p_timeout      &#61;&gt; 180,&#10;                p_max_threads  &#61;&gt; l_max_threads );&#10;    END get_available_thread;&#10;    --&#10;    PROCEDURE wait_for_threads_to_finish(p_thread_id INTEGER DEFAULT -1) IS&#10;    BEGIN&#10;        C08001_PDT_SUPPORT.wait_for_threads_to_finish(p_component_id &#61;&gt; l_component_id);&#10;    END wait_for_threads_to_finish;&#10;    --&#10;    FUNCTION check_semaphore(p_component_code VARCHAR2) RETURN VARCHAR2 IS&#10;    BEGIN&#10;        RETURN C08001_PDT_SUPPORT.check_semaphore(p_component_code &#61;&gt; p_component_code);&#10;    END check_semaphore;&#10;    --&#10;    PROCEDURE update_main_thread_status(p_status INTEGER, p_err_msg VARCHAR2 DEFAULT NULL) IS&#10;    BEGIN&#10;        C08001_PDT_SUPPORT.update_thread_status(&#10;            p_component_id &#61;&gt; mainComponentID_in,&#10;            p_thread_id    &#61;&gt; mainThreadID_in,&#10;            p_status       &#61;&gt; p_status,&#10;            p_err_msg      &#61;&gt; p_err_msg);&#10;    END update_main_thread_status;&#10;    --&#10;    PROCEDURE update_main_thread_progress(p_rows INTEGER, p_info_msg VARCHAR2 DEFAULT NULL) IS&#10;    BEGIN&#10;        C08001_PDT_SUPPORT.update_thread_progress(&#10;            p_component_id &#61;&gt; mainComponentID_in,&#10;            p_thread_id    &#61;&gt; mainThreadID_in,&#10;            p_rows         &#61;&gt; p_rows,&#10;            p_info_msg     &#61;&gt; p_info_msg);&#10;    END update_main_thread_progress;&#10;    --&#10;BEGIN&#10;    l_batch_id      :&#61; batchID_in;&#10;    l_component_id  :&#61; TO_NUMBER(&#39;110&#39; || TO_CHAR(l_batch_id));&#10;    l_max_threads   :&#61; CASE WHEN numOfThreads_in &lt;&#61; 0 THEN C08001_PDT_SUPPORT.get_cpu_count * 2 ELSE numOfThreads_in END;&#10;    l_stop_detected :&#61; FALSE;&#10;    --&#10;    g_label :&#61; &#39;600000&#39;;&#10;    g_procedure_name :&#61; &#39;migrateOffender&#39;;&#10;    --&#10;    update_main_thread_status(1);&#10;    IF check_alfresco_support THEN&#10;        info(&#39;Commence threaded offender migration [&#39; || l_batch_id || &#39;]&#39;);&#10;        --&#10;        g_label :&#61; &#39;600005&#39;;&#10;        DELETE FROM pdt_semaphore WHERE component_code &#61; TO_CHAR(l_component_id);&#10;        COMMIT;&#10;        info(&#39;Cleared current semaphore rows&#39;);&#10;        --&#10;        g_label :&#61; &#39;600010&#39;;&#10;        UPDATE dms_batch SET&#10;          folder_create_start &#61; SYSDATE,&#10;          folder_create_status_id &#61; dms_commenced&#10;        WHERE dms_batch_id &#61; l_batch_id;&#10;        COMMIT;&#10;        info(&#39;Changed batch status to 1 [Commenced] for batch_id&#39; || l_batch_id);&#10;        --&#10;        g_label :&#61; &#39;600020&#39;;&#10;        reset_threads(p_component_id &#61;&gt; l_component_id);&#10;        g_label :&#61; &#39;600030&#39;;&#10;        --&#10;        update_main_thread_progress(p_rows &#61;&gt; 1, p_info_msg &#61;&gt; &#39;processing sub threads&#39;);&#10;        --&#10;        OPEN cs;&#10;        LOOP&#10;            g_label :&#61; &#39;600040&#39;;&#10;            FETCH cs INTO l_bucket_num, l_min_dms_offender_id, l_max_dms_offender_id, l_rows;&#10;            EXIT WHEN cs%NOTFOUND;&#10;            --&#10;            LOOP&#10;                -- Get next available thread&#10;                l_thread_id :&#61; get_available_thread;&#10;                EXIT WHEN l_thread_id &gt; 0;&#10;            END LOOP;&#10;            --&#10;            --&#10;            g_label :&#61; &#39;600045&#39;;&#10;            IF check_semaphore(TO_CHAR(l_component_id)) !&#61; &#39;0&#39; THEN&#10;                info(&#39;Semaphore signalled - stopping thread&#39;);&#10;                l_stop_detected :&#61; TRUE;&#10;                EXIT;&#10;            END IF;&#10;            --&#10;            g_label :&#61; &#39;600050&#39;;&#10;            info(&#39;CREATE_THREAD_PROCESS( l_thread_id &#61;&gt; &#39; || l_thread_id || &#39;, l_batch_id &#61;&gt;  &#39; || l_batch_id || &#39;, l_min_dms_offender_id &#61;&gt; &#39; || l_min_dms_offender_id || &#39;, l_max_dms_offender_id &#61;&gt; &#39; || l_max_dms_offender_id || &#39;)&#39;);&#10;            create_thread_process(l_thread_id, l_batch_id, l_min_dms_offender_id, l_max_dms_offender_id);&#10;            COMMIT;&#10;            --&#10;            g_label :&#61; &#39;600060&#39;;&#10;            l_failed_threads :&#61; get_num_of_failed_threads;&#10;            IF l_failed_threads &gt; 0 THEN&#10;                g_label :&#61; &#39;600070&#39;;&#10;                error(&#39;Failed threads detected&#39;);&#10;                update_main_thread_status(3);&#10;                EXIT;&#10;            END IF;&#10;            --&#10;        END LOOP;&#10;        g_label :&#61; &#39;600080&#39;;&#10;        CLOSE cs;&#10;        --&#10;        info(&#39;Stop Detected &#61;&gt; &#39; || CASE WHEN l_stop_detected THEN &#39;TRUE&#39; ELSE &#39;FALSE&#39; END);&#10;        --&#10;        update_main_thread_progress(p_rows &#61;&gt; 1, p_info_msg &#61;&gt; &#39;waiting for sub threads to finish&#39;);&#10;        --&#10;        g_label :&#61; &#39;600090&#39;;&#10;        info(&#39;waiting for threads to complete&#39;);&#10;        wait_for_threads_to_finish;&#10;        --&#10;        g_label :&#61; &#39;600100&#39;;&#10;        l_failed_threads :&#61; get_num_of_failed_threads;&#10;        info(&#39;failed thread count &#61; &#39; || l_failed_threads);&#10;        --&#10;        --&#10;        -- if any failed threads then fail batch signal main thread&#10;        IF l_failed_threads &gt; 0 THEN&#10;            g_label :&#61; &#39;600110&#39;;&#10;            UPDATE dms_batch SET folder_create_status_id &#61; dms_fatalerror&#10;            WHERE dms_batch_id &#61; l_batch_id;&#10;            update_main_thread_status(2);&#10;            info(&#39;Failed thread detected - set batch to error [&#39; || SQL%ROWCOUNT || &#39; rows updated]&#39;);&#10;        -- else if stop signal set all incomplete offenders to paused&#10;        ELSIF l_stop_detected OR check_semaphore(TO_CHAR(l_component_id)) !&#61; &#39;0&#39; THEN&#10;            g_label :&#61; &#39;600120&#39;;&#10;            UPDATE dms_offender SET folder_create_status_id &#61; dms_paused&#10;            WHERE folder_create_status_id &lt; dms_completed&#10;              AND dms_batch_id &#61; l_batch_id;&#10;            --&#10;            info(&#39;Stop detected - set offenders to paused [&#39; || SQL%ROWCOUNT || &#39; rows updated]&#39;);&#10;            g_label :&#61; &#39;600130&#39;;&#10;            UPDATE dms_batch SET folder_create_status_id &#61; dms_paused&#10;            WHERE folder_create_status_id &lt; dms_completederr&#10;              AND dms_batch_id &#61; l_batch_id;&#10;            --&#10;            info(&#39;Stop detected - set batches to paused [&#39; || SQL%ROWCOUNT || &#39; rows updated]&#39;);&#10;        -- all threads complete set batch status&#10;        ELSE&#10;            g_label :&#61; &#39;600130&#39;;&#10;            SELECT COUNT(1) INTO l_row_count&#10;            FROM dms_offender&#10;            WHERE dms_batch_id &#61; l_batch_id&#10;              AND folder_create_status_id !&#61; dms_completed;&#10;            --&#10;            IF l_row_count &gt; 0 THEN&#10;                l_status_id :&#61; dms_completederr;&#10;            ELSE&#10;                l_status_id :&#61; dms_completed;&#10;            END IF;&#10;            --&#10;            UPDATE dms_batch SET&#10;              folder_create_finish &#61; SYSDATE,&#10;              folder_create_status_id &#61; l_status_id&#10;            WHERE dms_batch_id &#61; l_batch_id;&#10;            --&#10;            update_main_thread_progress(p_rows &#61;&gt; 1, p_info_msg &#61;&gt; &#39;finished processing sub threads&#39;);&#10;            update_main_thread_status(3);&#10;            info(&#39;Completed threaded offender migration [&#39; || l_batch_id || &#39;]&#39;);&#10;            --&#10;        END IF;&#10;        --&#10;        COMMIT;&#10;    ELSE&#10;        g_label :&#61; &#39;600140&#39;;&#10;        UPDATE dms_batch SET folder_create_status_id &#61; dms_fatalerror&#10;        WHERE dms_batch_id &#61; l_batch_id;&#10;        --&#10;        update_main_thread_status(2);&#10;        COMMIT;&#10;        fatal(&#39;Unsupported version of Alfresco Support package&#39;);&#10;        --&#10;    END IF;&#10;EXCEPTION WHEN OTHERS THEN&#10;    error(&#39;Error captured in migrateOffender raising &#39; || SQLERRM);&#10;    RAISE;&#10;END migrateOffender;&#10;--&#10;--&#10;PROCEDURE migrateDocument(&#10;    dmsBatchID_in          NUMBER,&#10;    dmsoffenderID_in       NUMBER,&#10;    start_dmsDocumentID_in NUMBER,&#10;    end_dmsDocumentID_in   NUMBER,&#10;    componentID_in         NUMBER,&#10;    threadID_in            NUMBER )&#10;IS&#10;    l_status          VARCHAR2(32767);&#10;    l_response_string CLOB;&#10;    l_return_string   CLOB;&#10;    l_row_count       PLS_INTEGER :&#61; 0;&#10;    l_err_count       PLS_INTEGER :&#61; 0;&#10;    l_component_id    PDT_THREAD.component_id%TYPE;&#10;    l_thread_id       PDT_THREAD.thread_id%TYPE;&#10;    --&#10;    PROCEDURE update_thread_progress(p_rows INTEGER, p_info_msg VARCHAR2 DEFAULT NULL) IS&#10;    BEGIN&#10;        C08001_PDT_SUPPORT.update_thread_progress(&#10;            p_component_id &#61;&gt; componentID_in,&#10;            p_thread_id    &#61;&gt; threadID_in,&#10;            p_rows         &#61;&gt; p_rows,&#10;            p_info_msg     &#61;&gt; p_info_msg);&#10;    END update_thread_progress;&#10;    --&#10;    FUNCTION check_semaphore(p_component_code VARCHAR2) RETURN VARCHAR2 IS&#10;    BEGIN&#10;        RETURN C08001_PDT_SUPPORT.check_semaphore(p_component_code &#61;&gt; p_component_code);&#10;    END check_semaphore;&#10;    --&#10;BEGIN&#10;    g_label :&#61; &#39;700000&#39;;&#10;    g_procedure_name :&#61; &#39;migrateOffender&#39;;&#10;    --&#10;    l_component_id  :&#61; componentID_in;&#10;    l_thread_id     :&#61; threadID_in;&#10;    --&#10;    IF check_alfresco_support THEN&#10;        info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;Commence offender migration [thread &#61; &#39; || TO_CHAR(threadID_in) || &#39;]&#39;);&#10;        g_label :&#61; &#39;700010&#39;;&#10;        FOR each_document IN (&#10;            SELECT do.dms_offender_id, dd.dms_document_id, dd.source_table, dd.source_table_key, do.offender_id, o.crn, dd.document_locked, document_checked_out&#10;            FROM&#10;              dms_batch db&#10;                INNER JOIN dms_offender do ON do.dms_batch_id &#61; db.dms_batch_id&#10;                  INNER JOIN offender o ON o.offender_id &#61; do.offender_id&#10;                  INNER JOIN dms_document dd ON dd.dms_offender_id &#61; do.dms_offender_id&#10;            WHERE db.dms_batch_id &#61; dmsBatchID_in&#10;              AND do.dms_offender_id &#61; dmsOffenderID_in&#10;              AND dd.dms_document_id BETWEEN start_dmsDocumentID_in AND end_dmsDocumentID_in&#10;              AND dd.document_create_status_id &lt;&#61; dms_completederr )&#10;        LOOP&#10;            g_label :&#61; &#39;700020&#39;;&#10;            l_row_count :&#61; l_row_count + 1;&#10;            info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;Trying document &#39; || l_row_count);&#10;            l_status :&#61;&#10;                ALFRESCOSUPPORT.uploadnew(  entityType_in       &#61;&gt; each_document.source_table,&#10;                    entityId_in         &#61;&gt; each_document.source_table_key,&#10;                    responseString_out  &#61;&gt; l_response_string,&#10;                    returnString_out    &#61;&gt; l_return_string,&#10;                    lockDocument_in     &#61;&gt; each_document.document_locked,&#10;                    checkoutDocument_in &#61;&gt; each_document.document_checked_out );&#10;            --&#10;            g_label :&#61; &#39;700030&#39;;&#10;            info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;WEB API Status [&#39; || l_status || &#39;]&#39;);&#10;            --&#10;            IF l_status &#61; &#39;200&#39; THEN&#10;                --&#10;                g_label :&#61; &#39;700040&#39;;&#10;                info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;Document Upload Success&#39;);&#10;                UPDATE dms_document SET&#10;                  document_created &#61; 1,&#10;                  document_create_datetime &#61; SYSDATE,&#10;                  document_create_status_id &#61; dms_completed,&#10;                  api_response &#61; l_response_string,&#10;                  api_return &#61; l_return_string&#10;                WHERE dms_document_id &#61; each_document.dms_document_id;&#10;                --&#10;            ELSE&#10;                --&#10;                g_label :&#61; &#39;700050&#39;;&#10;                info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;Document Upload Error&#39;);&#10;                l_err_count :&#61; l_err_count + 1;&#10;                --&#10;                UPDATE dms_document SET&#10;                  document_created &#61; 0,&#10;                  document_create_datetime &#61; SYSDATE,&#10;                  document_create_status_id &#61; dms_completederr,&#10;                  api_response &#61; l_response_string,&#10;                  api_return &#61; l_return_string&#10;                WHERE dms_document_id &#61; each_document.dms_document_id;&#10;                --&#10;            END IF;&#10;            COMMIT;&#10;            g_label :&#61; &#39;700060&#39;;&#10;            info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;updating thread progress [component_id: &#39; || l_component_id || &#39;][thread_id: &#39; || l_thread_id || &#39;][stop_flag: &#39; || check_semaphore(TO_CHAR(l_component_id)) || &#39;]&#39;);&#10;            update_thread_progress(p_rows &#61;&gt; l_row_count, p_info_msg &#61;&gt; l_row_count || &#39; rows completed [&#39; || l_err_count || &#39; with errors]&#39; );&#10;            --&#10;            g_label :&#61; &#39;700070&#39;;&#10;            IF check_semaphore(TO_CHAR(l_component_id)) !&#61; &#39;0&#39; THEN&#10;                info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;Semaphore signalled - stopping thread [componentID: &#39; || TO_CHAR(l_component_id));&#10;                EXIT;&#10;            END IF;&#10;        END LOOP;&#10;        --&#10;        g_label :&#61; &#39;700080&#39;;&#10;        info(&#39;[&#39; || l_component_id || &#39;]&#39; || l_row_count || &#39; rows completed [&#39; || l_err_count || &#39; with errors]&#39;);&#10;        IF check_semaphore(TO_CHAR(l_component_id)) !&#61; &#39;0&#39; THEN&#10;            info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;Stop document migration [componentID: &#39; || TO_CHAR(l_component_id) || &#39;][thread &#61; &#39; || TO_CHAR(l_thread_id) || &#39;]&#39;);&#10;        ELSE&#10;            info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;Completed document migration [thread &#61; &#39; || TO_CHAR(l_thread_id) || &#39;]&#39;);&#10;        END IF;&#10;    ELSE&#10;        UPDATE dms_document SET document_create_status_id &#61; dms_fatalerror&#10;        WHERE dms_offender_id &#61; dmsoffenderID_in&#10;          AND dms_document_id BETWEEN start_dmsDocumentID_in&#10;          AND end_dmsDocumentID_in;&#10;        COMMIT;&#10;        fatal(&#39;Unsupported version of Alfresco Support package&#39;);&#10;    END IF;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    error(&#39;Error captured in migrateDocument raising &#39; || SQLERRM);&#10;    RAISE;&#10;END migrateDocument;&#10;--&#10;--&#10;PROCEDURE migrateDocument(&#10;    dmsOffenderID_in       NUMBER,&#10;    start_dmsDocumentID_in NUMBER,&#10;    end_dmsDocumentID_in   NUMBER )&#10;IS&#10;    --&#10;    l_status          VARCHAR2(32767);&#10;    l_response_string CLOB;&#10;    l_return_string   CLOB;&#10;    l_row_count       PLS_INTEGER :&#61; 0;&#10;    l_err_count       PLS_INTEGER :&#61; 0;&#10;    --&#10;BEGIN&#10;    g_label :&#61; &#39;800000&#39;;&#10;    g_procedure_name :&#61; &#39;migrateDocument&#39;;&#10;    --&#10;    IF check_alfresco_support THEN&#10;        info(&#39;Commence document migration [queue]&#39;);&#10;        g_label :&#61; &#39;800010&#39;;&#10;        FOR each_document IN (&#10;            SELECT&#10;              do.dms_offender_id,&#10;              dd.dms_document_id,&#10;              dd.source_table,&#10;              dd.source_table_key,&#10;              do.offender_id,&#10;              o.crn,&#10;              dd.document_locked,&#10;              document_checked_out&#10;            FROM&#10;              dms_batch db&#10;                INNER JOIN dms_offender do ON do.dms_batch_id &#61; db.dms_batch_id&#10;                  INNER JOIN offender o ON o.offender_id &#61; do.offender_id&#10;                  INNER JOIN dms_document dd ON dd.dms_offender_id &#61; do.dms_offender_id&#10;            WHERE do.dms_offender_id &#61; dmsOffenderID_in&#10;              AND dd.dms_document_id BETWEEN start_dmsDocumentID_in AND end_dmsDocumentID_in&#10;              AND dd.document_create_status_id &lt;&#61; dms_completederr )&#10;        LOOP&#10;            g_label :&#61; &#39;800020&#39;;&#10;            l_row_count :&#61; l_row_count + 1;&#10;            info(&#39;Trying document &#39; || l_row_count);&#10;            l_status :&#61;&#10;                ALFRESCOSUPPORT.uploadnew(&#10;                    entityType_in       &#61;&gt; each_document.source_table,&#10;                    entityId_in         &#61;&gt; each_document.source_table_key,&#10;                    responseString_out  &#61;&gt; l_response_string,&#10;                    returnString_out    &#61;&gt; l_return_string,&#10;                    lockDocument_in     &#61;&gt; each_document.document_locked,&#10;                    checkoutDocument_in &#61;&gt; each_document.document_checked_out );&#10;            --&#10;            g_label :&#61; &#39;800030&#39;;&#10;            info(&#39;WEB API Status [&#39; || l_status || &#39;]&#39;);&#10;            --&#10;            IF l_status &#61; &#39;200&#39; THEN&#10;                g_label :&#61; &#39;800040&#39;;&#10;                info(&#39;Document Upload Success&#39;);&#10;                UPDATE dms_document SET&#10;                  document_created &#61; 1,&#10;                  document_create_datetime &#61; SYSDATE,&#10;                  document_create_status_id &#61; dms_completed,&#10;                  api_response &#61; l_response_string,&#10;                  api_return &#61; l_return_string&#10;                WHERE dms_document_id &#61; each_document.dms_document_id;&#10;                --&#10;            ELSE&#10;                g_label :&#61; &#39;800050&#39;;&#10;                info(&#39;Document Upload Error&#39;);&#10;                l_err_count :&#61; l_err_count + 1;&#10;                UPDATE dms_document SET&#10;                  document_created &#61; 0,&#10;                  document_create_datetime &#61; SYSDATE,&#10;                  document_create_status_id &#61; dms_completederr,&#10;                  api_response &#61; l_response_string,&#10;                  api_return &#61; l_return_string&#10;                WHERE dms_document_id &#61; each_document.dms_document_id;&#10;            END IF;&#10;            --&#10;            COMMIT;&#10;            --&#10;        END LOOP;&#10;        --&#10;        g_label :&#61; &#39;800080&#39;;&#10;        info(l_row_count || &#39; rows completed [&#39; || l_err_count || &#39; with errors]&#39;);&#10;        --&#10;    ELSE&#10;        --&#10;        UPDATE dms_document SET document_create_status_id &#61; dms_fatalerror&#10;        WHERE dms_offender_id &#61; dmsoffenderID_in&#10;          AND dms_document_id BETWEEN start_dmsDocumentID_in AND end_dmsDocumentID_in;&#10;        --&#10;        COMMIT;&#10;        --&#10;        fatal(&#39;Unsupported version of Alfresco Support package&#39;);&#10;    END IF;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    error(&#39;Error captured in migrateDocument raising &#39; || SQLERRM);&#10;    RAISE;&#10;END migrateDocument;&#10;--&#10;--&#10;PROCEDURE migrateDocument(&#10;    batchID_in         NUMBER,&#10;    mainComponentID_in NUMBER,&#10;    mainThreadID_in    NUMBER,&#10;    numOfThreads_in    INTEGER DEFAULT -1 )&#10;IS&#10;    l_batch_id     INTEGER;&#10;    l_component_id INTEGER;&#10;    l_max_threads  INTEGER;&#10;    l_rows         INTEGER;&#10;    --&#10;    CURSOR cs IS&#10;      WITH buckets AS (&#10;        SELECT&#10;          NTILE(l_max_threads) OVER(ORDER BY dd.dms_document_id) AS bucket_num,&#10;          dd.dms_document_id,&#10;          dd.dms_offender_id,&#10;          do.dms_batch_id,&#10;          SUBSTR(o.crn,1,3) folder&#10;        FROM&#10;          dms_batch db&#10;            INNER JOIN dms_offender do ON do.dms_batch_id &#61; db.dms_batch_id&#10;              INNER JOIN offender o ON o.offender_id &#61; do.offender_id&#10;              INNER JOIN dms_document dd ON dd.dms_offender_id &#61; do.dms_offender_id&#10;        WHERE db.dms_batch_id &#61; l_batch_id&#10;          AND db.document_create_status_id &lt;&#61; dms_completederr&#10;          AND dd.document_create_status_id &lt;&#61; dms_completederr )&#10;      --&#10;      SELECT&#10;        folder,&#10;        dms_offender_id,&#10;        min(dms_document_id) min_dms_document_id,&#10;        max(dms_document_id) max_dms_document_id,&#10;        COUNT(1) num_of_documents&#10;      FROM buckets&#10;      GROUP BY folder, dms_offender_id&#10;      ORDER BY 1,2,3;&#10;    --&#10;    l_thread_id      INTEGER;&#10;    l_failed_threads INTEGER;&#10;    --&#10;    l_folder              VARCHAR2(3);&#10;    l_dms_offender_id     DMS_OFFENDER.dms_offender_id%TYPE;&#10;    l_min_dms_document_id DMS_DOCUMENT.dms_document_id%TYPE;&#10;    l_max_dms_document_id DMS_DOCUMENT.dms_document_id%TYPE;&#10;    l_row_count           INTEGER;&#10;    l_status_id           DMS_STATUS.dms_status_id%TYPE;&#10;    l_stop_detected       BOOLEAN;&#10;    --&#10;    PROCEDURE create_thread_process(&#10;        p_thread_id         INTEGER,&#10;        dmsBatchID_in        NUMBER,&#10;        dmsOffenderID_in     NUMBER,&#10;        min_dmsDocumentID_in NUMBER,&#10;        max_dmsDocumentID_in NUMBER )&#10;    IS&#10;    BEGIN&#10;        --&#10;        IF NOT p_thread_id BETWEEN 1 AND l_max_threads THEN&#10;            error(&#39;ERROR: can not create the thread [&#39; || p_thread_id || &#39;] - thread# must be within the [1 .. &#39; || l_max_threads || &#39;] range&#39;);&#10;            RETURN;&#10;        END IF;&#10;        --&#10;        IF dmsBatchID_in IS NOT NULL AND min_dmsDocumentID_in IS NOT NULL AND max_dmsDocumentID_in IS NOT NULL THEN&#10;            C08001_PDT_SUPPORT.create_thread_process(&#10;                p_component_id &#61;&gt; l_component_id,&#10;                p_thread_id    &#61;&gt; p_thread_id,&#10;                p_min_id_val   &#61;&gt; min_dmsDocumentID_in,&#10;                p_max_id_val   &#61;&gt; max_dmsDocumentID_in,&#10;                p_thread_label &#61;&gt; &#39;Processing offender &#61;&gt; &#39; || TO_CHAR(dmsOffenderID_in),&#10;                p_program_action &#61;&gt;&#10;                   &#39;DECLARE&#10;                        l_thread_id    INTEGER :&#61; &#39; || p_thread_id    || &#39;;&#10;                        l_component_id INTEGER :&#61; &#39; || l_component_id || &#39;;&#10;                        l_rows         INTEGER :&#61; &#39; || l_rows || &#39;;&#10;                        l_label        VARCHAR2(10) :&#61; &#39;&#39;000010&#39;&#39;;&#10;                        --&#10;                        PROCEDURE update_thread_status(p_status INTEGER, p_err_msg VARCHAR2 DEFAULT NULL) IS&#10;                        BEGIN&#10;                            C08001_PDT_SUPPORT.update_thread_status(&#10;                                p_component_id &#61;&gt; l_component_id,&#10;                                p_thread_id    &#61;&gt; l_thread_id,&#10;                                p_status       &#61;&gt; p_status,&#10;                                p_err_msg      &#61;&gt; p_err_msg);&#10;                        END update_thread_status;&#10;                        --&#10;                        PROCEDURE update_thread_progress(p_rows INTEGER, p_info_msg VARCHAR2 DEFAULT NULL) IS&#10;                        BEGIN&#10;                            C08001_PDT_SUPPORT.update_thread_progress(&#10;                                p_component_id &#61;&gt; l_component_id,&#10;                                p_thread_id    &#61;&gt; l_thread_id,&#10;                                p_rows         &#61;&gt; p_rows,&#10;                                p_info_msg     &#61;&gt; p_info_msg);&#10;                        END update_thread_progress;&#10;                        --&#10;                    BEGIN&#10;                        --&#10;                        l_label :&#61; &#39;&#39;000010&#39;&#39;;&#10;                        update_thread_status(1);&#10;                        l_label :&#61; &#39;&#39;000020&#39;&#39;;&#10;                        DOCMIGRATIONSUPPORT.migrateDocument(  dmsBatchID_in &#61;&gt; &#39; || dmsBatchID_in ||&#39;,&#10;                                                              dmsOffenderID_in &#61;&gt; &#39; || dmsOffenderID_in || &#39;,&#10;                                                              start_dmsDocumentID_in &#61;&gt; &#39; || min_dmsDocumentID_in || &#39;,&#10;                                                              end_dmsDocumentID_in &#61;&gt; &#39; || max_dmsDocumentID_in || &#39;,&#10;                                                              componentID_in &#61;&gt; l_component_id,&#10;                                                              threadID_in &#61;&gt; l_thread_id);&#10;                        l_label :&#61; &#39;&#39;000030&#39;&#39;;&#10;                        update_thread_status(3);&#10;                    EXCEPTION WHEN OTHERS THEN&#10;                        update_thread_status(2, &#39;&#39;Fatal error exception [&#39;&#39; || l_label || &#39;&#39;]: &#39;&#39; || SQLERRM);&#10;                    END;&#39;&#10;            );&#10;        ELSE&#10;            error(&#39;Error: THREAD# &#39; || p_thread_id || &#39; can not be initialised due to incorrect Document ID range [&#39; || min_dmsDocumentID_in || &#39;][&#39; || max_dmsDocumentID_in || &#39;]&#39;);&#10;        END IF;&#10;        --&#10;    END create_thread_process;&#10;    --&#10;    PROCEDURE reset_threads(p_component_id INTEGER, p_thread_id INTEGER DEFAULT NULL) IS&#10;    BEGIN&#10;        C08001_PDT_SUPPORT.reset_threads(p_component_id &#61;&gt; p_component_id, p_thread_id &#61;&gt; p_thread_id);&#10;    END reset_threads;&#10;    --&#10;    FUNCTION get_num_of_failed_threads RETURN INTEGER&#10;    IS&#10;        l_ret INTEGER;&#10;    BEGIN&#10;        IF l_max_threads &gt; 1 THEN&#10;            l_ret :&#61; C08001_PDT_SUPPORT.get_num_of_failed_threads(p_component_id &#61;&gt; l_component_id);&#10;        ELSE&#10;            l_ret :&#61; 0;&#10;        END IF;&#10;        --&#10;        RETURN l_ret;&#10;    END get_num_of_failed_threads;&#10;    --&#10;    FUNCTION get_available_thread RETURN INTEGER IS&#10;    BEGIN&#10;        RETURN&#10;            C08001_PDT_SUPPORT.get_available_thread(&#10;                p_component_id &#61;&gt; l_component_id,&#10;                p_wait         &#61;&gt; 5,&#10;                p_timeout      &#61;&gt; 180,&#10;                p_max_threads  &#61;&gt; l_max_threads );&#10;    END get_available_thread;&#10;    --&#10;    PROCEDURE wait_for_threads_to_finish(p_thread_id INTEGER DEFAULT -1) IS&#10;    BEGIN&#10;        C08001_PDT_SUPPORT.wait_for_threads_to_finish(p_component_id &#61;&gt; l_component_id);&#10;    END wait_for_threads_to_finish;&#10;    --&#10;    FUNCTION check_semaphore(p_component_code VARCHAR2) RETURN VARCHAR2 IS&#10;    BEGIN&#10;        RETURN C08001_PDT_SUPPORT.check_semaphore(p_component_code &#61;&gt; p_component_code);&#10;    END check_semaphore;&#10;    --&#10;    PROCEDURE update_main_thread_status(p_status INTEGER, p_err_msg VARCHAR2 DEFAULT NULL) IS&#10;    BEGIN&#10;        C08001_PDT_SUPPORT.update_thread_status(&#10;            p_component_id &#61;&gt; mainComponentID_in,&#10;            p_thread_id    &#61;&gt; mainThreadID_in,&#10;            p_status       &#61;&gt; p_status,&#10;            p_err_msg      &#61;&gt; p_err_msg);&#10;    END update_main_thread_status;&#10;    --&#10;    PROCEDURE update_main_thread_progress(p_rows INTEGER, p_info_msg VARCHAR2 DEFAULT NULL) IS&#10;    BEGIN&#10;        C08001_PDT_SUPPORT.update_thread_progress(&#10;            p_component_id &#61;&gt; mainComponentID_in,&#10;            p_thread_id    &#61;&gt; mainThreadID_in,&#10;            p_rows         &#61;&gt; p_rows,&#10;            p_info_msg     &#61;&gt; p_info_msg);&#10;    END update_main_thread_progress;&#10;    --&#10;BEGIN&#10;    l_batch_id      :&#61; batchID_in;&#10;    l_component_id  :&#61; TO_NUMBER(&#39;130&#39; || TO_CHAR(batchID_in));&#10;    l_max_threads   :&#61; CASE WHEN numOfThreads_in &lt;&#61; 0 THEN C08001_PDT_SUPPORT.get_cpu_count * 2 ELSE numOfThreads_in END;&#10;    l_rows          :&#61; -1;&#10;    l_stop_detected :&#61; FALSE;&#10;    --&#10;    g_label :&#61; &#39;800000&#39;;&#10;    g_procedure_name :&#61; &#39;migrateDocument&#39;;&#10;    --&#10;    update_main_thread_status(1);&#10;    IF check_alfresco_support THEN&#10;        info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;Commence threaded document migration [&#39; || l_batch_id || &#39;]&#39;);&#10;        --&#10;        g_label :&#61; &#39;800005&#39;;&#10;        DELETE FROM pdt_semaphore WHERE component_code &#61; TO_CHAR(l_component_id);&#10;        COMMIT;&#10;        info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;Cleared current semaphore rows&#39;);&#10;        --&#10;        g_label :&#61; &#39;800010&#39;;&#10;        UPDATE dms_batch SET&#10;          document_create_start &#61; SYSDATE,&#10;          document_create_status_id &#61; dms_commenced&#10;        WHERE dms_batch_id &#61; l_batch_id;&#10;        --&#10;        COMMIT;&#10;        --&#10;        info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;Changed document_create_status to 2 [Commenced] for batch_id &#39; || l_batch_id);&#10;        --&#10;        g_label :&#61; &#39;800020&#39;;&#10;        reset_threads(p_component_id &#61;&gt; l_component_id);&#10;        g_label :&#61; &#39;800030&#39;;&#10;        --&#10;        update_main_thread_progress(p_rows &#61;&gt; 1, p_info_msg &#61;&gt; &#39;processing sub threads&#39;);&#10;        --&#10;        OPEN cs;&#10;        LOOP&#10;            g_label :&#61; &#39;800040&#39;;&#10;            FETCH cs INTO l_folder, l_dms_offender_id, l_min_dms_document_id, l_max_dms_document_id, l_rows;&#10;            EXIT WHEN cs%NOTFOUND;&#10;            --&#10;            LOOP&#10;                -- Get next available thread&#10;                l_thread_id :&#61; get_available_thread;&#10;                EXIT WHEN l_thread_id &gt; 0;&#10;            END LOOP;&#10;            --&#10;            g_label :&#61; &#39;800045&#39;;&#10;            IF check_semaphore(TO_CHAR(l_component_id)) !&#61; &#39;0&#39; THEN&#10;              info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;Semaphore signalled - stopping thread&#39;);&#10;              l_stop_detected :&#61; TRUE;&#10;              EXIT;&#10;            END IF;&#10;            --&#10;            g_label :&#61; &#39;800050&#39;;&#10;            info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;CREATE_THREAD_PROCESS( l_thread_id &#61;&gt; &#39; || l_thread_id || &#39;, l_batch_id &#61;&gt;  &#39; || l_batch_id || &#39;, l_dms_offender_id &#61;&gt; &#39; || l_dms_offender_id || &#39;, l_min_dms_document_id &#61;&gt; &#39; || l_min_dms_document_id || &#39;, l_max_dms_document_id &#61;&gt; &#39; || l_max_dms_document_id || &#39;)&#39;);&#10;            create_thread_process(l_thread_id, l_batch_id, l_dms_offender_id, l_min_dms_document_id, l_max_dms_document_id);&#10;            COMMIT;&#10;            --&#10;            g_label :&#61; &#39;800060&#39;;&#10;            l_failed_threads :&#61; get_num_of_failed_threads;&#10;            IF l_failed_threads &gt; 0 THEN&#10;                g_label :&#61; &#39;800070&#39;;&#10;                error(&#39;Failed threads detected&#39;);&#10;                update_main_thread_status(3);&#10;                EXIT;&#10;            END IF;&#10;            --&#10;        END LOOP;&#10;        g_label :&#61; &#39;800080&#39;;&#10;        CLOSE cs;&#10;        --&#10;        info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;Stop Detected &#61;&gt; &#39; || CASE WHEN l_stop_detected THEN &#39;TRUE&#39; ELSE &#39;FALSE&#39; END);&#10;        --&#10;        update_main_thread_progress(p_rows &#61;&gt; 1, p_info_msg &#61;&gt; &#39;waiting for sub threads to finish&#39;);&#10;        --&#10;        g_label :&#61; &#39;800090&#39;;&#10;        info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;waiting for threads to complete&#39;);&#10;        wait_for_threads_to_finish;&#10;        --&#10;        g_label :&#61; &#39;800100&#39;;&#10;        l_failed_threads :&#61; get_num_of_failed_threads;&#10;        info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;failed thread count &#61; &#39; || l_failed_threads);&#10;        --&#10;        IF l_failed_threads &gt; 0 THEN&#10;            --&#10;            g_label :&#61; &#39;800110&#39;;&#10;            UPDATE dms_batch SET document_create_status_id &#61; dms_fatalerror&#10;            WHERE dms_batch_id &#61; l_batch_id;&#10;            update_main_thread_status(2);&#10;            info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;Failed thread detected - set batch to error [&#39; || SQL%ROWCOUNT || &#39; rows updated]&#39;);&#10;            --&#10;        ELSIF l_stop_detected OR check_semaphore(TO_CHAR(l_component_id)) !&#61; &#39;0&#39; THEN&#10;            --&#10;            g_label :&#61; &#39;800120&#39;;&#10;            UPDATE dms_document SET document_create_status_id &#61; dms_paused&#10;            WHERE document_create_status_id &lt; dms_completederr&#10;              AND document_create_status_id &lt;&gt; dms_paused AND 1&#61;0;&#10;            info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;Stop detected - set documents to paused [&#39; || SQL%ROWCOUNT || &#39; rows updated]&#39;);&#10;            --&#10;            UPDATE dms_batch SET document_create_status_id &#61; dms_paused&#10;            WHERE document_create_status_id &lt; dms_completederr&#10;              AND dms_batch_id &#61; l_batch_id;&#10;            info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;Stop detected - set batches to paused [&#39; || SQL%ROWCOUNT || &#39; rows updated]&#39;);&#10;            --&#10;        ELSE&#10;            g_label :&#61; &#39;800130&#39;;&#10;            SELECT COUNT(1) INTO l_row_count&#10;            FROM&#10;              dms_batch db&#10;                INNER JOIN dms_offender do ON do.dms_batch_id &#61; db.dms_batch_id&#10;                  INNER JOIN offender o ON o.offender_id &#61; do.offender_id&#10;                  INNER JOIN dms_document dd ON dd.dms_offender_id &#61; do.dms_offender_id&#10;            WHERE db.dms_batch_id &#61; l_batch_id&#10;              AND dd.document_create_status_id !&#61; dms_completed;&#10;            --&#10;            g_label :&#61; &#39;800140&#39;;&#10;            info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;l_row_count &#61;&gt; &#39; || l_row_count);&#10;            IF l_row_count &gt; 0 THEN&#10;                l_status_id :&#61; dms_completederr;&#10;            ELSE&#10;                l_status_id :&#61; dms_completed;&#10;            END IF;&#10;            --&#10;            g_label :&#61; &#39;800150&#39;;&#10;            UPDATE dms_batch SET&#10;              document_create_finish &#61; SYSDATE,&#10;              document_create_status_id &#61; l_status_id&#10;            WHERE dms_batch_id &#61; l_batch_id;&#10;            --&#10;            info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;updated &#39; || SQL%ROWCOUNT || &#39; rows in dms_batch&#39;);&#10;            --&#10;            update_main_thread_progress(p_rows &#61;&gt; 1, p_info_msg &#61;&gt; &#39;finished processing sub threads&#39;);&#10;            update_main_thread_status(3);&#10;            info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;Completed threaded document migration [&#39; || l_batch_id || &#39;]&#39;);&#10;            --&#10;        END IF;&#10;        --&#10;        COMMIT;&#10;        --&#10;    ELSE&#10;        --&#10;        UPDATE dms_batch SET document_create_status_id &#61; dms_fatalerror&#10;        WHERE dms_batch_id &#61; l_batch_id;&#10;        --&#10;        update_main_thread_status(2);&#10;        --&#10;        COMMIT;&#10;        --&#10;        fatal(&#39;Unsupported version of Alfresco Support package&#39;);&#10;    END IF;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    error(&#39;Error captured in migrateDocument raising &#39; || SQLERRM);&#10;    RAISE;&#10;END migrateDocument;&#10;--&#10;--&#10;FUNCTION getProbationArea(userId_in NUMBER) RETURN NUMBER RESULT_CACHE&#10;IS&#10;    --&#10;    l_ret NUMBER;&#10;    --&#10;    CURSOR cs IS&#10;      SELECT probation_area_id&#10;      FROM probation_area_user&#10;      WHERE user_id &#61; userID_in;&#10;    --&#10;BEGIN&#10;    OPEN cs;&#10;    FETCH cs INTO l_ret;&#10;    CLOSE cs;&#10;    --&#10;    RETURN l_ret;&#10;END getProbationArea;&#10;--&#10;--&#10;PROCEDURE save_search(OffenderID_in NUMBER, documentCount_in NUMBER, returnString_in IN CLOB)&#10;IS&#10;    PRAGMA AUTONOMOUS_TRANSACTION;&#10;BEGIN&#10;    UPDATE dms_offender SET&#10;      search_return &#61; returnString_in,&#10;      alfresco_document_count &#61; documentCount_in,&#10;      last_search_datetime &#61; SYSDATE&#10;    WHERE offender_id &#61; OffenderID_in;&#10;    COMMIT;&#10;END save_search;&#10;--&#10;--&#10;/*100000*/&#10;FUNCTION alfrescoContent(&#10;    crn_in       VARCHAR2,&#10;    p_alf_doc_id VARCHAR2 DEFAULT NULL,&#10;    p_wait       NUMBER   DEFAULT NULL )&#10;RETURN alfresco_content_tab_TYP PIPELINED&#10;IS&#10;    --&#10;    l_status          VARCHAR2(10);&#10;    l_response_string CLOB;&#10;    l_return_string   CLOB;&#10;    --&#10;    l_crn             OFFENDER.crn%TYPE;&#10;    l_offender_id     NUMBER;&#10;    l_rec             alfresco_content_row_typ;&#10;    l_obj             JSON_OBJECT_T; -- :&#61; JSON_OBJECT_T(); --json;&#10;    l_obj1            JSON_OBJECT_T;&#10;    l_arr             JSON_ARRAY_T;&#10;    l_cnt             INTEGER;&#10;    --&#10;    L_WAIT            NUMBER :&#61; NVL(p_wait, -1);&#10;    --&#10;    FUNCTION json_2_ora_date(p_date_char VARCHAR2) RETURN DATE IS&#10;    BEGIN&#10;        RETURN&#10;            TO_TIMESTAMP(&#10;                REPLACE(REPLACE(p_date_char, &#39;T&#39;, &#39; &#39;), &#39;Z&#39;, &#39;&#39;),&#10;                &#39;YYYY-MM-DD HH24:MI:SS.FF3&#39; );&#10;    END json_2_ora_date;&#10;    --&#10;BEGIN&#10;    --&#10;    l_crn :&#61; crn_in;&#10;    --&#10;    l_offender_id :&#61; PKG_Lookups.funcgetTabRecord(p_table&#61;&gt;&#39;OFFENDER&#39;, p_data_fld&#61;&gt;&#39;offender_id&#39;, p_ref_col&#61;&gt;&#39;CRN&#39;, p_ref_val&#61;&gt;l_crn);&#10;    --&#10;    l_status :&#61;&#10;        ALFRESCOSUPPORT.searchAlfresco(&#10;            offenderID_in      &#61;&gt; l_offender_id,&#10;            responseString_out &#61;&gt; l_response_string,&#10;            returnString_out   &#61;&gt; l_return_string );&#10;    --&#10;    IF L_WAIT &gt; 0 THEN&#10;        -- DST-11269: a workaround for the ALF limiter&#10;        DBMS_LOCK.sleep(LEAST(L_WAIT, 30));&#10;    END IF;&#10;    --&#10;    --raise_application_error(-20001, &#39;[&#39; || l_status || &#39;][&#39; || l_return_string || &#39;][&#39; || l_response_string || &#39;]&#39;);&#10;    --&#10;    IF l_status &#61; &#39;503&#39; OR l_response_string LIKE &#39;%HTTP server error 503 - Service Temporarily Unavailable&#39; THEN&#10;        fatal(&#39;ALF Server is unavailable: &#39; || &#39;[&#39; || l_status || &#39;][&#39; || l_return_string || &#39;][&#39; || l_response_string || &#39;]&#39;, &#39;DocMigrationSupport.alfrescoContent&#39;);&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    IF l_status &#61; &#39;200&#39; THEN&#10;        --&#10;        l_obj :&#61; JSON_OBJECT_T.parse(l_return_string);&#10;        l_arr :&#61; l_obj.get_array(&#39;documents&#39;);&#10;        l_cnt :&#61; l_arr.get_size;&#10;        --l_cnt :&#61; l_obj.get_string(&#39;numberOfDocuments&#39;);&#10;        --&#10;        --save_search(OffenderID_in &#61;&gt; l_offender_id, documentCount_in &#61;&gt; l_cnt, returnString_in &#61;&gt; l_return_string);&#10;        --&#10;        FOR l_i IN 0 .. l_cnt-1 LOOP&#10;            --&#10;            --    /*00*/ crn                 VARCHAR2(7),&#10;            --    --&#10;            --    /*01*/ id                  VARCHAR2(36),&#10;            --    /*02*/ name                VARCHAR2(200),&#10;            --    --&#10;            --    /*03*/ entity_type         VARCHAR2(30),   --entityType&#10;            --    /*04*/ entity_id           VARCHAR2(40),   --entityId&#10;            --    /*05*/ document_type       VARCHAR2(100),  --docType&#10;            --    /*06*/ author              VARCHAR2(200),  --author&#10;            --    --&#10;            --    /*07*/ lock_owner          VARCHAR2(200),  --lockOwner&#10;            --    /*08*/ reservation_owner   VARCHAR2(200),  --reservationOwner&#10;            --    --&#10;            --    /*09*/ locked              VARCHAR2(5),&#10;            --    /*10*/ reserved            VARCHAR2(5),&#10;            --    /*11*/ deleted             VARCHAR2(5),&#10;            --    --&#10;            --    /*12*/ creation_date       DATE,           --creationDate&#10;            --    /*13*/ last_modified_date  DATE,           --lastModifiedDate&#10;            --    /*14*/ modifier            VARCHAR2(200),&#10;            --    --&#10;            --    /*15*/ url                 VARCHAR2(100) );&#10;            --&#10;            l_obj1 :&#61; JSON_OBJECT_T(l_arr.get(l_i));&#10;            --&#10;            l_rec.crn               :&#61; /*00*/ l_obj1.get_string(&#39;crn&#39;);&#10;            l_rec.id                :&#61; /*01*/ l_obj1.get_string(&#39;id&#39;);&#10;            l_rec.name              :&#61; /*02*/ l_obj1.get_string(&#39;name&#39;);&#10;            --&#10;            l_rec.entity_type       :&#61; /*03*/ l_obj1.get_string(&#39;entityType&#39;);&#10;            l_rec.entity_id         :&#61; /*04*/ l_obj1.get_string(&#39;entityId&#39;);&#10;            l_rec.document_type     :&#61; /*05*/ l_obj1.get_string(&#39;docType&#39;);&#10;            l_rec.author            :&#61; /*06*/ l_obj1.get_string(&#39;author&#39;);&#10;            l_rec.lock_owner        :&#61; /*07*/ l_obj1.get_string(&#39;lockOwner&#39;);&#10;            l_rec.reservation_owner :&#61; /*08*/ l_obj1.get_string(&#39;reservationOwner&#39;);&#10;            --&#10;            l_rec.locked            :&#61; /*09*/ l_obj1.get_string(&#39;locked&#39;);&#10;            l_rec.reserved          :&#61; /*10*/ l_obj1.get_string(&#39;reserved&#39;);&#10;            --&#10;            l_rec.creation_date     :&#61; /*12*/ json_2_ora_date(l_obj1.get_string(&#39;creationDate&#39;));&#10;            l_rec.last_modified_date:&#61; /*13*/ json_2_ora_date(l_obj1.get_string(&#39;lastModifiedDate&#39;));&#10;            l_rec.modifier          :&#61; /*14*/ l_obj1.get_string(&#39;modifier&#39;);&#10;            l_rec.url               :&#61; /*15*/ l_obj1.get_string(&#39;url&#39;);&#10;            --&#10;            IF p_alf_doc_id IS NULL OR p_alf_doc_id &#61; l_rec.id THEN&#10;                PIPE ROW(l_rec);&#10;            END IF;&#10;            --&#10;        END LOOP;&#10;        --&#10;    END IF;&#10;    --&#10;    --DBMS_LOCK.sleep(0.1);&#10;    --&#10;    RETURN;&#10;    --&#10;END alfrescoContent;&#10;--&#10;--&#10;/*110000*/&#10;FUNCTION ndeliusContent(crn_in VARCHAR2) RETURN alfresco_content_tab_typ PIPELINED&#10;IS&#10;    --&#10;    l_crn             OFFENDER.crn%TYPE;&#10;    l_offender_id     NUMBER;&#10;    l_rec             alfresco_content_row_typ;&#10;    --&#10;BEGIN&#10;    l_crn :&#61; crn_in;&#10;    --&#10;    SELECT offender_id INTO l_offender_id&#10;    FROM offender&#10;    WHERE crn &#61; l_crn;&#10;    --&#10;    --    l_rec.crn               :&#61; /*00*/ l_obj1.get_string(&#39;crn&#39;);&#10;    --    l_rec.id                :&#61; /*01*/ l_obj1.get_string(&#39;id&#39;);&#10;    --    l_rec.name              :&#61; /*02*/ l_obj1.get_string(&#39;name&#39;);&#10;    --&#10;    --    l_rec.entity_type       :&#61; /*03*/ l_obj1.get_string(&#39;entityType&#39;);&#10;    --    l_rec.entity_id         :&#61; /*04*/ l_obj1.get_string(&#39;entityId&#39;);&#10;    --    l_rec.document_type     :&#61; /*05*/ l_obj1.get_string(&#39;docType&#39;);&#10;    --    l_rec.author            :&#61; /*06*/ l_obj1.get_string(&#39;author&#39;);&#10;    --    l_rec.lock_owner        :&#61; /*07*/ l_obj1.get_string(&#39;lockOwner&#39;);&#10;    --    l_rec.reservation_owner :&#61; /*08*/ l_obj1.get_string(&#39;reservationOwner&#39;);&#10;    --&#10;    --    l_rec.locked            :&#61; /*09*/ l_obj1.get_string(&#39;locked&#39;);&#10;    --    l_rec.reserved          :&#61; /*10*/ l_obj1.get_string(&#39;reserved&#39;);&#10;    --    --&#10;    --    l_rec.creation_date     :&#61; /*12*/ json_2_ora_date(l_obj1.get_string(&#39;creationDate&#39;));&#10;    --    l_rec.last_modified_date:&#61; /*13*/ json_2_ora_date(l_obj1.get_string(&#39;lastModifiedDate&#39;));&#10;    --    l_rec.modifier          :&#61; /*14*/ l_obj1.get_string(&#39;modifier&#39;);&#10;    --    l_rec.url               :&#61; /*15*/ l_obj1.get_string(&#39;url&#39;);&#10;&#10;    FOR each_document IN (&#10;        SELECT&#10;          /*00*/ O.crn,&#10;          /*01*/ D.alfresco_document_id                AS id,&#10;          /*02*/ D.document_name                       AS name,&#10;          /*03*/ NVL(D.table_name, &#39;DOCUMENT&#39;)         AS entity_type,&#10;          /*04*/ D.document_id                         AS entity_id,&#10;          /*05*/ &#39;DOCUMENT&#39;                            AS document_type,&#10;          /*06*/ U1.distinguished_name                 AS author,&#10;          --&#10;          /*07*/ CASE WHEN DD.document_locked &#61; &#39;Y&#39;      THEN DD.last_updated_user END AS lock_owner,&#10;          /*08*/ CASE WHEN DD.document_checked_out &#61; &#39;Y&#39; THEN DD.last_updated_user END AS reservation_owner,&#10;          /*09*/ CASE WHEN DD.document_locked &#61; &#39;Y&#39;      THEN &#39;true&#39; ELSE &#39;false&#39;  END AS locked,&#10;          /*10*/ CASE WHEN DD.document_checked_out &#61; &#39;Y&#39; THEN &#39;true&#39; ELSE &#39;false&#39;  END AS reserved,&#10;          --&#10;          /*11*/ D.soft_deleted                        AS deleted,&#10;          --&#10;          /*12*/ D.created_datetime,&#10;          /*13*/ D.last_saved                          AS last_updated_datetime,&#10;          /*14*/ U2.distinguished_name                 AS modifier&#10;        FROM&#10;          document D&#10;            LEFT OUTER JOIN dms_document DD ON D.document_id &#61; DD.source_table_key AND DD.source_table &#61; &#39;DOCUMENT&#39;&#10;            INNER JOIN offender O ON O.offender_id &#61; D.offender_id&#10;            INNER JOIN user_ U1 ON U1.user_id &#61; D.created_by_user_id&#10;            INNER JOIN user_ U2 ON U2.user_id &#61; D.last_updated_user_id&#10;        WHERE O.offender_id &#61; l_offender_id&#10;        --&#10;        UNION ALL&#10;        --&#10;        SELECT&#10;          /*00*/ O.crn,&#10;          /*01*/ D.alfresco_document_id                AS id,&#10;          /*02*/ D.document_name                       AS name,&#10;          /*03*/ &#39;EVENT&#39;                               AS entity_type,&#10;          /*04*/ E.event_id                            AS entity_id,&#10;          /*05*/ &#39;CPS_DOCUMENT&#39;                        AS document_type,&#10;          /*06*/ U1.distinguished_name                 AS author,&#10;          --&#10;          /*07*/ CASE WHEN DD.document_locked &#61; &#39;Y&#39;      THEN DD.last_updated_user END AS lock_owner,&#10;          /*08*/ CASE WHEN DD.document_checked_out &#61; &#39;Y&#39; THEN DD.last_updated_user END AS reservation_owner,&#10;          /*09*/ CASE WHEN DD.document_locked &#61; &#39;Y&#39;      THEN &#39;true&#39; ELSE &#39;false&#39;  END AS locked,&#10;          /*10*/ CASE WHEN DD.document_checked_out &#61; &#39;Y&#39; THEN &#39;true&#39; ELSE &#39;false&#39;  END AS reserved,&#10;          /*11*/ D.soft_deleted                        AS deleted,&#10;          --&#10;          /*12*/ D.created_datetime                    AS created_datetime,&#10;          /*13*/ D.date_produced                       AS last_updated_datetime,&#10;          /*14*/ U2.distinguished_name                 AS modifier&#10;        FROM&#10;          event E&#10;            INNER JOIN document D ON D.offender_id &#61; E.offender_id&#10;                                 AND D.table_name &#61; &#39;EVENT&#39;&#10;                                 AND D.primary_key_id &#61; TO_CHAR(E.event_id)&#10;                                 AND D.document_type &#61; &#39;CPS_PACK&#39;&#10;            LEFT OUTER JOIN dms_document DD ON E.event_id &#61; DD.source_table_key AND DD.source_table &#61; &#39;EVENT&#39;&#10;            INNER JOIN offender O ON O.offender_id &#61; E.offender_id&#10;            LEFT OUTER JOIN user_ U1 ON U1.user_id &#61; D.created_by_user_id&#10;            LEFT OUTER JOIN user_ U2 ON U2.user_id &#61; D.last_updated_user_id&#10;        WHERE E.offender_id &#61; l_offender_id&#10;          AND D.alfresco_document_id IS NOT NULL&#10;        --&#10;        UNION ALL&#10;        --&#10;        SELECT&#10;          /*00*/ O.crn,&#10;          /*01*/ D.alfresco_document_id                AS id,&#10;          /*02*/ D.document_name                       AS name,&#10;          /*03*/ &#39;OFFENDER&#39;                            AS entity_type,&#10;          /*04*/ O.offender_id                         AS entity_id,&#10;          /*05*/ &#39;PREVIOUS_CONVICTION&#39;                 AS document_type,&#10;          /*06*/ U1.distinguished_name                 AS author,&#10;          --&#10;          /*07*/ CASE WHEN DD.document_locked &#61; &#39;Y&#39;      THEN DD.last_updated_user END AS lock_owner,&#10;          /*08*/ CASE WHEN DD.document_checked_out &#61; &#39;Y&#39; THEN DD.last_updated_user END AS reservation_owner,&#10;          /*09*/ CASE WHEN dd.document_locked &#61; &#39;Y&#39;      THEN &#39;true&#39; ELSE &#39;false&#39;  END AS locked,&#10;          /*10*/ CASE WHEN dd.document_checked_out &#61; &#39;Y&#39; THEN &#39;true&#39; ELSE &#39;false&#39;  END AS reserved,&#10;          /*11*/ O.soft_deleted                        AS deleted,&#10;          --&#10;          /*12*/ D.created_datetime,&#10;          /*13*/ D.date_produced                       AS last_updated_datetime,&#10;          /*14*/ U2.distinguished_name                 AS modifier&#10;        FROM&#10;           offender O&#10;             INNER JOIN document D ON D.offender_id &#61; O.offender_id&#10;                                  AND D.table_name &#61; &#39;OFFENDER&#39;&#10;                                  AND D.primary_key_id &#61; TO_CHAR(O.offender_id)&#10;                                  AND D.document_type &#61; &#39;PREVIOUS_CONVICTION&#39;&#10;             LEFT OUTER JOIN dms_document DD ON O.offender_id &#61; DD.source_table_key AND DD.source_table &#61; &#39;OFFENDER&#39;&#10;             LEFT OUTER JOIN user_ U1 ON U1.user_id &#61; D.created_by_user_id&#10;             LEFT OUTER JOIN user_ U2 ON U2.user_id &#61; D.last_updated_user_id&#10;        WHERE O.offender_id &#61; l_offender_id&#10;          AND D.alfresco_document_id IS NOT NULL&#10;      )&#10;    LOOP&#10;        l_rec.crn               :&#61; /*00*/ l_crn;&#10;        l_rec.id                :&#61; /*01*/ each_document.id;&#10;        l_rec.name              :&#61; /*02*/ each_document.name;&#10;        --&#10;        l_rec.entity_type       :&#61; /*03*/ each_document.entity_type;&#10;        l_rec.entity_id         :&#61; /*04*/ each_document.entity_id;&#10;        l_rec.document_type     :&#61; /*05*/ each_document.document_type;&#10;        l_rec.author            :&#61; /*06*/ each_document.author;&#10;        l_rec.lock_owner        :&#61; /*07*/ each_document.lock_owner;&#10;        l_rec.reservation_owner :&#61; /*08*/ each_document.reservation_owner;&#10;        --&#10;        l_rec.locked            :&#61; /*09*/ each_document.locked;&#10;        l_rec.reserved          :&#61; /*10*/ each_document.reserved;&#10;        l_rec.deleted           :&#61; /*11*/ each_document.deleted;&#10;        --&#10;        l_rec.creation_date     :&#61; /*12*/ each_document.created_datetime;&#10;        l_rec.last_modified_date:&#61; /*13*/ each_document.last_updated_datetime;&#10;        l_rec.modifier          :&#61; /*14*/ each_document.modifier;&#10;        l_rec.url               :&#61; /*15*/ NULL;&#10;        --&#10;        PIPE ROW(l_rec);&#10;        --&#10;    END LOOP;&#10;    --&#10;    RETURN;&#10;    --&#10;END ndeliusContent;&#10;--&#10;--&#10;/*120000*/&#10;PROCEDURE collectValidation(CRN_in VARCHAR2)&#10;IS&#10;    l_crn               OFFENDER.crn%TYPE;&#10;    l_dms_offender_id   DMS_OFFENDER.dms_offender_id%TYPE;&#10;    --&#10;    CURSOR cs(CRNin VARCHAR2) IS&#10;      SELECT&#10;        0 dms_validation_id,&#10;        0 dms_offender_id, id,&#10;        name,&#10;        locked,&#10;        reserved,&#10;        COUNT(src1) ndelius_flag,&#10;        COUNT(src2) alfresco_flag&#10;      FROM&#10;        ( SELECT a.*, 1 src1, TO_NUMBER(NULL) src2&#10;          FROM TABLE(DOCMIGRATIONSUPPORT.ndeliusContent(crn_in &#61;&gt; CRNin)) a&#10;          UNION ALL&#10;          SELECT b.*, TO_NUMBER(NULL) src1, 2 src2&#10;          FROM TABLE(DOCMIGRATIONSUPPORT.alfrescoContent(crn_in &#61;&gt; CRNin )) b&#10;        )&#10;      GROUP BY id, name,locked,reserved&#10;      HAVING COUNT(src1) &lt;&gt; COUNT(src2);&#10;    --&#10;    TYPE validation_tab_typ IS TABLE OF cs%ROWTYPE INDEX BY PLS_INTEGER;&#10;    validation  validation_tab_typ;&#10;    --&#10;BEGIN&#10;    l_crn :&#61; CRN_in;&#10;    --&#10;    SELECT do.dms_offender_id INTO l_dms_offender_id&#10;    FROM offender o INNER JOIN dms_offender do ON o.offender_id &#61; do.offender_id&#10;    WHERE o.crn &#61; l_crn;&#10;    --&#10;    DELETE FROM dms_validation WHERE dms_offender_id &#61; l_dms_offender_id;&#10;    --&#10;    OPEN cs(CRNin &#61;&gt; l_crn);&#10;    FETCH cs BULK COLLECT INTO validation;&#10;    CLOSE cs;&#10;    --&#10;    FOR i IN 1 .. validation.COUNT LOOP&#10;        validation(i).dms_validation_id :&#61; dms_validation_id_seq.NEXTVAL;&#10;        validation(i).dms_offender_id :&#61; l_dms_offender_id;&#10;    END LOOP;&#10;    --&#10;    FORALL i IN 1 .. validation.COUNT&#10;        INSERT INTO dms_validation(&#10;          dms_validation_id,&#10;          dms_offender_id,&#10;          id,&#10;          name,&#10;          locked,&#10;          reserved,&#10;          ndelius_flag,&#10;          alfresco_flag&#10;        ) VALUES (&#10;          validation(i).dms_validation_id,&#10;          validation(i).dms_offender_id,&#10;          validation(i).id,&#10;          validation(i).name,&#10;          validation(i).locked,&#10;          validation(i).reserved,&#10;          validation(i).ndelius_flag,&#10;          validation(i).alfresco_flag );&#10;    --&#10;    COMMIT;&#10;    --&#10;END collectValidation;&#10;--&#10;--&#10;/*130000*/&#10;PROCEDURE validateBatch(dmsBatchID_in NUMBER)&#10;IS&#10;    --&#10;    CURSOR cs(dmsBatchID_in NUMBER) IS&#10;      SELECT o.crn&#10;      FROM dms_offender do INNER JOIN offender o ON do.offender_id &#61; o.offender_id&#10;      WHERE dms_batch_id &#61; dmsBatchID_in;&#10;    --&#10;    TYPE crn_tab_typ IS TABLE OF cs%ROWTYPE INDEX BY PLS_INTEGER;&#10;    crns  crn_tab_typ;&#10;    --&#10;    l_batch_id      DMS_BATCH.dms_batch_id%TYPE;&#10;    --&#10;    l_rindex        PLS_INTEGER;&#10;    l_slno          PLS_INTEGER;&#10;    l_totalwork     NUMBER;&#10;    l_sofar         NUMBER;&#10;    l_obj           PLS_INTEGER;&#10;    l_component_id  INTEGER;&#10;    --&#10;    FUNCTION check_semaphore(p_component_code VARCHAR2) RETURN VARCHAR2 IS&#10;    BEGIN&#10;        RETURN C08001_PDT_SUPPORT.check_semaphore(p_component_code &#61;&gt; p_component_code);&#10;    END check_semaphore;&#10;    --&#10;BEGIN&#10;    g_label :&#61; &#39;130000&#39;;&#10;    g_procedure_name :&#61; &#39;migrateDocument&#39;;&#10;    --&#10;    l_batch_id :&#61; dmsBatchID_in;&#10;    l_component_id :&#61; &#39;140001&#39;;&#10;    --&#10;    g_label :&#61; &#39;130005&#39;;&#10;    l_rindex  :&#61; DBMS_APPLICATION_INFO.set_session_longops_nohint;&#10;    --&#10;    g_label :&#61; &#39;130010&#39;;&#10;    OPEN cs(dmsBatchID_in &#61;&gt; l_batch_id);&#10;    LOOP&#10;        g_label :&#61; &#39;130015&#39;;&#10;        FETCH cs BULK COLLECT INTO crns LIMIT 500;&#10;        EXIT WHEN crns.COUNT &#61; 0;&#10;        --&#10;        g_label :&#61; &#39;130020&#39;;&#10;        l_sofar   :&#61; 0;&#10;        l_totalwork :&#61; crns.COUNT;&#10;        --&#10;        g_label :&#61; &#39;130025&#39;;&#10;        FOR i IN 1 .. crns.COUNT LOOP&#10;            g_label :&#61; &#39;130030&#39;;&#10;            collectValidation(CRN_in &#61;&gt; crns(i).crn);&#10;            --&#10;            g_label :&#61; &#39;130035&#39;;&#10;            l_sofar :&#61; l_sofar + 1;&#10;            DBMS_APPLICATION_INFO.set_session_longops (&#10;                rindex      &#61;&gt; l_rindex,&#10;                slno        &#61;&gt; l_slno,&#10;                op_name     &#61;&gt; &#39;collect offender validation&#39;,&#10;                target      &#61;&gt; l_obj,&#10;                context     &#61;&gt; 0,&#10;                sofar       &#61;&gt; l_sofar,&#10;                totalwork   &#61;&gt; l_totalwork,&#10;                target_desc &#61;&gt; &#39;VALIDATE_BATCH [&#39; || l_batch_id || &#39;]&#39;,&#10;                units       &#61;&gt; &#39;rows processed&#39; );&#10;            --&#10;            g_label :&#61; &#39;130040&#39;;&#10;            IF check_semaphore(TO_CHAR(l_component_id)) !&#61; &#39;0&#39; THEN&#10;                g_label :&#61; &#39;130045&#39;;&#10;                info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;Semaphore signalled - stopping thread&#39;);&#10;                EXIT;&#10;            END IF;&#10;            --&#10;        END LOOP;&#10;        --&#10;        g_label :&#61; &#39;130045&#39;;&#10;        IF check_semaphore(TO_CHAR(l_component_id)) !&#61; &#39;0&#39; THEN&#10;            g_label :&#61; &#39;130047&#39;;&#10;          info(&#39;[&#39; || l_component_id || &#39;]&#39; || &#39;Semaphore signalled - stopping thread&#39;);&#10;          EXIT;&#10;        END IF;&#10;        --&#10;    END LOOP;&#10;    --&#10;    g_label :&#61; &#39;130050&#39;;&#10;    CLOSE cs;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    error(&#39;Unexpected Error Raising: &#39; || SQLERRM);&#10;    RAISE;&#10;END validateBatch;&#10;--&#10;--&#10;/*140000*/&#10;PROCEDURE stopAllThreads(thread_type VARCHAR2 DEFAULT &#39;folder&#39;)&#10;IS&#10;    --&#10;    bulk_errors exception;&#10;    PRAGMA EXCEPTION_INIT (bulk_errors, -24381);&#10;    --&#10;    CURSOR cs IS&#10;      SELECT &#39;100001&#39;component_id&#10;      FROM DUAL&#10;      WHERE thread_type &#61; &#39;folder&#39;&#10;      UNION ALL&#10;      SELECT &#39;110&#39; || dms_batch_id&#10;      FROM dms_batch&#10;      WHERE thread_type &#61; &#39;folder&#39;&#10;      UNION ALL&#10;      SELECT &#39;120001&#39; component_id&#10;      FROM DUAL&#10;      WHERE thread_type &#61; &#39;document&#39;&#10;      UNION ALL&#10;      SELECT &#39;130&#39; || dms_batch_id&#10;      FROM dms_batch&#10;      WHERE thread_type &#61; &#39;document&#39;&#10;      UNION ALL&#10;      SELECT &#39;140001&#39; component_id&#10;      FROM dms_batch&#10;      WHERE thread_type &#61; &#39;validation&#39;;&#10;    --&#10;    TYPE run_thread_tab_typ IS TABLE OF cs%ROWTYPE;&#10;    l_running_threads run_thread_tab_typ;&#10;    --&#10;BEGIN&#10;    --&#10;    OPEN cs;&#10;    FETCH cs BULK COLLECT INTO l_running_threads;&#10;    CLOSE cs;&#10;    --&#10;    FORALL i IN 1 .. l_running_threads.COUNT&#10;        SAVE EXCEPTIONS&#10;        INSERT INTO pdt_semaphore(component_code, signal)&#10;        VALUES (l_running_threads(i).component_id, &#39;STOP&#39;);&#10;        COMMIT;&#10;    --&#10;EXCEPTION&#10;    WHEN bulk_errors THEN&#10;        COMMIT;&#10;    WHEN OTHERS THEN&#10;        error(&#39;Unexpected Error Raising: &#39; || SQLERRM);&#10;        RAISE;&#10;END;&#10;--&#10;--&#10;FUNCTION existing_doc_migrations(offender_id_in NUMBER) RETURN VARCHAR2 RESULT_CACHE&#10;IS&#10;    --&#10;    l_ret                VARCHAR2(1);&#10;    l_doc_migration_type DOC_MIGRATION_TYPE;&#10;    l_count              INTEGER;&#10;    --&#10;BEGIN&#10;    --&#10;    l_count :&#61; 0;&#10;    l_doc_migration_type :&#61; NULL;&#10;    l_ret :&#61; &#39;N&#39;;&#10;    --&#10;    BEGIN&#10;        SELECT&#10;          DOC_MIGRATION_TYPE(&#10;              do.dms_offender_id,&#10;              MIN(dd.dms_document_id),&#10;              MAX(dms_document_id) ),&#10;          COUNT(1)&#10;        INTO&#10;          l_doc_migration_type,&#10;          l_count&#10;        FROM&#10;          dms_offender do&#10;            INNER JOIN dms_document dd ON do.dms_offender_id &#61; dd.dms_offender_id&#10;                                      AND dd.document_create_status_id &lt;&#61; 5&#10;        WHERE do.offender_id &#61; offender_id_in&#10;          AND NOT EXISTS (&#10;            SELECT 1&#10;            FROM aq$doc_migration_queue_tab&#10;            WHERE corr_id &#61; do.offender_id&#10;              AND msg_state &lt;&gt; &#39;PROCESSED&#39; )&#10;        GROUP BY do.dms_offender_id;&#10;        --&#10;    EXCEPTION WHEN OTHERS THEN&#10;      l_ret :&#61; &#39;N&#39;;&#10;      l_count :&#61; 0;&#10;    END;&#10;    --&#10;    IF l_count &gt; 0 THEN&#10;        g_doc_migration_type :&#61; l_doc_migration_type;&#10;        l_ret :&#61; &#39;Y&#39;;&#10;    END IF;&#10;    --&#10;    RETURN l_ret;&#10;    --&#10;END existing_doc_migrations;&#10;--&#10;--&#10;FUNCTION get_doc_migration RETURN doc_migration_type IS&#10;BEGIN&#10;    RETURN g_doc_migration_type;&#10;END get_doc_migration;&#10;--&#10;--&#10;PROCEDURE add_offender_2_dynamic_q(offender_id_in NUMBER)&#10;IS&#10;    --&#10;    enqueue_options     DBMS_AQ.enqueue_options_t;&#10;    message_properties  DBMS_AQ.message_properties_t;&#10;    message_handle      RAW(16);&#10;    message             doc_migration_type;&#10;    --&#10;BEGIN&#10;    IF existing_doc_migrations(offender_id_in &#61;&gt; offender_id_in) &#61; &#39;Y&#39; THEN&#10;        message :&#61; get_doc_migration;&#10;        --&#10;        enqueue_options.VISIBILITY           :&#61; DBMS_AQ.ON_COMMIT;&#10;        enqueue_options.SEQUENCE_DEVIATION   :&#61; NULL;&#10;        --&#10;        message_properties.PRIORITY            :&#61; -5;&#10;        message_properties.DELAY               :&#61; DBMS_AQ.NO_DELAY;&#10;        message_properties.EXPIRATION          :&#61; DBMS_AQ.NEVER;&#10;        message_properties.CORRELATION         :&#61; TO_CHAR(offender_id_in);&#10;        --&#10;        DBMS_AQ.ENQUEUE (&#10;            queue_name         &#61;&gt; &#39;DELIUS_APP_SCHEMA.DOC_MIGRATION_QUEUE&#39;,&#10;            enqueue_options    &#61;&gt; enqueue_options,&#10;            message_properties &#61;&gt; message_properties,&#10;            payload            &#61;&gt; message,&#10;            msgid              &#61;&gt; message_handle );&#10;        --&#10;    END IF;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    error(&#39;Unexpected Error Raising: &#39; || SQLERRM);&#10;    RAISE;&#10;END add_offender_2_dynamic_q;&#10;--&#10;--&#10;PROCEDURE process_dynamic_q&#10;IS&#10;    --&#10;    dequeue_options     DBMS_AQ.dequeue_options_t;&#10;    message_properties  DBMS_AQ.message_properties_t;&#10;    message_handle      RAW(16);&#10;    message             doc_migration_type;&#10;    --&#10;    id                number;&#10;    lock_name         varchar2(30) :&#61; &#39;DOC_MIGRATION_CALLBACK_LOCK&#39;;&#10;    lock_handle       varchar2(128);&#10;    dummy             pls_integer;&#10;    more_msgs         BOOLEAN :&#61; TRUE;&#10;    cnt               NUMBER :&#61; 0;&#10;    cnt_max           NUMBER :&#61; 1000;&#10;    --&#10;    no_messages EXCEPTION;&#10;    PRAGMA EXCEPTION_INIT (no_messages, -25228);&#10;    --&#10;BEGIN&#10;    --&#10;    DBMS_LOCK.allocate_unique(lock_name, lock_handle);&#10;    dummy :&#61; dbms_lock.request(lock_handle,dbms_lock.x_mode,dbms_lock.maxwait,false);&#10;    --&#10;    dequeue_options.consumer_name :&#61; &#39;PL_SQL&#39;;&#10;    dequeue_options.navigation :&#61; DBMS_AQ.FIRST_MESSAGE;&#10;    dequeue_options.wait :&#61; DBMS_AQ.NO_WAIT;&#10;    --&#10;    WHILE (more_msgs) LOOP&#10;        BEGIN&#10;            DBMS_AQ.dequeue(&#39;DELIUS_APP_SCHEMA.DOC_MIGRATION_QUEUE&#39;, dequeue_options, message_properties, message, message_handle);&#10;             --&#10;             DOCMIGRATIONSUPPORT.migrateDocument (&#10;                dmsOffenderID_in        &#61;&gt; message.dms_offender_id,&#10;                start_dmsDocumentID_in  &#61;&gt; message.start_dms_document_id,&#10;                end_dmsDocumentID_in    &#61;&gt; message.end_dms_document_id );&#10;            -- to avoid ORA-1555 messages (Snapshot too old), re-execute the cursor&#10;            -- and get a new snapshot by dequeuing with the FIRST_MESSAGE option&#10;            cnt :&#61; cnt + 1;&#10;            --&#10;            IF MOD (cnt, cnt_max) &#61; 0 THEN&#10;                dequeue_options.navigation :&#61; DBMS_AQ.FIRST_MESSAGE;&#10;                COMMIT;&#10;            ELSE&#10;                dequeue_options.navigation :&#61; DBMS_AQ.NEXT_MESSAGE;&#10;            END IF;&#10;            --&#10;        EXCEPTION WHEN no_messages THEN&#10;            more_msgs :&#61; FALSE;&#10;        END;&#10;        --&#10;    END LOOP;&#10;    --&#10;    dummy :&#61; DBMS_LOCK.release(lock_handle);&#10;    --&#10;END process_dynamic_q;&#10;--&#10;--&#10;PROCEDURE process_callback(&#10;    context   RAW,&#10;    reginfo   SYS.aq$_reg_info,&#10;    descr     SYS.aq$_descriptor,&#10;    payload   RAW,&#10;    payloadl  NUMBER )&#10;IS&#10;    --&#10;    dequeue_options    DBMS_AQ.dequeue_options_t;&#10;    message_properties DBMS_AQ.message_properties_t;&#10;    message_handle     RAW(16);&#10;    message            doc_migration_type;&#10;    --&#10;BEGIN&#10;    --&#10;    dequeue_options.msgid         :&#61; descr.msg_id;&#10;    dequeue_options.consumer_name :&#61; descr.consumer_name;&#10;    --&#10;    DBMS_AQ.dequeue(&#10;        queue_name         &#61;&gt; descr.queue_name,&#10;        dequeue_options    &#61;&gt; dequeue_options,&#10;        message_properties &#61;&gt; message_properties,&#10;        payload            &#61;&gt; message,&#10;        msgid              &#61;&gt; message_handle );&#10;    --&#10;    DOCMIGRATIONSUPPORT.migrateDocument(&#10;        dmsOffenderID_in        &#61;&gt; message.dms_offender_id,&#10;        start_dmsDocumentID_in  &#61;&gt; message.start_dms_document_id,&#10;        end_dmsDocumentID_in    &#61;&gt; message.end_dms_document_id );&#10;   --&#10;   COMMIT;&#10;   --&#10;END process_callback;&#10;--&#10;--&#10;--&#10;--&#10;FUNCTION documentContent(&#10;    p_alf_doc_id     VARCHAR2,&#10;    p_wait           NUMBER   DEFAULT NULL )&#10;RETURN alfresco_content_tab_TYP PIPELINED&#10;IS&#10;    --&#10;    l_status          VARCHAR2(10);&#10;    l_response_string CLOB;&#10;    l_return_string   CLOB;&#10;    --&#10;    l_docid           DOCUMENT.alfresco_document_id%TYPE;&#10;    l_rec             alfresco_content_row_typ;&#10;    l_obj             JSON_OBJECT_T; -- :&#61; JSON_OBJECT_T(); --json;&#10;    --&#10;    L_WAIT            NUMBER :&#61; NVL(p_wait, -1);&#10;    --&#10;    FUNCTION json_2_ora_date(p_date_char VARCHAR2) RETURN DATE IS&#10;    BEGIN&#10;        RETURN&#10;            TO_TIMESTAMP(&#10;                REPLACE(REPLACE(p_date_char, &#39;T&#39;, &#39; &#39;), &#39;Z&#39;, &#39;&#39;),&#10;                &#39;YYYY-MM-DD HH24:MI:SS.FF3&#39; );&#10;    END json_2_ora_date;&#10;    --&#10;BEGIN&#10;    --&#10;    l_docid :&#61; p_alf_doc_id;&#10;    --&#10;    l_status :&#61;&#10;        alfrescosupport.detailsDocument(&#10;            docId_in           &#61;&gt; l_docid,&#10;            responseString_out &#61;&gt; l_response_string,&#10;            returnString_out   &#61;&gt; l_return_string );&#10;    --&#10;    IF L_WAIT &gt; 0 THEN&#10;        -- DST-11269: a workaround for the ALF limiter&#10;        DBMS_LOCK.sleep(LEAST(L_WAIT, 30));&#10;    END IF;&#10;    --&#10;    IF l_status &#61; &#39;503&#39; OR l_response_string LIKE &#39;%HTTP server error 503 - Service Temporarily Unavailable&#39; THEN&#10;        fatal(&#39;ALF Server is unavailable: &#39; || &#39;[&#39; || l_status || &#39;][&#39; || l_return_string || &#39;][&#39; || l_response_string || &#39;]&#39;, &#39;DocMigrationSupport.documentContent&#39;);&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    IF l_status &#61; &#39;200&#39; THEN&#10;        --&#10;        l_obj :&#61; JSON_OBJECT_T.parse(l_return_string);&#10;        --&#10;        l_rec.crn               :&#61; /*00*/ l_obj.get_string(&#39;crn&#39;);&#10;        l_rec.id                :&#61; /*01*/ l_obj.get_string(&#39;ID&#39;);&#10;        l_rec.name              :&#61; /*02*/ l_obj.get_string(&#39;name&#39;);&#10;        --&#10;        l_rec.entity_type       :&#61; /*03*/ l_obj.get_string(&#39;entityType&#39;);&#10;        l_rec.entity_id         :&#61; /*04*/ l_obj.get_string(&#39;entityId&#39;);&#10;        l_rec.document_type     :&#61; /*05*/ l_obj.get_string(&#39;docType&#39;);&#10;        l_rec.author            :&#61; /*06*/ l_obj.get_string(&#39;author&#39;);&#10;        l_rec.lock_owner        :&#61; /*07*/ l_obj.get_string(&#39;lockOwner&#39;);&#10;        l_rec.reservation_owner :&#61; /*08*/ l_obj.get_string(&#39;reservationOwner&#39;);&#10;        --&#10;        l_rec.locked            :&#61; /*09*/ l_obj.get_string(&#39;locked&#39;);&#10;        l_rec.reserved          :&#61; /*10*/ l_obj.get_string(&#39;reserved&#39;);&#10;        --&#10;        l_rec.creation_date     :&#61; /*12*/ json_2_ora_date(l_obj.get_string(&#39;creationDate&#39;));&#10;        l_rec.last_modified_date:&#61; /*13*/ json_2_ora_date(l_obj.get_string(&#39;lastModifiedDate&#39;));&#10;        l_rec.modifier          :&#61; /*14*/ l_obj.get_string(&#39;modifier&#39;);&#10;        l_rec.url               :&#61; /*15*/ l_obj.get_string(&#39;url&#39;);&#10;        --&#10;        IF p_alf_doc_id IS NULL OR p_alf_doc_id &#61; l_rec.id THEN&#10;            PIPE ROW(l_rec);&#10;        END IF;&#10;        --&#10;    END IF;&#10;    --&#10;    RETURN;&#10;    --&#10;END documentContent;&#10;--&#10;--&#10;FUNCTION softDeletedDocumentContent(&#10;    crn_in              VARCHAR2,&#10;    p_wait              NUMBER   DEFAULT NULL )&#10;RETURN alfresco_content_tab_TYP PIPELINED&#10;IS&#10;    --&#10;    l_status          VARCHAR2(10);&#10;    l_response_string CLOB;&#10;    l_return_string   CLOB;&#10;    --&#10;    l_crn             OFFENDER.crn%TYPE;&#10;    l_rec             alfresco_content_row_typ;&#10;    l_obj             JSON_OBJECT_T;&#10;    l_obj1            JSON_OBJECT_T;&#10;    l_arr             JSON_ARRAY_T;&#10;    l_cnt             INTEGER;&#10;    --&#10;    L_WAIT            NUMBER :&#61; NVL(p_wait, -1);&#10;    --&#10;    FUNCTION json_2_ora_date(p_date_char VARCHAR2) RETURN DATE IS&#10;    BEGIN&#10;        RETURN&#10;            TO_TIMESTAMP(&#10;                REPLACE(REPLACE(p_date_char, &#39;T&#39;, &#39; &#39;), &#39;Z&#39;, &#39;&#39;),&#10;                &#39;YYYY-MM-DD HH24:MI:SS.FF3&#39; );&#10;    END json_2_ora_date;&#10;    --&#10;BEGIN&#10;    --&#10;    l_crn :&#61; crn_in;&#10;    --&#10;    l_status :&#61;&#10;        alfrescosupport.searchSoftDeletedDocument(&#10;            crn_in      &#61;&gt; l_crn,&#10;            responseString_out &#61;&gt; l_response_string,&#10;            returnString_out   &#61;&gt; l_return_string );&#10;    --&#10;    IF L_WAIT &gt; 0 THEN&#10;        -- DST-11269: a workaround for the ALF limiter&#10;        DBMS_LOCK.sleep(LEAST(L_WAIT, 30));&#10;    END IF;&#10;    --&#10;    IF l_status &#61; &#39;503&#39; OR l_response_string LIKE &#39;%HTTP server error 503 - Service Temporarily Unavailable&#39; THEN&#10;        fatal(&#39;ALF Server is unavailable: &#39; || &#39;[&#39; || l_status || &#39;][&#39; || l_return_string || &#39;][&#39; || l_response_string || &#39;]&#39;, &#39;DocMigrationSupport.softDeletedDocumentContent&#39;);&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    IF l_status &#61; &#39;200&#39; THEN&#10;        --&#10;        l_obj :&#61; JSON_OBJECT_T.parse(l_return_string);&#10;        l_arr :&#61; l_obj.get_array(&#39;documents&#39;);&#10;        l_cnt :&#61; l_arr.get_size;&#10;        --&#10;&#10;        FOR l_i IN 0 .. l_cnt-1 LOOP&#10;            --&#10;            l_obj1 :&#61; JSON_OBJECT_T(l_arr.get(l_i));&#10;            --&#10;            l_rec.crn                :&#61; /*00*/l_obj1.get_string(&#39;crn&#39;);&#10;            l_rec.id               :&#61; /*01*/l_obj1.get_string(&#39;id&#39;);&#10;            l_rec.name              :&#61; /*02*/l_obj1.get_string(&#39;name&#39;);&#10;            --&#10;            l_rec.entity_id         :&#61; /*03*/l_obj1.get_string(&#39;entityType&#39;);&#10;            l_rec.entity_type       :&#61; /*04*/l_obj1.get_string(&#39;entityId&#39;);&#10;            l_rec.document_type     :&#61; /*05*/l_obj1.get_string(&#39;docType&#39;);&#10;            l_rec.author            :&#61; /*06*/l_obj1.get_string(&#39;author&#39;);&#10;            --&#10;            l_rec.lock_owner        :&#61; /*07*/l_obj1.get_string(&#39;lockOwner&#39;);&#10;            l_rec.reservation_owner :&#61; /*08*/l_obj1.get_string(&#39;reservationOwner&#39;);&#10;            l_rec.locked            :&#61; /*09*/l_obj1.get_string(&#39;locked&#39;);&#10;            l_rec.reserved          :&#61; /*10*/l_obj1.get_string(&#39;reserved&#39;);&#10;            --&#10;            l_rec.creation_date     :&#61; /*12*/json_2_ora_date(l_obj1.get_string(&#39;creationDate&#39;));&#10;            l_rec.last_modified_date:&#61; /*13*/json_2_ora_date(l_obj1.get_string(&#39;lastModifiedDate&#39;));&#10;            l_rec.modifier          :&#61; /*14*/l_obj1.get_string(&#39;modifier&#39;);&#10;            --&#10;            l_rec.url               :&#61; /*15*/l_obj1.get_string(&#39;url&#39;);&#10;            --&#10;            PIPE ROW(l_rec);&#10;            --&#10;        END LOOP;&#10;        --&#10;    END IF;&#10;    --&#10;    RETURN;&#10;    --&#10;END softDeletedDocumentContent;&#10;--&#10;-- PLSQL package Initialisation block&#10;--&#10;BEGIN&#10;    --&#10;    PKG_Global.do_init;&#10;    --&#10;    do_init_vars;&#10;    --&#10;END DocMigrationSupport;</textarea>
                        </div>
                    </div>
                </section>
            </div>
            <!-- /.content-wrapper -->
            <footer class="main-footer">
                <div>
                    <div class="pull-right hidden-xs">
                        <a href="https://github.com/schemaspy/schemaspy" title="GitHub for SchemaSpy"><i class="fa fa-github-square fa-2x"></i></a>
                        <a href="http://stackoverflow.com/questions/tagged/schemaspy" title="StackOverflow for SchemaSpy"><i class="fa fa-stack-overflow fa-2x"></i></a>
                    </div>
                    <strong>Generated by <a href="http://schemaspy.org/" class="logo-text"><i class="fa fa-database"></i> SchemaSpy 6.2.4</a></strong>
                </div>
                <!-- /.container -->
            </footer>
        </div>
        <!-- ./wrapper -->

        <!-- jQuery 2.2.3 -->
        <script src="../bower/admin-lte/plugins/jQuery/jquery-2.2.3.min.js"></script>
        <script src="../bower/admin-lte/plugins/jQueryUI/jquery-ui.min.js"></script>
        <!-- Bootstrap 3.3.5 -->
        <script src="../bower/admin-lte/bootstrap/js/bootstrap.min.js"></script>
        <!-- DataTables -->
        <script src="../bower/datatables.net/jquery.dataTables.min.js"></script>
        <script src="../bower/datatables.net-bs/js/dataTables.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/dataTables.buttons.min.js"></script>
        <script src="../bower/datatables.net-buttons-bs/js/buttons.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.html5.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.print.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.colVis.min.js"></script>
        <!-- SheetJS -->
        <script src="../bower/js-xlsx/xlsx.full.min.js"></script>
        <!-- pdfmake -->
        <script src="../bower/pdfmake/pdfmake.min.js"></script>
        <script src="../bower/pdfmake/vfs_fonts.js"></script>
        <!-- SlimScroll -->
        <script src="../bower/admin-lte/plugins/slimScroll/jquery.slimscroll.min.js"></script>
        <!-- FastClick -->
        <script src="../bower/admin-lte/plugins/fastclick/fastclick.js"></script>
        <!-- Salvattore -->
        <script src="../bower/salvattore/salvattore.min.js"></script>
        <!-- AnchorJS -->
        <script src="../bower/anchor-js/anchor.min.js"></script>
        <!-- CodeMirror -->
        <script src="../bower/codemirror/codemirror.js"></script>
        <script src="../bower/codemirror/sql.js"></script>
        <!-- AdminLTE App -->
        <script src="../bower/admin-lte/dist/js/app.min.js"></script>
        <script src="routine.js"></script>
        <script src="../schemaSpy.js"></script>
    </body>
</html>