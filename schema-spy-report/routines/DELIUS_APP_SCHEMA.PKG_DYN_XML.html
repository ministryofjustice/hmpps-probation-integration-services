<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>TSTNDA.DELIUS_APP_SCHEMA</title>
        <!-- Tell the browser to be responsive to screen width -->
        <meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport">
        <link rel="icon" type="image/png" sizes="16x16" href="../favicon.png">
        <!-- Bootstrap 3.3.5 -->
        <link rel="stylesheet" href="../bower/admin-lte/bootstrap/css/bootstrap.min.css">
        <!-- Font Awesome -->
        <link rel="stylesheet" href="../bower/font-awesome/css/font-awesome.min.css">
        <!-- Ionicons -->
        <link rel="stylesheet" href="../bower/ionicons/css/ionicons.min.css">
        <!-- DataTables -->
        <link rel="stylesheet" href="../bower/datatables.net-bs/css/dataTables.bootstrap.min.css">
        <link rel="stylesheet" href="../bower/datatables.net-buttons-bs/css/buttons.bootstrap.min.css">
        <!-- Code Mirror -->
        <link rel="stylesheet" href="../bower/codemirror/codemirror.css">
        <!-- Fonts -->
        <link href='../fonts/indieflower/indie-flower.css' rel='stylesheet' type='text/css'>
        <link href='../fonts/source-sans-pro/source-sans-pro.css' rel='stylesheet' type='text/css'>

        <!-- Theme style -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/AdminLTE.min.css">
        <!-- Salvattore -->
        <link rel="stylesheet" href="../bower/salvattore/salvattore.css">
        <!-- AdminLTE Skins. Choose a skin from the css/skins
           folder instead of downloading all of them to reduce the load. -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/skins/_all-skins.min.css">
        <!-- SchemaSpy -->
        <link rel="stylesheet" href="../schemaSpy.css">

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
        <script src="../bower/html5shiv/html5shiv.min.js"></script>
        <script src="../bower/respond/respond.min.js"></script>
        <![endif]-->
    </head>
    <!-- ADD THE CLASS layout-top-nav TO REMOVE THE SIDEBAR. -->
    <body class="hold-transition skin-blue layout-top-nav">
        <div class="wrapper">
            <header class="main-header">
                <nav class="navbar navbar-static-top">
                    <div class="container">
                        <div class="navbar-header">
                            <a href="../index.html" class="navbar-brand"><b>TSTNDA</b></a><span class="navbar-brand" style="padding-left: 0">.DELIUS_APP_SCHEMA</span>
                            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse"><i class="fa fa-bars"></i></button>
                        </div>

                        <!-- Collect the nav links, forms, and other content for toggling -->
                        <div class="collapse navbar-collapse pull-left" id="navbar-collapse">
                            <ul class="nav navbar-nav">
                                <li><a href="../index.html">Tables <span class="sr-only">(current)</span></a></li>
                                <li><a href="../columns.html" title="All of the columns in the schema">Columns</a></li>
                                <li><a href="../constraints.html" title="Useful for diagnosing error messages that just give constraint name or number">Constraints</a></li>
                                <li><a href="../relationships.html" title="Diagram of table relationships">Relationships</a></li>
                                <li><a href="../orphans.html" title="View of tables with neither parents nor children">Orphan&nbsp;Tables</a></li>
                                <li><a href="../anomalies.html" title="Things that might not be quite right">Anomalies</a></li>
                                <li><a href="../routines.html" title="Procedures and functions">Routines</a></li>
                            </ul>
                        </div>
                        <!-- /.navbar-collapse -->
                        <!-- Navbar Right Menu -->
                    </div>
                    <!-- /.container-fluid -->
                </nav>
            </header>
            <!-- Main content -->
            <!-- Full Width Column -->
            <div class="content-wrapper">
                <!-- Content Header (Page header) -->
                <section class="content-header">
                    <h1>DELIUS_APP_SCHEMA.PKG_DYN_XML</h1><br />
                </section>
                <!-- Main content -->
                <section class="content">
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <span class="glyphicon glyphicon-list-alt" aria-hidden="true"></span>
                            <h3 id="Columns" class="box-title">Parameters</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <table id="standard_table" class="table table-bordered table-striped dataTable" role="grid">
                                <thead align='left'>
                                <tr>
                                    <th>Name</th>
                                    <th>Type</th>
                                    <th>Mode</th>
                                </tr>
                                </thead>
                                <tbody>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <i class="fa fa-file-code-o"></i>
                            <h3 id="RoutineDefinition" class="box-title">Definition</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <textarea id="sql-script-codemirror" name="sql-script-codemirror" rows="" style="display: none;">PACKAGE BODY PKG_DYN_XML&#10;AS&#10;--&#10;--&#10;--&#10;--&#10;&#10;g_label                   VARCHAR2(32);&#10;--&#10;G_TRACE_LEVEL    CONSTANT INTEGER :&#61; 1;&#10;--&#10;&#10;G_CONTROL_REFERENCE       NUMBER       :&#61; 99999999999999;&#10;G_RECEIVER_CTL_REFERENCE  VARCHAR2(38);&#10;G_SENDER_IDENTITY         VARCHAR2(3)  :&#61; &#39;XXX&#39;;&#10;G_RECEIVER_IDENTITY       VARCHAR2(3)  :&#61; &#39;ZZZ&#39;;&#10;G_APPLICATION_REFERENCE   VARCHAR2(30) :&#61; &#39;NDELIUS&#39;;&#10;G_TEST_INDICATOR          VARCHAR2(1)  :&#61; &#39;Y&#39;;&#10;G_TOP_MSG_UPD_MODE        VARCHAR2(1)  :&#61; &#39;N&#39;;&#10;&#10;G_CONTROL_COUNT           INTEGER :&#61; 0;&#10;&#10;G_TAB_CACHE_INIT_FLAG     BOOLEAN :&#61; FALSE;&#10;--&#10;--&#10;--&#10;FUNCTION get_version RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN GC_VERSION;&#10;END get_version;&#10;&#10;&#10;--***************************************************&#10;--                                                  *&#10;-- PKG_COMMON wrappers                              *&#10;--                                                  *&#10;--***************************************************&#10;PROCEDURE procDebug(p_msg CLOB, p_trace_level INTEGER DEFAULT 15, p_print_flag VARCHAR2 DEFAULT &#39;N&#39;) IS&#10;BEGIN&#10;    IF NVL(p_trace_level, 15) &lt;&#61; G_TRACE_LEVEL THEN&#10;        PKG_Debug.procDebug(p_msg, p_print_flag);&#10;    END IF;&#10;END procDebug;&#10;--&#10;FUNCTION is_str_empty(p_str VARCHAR2, p_ignore_spaces_and_zeroes VARCHAR2 DEFAULT &#39;N&#39;) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.is_str_empty( p_str, p_ignore_spaces_and_zeroes );&#10;END is_str_empty;&#10;--&#10;FUNCTION empty2null(p_str VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.empty2null(p_str);&#10;END empty2null;&#10;&#10;FUNCTION nvlstr(p_str1 VARCHAR2, p_str2 VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.nvlstr(p_str1, p_str2);&#10;END nvlstr;&#10;--&#10;PROCEDURE raise_error(p_err_msg VARCHAR2, p_proc VARCHAR2, p_label VARCHAR2 DEFAULT &#39;&#39;) IS&#10;BEGIN&#10;    procDebug(&#10;        p_proc || &#39; FAILED. [Step: &#39; || PKG_Common.nvl2(p_label, g_label, &#39;N/A&#39;) || &#39;]&#39; ||&#10;        --&#39;[&#39; || DBMS_UTILITY.format_error_backtrace || &#39;]: &#39; ||&#10;        &#39;[&#39; || DBMS_UTILITY.format_call_stack || &#39;]: &#39; ||&#10;        p_err_msg,&#10;        p_trace_level&#61;&gt; 0,&#10;        p_print_flag &#61;&gt; &#39;Y&#39; );&#10;    PKG_Common.raise_error( p_err_msg, p_proc, p_label );&#10;END raise_error;&#10;--&#10;FUNCTION concat_CLOB(&#10;    p_val1  CLOB,&#10;    p_val2  CLOB,&#10;    p_val3  CLOB DEFAULT NULL,&#10;    p_val4  CLOB DEFAULT NULL,&#10;    p_val5  CLOB DEFAULT NULL,&#10;    p_val6  CLOB DEFAULT NULL,&#10;    p_val7  CLOB DEFAULT NULL,&#10;    p_val8  CLOB DEFAULT NULL,&#10;    p_val9  CLOB DEFAULT NULL,&#10;    p_val10 CLOB DEFAULT NULL,&#10;    p_val11 CLOB DEFAULT NULL,&#10;    p_val12 CLOB DEFAULT NULL,&#10;    p_val13 CLOB DEFAULT NULL,&#10;    p_val14 CLOB DEFAULT NULL,&#10;    p_val15 CLOB DEFAULT NULL,&#10;    --&#10;    p_delim         VARCHAR2 DEFAULT &#39;,&#39;,&#10;    p_include_nulls VARCHAR2 DEFAULT &#39;N&#39;)&#10;RETURN CLOB IS&#10;BEGIN&#10;    RETURN&#10;        PKG_LstUtl.concat_CLOB(&#10;            p_val1  &#61;&gt; p_val1,&#10;            p_val2  &#61;&gt; p_val2,&#10;            p_val3  &#61;&gt; p_val3,&#10;            p_val4  &#61;&gt; p_val4,&#10;            p_val5  &#61;&gt; p_val5,&#10;            p_val6  &#61;&gt; p_val6,&#10;            p_val7  &#61;&gt; p_val7,&#10;            p_val8  &#61;&gt; p_val8,&#10;            p_val9  &#61;&gt; p_val9,&#10;            p_val10 &#61;&gt; p_val10,&#10;            p_val11 &#61;&gt; p_val11,&#10;            p_val12 &#61;&gt; p_val12,&#10;            p_val13 &#61;&gt; p_val13,&#10;            p_val14 &#61;&gt; p_val14,&#10;            p_val15 &#61;&gt; p_val15,&#10;            --&#10;            p_delim &#61;&gt; p_delim,&#10;            p_include_nulls &#61;&gt; p_include_nulls );&#10;END concat_CLOB;&#10;--&#10;FUNCTION get_indented_text(p_text VARCHAR2, p_num_of_spaces INTEGER)&#10;RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_LstUtl.get_indented_text(p_text, p_num_of_spaces);&#10;END get_indented_text;&#10;--&#10;--&#10;PROCEDURE do_init_tab_info IS&#10;BEGIN&#10;    PKG_SPG_SUPPORT.do_init_tab_info;&#10;END do_init_tab_info;&#10;--&#10;PROCEDURE do_init_vars IS&#10;BEGIN&#10;    G_TAB_CACHE_INIT_FLAG :&#61; FALSE;&#10;    --PKG_DynSQL.init_tab_info(p_reset_flag &#61;&gt; &#39;Y&#39;);&#10;    --G_TAB_CACHE_INIT_FLAG :&#61; TRUE;&#10;END do_init_vars;&#10;--&#10;&#10;/*&#10;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#10;  DYNAMIC Lookup functions&#10;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#10;*/&#10;FUNCTION get_team_or_provider_record(p_trust_provider_flag INTEGER, p_record_id NUMBER, p_lup_fld VARCHAR2)&#10;RETURN VARCHAR2&#10;IS&#10;    l_data_fld  VARCHAR2(255);&#10;    l_data_fld1 VARCHAR2(100);&#10;    l_data_fld2 VARCHAR2(100);&#10;    --&#10;    l_ret VARCHAR2(1024);&#10;BEGIN&#10;    l_data_fld :&#61; UPPER(TRIM(p_lup_fld));&#10;    l_data_fld1 :&#61; PKG_LstUtl.list_next_elem(l_data_fld, &#39;/&#39;);&#10;    l_data_fld2 :&#61; NVLSTR(l_data_fld, l_data_fld1);&#10;    --&#10;    IF NVL(p_trust_provider_flag, 0) &#61; 0 THEN&#10;        l_ret :&#61;&#10;            PKG_Lookups.funcgetTabRecord_CACHED(&#10;                p_table    &#61;&gt; &#39;team&#39;,&#10;                p_ref_col  &#61;&gt; &#39;team_id&#39;,&#10;                p_ref_val  &#61;&gt; TO_CHAR(p_record_id),&#10;                p_data_fld &#61;&gt; l_data_fld1 );&#10;    ELSE&#10;        l_ret :&#61;&#10;            PKG_Lookups.funcgetTabRecord_CACHED(&#10;                p_table    &#61;&gt; &#39;provider_team&#39;,&#10;                p_ref_col  &#61;&gt; &#39;provider_team_id&#39;,&#10;                p_ref_val  &#61;&gt; TO_CHAR(p_record_id),&#10;                p_data_fld &#61;&gt; l_data_fld2 );&#10;    END IF;&#10;    --&#10;    RETURN l_ret;&#10;END get_team_or_provider_record;&#10;&#10;FUNCTION get_staff_or_provider_record(p_trust_provider_flag INTEGER, p_record_id NUMBER, p_lup_fld VARCHAR2)&#10;RETURN VARCHAR2&#10;IS&#10;    l_data_fld  VARCHAR2(255);&#10;    l_data_fld1 VARCHAR2(100);&#10;    l_data_fld2 VARCHAR2(100);&#10;    --&#10;    l_ret VARCHAR2(1024);&#10;BEGIN&#10;    l_data_fld :&#61; UPPER(TRIM(p_lup_fld));&#10;    l_data_fld1 :&#61; PKG_LstUtl.list_next_elem(l_data_fld, &#39;/&#39;);&#10;    l_data_fld2 :&#61; NVLSTR(l_data_fld, l_data_fld1);&#10;    --&#10;    IF NVL(p_trust_provider_flag, 0) &#61; 0 THEN&#10;        l_ret :&#61;&#10;            PKG_Lookups.funcgetTabRecord_CACHED(&#10;                p_table    &#61;&gt; &#39;staff&#39;,&#10;                p_ref_col  &#61;&gt; &#39;staff_id&#39;,&#10;                p_ref_val  &#61;&gt; TO_CHAR(p_record_id),&#10;                p_data_fld &#61;&gt; l_data_fld1 );&#10;    ELSE&#10;        l_ret :&#61;&#10;            PKG_Lookups.funcgetTabRecord_CACHED(&#10;                p_table    &#61;&gt; &#39;provider_employee&#39;,&#10;                p_ref_col  &#61;&gt; &#39;provider_employee_id&#39;,&#10;                p_ref_val  &#61;&gt; TO_CHAR(p_record_id),&#10;                p_data_fld &#61;&gt; l_data_fld2 );&#10;    END IF;&#10;    --&#10;    RETURN l_ret;&#10;END get_staff_or_provider_record;&#10;--&#10;FUNCTION get_team_or_provider_prob_area(p_team_id NUMBER, p_team_provider_id NUMBER)&#10;RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN&#10;        PKG_Lookups.funcgetTabRecord_CACHED(&#10;            p_table     &#61;&gt; &#39;all_team T, probation_area PA&#39;,&#10;            p_data_fld  &#61;&gt; &#39;PA.code&#39;,&#10;            p_ref_col   &#61;&gt; &#39;T.TRUST_PROVIDER_FLAG&#39;,&#10;            p_ref_val   &#61;&gt; TO_CHAR(CASE WHEN p_team_provider_id IS NOT NULL THEN 1 ELSE 0 END),&#10;            p_where     &#61;&gt; &#39;T.TRUST_PROVIDER_TEAM_ID &#61; :p_trust_provider_team_id AND PA.probation_area_id &#61; T.probation_area_id&#39;,&#10;            p_bind_var1 &#61;&gt; TO_CHAR(NVL(p_team_id, p_team_provider_id)) );&#10;END get_team_or_provider_prob_area;&#10;--&#10;/*&#10;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#10;  DYNAMIC XML/SQLx generation subroutines&#10;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#10;*/&#10;--&#10;FUNCTION get_tab_alias(p_table VARCHAR2, p_level INTEGER) RETURN VARCHAR2&#10;IS&#10;    l_postfix VARCHAR2(10);&#10;BEGIN&#10;    IF p_level &gt;&#61; 0 THEN&#10;        l_postfix :&#61; &#39;_&#39; || TO_CHAR(p_level);&#10;    ELSE&#10;        l_postfix :&#61; &#39;&#39;;&#10;    END IF;&#10;    --&#10;    RETURN SUBSTR(UPPER(p_table), 1, 30-NVL(LENGTH(l_postfix), 0)) || l_postfix;&#10;END get_tab_alias;&#10;--&#10;FUNCTION get_xml_message_name(p_table VARCHAR2, p_table_type VARCHAR2) RETURN VARCHAR2&#10;IS&#10;    l_ret VARCHAR2(255);&#10;BEGIN&#10;    IF p_table_type &#61; &#39;M&#39; THEN&#10;        l_ret :&#61;&#10;            PKG_Lookups.funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;BUSINESS_INT_XML_SUMMARY&#39;,&#10;                p_ref_col  &#61;&gt; &#39;xml_message_id&#39;,&#10;                p_ref_val  &#61;&gt; TO_CHAR(PKG_DynSql.get_xml_message_id(p_table)),&#10;                p_data_fld &#61;&gt; &#39;XML_MESSAGE_NAME&#39;,&#10;                p_where    &#61;&gt; &#39;xsd_number &#61; :p_xsd_number&#39;,&#10;                p_bind_var1&#61;&gt; TO_CHAR(NVL(SPGMESSAGE.GC_SCHEMA_NUMBER, 1)) );&#10;    ELSE&#10;        l_ret :&#61; INITCAP(p_table) || &#39;XML&#39;;&#10;    END IF;&#10;    --&#10;    RETURN l_ret;&#10;END get_xml_message_name;&#10;--&#10;FUNCTION get_xml_message_tag(&#10;    p_table           VARCHAR2,&#10;    p_table_type      VARCHAR2,&#10;    p_recursive_level INTEGER,&#10;    p_xsd_level       INTEGER DEFAULT GC_XSD_LEVEL_MSG_ENTITY,&#10;    p_update_mode     VARCHAR2 DEFAULT NULL )&#10;RETURN VARCHAR2 IS&#10;    l_xml_tag   VARCHAR2(100);&#10;    l_lst       VARCHAR2(100);&#10;    l_elem      VARCHAR2(100);&#10;BEGIN&#10;    IF p_table_type &#61; &#39;M&#39; THEN&#10;        /*&#10;        GC_XSD_LEVEL_MSG_COMPOUND&#10;        GC_XSD_LEVEL_MSG_ENTITY&#10;        GC_XSD_LEVEL_MSG_STRUCTURE&#10;        */&#10;        IF p_xsd_level IN (GC_XSD_LEVEL_MSG_STRUCTURE) THEN&#10;            l_xml_tag :&#61; get_xml_message_name(p_table, p_table_type) || &#39;Details&#39; || CASE WHEN p_update_mode &#61; &#39;D&#39; THEN &#39;D&#39; END;&#10;        ELSIF p_xsd_level IN (GC_XSD_LEVEL_MSG_TABLE) THEN&#10;            -- e.g. OFFENDER_TRANSFER -&gt; OffenderTransfer&#10;            l_lst :&#61; p_table;&#10;            --procDebug(&#39;1. l_lst&#61;&#39; || l_lst, p_trace_level&#61;&gt;15);&#10;            LOOP&#10;                l_elem :&#61; PKG_LstUtl.list_next_elem(l_lst, &#39;_&#39;);&#10;                EXIT WHEN EMPTY2NULL(l_elem) IS NULL AND EMPTY2NULL(l_lst) IS NULL;&#10;                --&#10;                l_xml_tag :&#61; l_xml_tag || INITCAP(l_elem);&#10;            END LOOP;&#10;            --&#10;            --procDebug(&#39;2. l_xml_tag&#61;&#39; || l_xml_tag, p_trace_level&#61;&gt;15);&#10;            IF SUBSTR(l_xml_tag, 1, 3) IN ( &#39;Pss&#39;, &#39;Upw&#39;, &#39;Spg&#39;, &#39;Crc&#39; ) THEN&#10;                l_xml_tag :&#61; UPPER(SUBSTR(l_xml_tag, 1, 3)) || SUBSTR(l_xml_tag, 4);&#10;            ELSIF SUBSTR(l_xml_tag, 1, 6) IN (&#39;Offloc&#39;) THEN&#10;                l_xml_tag :&#61; &#39;OFFLOC&#39; || SUBSTR(l_xml_tag, 7);&#10;            ELSIF SUBSTR(l_xml_tag, 1, 10) IN (&#39;CustodyPss&#39;) THEN&#10;                l_xml_tag :&#61; &#39;CustodyPSS&#39; || SUBSTR(l_xml_tag, 11);&#10;            ELSIF SUBSTR(l_xml_tag, 1, 11) IN (&#39;ProviderLao&#39;) THEN&#10;                l_xml_tag :&#61; &#39;ProviderLAO&#39; || SUBSTR(l_xml_tag, 12);&#10;            ELSIF l_xml_tag LIKE &#39;%Pss%&#39; THEN&#10;                l_xml_tag :&#61; REPLACE(l_xml_tag, &#39;PssUndo&#39;, &#39;PSSUndo&#39;);&#10;                l_xml_tag :&#61; REPLACE(l_xml_tag, &#39;PssChange&#39;, &#39;PSSChange&#39;);&#10;            ELSIF l_xml_tag LIKE &#39;%TransferRequest&#39; THEN&#10;                l_xml_tag :&#61; UPPER(REPLACE(l_xml_tag, &#39;TransferRequest&#39;, &#39;&#39;)) || &#39;TransferRequest&#39;;&#10;                --procDebug(&#39;3. l_xml_tag&#61;&#39; || l_xml_tag, p_trace_level&#61;&gt;15);&#10;            ELSIF l_xml_tag LIKE &#39;%TransferResponse&#39; THEN&#10;                l_xml_tag :&#61; UPPER(REPLACE(l_xml_tag, &#39;TransferResponse&#39;, &#39;&#39;)) || &#39;TransferResponse&#39;;&#10;            END IF;&#10;            --&#10;            IF l_xml_tag LIKE &#39;%Hdr%&#39; THEN&#10;                l_xml_tag :&#61; REPLACE(l_xml_tag, &#39;Hdr&#39;, &#39;HDR&#39;);&#10;            ELSIF l_xml_tag LIKE &#39;%Dtl%&#39; THEN&#10;                l_xml_tag :&#61; REPLACE(l_xml_tag, &#39;Dtl&#39;, &#39;DTL&#39;);&#10;            END IF;&#10;            --&#10;            l_xml_tag :&#61; l_xml_tag || CASE WHEN p_update_mode &#61; &#39;D&#39; AND l_xml_tag NOT IN (&#39;Offender&#39;, &#39;SPGVersion&#39;) THEN &#39;D&#39; END;&#10;        ELSE&#10;            l_xml_tag :&#61; get_xml_message_name(p_table, p_table_type);&#10;            IF p_recursive_level &#61; 0 THEN&#10;                l_xml_tag :&#61; l_xml_tag || &#39;&#39;; --CASE WHEN p_update_mode &#61; &#39;D&#39; THEN &#39;D&#39; END; --PKG_LstUtl.add_postfix(l_xml_tag, UPPER(TRIM(p_update_mode))); -- || &#39;_&#39; || PKG_DynSql.get_xml_message_id(p_table);&#10;            END IF;&#10;        END IF;&#10;        --&#10;    ELSE&#10;        IF p_recursive_level &#61; 0 THEN&#10;            l_xml_tag :&#61; INITCAP(p_table);&#10;        ELSE&#10;            l_xml_tag :&#61; INITCAP(get_tab_alias(p_table, p_recursive_level));&#10;        END IF;&#10;    END IF;&#10;    --&#10;    RETURN l_xml_tag;&#10;END get_xml_message_tag;&#10;--&#10;FUNCTION get_xml_fld_lst(p_table VARCHAR2, p_table_type VARCHAR2, p_recursive_level INTEGER, p_update_mode VARCHAR2) RETURN CLOB&#10;IS&#10;    TYPE l_rec_TYP IS RECORD(table_name VARCHAR2(200), fld_lst VARCHAR2(32767));&#10;    TYPE l_tab_TYP IS TABLE OF l_rec_TYP;&#10;    TYPE l_tab_idx_TYP IS TABLE OF NUMBER INDEX BY VARCHAR2(100);&#10;    --&#10;    l_rec       l_rec_TYP;&#10;    l_tab       l_tab_TYP :&#61; l_tab_TYP();&#10;    l_tab_idx   l_tab_idx_TYP;&#10;    l_idx       NUMBER;&#10;    --&#10;    l_elem            VARCHAR2(1024);&#10;    l_table_name      VARCHAR2(1024);&#10;    l_target_sql_expr VARCHAR2(4000);&#10;    l_fld_name        VARCHAR2(1024);&#10;    l_fld_lst         VARCHAR2(32767);&#10;    --&#10;    l_msg_id          NUMBER;&#10;    --&#10;    l_ret             CLOB;&#10;    --&#10;BEGIN&#10;    --&#10;    l_msg_id :&#61; PKG_DynSQL.get_xml_message_id(p_table);&#10;    --&#10;    l_fld_lst :&#61; PKG_SPG_SUPPORT.get_parsed_fld_lst(p_table, p_cr_view_mode&#61;&gt;&#39;N&#39;, p_delim &#61;&gt; &#39;@|@&#39;, p_src_tab_prefix_flag&#61;&gt;&#39;Y&#39;, p_update_mode&#61;&gt;p_update_mode);&#10;    --DBMS_OUTPUT.put_line(&#39;GET_XML_FLD_LST(&#39; || p_table || &#39;)[&#39; || l_fld_lst || &#39;]&#39;);&#10;    LOOP&#10;        l_elem :&#61; TRIM(PKG_LstUtl.list_next_elem(l_fld_lst, &#39;@|@&#39;));&#10;        --DBMS_OUTPUT.put_line(&#39;L_ELEM&#61;&#39; || l_elem);&#10;        procDebug(&#39;L_ELEM&#61;&#39; || l_elem, p_trace_level&#61;&gt;15);&#10;        EXIT WHEN EMPTY2NULL(l_elem) IS NULL AND EMPTY2NULL(l_fld_lst) IS NULL;&#10;        --&#10;        l_table_name :&#61; UPPER(TRIM(PKG_LstUtl.list_next_elem(l_elem, &#39;#&#39;)));&#10;        l_fld_name   :&#61; TRIM(l_elem);&#10;        --&#10;        procDebug(&#39;L_TABLE_NAME&#61;&#39; || l_table_name || &#39;; L_FLD_NAME&#61;&#39; || l_fld_name, p_trace_level&#61;&gt;15);&#10;        --&#10;        IF SUBSTR(l_fld_name, -1) &lt;&gt; &#39;*&#39; AND SUBSTR(l_fld_name, -2) &lt;&gt; &#39;*&quot;&#39; THEN&#10;            --&#10;            l_table_name :&#61;&#10;                PKG_Lookups.funcgetTabRecord_CACHED(&#10;                    p_data_fld    &#61;&gt; &#39;RTRIM(UPPER(NVL(target_table, source_table)), &#39;&#39;*&#39;&#39;)&#39;,&#10;                    p_default_val &#61;&gt; l_table_name,&#10;                    p_table       &#61;&gt; &#39;business_int_xml_detail&#39;,&#10;                    p_ref_col     &#61;&gt; &#39;xml_message_id&#39;,&#10;                    p_ref_val     &#61;&gt; TO_CHAR(l_msg_id),&#10;                    p_where       &#61;&gt; &#39;xml_field_name &#61; :p_xml_tag AND xsd_number &#61; :p_xsd_number&#39;,&#10;                    p_bind_var1   &#61;&gt; LTRIM(RTRIM(TRIM(PKG_LstUtl.list_num_elem(l_fld_name, &#39; AS &#39;, 2)), &#39;&quot;&#39;), &#39;&quot;&#39;),&#10;                    p_bind_var2   &#61;&gt; TO_CHAR(NVL(SPGMESSAGE.GC_SCHEMA_NUMBER, 1))&#10;                );&#10;            --DBMS_OUTPUT.put_line(&#39;L_TABLE_NAME&#61;&#39; || l_table_name || &#39;, L_COL_NAME&#61;&#39; || l_fld_name);&#10;            procDebug(&#39;L_TABLE_NAME1&#61;&#39; || l_table_name || &#39;; L_FLD_NAME&#61;&#39; || l_fld_name, p_trace_level&#61;&gt;15);&#10;            --&#10;            l_target_sql_expr :&#61;&#10;                PKG_Lookups.funcgetTabRecord_CACHED(&#10;                    p_data_fld    &#61;&gt;&#10;                       &#39;CASE&#10;                            WHEN TRIM(target_sql_expression) IS NULL OR TRIM(target_sql_expression) &#61; &#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39; THEN NULL&#10;--                            WHEN UPPER(TRIM(target_sql_expression)) LIKE UPPER(&#39;&#39;%PKG_SPG_SUPPORT.get_responsible_team%&#39;&#39;) OR&#10;--                                 UPPER(TRIM(target_sql_expression)) LIKE UPPER(&#39;&#39;%PKG_SPG_SUPPORT.get_responsible_staff%&#39;&#39;) THEN&#10;--                                 &#39;&#39;REPLACE(REPLACE(&#39;&#39; || target_sql_expression || &#39;&#39;, &#39;&#39;&#39;&#39;[&#39;&#39;&#39;&#39;, &#39;&#39;&#39;&#39;&#39; || &#39;#CHR_91&#39; || &#39;&#39;&#39;&#39;&#39;), &#39;&#39;&#39;&#39;]&#39;&#39;&#39;&#39;, &#39;&#39;&#39;&#39;&#39; || &#39;#CHR_93&#39; || &#39;&#39;&#39;&#39;&#39;)&#39;&#39; || &#39;&#39; AS &quot;&#39;&#39; || xml_field_name || &#39;&#39;&quot;&#39;&#39;&#10;                            ELSE target_sql_expression || &#39;&#39; AS &quot;&#39;&#39; || xml_field_name || &#39;&#39;&quot;&#39;&#39;&#10;                        END&#39;,&#10;                    p_table       &#61;&gt; &#39;business_int_xml_detail&#39;,&#10;                    p_ref_col     &#61;&gt; &#39;xml_message_id&#39;,&#10;                    p_ref_val     &#61;&gt; TO_CHAR(l_msg_id),&#10;                    p_where       &#61;&gt; &#39;xml_field_name &#61; :p_xml_tag AND xsd_number &#61; :p_xsd_number&#39;,&#10;                    p_bind_var1   &#61;&gt; LTRIM(RTRIM(TRIM(PKG_LstUtl.list_num_elem(l_fld_name, &#39; AS &#39;, 2)), &#39;&quot;&#39;), &#39;&quot;&#39;),&#10;                    p_bind_var2   &#61;&gt; TO_CHAR(NVL(SPGMESSAGE.GC_SCHEMA_NUMBER, 1))&#10;                );&#10;            --&#10;            procDebug(&#39;L_SQLEPR&#61;&#39; || l_target_sql_expr, p_trace_level&#61;&gt;15);&#10;            IF EMPTY2NULL(l_target_sql_expr) IS NOT NULL THEN&#10;                l_target_sql_expr :&#61; CHR(10) || l_target_sql_expr;&#10;            END IF;&#10;            --&#10;            IF NOT l_tab_idx.EXISTS(l_table_name) THEN&#10;                l_tab.EXTEND;&#10;                l_idx :&#61; l_tab.COUNT;&#10;                l_tab_idx(l_table_name) :&#61; l_idx;&#10;                --&#10;                l_tab(l_idx).table_name :&#61; l_table_name;&#10;                l_tab(l_idx).fld_lst    :&#61; NVLSTR(l_target_sql_expr, /*l_table_name || &#39;.&#39; ||*/ l_fld_name);&#10;            ELSE&#10;                l_idx :&#61; l_tab_idx(l_table_name);&#10;                --&#10;                l_tab(l_idx).fld_lst :&#61; l_tab(l_idx).fld_lst || &#39;,&#39; || NVLSTR(l_target_sql_expr, /*l_table_name || &#39;.&#39; ||*/ l_fld_name);&#10;                --&#10;            END IF;&#10;            --&#10;        END IF; --IF SUBSTR(l_fld_name, -1) &lt;&gt; &#39;*&#39; AND SUBSTR(l_fld_name, -2) &lt;&gt; &#39;*&quot;&#39; THEN&#10;        --&#10;    END LOOP;&#10;    --&#10;    IF l_tab.COUNT &gt; 0 THEN&#10;        FOR l_idx IN 1..l_tab.COUNT LOOP&#10;            l_table_name :&#61; l_tab(l_idx).table_name;&#10;            --DBMS_OUTPUT.put_line(&#39;L_TAB(&#39; || l_table_name || &#39;)&#61;&#39; || l_tab(l_table_name));&#10;            l_ret :&#61;&#10;                concat_CLOB(&#10;                    l_ret,&#10;                    &#39;XMLFOREST(&#39; || l_tab(l_idx).fld_lst || &#39;) AS &quot;&#39; || get_xml_message_tag(l_table_name, p_table_type, p_recursive_level, GC_XSD_LEVEL_MSG_TABLE, p_update_mode) || &#39;&quot;&#39;,&#10;                    p_delim   &#61;&gt; &#39;,&#39; || CHR(10)/*, p_max_len &#61;&gt; 32767*/ );&#10;            --&#10;            IF PKG_Debug.funcGetDebugActive THEN&#10;                procDebug(&#39;L_TAB(&#39; || l_idx || &#39;).FLD_LST&#61;&#39; || l_tab(l_idx).fld_lst, p_trace_level&#61;&gt;15);&#10;                procDebug(&#39;L_RET&#61;&#39; || l_ret, p_trace_level&#61;&gt;15);&#10;            END IF;&#10;            --&#10;        END LOOP;&#10;    END IF;&#10;    --&#10;    --procDebug(&#39;LENGTH(L_RET)&#61;&#39; || LENGTH(l_ret), p_trace_level&#61;&gt;10);&#10;    --&#10;    RETURN l_ret;&#10;END get_xml_fld_lst;&#10;--&#10;FUNCTION get_where_clause(p_table VARCHAR2, p_table_type VARCHAR2, p_parent_table VARCHAR2, p_level INTEGER, p_top_parent_table VARCHAR2 DEFAULT NULL) RETURN VARCHAR2&#10;IS&#10;    --&#10;    l_fld_lst VARCHAR2(4096);&#10;    l_fld VARCHAR2(30);&#10;    l_ret VARCHAR2(4096);&#10;    --&#10;    l_tab_alias             VARCHAR2(100);&#10;    l_pk_fld_lst            VARCHAR2(1000);&#10;    l_parent_pk_fld_lst     VARCHAR2(1000);&#10;    l_parent_tab_alias      VARCHAR2(100);&#10;    l_top_parent_tab_alias  VARCHAR2(100);&#10;    --&#10;    l_level_offset          NUMBER;&#10;    --&#10;BEGIN&#10;    --&#10;    do_init_tab_info;&#10;    --&#10;    l_tab_alias  :&#61; get_tab_alias(p_table, p_level);&#10;    IF p_level &gt; 0 THEN&#10;        l_parent_tab_alias :&#61; get_tab_alias(p_parent_table, p_level-1);&#10;    END IF;&#10;    --&#10;    IF EMPTY2NULL(p_top_parent_table) IS NOT NULL  THEN&#10;        l_top_parent_tab_alias :&#61; get_tab_alias(p_top_parent_table, 0);&#10;        l_level_offset :&#61; PKG_DynSQL.get_tab_hier_level(p_top_parent_table);&#10;    ELSE&#10;        l_level_offset :&#61; 0;&#10;    END IF;&#10;    --&#10;    IF p_table_type &#61; &#39;M&#39; THEN&#10;        IF p_level &lt;&#61; 0 THEN&#10;            l_ret :&#61; l_tab_alias || &#39;.&#39; || &#39;UNIQUE_KEY &#61; :P_PK_VAL&#39;;&#10;        ELSIF p_level &#61; 1 THEN&#10;            IF PKG_Global.GC_SPG_MULTIPARENT_FLAG &#61; &#39;Y&#39; THEN&#10;                l_ret :&#61; PKG_DynSQL.get_tab_fk_fld_name(p_table, p_level+l_level_offset) || &#39; &#61; &#39; || l_parent_tab_alias || &#39;.UNIQUE_KEY&#39;;&#10;            ELSE&#10;                l_ret :&#61; &#39;FOREIGN_KEY&#39; || &#39; &#61; &#39; || l_parent_tab_alias || &#39;.UNIQUE_KEY&#39;;&#10;            END IF;&#10;        ELSE&#10;            -- TODO:&#10;            -- 1) Replace FOREIGN_KEY with hierarchy-specific FK (to be stored in WHERE1)&#10;            -- 2) get_tab_parent_table should also become hier_level specific as the same XML view may have &gt; than 1 parent entity&#10;            -- 3) introduce extra WHERE clause (e.g. NSI.EVENT_ID IS NULL for hier_level&#61;2)&#10;            IF PKG_Global.GC_SPG_MULTIPARENT_FLAG &#61; &#39;Y&#39; THEN&#10;                l_ret :&#61; PKG_DynSQL.get_tab_fk_fld_name(p_table, p_level+l_level_offset) || &#39; IN ( SELECT UNIQUE_KEY FROM &#39; || p_parent_table || &#39; WHERE &#39; || get_where_clause(p_parent_table, p_table_type, PKG_DynSQL.get_tab_parent_table(p_parent_table), p_level-1, p_top_parent_table) || &#39; )&#39;;&#10;                l_ret :&#61; &#39;CRN &#61; &#39; || l_top_parent_tab_alias || &#39;.CRN AND ( &#39; || l_ret || &#39; )&#39;;&#10;                --raise_application_error(-20001, &#39;ERROR in PKG_DynXML.get_where_clause: PKG_Global.GC_SPG_MULTIPARENT_FLAG&#61;Y mode is not implemented yet&#39;);&#10;            ELSE&#10;                l_ret :&#61; &#39;FOREIGN_KEY&#39; || &#39; IN ( SELECT UNIQUE_KEY FROM &#39; || p_parent_table || &#39; WHERE &#39; || get_where_clause(p_parent_table, p_table_type, PKG_DynSQL.get_tab_parent_table(p_parent_table), p_level-1, p_top_parent_table) || &#39; )&#39;;&#10;                l_ret :&#61; &#39;CRN &#61; &#39; || l_top_parent_tab_alias || &#39;.CRN AND ( &#39; || l_ret || &#39; )&#39;;&#10;            END IF;&#10;        END IF;&#10;        --&#10;        IF PKG_Debug.funcGetDebugActive THEN&#10;            procDebug(&#39;PKG_DynXML.get_where_clause(&#39; || p_table || &#39;, &#39; || p_table_type || &#39;, &#39; || p_parent_table || &#39;, &#39; || p_level || &#39;, &#39; || p_top_parent_table || &#39;): &#39; || l_ret, p_trace_level&#61;&gt;10);&#10;        END IF;&#10;        --&#10;    ELSE&#10;        --&#10;        l_pk_fld_lst :&#61; PKG_DynSQL.get_tab_pk_fld_lst(p_table);&#10;        --&#10;        IF p_level &lt;&#61; 0 THEN&#10;            --l_ret :&#61; l_tab_alias || &#39;.&#39; || l_pk_fld_lst || &#39; &#61; :P_PK_VAL&#39;;&#10;            l_ret :&#61; get_where_clause(p_table, p_table_type, PKG_DynSQL.get_tab_parent_table(p_table), p_level, p_top_parent_table);&#10;        ELSE&#10;            l_parent_pk_fld_lst :&#61; PKG_DynSQL.get_tab_pk_fld_lst(p_parent_table);&#10;            l_fld_lst :&#61; LOWER(REPLACE(l_parent_pk_fld_lst, &#39; &#39;, &#39;&#39;));&#10;            LOOP&#10;                l_fld :&#61; PKG_LstUtl.list_next_elem(l_fld_lst, &#39;,&#39;);&#10;                l_fld :&#61; PKG_LstUtl.list_last_elem(l_fld, &#39;.&#39;);&#10;                EXIT WHEN EMPTY2NULL(l_fld) IS NULL;&#10;                --&#10;                l_ret :&#61;&#10;                    PKG_LstUtl.concat(&#10;                        l_ret,&#10;                        l_fld || &#39; &#61; &#39; || l_top_parent_tab_alias || &#39;.&#39; || l_fld,&#10;                        p_delim &#61;&gt; &#39; AND &#39;, p_max_len &#61;&gt; 32767 );&#10;            END LOOP;&#10;        END IF;&#10;    END IF;&#10;    --&#10;    RETURN l_ret;&#10;END get_where_clause;&#10;--&#10;FUNCTION get_xml_attr_as_txt(p_xSQL VARCHAR2) RETURN VARCHAR2&#10;IS&#10;    l_xSQL VARCHAR2(8096);&#10;    l_line VARCHAR2(1024);&#10;    l_ret  VARCHAR2(8096);&#10;BEGIN&#10;    IF p_xSQL LIKE &#39;XMLForest(%&#39; THEN&#10;        EXECUTE IMMEDIATE &#39;SELECT &#39; || p_xSQL || &#39; FROM dual&#39; INTO l_ret;&#10;    ELSE&#10;        l_xSQL :&#61; TRIM(RTRIM(LTRIM(TRIM(REPLACE(p_xSQL, &#39;XMLAttributes(&#39;, &#39;&#39;)), CHR(10)), &#39;)&#39;));&#10;        LOOP&#10;            l_line :&#61; TRIM(RTRIM(REPLACE(PKG_LstUtl.list_next_elem(l_xSQL, CHR(10)), &#39;&#39;&#39;&#39;&#39;&#39;, &#39;&#39;&#39;&#39;), &#39;,&#39;));&#10;            EXIT WHEN EMPTY2NULL(l_line) IS NULL AND EMPTY2NULL(l_xSQL) IS NULL;&#10;            --&#10;            l_ret :&#61; PKG_LstUtl.concat(l_ret, TRIM(REPLACE(PKG_LstUtl.list_last_elem(l_line, &#39; AS &#39;), &#39;&quot;&#39;, &#39;&#39;)) || &#39;&#61;&#39; || REPLACE(l_line, &#39;&#39;&#39;&#39;, &#39;&quot;&#39;), p_delim&#61;&gt;&#39; &#39;, p_max_len&#61;&gt;32767 );&#10;        END LOOP;&#10;    END IF;&#10;    --&#10;    RETURN l_ret;&#10;END get_xml_attr_as_txt;&#10;--&#10;FUNCTION get_xml_msg_root(p_xSQL VARCHAR2 DEFAULT &#39;Y&#39;) RETURN VARCHAR2&#10;IS&#10;    l_SQL VARCHAR2(1024);&#10;BEGIN&#10;  l_SQL :&#61;&#10;&#39;XMLAttributes(&#10;  &#39;&#39;http://www.justice.gsi.gov.uk/SPG/&#39;&#39; AS &quot;xmlns&quot;,&#10;  &#39;&#39;http://www.w3.org/2001/XMLSchema-instance&#39;&#39; AS &quot;xmlns:xsi&quot;,&#10;  &#39;&#39;&#39; || SPGMessage.GC_SCHEMA_VERSION || &#39;&#39;&#39; AS &quot;SchemaVersion&quot;,&#10;  &#39;&#39;&#39; || SPGMessage.GC_SCHEMA_DATE    || &#39;&#39;&#39; AS &quot;SchemaDate&quot;,&#10;  &#39;&#39;http://www.justice.gsi.gov.uk/SPG/ SPG-XML_Message_Root-V&#39; || SPGMessage.GC_SCHEMA_VERSION || &#39;.xsd&#39;&#39; AS &quot;xsi:schemaLocation&quot; )&#39;;&#10;    --&#10;    RETURN&#10;        CASE WHEN NVL(p_xSQL, &#39;N&#39;) &#61; &#39;Y&#39; THEN&#10;            l_SQL&#10;        ELSE&#10;            get_xml_attr_as_txt(l_SQL)&#10;        END;&#10;END get_xml_msg_root;&#10;--&#10;FUNCTION get_xml_int_header(p_xSQL VARCHAR2 DEFAULT &#39;Y&#39;) RETURN VARCHAR2&#10;IS&#10;    l_SQL VARCHAR2(1024);&#10;BEGIN&#10;  l_SQL :&#61;&#10;&#39;XMLForest(&#10;  &#39;&#39;&#39; || G_SENDER_IDENTITY   || &#39;&#39;&#39; AS &quot;SenderIdentity&quot;,&#10;  &#39;&#39;&#39; || G_RECEIVER_IDENTITY || &#39;&#39;&#39; AS &quot;ReceiverIdentity&quot;,&#10;  &#39; || G_CONTROL_REFERENCE   || &#39; AS &quot;SenderControlReference&quot;,&#10;  &#39; || CASE WHEN G_RECEIVER_CTL_REFERENCE IS NOT NULL THEN &#39;&#39;&#39;&#39; || G_RECEIVER_CTL_REFERENCE || &#39;&#39;&#39; AS &quot;ReceiverControlReference&quot;, &#39; END&#10;  || &#39; TO_CHAR(SYSDATE, &#39;&#39;YYYY-MM-DD&#39;&#39;) AS &quot;DateOfPreparation&quot;,&#10;  TO_CHAR(SYSDATE, &#39;&#39;HH24:MI:SS&#39;&#39;) AS &quot;TimeOfPreparation&quot;,&#10;  &#39;&#39;&#39; || G_APPLICATION_REFERENCE || &#39;&#39;&#39; AS &quot;ApplicationReference&quot;&#39;;&#10;  --&#10;  IF G_TEST_INDICATOR IN (&#39;Y&#39;,&#39;n&#39;) THEN&#10;      l_SQL :&#61; l_SQL || &#39;,&#39; || CHR(10) || &#39;  &#39;&#39;&#39; || G_TEST_INDICATOR || &#39;&#39;&#39; AS &quot;TestIndicator&quot;&#39;;&#10;  END IF;&#10;  --&#10;  l_SQL :&#61; l_SQL || &#39; )&#39;;&#10;    --&#10;    RETURN&#10;        CASE WHEN NVL(p_xSQL, &#39;N&#39;) &#61; &#39;Y&#39; THEN&#10;            l_SQL&#10;        ELSE&#10;            get_xml_attr_as_txt(l_SQL)&#10;        END;&#10;END get_xml_int_header;&#10;--&#10;FUNCTION get_xml_int_trailer(p_xSQL VARCHAR2 DEFAULT &#39;Y&#39;) RETURN VARCHAR2&#10;IS&#10;    l_SQL VARCHAR2(1024);&#10;BEGIN&#10;  l_SQL :&#61;&#10;&#39;XMLForest(&#10;  &#39;   || G_CONTROL_REFERENCE || &#39; AS &quot;SenderControlReference&quot;,&#10;  &#39; || CASE WHEN G_RECEIVER_CTL_REFERENCE IS NOT NULL THEN &#39;&#39;&#39;&#39; || G_RECEIVER_CTL_REFERENCE || &#39;&#39;&#39; AS &quot;ReceiverControlReference&quot;, &#39; END&#10;     || G_CONTROL_COUNT     || &#39; AS &quot;ControlCount&quot;,&#10;  &#39;&#39;&#39; || G_SENDER_IDENTITY   || &#39;&#39;&#39; AS &quot;SenderIdentity&quot;,&#10;  &#39;&#39;&#39; || G_RECEIVER_IDENTITY || &#39;&#39;&#39; AS &quot;ReceiverIdentity&quot; )&#39;;&#10;    --&#10;    RETURN&#10;        CASE WHEN NVL(p_xSQL, &#39;N&#39;) &#61; &#39;Y&#39; THEN&#10;            l_SQL&#10;        ELSE&#10;            get_xml_attr_as_txt(l_SQL)&#10;        END;&#10;END get_xml_int_trailer;&#10;--&#10;FUNCTION get_xml_msg_header(p_xSQL VARCHAR2 DEFAULT &#39;Y&#39;, p_update_mode VARCHAR2 DEFAULT &#39;I&#39;) RETURN VARCHAR2&#10;IS&#10;    l_SQL VARCHAR2(1024);&#10;    l_update_mode VARCHAR2(3);&#10;BEGIN&#10;    SELECT&#10;      DECODE(NVL(TRIM(p_update_mode), &#39;I&#39;),&#10;          &#39;I&#39;, &#39;INS&#39;,&#10;          &#39;U&#39;, &#39;UPD&#39;,&#10;          &#39;D&#39;, &#39;DEL&#39;,&#10;          &#39;G&#39;, &#39;GET&#39;,&#10;          &#39;S&#39;, &#39;SYS&#39;,&#10;          &#39;R&#39;, &#39;RSP&#39;,&#10;          TRIM(p_update_mode))&#10;    INTO l_update_mode&#10;    FROM dual;&#10;    --&#10;    l_SQL :&#61;&#10;&#39;XMLForest(&#10;  &#39;&#39;&#39; || l_update_mode                || &#39;&#39;&#39; AS &quot;MessageType&quot;,&#10;  &#39;&#39;&#39; || SPGMessage.GC_SCHEMA_VERSION || &#39;&#39;&#39; AS &quot;MessageVersionNumber&quot;,&#10;  1                                          AS &quot;MessageReferenceNumber&quot; )&#39;;&#10;/*&#10;MB 06/08 - Currently not used in workflow and optional in schema&#10;,&#10;  &#39;&#39;a&#39;&#39;          AS &quot;MessageRecordIdentifier&quot; )&#39;;&#10;*/&#10;    --&#10;    RETURN&#10;        CASE WHEN NVL(p_xSQL, &#39;N&#39;) &#61; &#39;Y&#39; THEN&#10;            l_SQL&#10;        ELSE&#10;            get_xml_attr_as_txt(l_SQL)&#10;        END;&#10;END get_xml_msg_header;&#10;--&#10;FUNCTION get_xml_msg_trailer(p_xSQL VARCHAR2 DEFAULT &#39;Y&#39;) RETURN VARCHAR2&#10;IS&#10;    l_SQL VARCHAR2(1024);&#10;BEGIN&#10;  l_SQL :&#61;&#10;&#39;XMLForest(&#10;  1 AS &quot;MessageReferenceNumber&quot; )&#39;;&#10;    --&#10;    RETURN&#10;        CASE WHEN NVL(p_xSQL, &#39;N&#39;) &#61; &#39;Y&#39; THEN&#10;            l_SQL&#10;        ELSE&#10;            get_xml_attr_as_txt(l_SQL)&#10;        END;&#10;END get_xml_msg_trailer;&#10;--&#10;FUNCTION get_gen_xml_SQL(&#10;    p_table                 VARCHAR2,&#10;    p_table_type            VARCHAR2 DEFAULT &#39;M&#39;,&#10;    p_parent_table          VARCHAR2 DEFAULT NULL,&#10;    p_top_parent_table      VARCHAR2 DEFAULT NULL,&#10;    p_not_null_col_name     VARCHAR2 DEFAULT NULL,&#10;    p_where_clause          VARCHAR2 DEFAULT NULL,&#10;    p_recursive_level       INTEGER DEFAULT 0,&#10;    p_max_p_recursive_level INTEGER DEFAULT -1,&#10;    p_inc_tab_list          VARCHAR2 DEFAULT &#39;ALL&#39;,&#10;    p_excl_tab_list         VARCHAR2 DEFAULT &#39;NONE&#39;,&#10;    p_compound_message_name VARCHAR2 DEFAULT NULL,&#10;    p_headers_and_trailers  VARCHAR2 DEFAULT &#39;Y&#39;,&#10;    p_update_mode           VARCHAR2 DEFAULT NULL )&#10;RETURN CLOB IS&#10;    --&#10;    l_proc VARCHAR2(32) :&#61; UPPER(&#39;get_gen_xml_SQL&#39;);&#10;    --&#10;    recursive_limit_exception EXCEPTION;&#10;    lc_max_recursion CONSTANT NUMBER :&#61; 100;&#10;    --&#10;    TYPE  l_cur_TYP IS REF CURSOR;&#10;    l_cur l_cur_TYP;&#10;    --&#10;    l_fld_lst CLOB;&#10;    l_SQL     CLOB;&#10;    l_SQL1    CLOB;&#10;    --&#10;    l_tab_OH  PKG_DynSQL.t_hier_tab_TYP;&#10;    l_tab_idx INTEGER;&#10;    --&#10;    l_top_parent_table VARCHAR2(100);&#10;    --&#10;BEGIN&#10;    IF PKG_Debug.funcGetDebugActive THEN&#10;        procDebug(l_proc || &#39; Started. &#39; ||&#10;            &#39;(table&#61;&#39;             || p_table              || &#39;)&#39; ||&#10;            &#39;(parent_table&#61;&#39;      || p_parent_table       || &#39;)&#39; ||&#10;            &#39;(not_null_col_name&#61;&#39; || p_not_null_col_name  || &#39;)&#39; ||&#10;            &#39;(where&#61;&#39;             || p_where_clause       || &#39;)&#39; ||&#10;            &#39;(recursive_level&#61;&#39;   || p_recursive_level    || &#39;)&#39;,&#10;            p_trace_level&#61;&gt;5 );&#10;    END IF;&#10;    --&#10;    do_init_tab_info;&#10;    --&#10;    IF (p_recursive_level &gt;&#61; lc_max_recursion) THEN&#10;        procDebug(&#39;ERROR in &#39; || l_proc || &#39;: &#39; ||&#10;            &#39;Count no. of recursive calls [&#39; || p_recursive_level || &#39;] - must not exceed the maximum of &#39; || lc_max_recursion,&#10;            p_trace_level&#61;&gt;0);&#10;        RAISE recursive_limit_exception;&#10;    ELSIF p_max_p_recursive_level &gt; 0 AND p_recursive_level &gt; p_max_p_recursive_level THEN&#10;        procDebug(&#39;INFO in &#39; || l_proc || &#39;: &#39; ||&#10;            &#39;Count no. of recursive calls [&#39; || p_recursive_level || &#39;] - has reached its requested maximum value of &#39; || p_max_p_recursive_level,&#10;            p_trace_level&#61;&gt;0);&#10;        RETURN NULL;&#10;    END IF;&#10;    --&#10;    IF p_recursive_level &#61; 0 THEN --UPPER(p_table) &#61; &#39;OFFENDER&#39; THEN&#10;        --&#10;        l_top_parent_table :&#61; p_table;&#10;        --&#10;        l_SQL :&#61;&#10;           &#39;SELECT&#39; || CHR(10) ||&#10;           --&#10;           CASE WHEN p_table_type &#61; &#39;M&#39; AND p_headers_and_trailers &#61; &#39;Y&#39; THEN&#10;           --&#10;           --&#39;  XMLElement(name &quot;SPGInterchange&quot;,&#39;   || CHR(10) || get_indented_text(get_xml_msg_root, 4)   || &#39;,&#39; || CHR(10) ||&#10;           --&#39;  XMLElement(name &quot;SPGInterchangeHeader&quot;,&#39; || CHR(10) || get_indented_text(get_xml_int_header, 4) || &#39; AS &quot;SPGInterchangeHeader&quot; ),&#39; || CHR(10) ||&#10;           --&#10;           &#39;  XMLElement(name &quot;SPGMessageHeader&quot;,&#39;     || CHR(10) || get_indented_text(get_xml_msg_header(&#39;Y&#39;, (CASE WHEN G_TOP_MSG_UPD_MODE &#61; &#39;Y&#39; THEN &#39;U&#39; ELSE p_update_mode END)), 4) || &#39; AS &quot;SPGMessageHeader&quot; ) ,&#39;&#10;           ELSE&#10;           &#39;  XMLComment(&#39;&#39;SPGMessageHeader&#39;&#39;) AS &quot;SPGMessageHeader&quot;,&#39;&#10;           END ||&#10;           &#39;  --&#39; || CHR(10) ||&#10;           &#39;  -- Beginning of the NDelius XML Message Payload&#39; || CHR(10) ||&#10;           &#39;  /* XMLElement(name &quot;SPGMessage&quot;,  NOTE: YF: Moved to the XML message payload top level*/&#39; || CHR(10) ||&#10;           &#39;  --&#39; || CHR(10) ||&#10;           CASE WHEN EMPTY2NULL(p_compound_message_name) IS NOT NULL THEN&#10;           &#39;  XMLElement(name &quot;&#39; || p_compound_message_name || &#39;&quot;,&#39; || CHR(10)&#10;           ELSE &#39;&#39; END ||&#10;           --&#10;           &#39;  XMLElement(name &#39; || &#39;&quot;&#39; || get_xml_message_tag(p_table, p_table_type, p_recursive_level, GC_XSD_LEVEL_MSG_ENTITY, p_update_mode) || &#39;&quot;,&#39; || CHR(10) ||&#10;           --&#39;    XMLAttributes(&#39;&#39;http://www.w3.org/2001/XMLSchema-instance&#39;&#39; AS &quot;xmlns:xsi&quot;),&#39; || CHR(10) ||&#10;           &#39;    XMLComment(&#39;&#39;&#39; || p_table || &#39; Table Records&#39;&#39;),&#39; || CHR(10) ||&#10;           &#39;    XMLElement(name &quot;&#39; || get_xml_message_tag(p_table, p_table_type, p_recursive_level, GC_XSD_LEVEL_MSG_STRUCTURE, p_update_mode) || &#39;&quot;, XMLForest(&#39;;&#10;    ELSE&#10;        --&#10;        l_top_parent_table :&#61; p_top_parent_table;&#10;        --&#10;        l_SQL :&#61; get_indented_text(&#10;           &#39;XMLComment(&#39;&#39;&#39; || p_table || &#39;(&#39; || TO_CHAR(p_recursive_level) || &#39;) Table Records&#39;&#39;),&#39; || CHR(10) ||&#10;           &#39;( SELECT&#39; || CHR(10) ||&#10;           &#39;    XMLAgg(XMLElement(name &#39; || &#39;&quot;&#39; || get_xml_message_tag(p_table, p_table_type, p_recursive_level, GC_XSD_LEVEL_MSG_ENTITY) || &#39;&quot;,&#39; || CHR(10) ||&#10;           &#39;      XMLElement(name &quot;&#39; || get_xml_message_tag(p_table, p_table_type, p_recursive_level, GC_XSD_LEVEL_MSG_STRUCTURE, p_update_mode) || &#39;&quot;, XMLForest(&#39;,&#10;           6 * p_recursive_level);&#10;    END IF;&#10;    --&#10;    G_TOP_MSG_UPD_MODE :&#61; &#39;N&#39;;&#10;    --&#10;    l_fld_lst :&#61;&#10;        CASE WHEN p_table_type &#61; &#39;M&#39; THEN&#10;            CHR(10) ||&#10;            get_indented_text( get_xml_fld_lst(p_table, p_table_type, p_recursive_level, p_update_mode), 6 * p_recursive_level + 6 + 2 ) ||&#10;            &#39; ) AS &quot;&#39; || get_xml_message_tag(p_table, p_table_type, p_recursive_level, GC_XSD_LEVEL_MSG_STRUCTURE, p_update_mode) || &#39;&quot; )&#39;&#10;        ELSE&#10;            PKG_DynSQL.get_tab_pk_fld_lst(p_table) ||&#10;            &#39; ) )&#39;&#10;        END;&#10;    --&#10;    l_SQL :&#61; l_SQL || &#39; &#39; || l_fld_lst ||&#10;        -- Moved from AFTER LOOP&#10;        &#39;  )&#39;;&#10;    --&#10;    IF p_recursive_level &gt; 0 THEN --UPPER(p_table) &#61; &#39;OFFENDER&#39; THEN&#10;        l_SQL :&#61; l_SQL || &#39; ) AS &quot;&#39; || get_xml_message_tag(p_table, p_table_type, p_recursive_level, GC_XSD_LEVEL_MSG_ENTITY, p_update_mode) || &#39;&quot;&#39; || CHR(10) ||&#10;            get_indented_text(&#10;                &#39;  FROM &#39; || LOWER(p_table) || &#39; &#39; || get_tab_alias(p_table, p_recursive_level) || CHR(10) ||&#10;                PKG_LstUtl.concat(&#10;                    &#39;  WHERE &#39; || get_where_clause(p_table, p_table_type, p_parent_table, p_recursive_level, l_top_parent_table),&#10;                    PKG_LstUtl.add_prefix(&#39;    AND &#39;, PKG_LstUtl.add_postfix(p_not_null_col_name, &#39; IS NOT NULL&#39;)),&#10;                    CASE WHEN EMPTY2NULL(p_where_clause) IS NOT NULL THEN  &#39;    AND ( &#39; || p_where_clause || &#39; )&#39; END,&#10;                    --&#39;&#39;,&#10;                    p_delim   &#61;&gt; CHR(10),&#10;                    p_max_len &#61;&gt; 32767&#10;                ) || CHR(10) ||&#10;                &#39;) AS &quot;&#39; || INITCAP(get_tab_alias(p_table, p_recursive_level)) || &#39;&quot;,&#39; || CHR(10) ||&#10;                &#39;XMLComment(&#39;&#39;End Of &#39; || p_table || &#39;(&#39; || TO_CHAR(p_recursive_level) || &#39;) Table Records&#39;&#39;)&#39;,&#10;                6 * p_recursive_level );&#10;    END IF;&#10;    --&#10;    -- Get next dependant table name (new p-table) for p-table from offender hierarchy&#10;    l_tab_OH :&#61; PKG_DynSQL.get_tab_child_tables(p_table);&#10;    --&#10;    FOR l_tab_idx IN 1..l_tab_OH.COUNT&#10;    LOOP&#10;        IF ( NVLSTR(p_inc_tab_list, &#39;ALL&#39;) &#61; &#39;ALL&#39; OR&#10;             &#39;,&#39;  || p_inc_tab_list  || &#39;,&#39; LIKE&#10;             &#39;%,&#39; || l_tab_OH(l_tab_idx).table_name || &#39;,%&#39; )&#10;           AND&#10;           ( NVLSTR(p_excl_tab_list, &#39;NONE&#39;) &#61; &#39;NONE&#39; OR&#10;             &#39;,&#39;  || p_excl_tab_list  || &#39;,&#39; NOT LIKE&#10;             &#39;%,&#39; || l_tab_OH(l_tab_idx).table_name || &#39;,%&#39; )&#10;        THEN&#10;            --&#10;            l_SQL1 :&#61;&#10;                get_gen_xml_SQL(&#10;                    p_table                 &#61;&gt; l_tab_OH(l_tab_idx).table_name,&#10;                    p_table_type            &#61;&gt; l_tab_OH(l_tab_idx).table_type,&#10;                    p_parent_table          &#61;&gt; l_tab_OH(l_tab_idx).parent_table,&#10;                    p_top_parent_table      &#61;&gt; l_top_parent_table,&#10;                    p_not_null_col_name     &#61;&gt; l_tab_OH(l_tab_idx).not_null_col_name,&#10;                    p_where_clause          &#61;&gt; l_tab_OH(l_tab_idx).where_clause,&#10;                    p_recursive_level       &#61;&gt; p_recursive_level+1,&#10;                    p_max_p_recursive_level &#61;&gt; p_max_p_recursive_level,&#10;                    p_inc_tab_list          &#61;&gt; p_inc_tab_list,&#10;                    p_excl_tab_list         &#61;&gt; p_excl_tab_list,&#10;                    p_update_mode           &#61;&gt; p_update_mode );&#10;            IF DBMS_LOB.getlength(l_SQL1) &gt; 0 THEN&#10;                l_SQL :&#61; l_SQL || &#39;,&#39; || CHR(10) || l_SQL1;&#10;            END IF;&#10;        END IF;&#10;        --&#10;        /*&#10;           &#39;SELECT SUBSTR(&#39; || PKG_DynSQL.get_tab_pk_fld_lst( l_tab_OH(l_tab_idx).table_name, &#39;||&#39; ) || &#39;, 1, 4000) AS PK_KEY_VAL&#10;            FROM &#39; || get_src_tab_name( l_tab_OH(l_tab_idx).table_name, g_src_schema ) || &#39;&#10;            WHERE 1&#61;1&#39; || CHR(10) ||&#10;                &#39;  AND &#39; || PKG_LstUtl.concat(&#10;                    PKG_DynSQL.get_tab_pk_fld_lst( l_tab_OH(l_tab_idx).parent_table, &#39;||&#39; ) || &#39; &#61; :P_PK_KEY_VAL&#39;,&#10;                    PKG_LstUtl.add_postfix(l_tab_OH(l_tab_idx).not_null_col_name, &#39; IS NOT NULL&#39;),&#10;                    &#39;( &#39; || NVLSTR(l_tab_OH(l_tab_idx).where_clause, &#39;1&#61;1&#39;) || &#39; )&#39;,&#10;                    --&#10;                    p_delim   &#61;&gt; CHR(10) || &#39;  AND &#39;,&#10;                    p_max_len &#61;&gt; 32767 )&#10;           ;&#10;        */&#10;    END LOOP;&#10;    --&#10;    IF p_recursive_level &#61; 0 THEN --UPPER(p_table) &#61; &#39;OFFENDER&#39; THEN&#10;        l_SQL :&#61; l_SQL || CHR(10) ||&#10;            -- Moved to BEFORE LOOP&#10;            --&#39;  ) AS &quot;&#39; || get_xml_message_tag(p_table, p_table_type, p_recursive_level, GC_XSD_LEVEL_MSG_ENTITY)/*get_xml_message_name(p_table, p_table_type)*/ || &#39;&quot;&#39; || CHR(10) ||&#10;            --&#10;            CASE WHEN EMPTY2NULL(p_compound_message_name) IS NOT NULL THEN&#10;            &#39;  ) AS &quot;&#39; || p_compound_message_name || &#39;&quot;&#39; || CHR(10)&#10;            ELSE &#39;&#39; END ||&#10;            --&#10;            &#39;  /*) AS &quot;SPGMessage&quot; NOTE: YF: Moved to the XML message payload top level*/,&#39; || CHR(10) ||&#10;            &#39;  --&#39; || CHR(10) ||&#10;            &#39;  -- End of the NDelius XML Message Payload&#39; || CHR(10) ||&#10;            &#39;  --&#39; || CHR(10) ||&#10;            --&#10;            CASE WHEN p_table_type &#61; &#39;M&#39; AND p_headers_and_trailers &#61; &#39;Y&#39; THEN&#10;            &#39;  XMLElement(name &quot;SPGMessageTrailer&quot;,&#39;     || CHR(10) || get_indented_text(get_xml_msg_trailer, 4) || &#39; AS &quot;SPGMessageTrailer&quot; )&#39;&#10;            --&#39;  --&#39; || CHR(10) ||&#10;            --&#39;  XMLElement(name &quot;SPGInterchangeTrailer&quot;,&#39; || CHR(10) || get_indented_text(get_xml_int_trailer, 4) || &#39; AS &quot;SPGInterchangeTrailer&quot; )&#39; || CHR(10) ||&#10;            --&#39;) AS &quot;SPGInterchange&quot;&#39; || CHR(10) ||&#10;            ELSE&#10;            &#39;  XMLComment(&#39;&#39;SPGMessageTrailer&#39;&#39;) AS &quot;SPGMessageTrailer&quot;&#39;&#10;            END || CHR(10) ||&#10;            &#39;  --&#39; || CHR(10) ||&#10;            &#39;FROM &#39; || LOWER(p_table) || &#39; &#39; || get_tab_alias(p_table, p_recursive_level) || CHR(10) ||&#10;            &#39;WHERE &#39; || get_where_clause(p_table, p_table_type, p_parent_table, p_recursive_level, l_top_parent_table);&#10;    END IF;&#10;    --&#10;    RETURN l_SQL;&#10;    --&#10;--EXCEPTION WHEN OTHERS THEN&#10;--    raise_application_error(-20001,&#10;--        &#39;ERROR in PKG_DynXML.get_gen_xml_SQL(&#39; ||&#10;--        p_table                 || &#39;, &#39; ||&#10;--        p_table_type            || &#39;, &#39; ||&#10;--        p_parent_table          || &#39;, &#39; ||&#10;--        p_top_parent_table      || &#39;, &#39; ||&#10;--        p_not_null_col_name     || &#39;, &#39; ||&#10;--        p_where_clause          || &#39;, &#39; ||&#10;--        p_recursive_level       || &#39;, &#39; ||&#10;--        p_max_p_recursive_level || &#39;, &#39; ||&#10;--        p_inc_tab_list          || &#39;, &#39; ||&#10;--        p_excl_tab_list         || &#39;, &#39; ||&#10;--        p_compound_message_name || &#39;, &#39; ||&#10;--        p_headers_and_trailers  || &#39;, &#39; ||&#10;--        p_update_mode           || &#39;): &#39; ||&#10;--        SQLERRM );&#10;END get_gen_xml_SQL;&#10;--&#10;FUNCTION get_msg_2_tab_LST(p_msg_lst VARCHAR2)&#10;RETURN VARCHAR2 IS&#10;    l_tab t_tab_ORGANISATIONS;&#10;    l_res VARCHAR2(32767);&#10;BEGIN&#10;    l_tab :&#61; PKG_LstUtl.get_list_2_array(p_msg_lst);&#10;    l_res :&#61; PKG_LstUtl.get_array_2_list(l_tab, p_max_len &#61;&gt; 32767, p_iterator_function &#61;&gt; &#39;PKG_DynSQL.get_xml_view_name(:p__xml_message_id)&#39;);&#10;    --&#10;    RETURN l_res;&#10;END get_msg_2_tab_LST;&#10;--&#10;FUNCTION get_gen_xml_msg_LST(&#10;    p_table                 VARCHAR2,&#10;    p_table_type            VARCHAR2 DEFAULT &#39;M&#39;,&#10;    p_parent_table          VARCHAR2 DEFAULT NULL,&#10;    p_top_parent_table      VARCHAR2 DEFAULT NULL,&#10;    p_recursive_level       INTEGER DEFAULT 0,&#10;    p_max_p_recursive_level INTEGER DEFAULT -1,&#10;    p_inc_tab_list          VARCHAR2 DEFAULT &#39;ALL&#39;,&#10;    p_excl_tab_list         VARCHAR2 DEFAULT &#39;NONE&#39; )&#10;RETURN VARCHAR2 IS&#10;    --&#10;    l_proc VARCHAR2(32) :&#61; UPPER(&#39;get_gen_xml_msg_LST&#39;);&#10;    --&#10;    recursive_limit_exception EXCEPTION;&#10;    lc_max_recursion CONSTANT NUMBER :&#61; 100;&#10;    --&#10;    TYPE  l_cur_TYP IS REF CURSOR;&#10;    l_cur l_cur_TYP;&#10;    --&#10;    l_tab_OH  PKG_DynSQL.t_hier_tab_TYP;&#10;    l_tab_idx INTEGER;&#10;    --&#10;    l_top_parent_table VARCHAR2(100);&#10;    l_msg_lst          VARCHAR2(32767);&#10;    --&#10;BEGIN&#10;    --&#10;    IF PKG_Debug.funcGetDebugActive THEN&#10;        procDebug(l_proc || &#39; Started. &#39; ||&#10;            &#39;(table&#61;&#39;             || p_table              || &#39;)&#39; ||&#10;            &#39;(parent_table&#61;&#39;      || p_parent_table       || &#39;)&#39; ||&#10;            &#39;(recursive_level&#61;&#39;   || p_recursive_level    || &#39;)&#39;,&#10;            p_trace_level&#61;&gt;5);&#10;    END IF;&#10;    --&#10;    do_init_tab_info;&#10;    --&#10;    IF (p_recursive_level &gt;&#61; lc_max_recursion) THEN&#10;        procDebug(&#39;ERROR in &#39; || l_proc || &#39;: &#39; ||&#10;            &#39;Count no. of recursive calls [&#39; || p_recursive_level || &#39;] - must not exceed the maximum of &#39; || lc_max_recursion,&#10;            p_trace_level&#61;&gt;0);&#10;        RAISE recursive_limit_exception;&#10;    ELSIF p_max_p_recursive_level &gt; 0 AND p_recursive_level &gt; p_max_p_recursive_level THEN&#10;        procDebug(&#39;INFO in &#39; || l_proc || &#39;: &#39; ||&#10;            &#39;Count no. of recursive calls [&#39; || p_recursive_level || &#39;] - has reached its requested maximum value of &#39; || p_max_p_recursive_level,&#10;            p_trace_level&#61;&gt;0);&#10;        RETURN NULL;&#10;    END IF;&#10;    --&#10;    IF p_recursive_level &#61; 0 THEN --UPPER(p_table) &#61; &#39;OFFENDER&#39; THEN&#10;        l_top_parent_table :&#61; p_table;&#10;    ELSE&#10;        l_top_parent_table :&#61; p_top_parent_table;&#10;    END IF;&#10;    --&#10;    l_msg_LST :&#61; PKG_LstUtl.concat( l_msg_LST, CASE WHEN p_table_type &#61; &#39;M&#39; THEN PKG_DynSQL.get_xml_message_id(p_table) ELSE p_table END, p_delim&#61;&gt;&#39;,&#39; );&#10;    --&#10;    -- Get next dependant table name (new p-table) for p-table from offender hierarchy&#10;    l_tab_OH :&#61; PKG_DynSQL.get_tab_child_tables(p_table);&#10;    --&#10;    IF PKG_Debug.funcGetDebugActive THEN&#10;        procDebug(l_proc || &#39;: &#39; || &#39;(l_tab_OH.COUNT&#61;&#39; || l_tab_OH.COUNT || &#39;)&#39;, p_trace_level&#61;&gt;10);&#10;    END IF;&#10;    --&#10;    FOR l_tab_idx IN 1..l_tab_OH.COUNT&#10;    LOOP&#10;        --&#10;        IF PKG_Debug.funcGetDebugActive THEN&#10;            procDebug(l_proc || &#39;: &#39; ||&#10;                &#39;(l_tab_OH(&#39; || l_tab_idx || &#39;.table_name&#61;&#39; || l_tab_OH(l_tab_idx).table_name || &#39;)&#39;,&#10;                p_trace_level&#61;&gt;15);&#10;        END IF;&#10;        --&#10;        IF ( NVLSTR(p_inc_tab_list, &#39;ALL&#39;) &#61; &#39;ALL&#39; OR&#10;             &#39;,&#39;  || p_inc_tab_list  || &#39;,&#39; LIKE&#10;             &#39;%,&#39; || l_tab_OH(l_tab_idx).table_name || &#39;,%&#39; )&#10;           AND&#10;           ( NVLSTR(p_excl_tab_list, &#39;NONE&#39;) &#61; &#39;NONE&#39; OR&#10;             &#39;,&#39;  || p_excl_tab_list  || &#39;,&#39; NOT LIKE&#10;             &#39;%,&#39; || l_tab_OH(l_tab_idx).table_name || &#39;,%&#39; )&#10;        THEN&#10;            --&#10;            l_msg_LST :&#61;&#10;                PKG_LstUtl.concat( l_msg_LST,&#10;                    get_gen_xml_msg_LST(&#10;                        p_table                 &#61;&gt; l_tab_OH(l_tab_idx).table_name,&#10;                        p_table_type            &#61;&gt; l_tab_OH(l_tab_idx).table_type,&#10;                        p_parent_table          &#61;&gt; l_tab_OH(l_tab_idx).parent_table,&#10;                        p_top_parent_table      &#61;&gt; l_top_parent_table,&#10;                        p_recursive_level       &#61;&gt; p_recursive_level+1,&#10;                        p_max_p_recursive_level &#61;&gt; p_max_p_recursive_level,&#10;                        p_inc_tab_list          &#61;&gt; p_inc_tab_list,&#10;                        p_excl_tab_list         &#61;&gt; p_excl_tab_list ),&#10;                    p_delim &#61;&gt; &#39;,&#39; );&#10;        END IF;&#10;        --&#10;    END LOOP;&#10;    --&#10;    RETURN l_msg_LST;&#10;    --&#10;END get_gen_xml_msg_LST;&#10;--&#10;FUNCTION get_gen_xml_SQL_VCHAR(&#10;    p_table                 VARCHAR2,&#10;    p_table_type            VARCHAR2 DEFAULT &#39;M&#39;,&#10;    p_parent_table          VARCHAR2 DEFAULT NULL,&#10;    p_top_parent_table      VARCHAR2 DEFAULT NULL,&#10;    p_not_null_col_name     VARCHAR2 DEFAULT NULL,&#10;    p_where_clause          VARCHAR2 DEFAULT NULL,&#10;    p_recursive_level       INTEGER DEFAULT 0,&#10;    p_max_p_recursive_level INTEGER DEFAULT -1,&#10;    p_inc_tab_list          VARCHAR2 DEFAULT &#39;ALL&#39;,&#10;    p_excl_tab_list         VARCHAR2 DEFAULT &#39;NONE&#39;,&#10;    p_compound_message_name VARCHAR2 DEFAULT NULL,&#10;    p_headers_and_trailers  VARCHAR2 DEFAULT &#39;Y&#39;,&#10;    p_update_mode           VARCHAR2 DEFAULT NULL )&#10;RETURN VARCHAR2&#10;       RESULT_CACHE&#10;IS&#10;    l_SQL CLOB;&#10;BEGIN&#10;    l_SQL :&#61;&#10;        get_gen_xml_SQL(&#10;            p_table                 &#61;&gt; p_table,&#10;            p_table_type            &#61;&gt; p_table_type,&#10;            p_parent_table          &#61;&gt; p_parent_table,&#10;            p_top_parent_table      &#61;&gt; p_top_parent_table,&#10;            p_not_null_col_name     &#61;&gt; p_not_null_col_name,&#10;            p_where_clause          &#61;&gt; p_where_clause,&#10;            p_recursive_level       &#61;&gt; p_recursive_level,&#10;            p_max_p_recursive_level &#61;&gt; p_max_p_recursive_level,&#10;            p_inc_tab_list          &#61;&gt; p_inc_tab_list,&#10;            p_excl_tab_list         &#61;&gt; p_excl_tab_list,&#10;            p_compound_message_name &#61;&gt; p_compound_message_name,&#10;            p_headers_and_trailers  &#61;&gt; p_headers_and_trailers,&#10;            p_update_mode           &#61;&gt; p_update_mode );&#10;    IF DBMS_LOB.GETLENGTH(l_SQL) &gt; 32767 THEN&#10;        procDebug(&#39;ERROR in get_gen_xml_SQL_VCHAR: xSQL string length (&#39; || DBMS_LOB.GETLENGTH(l_SQL) || &#39;) has exceeded maximum of 32767 characters&#39;, p_trace_level&#61;&gt;0);&#10;        --l_SQL :&#61; &#39;VARCHAR_IS_TOO_BIG&#39;;&#10;        RAISE VARCHAR_IS_TOO_BIG;&#10;    END IF;&#10;    --&#10;    --RETURN DBMS_LOB.SUBSTR(l_SQL, /*32767*/29000, 1);&#10;    RETURN SUBSTR(l_SQL, 1, 32767);&#10;    --RETURN l_SQL;&#10;END get_gen_xml_SQL_VCHAR;&#10;--&#10;FUNCTION get_gen_xml(&#10;    p_table                 VARCHAR2,&#10;    p_table_type            VARCHAR2 DEFAULT &#39;M&#39;,&#10;    p_pk_value              NUMBER  DEFAULT -1,&#10;    p_offender_id           NUMBER  DEFAULT -1,&#10;    p_max_p_recursive_level INTEGER DEFAULT -1,&#10;    p_inc_tab_list          VARCHAR2 DEFAULT &#39;ALL&#39;,&#10;    p_excl_tab_list         VARCHAR2 DEFAULT &#39;MOST_RECENTLY_VIEWED_OFFENDERS,ORGANISATION_OFFENDER&#39;,&#10;    p_compound_message_name VARCHAR2 DEFAULT NULL,&#10;    p_headers_and_trailers  VARCHAR2 DEFAULT &#39;Y&#39;,&#10;    p_update_mode           VARCHAR2 DEFAULT NULL,&#10;    p_target_provider       VARCHAR2 DEFAULT NULL )&#10;RETURN CLOB IS&#10;    l_SQL     CLOB;&#10;    l_SQL1    CLOB;&#10;    --&#10;    l_xml_hdr1 CLOB;&#10;    l_xml_msg1 CLOB;&#10;    l_xml_trl1 CLOB;&#10;    --&#10;    l_xml_hdr XMLTYPE;&#10;    l_xml_msg XMLTYPE;&#10;    l_xml_trl XMLTYPE;&#10;    --&#10;    --l_xml     XMLTYPE;&#10;    l_clob    CLOB;&#10;    --l_clob1   CLOB;&#10;    --&#10;    TYPE l_cur_TYP IS REF CURSOR;&#10;    l_cur l_cur_TYP;&#10;    --&#10;    l_offender_id_col_flag VARCHAR2(1);&#10;    --&#10;    l_xml_message_id NUMBER :&#61; PKG_DynSQL.get_xml_message_id(p_table);&#10;    --&#10;BEGIN&#10;    --&#10;    BEGIN&#10;        l_SQL :&#61;&#10;            TO_CLOB( get_gen_xml_SQL_VCHAR(&#10;                p_table                 &#61;&gt; p_table,&#10;                p_table_type            &#61;&gt; p_table_type,&#10;                p_max_p_recursive_level &#61;&gt; p_max_p_recursive_level,&#10;                p_inc_tab_list          &#61;&gt; p_inc_tab_list,&#10;                p_excl_tab_list         &#61;&gt; p_excl_tab_list,&#10;                p_compound_message_name &#61;&gt; p_compound_message_name,&#10;                p_headers_and_trailers  &#61;&gt; p_headers_and_trailers,&#10;                p_update_mode           &#61;&gt; p_update_mode ) );&#10;    EXCEPTION WHEN VARCHAR_IS_TOO_BIG THEN&#10;        l_SQL :&#61;&#10;            get_gen_xml_SQL(&#10;                p_table                 &#61;&gt; p_table,&#10;                p_table_type            &#61;&gt; p_table_type,&#10;                p_max_p_recursive_level &#61;&gt; p_max_p_recursive_level,&#10;                p_inc_tab_list          &#61;&gt; p_inc_tab_list,&#10;                p_excl_tab_list         &#61;&gt; p_excl_tab_list,&#10;                p_compound_message_name &#61;&gt; p_compound_message_name,&#10;                p_headers_and_trailers  &#61;&gt; p_headers_and_trailers,&#10;                p_update_mode           &#61;&gt; p_update_mode );&#10;    END;&#10;    --&#10;    G_CONTROL_COUNT :&#61; 0;&#10;    --&#10;    --l_offender_id_col_flag :&#61; PKG_Lookups.tab_col_exists(p_tab_name&#61;&gt;PKG_DynSQL.get_xml_view_name(2225), p_col_name&#61;&gt;&#39;OFFENDER_ID&#39;)&#10;    l_offender_id_col_flag :&#61; PKG_Lookups.tab_col_exists(p_tab_name&#61;&gt;p_table, p_col_name&#61;&gt;&#39;OFFENDER_ID&#39;);&#10;    --&#10;    SPGMESSAGE.set_xml_offender_id    ( p_offender_id    );&#10;    SPGMESSAGE.set_xml_unique_id      ( p_pk_value       );&#10;    SPGMESSAGE.set_xml_msg_id         ( l_xml_message_id );&#10;    SPGMessage.set_xml_target_provider( p_target_provider );&#10;    --&#10;    IF PKG_Debug.funcGetDebugActive THEN&#10;        procDebug(&#10;            &#39;PKG_DynXML.get_gen_xml: &#39; ||&#10;            &#39;(xml_msg_id&#61;&#39;            || SPGMESSAGE.get_xml_msg_id              || &#39;)&#39; ||&#10;            &#39;(offender_id&#61;&#39;           || SPGMessage.get_xml_offender_id         || &#39;)&#39; ||&#10;            &#39;(unique_id&#61;&#39;             || SPGMESSAGE.get_xml_unique_id           || &#39;)&#39; ||&#10;            &#39;(tgt_provider&#61;&#39;          || SPGMessage.get_xml_target_provider     || &#39;)&#39; ||&#10;            &#39;(trg_provider_doc_flag&#61;&#39; || SPGMessage.get_provider_documents_flag || &#39;)&#39; );&#10;    END IF;&#10;    --&#10;    IF ( p_offender_id &gt; 0 AND l_offender_id_col_flag &#61; &#39;Y&#39; ) AND p_pk_value &gt; 0 THEN&#10;        l_SQL :&#61; l_SQL || &#39; AND offender_id &#61; :p_offender_id&#39;;&#10;        OPEN l_cur FOR l_SQL USING p_pk_value, p_offender_id;&#10;        LOOP&#10;            FETCH l_cur INTO l_xml_hdr, l_xml_msg, l_xml_trl;&#10;            EXIT WHEN l_cur%NOTFOUND;&#10;            --&#10;            G_CONTROL_COUNT :&#61; G_CONTROL_COUNT + 1;&#10;            --&#10;            l_clob :&#61; concat_CLOB(l_clob, l_xml_hdr.getClobVal(), l_xml_msg.getClobVal(), l_xml_trl.getClobVal(), p_delim&#61;&gt;CHR(10));&#10;            --l_clob :&#61; concat_CLOB(l_xml_hdr, l_xml_msg, l_xml_trl, p_delim&#61;&gt;CHR(10));&#10;        END LOOP;&#10;        CLOSE l_cur;&#10;        --&#10;    ELSIF p_offender_id &gt; 0 AND l_offender_id_col_flag &#61; &#39;Y&#39; THEN&#10;        IF l_xml_message_id &lt;&gt; 1003 THEN&#10;            l_SQL :&#61; PKG_LstUtl.replace_clob(l_SQL, &#39; &#61; :P_PK_VAL&#39;, &#39; IN ( SELECT unique_key FROM &#39; || p_table || &#39; WHERE offender_id &#61; :p_offender_id )&#39;);&#10;            --raise_error(p_err_msg VARCHAR2, p_proc VARCHAR2, p_label VARCHAR2 DEFAULT &#39;&#39;) IS&#10;        END IF;&#10;        --&#10;        OPEN l_cur FOR l_SQL USING p_offender_id;&#10;        LOOP&#10;            FETCH l_cur INTO l_xml_hdr, l_xml_msg, l_xml_trl;&#10;            EXIT WHEN l_cur%NOTFOUND;&#10;            --&#10;            G_CONTROL_COUNT :&#61; G_CONTROL_COUNT + 1;&#10;            --&#10;            l_clob :&#61; concat_CLOB(l_clob, l_xml_hdr.getClobVal(), l_xml_msg.getClobVal(), l_xml_trl.getClobVal(), p_delim&#61;&gt;CHR(10));&#10;            --l_clob :&#61; concat_CLOB(l_xml_hdr, l_xml_msg, l_xml_trl, p_delim&#61;&gt;CHR(10));&#10;        END LOOP;&#10;        CLOSE l_cur;&#10;        --&#10;    ELSE -- p_offender_id is not specified AND p_pk_value &gt; 0&#10;        --&#10;        IF PKG_Debug.funcGetDebugActive THEN&#10;            procDebug(l_SQL, p_trace_level&#61;&gt;1);&#10;        END IF;&#10;        --&#10;        OPEN l_cur FOR l_SQL USING p_pk_value;&#10;        FETCH l_cur INTO l_xml_hdr, l_xml_msg, l_xml_trl;&#10;        CLOSE l_cur;&#10;&#10;        /*EXECUTE IMMEDIATE l_SQL&#10;        INTO l_xml_hdr, l_xml_msg, l_xml_trl&#10;        USING p_pk_value;*/&#10;        --&#10;        G_CONTROL_COUNT :&#61; 1;&#10;        --&#10;        l_clob :&#61; concat_CLOB(l_xml_hdr.getClobVal(), l_xml_msg.getClobVal(), l_xml_trl.getClobVal(), p_delim&#61;&gt;CHR(10));&#10;        --l_clob :&#61; concat_CLOB(l_xml_hdr, l_xml_msg, l_xml_trl, p_delim&#61;&gt;CHR(10));&#10;        --&#10;    END IF;&#10;    --&#10;    --l_clob :&#61; REPLACE(l_clob, CHR(38) || &#39;amp;#10;&#39;, CHR(38) || &#39;#10;&#39;);&#10;    l_clob :&#61; REPLACE(l_clob, PKG_Global.GC_SPG_CR, CHR(38) || &#39;#10;&#39;);&#10;    --l_clob :&#61; REPLACE(l_clob, PKG_Global.GC_SPG_OPEN_SQ_BR , CHR(38) || &#39;#91;&#39;);&#10;    --l_clob :&#61; REPLACE(l_clob, PKG_Global.GC_SPG_CLOSE_SQ_BR, CHR(38) || &#39;#93;&#39;);&#10;    --&#10;    IF p_table_type &#61; &#39;M&#39; AND p_headers_and_trailers &#61; &#39;Y&#39; THEN&#10;        --&#10;        l_clob :&#61;&#10;            concat_CLOB(&#10;                &#39;&lt;?xml version&#61;&quot;1.0&quot; encoding&#61;&quot;UTF-8&quot;?&gt;&#39;,&#10;                &#39;&lt;SPGInterchange &#39; || get_xml_msg_root(p_xSQL &#61;&gt; &#39;N&#39;) || &#39;&gt;&#39;,&#10;                    &#39;&lt;SPGInterchangeHeader&gt;&#39;,&#10;                        REPLACE(get_xml_int_header(p_xSQL &#61;&gt; &#39;N&#39;), CHR(10), &#39;&#39;),&#10;                    &#39;&lt;/SPGInterchangeHeader&gt;&#39;,&#10;                    -- XML Message payload&#10;                    &#39;&lt;SPGMessage&gt;&#39;,&#10;                        l_clob,&#10;                    &#39;&lt;/SPGMessage&gt;&#39;,&#10;                    --&#10;                    &#39;&lt;SPGInterchangeTrailer&gt;&#39;,&#10;                        REPLACE(get_xml_int_trailer(p_xSQL &#61;&gt; &#39;N&#39;), CHR(10), &#39;&#39;),&#10;                    &#39;&lt;/SPGInterchangeTrailer&gt;&#39;,&#10;                &#39;&lt;/SPGInterchange&gt;&#39;,&#10;                --&#10;                p_delim &#61;&gt; &#39;&#39; );&#10;    END IF;&#10;    --&#10;    IF PKG_Debug.funcGetDebugActive THEN&#10;        procDebug( concat_CLOB( TO_CLOB(&#10;            &#39;PKG_Dyn_XML.get_gen_xml &#39; ||&#10;            &#39;(tab&#61;&#39;           || p_table                 || &#39;)&#39; ||&#10;            &#39;(tab_typ&#61;&#39;       || p_table_type            || &#39;)&#39; ||&#10;            &#39;(pk&#61;&#39;            || p_pk_value              || &#39;)&#39; ||&#10;            &#39;(off_id&#61;&#39;        || p_offender_id           || &#39;)&#39; ||&#10;            &#39;(max_rec_level&#61;&#39; || p_max_p_recursive_level || &#39;)&#39; ||&#10;            &#39;(inc_tab&#61;&#39;       || p_inc_tab_list          || &#39;)&#39; ||&#10;            &#39;(excl_tab&#61;&#39;      || p_excl_tab_list         || &#39;)&#39; ||&#10;            &#39;(msg_name&#61;&#39;      || p_compound_message_name || &#39;)&#39; ||&#10;            &#39;(msg_id&#61;&#39;        || l_xml_message_id        || &#39;)&#39; ||&#10;            &#39;(hdr&#61;&#39;           || p_headers_and_trailers  || &#39;)&#39; ),&#10;            l_SQL,&#10;            CASE WHEN l_SQL1 IS NOT NULL THEN CHR(10) || l_SQL1 END,&#10;            p_delim &#61;&gt; CHR(10) ),&#10;            p_trace_level&#61;&gt;1 );&#10;    END IF;&#10;    --&#10;    SPGMESSAGE.set_xml_offender_id    ( NULL );&#10;    SPGMESSAGE.set_xml_unique_id      ( NULL );&#10;    SPGMESSAGE.set_xml_msg_id         ( NULL );&#10;    SPGMessage.set_xml_target_provider( NULL );&#10;    --&#10;    RETURN l_clob;&#10;    --&#10;EXCEPTION WHEN NO_DATA_FOUND THEN&#10;    --&#10;    SPGMESSAGE.set_xml_offender_id    ( NULL );&#10;    SPGMESSAGE.set_xml_unique_id      ( NULL );&#10;    SPGMESSAGE.set_xml_msg_id         ( NULL );&#10;    SPGMessage.set_xml_target_provider( NULL );&#10;    --&#10;    RETURN NULL;&#10;WHEN OTHERS THEN&#10;    procDebug( concat_CLOB( TO_CLOB(&#10;        &#39;FATAL ERROR in PKG_Dyn_XML.get_gen_xml &#39; ||&#10;        &#39;(tab&#61;&#39;           || p_table                 || &#39;)&#39; ||&#10;        &#39;(tab_typ&#61;&#39;       || p_table_type            || &#39;)&#39; ||&#10;        &#39;(pk&#61;&#39;            || p_pk_value              || &#39;)&#39; ||&#10;        &#39;(off_id&#61;&#39;        || p_offender_id           || &#39;)&#39; ||&#10;        &#39;(max_rec_level&#61;&#39; || p_max_p_recursive_level || &#39;)&#39; ||&#10;        &#39;(inc_tab&#61;&#39;       || p_inc_tab_list          || &#39;)&#39; ||&#10;        &#39;(excl_tab&#61;&#39;      || p_excl_tab_list         || &#39;)&#39; ||&#10;        &#39;(msg_name&#61;&#39;      || p_compound_message_name || &#39;)&#39; ||&#10;        &#39;(msg_id&#61;&#39;        || l_xml_message_id        || &#39;)&#39; ||&#10;        &#39;(hdr&#61;&#39;           || p_headers_and_trailers  || &#39;)&#39; || CHR(10) ||&#10;        &#39;: &#39; || SQLERRM ),&#10;        l_SQL,&#10;        CASE WHEN l_SQL1 IS NOT NULL THEN CHR(10) || l_SQL1 END,&#10;        p_delim &#61;&gt; CHR(10) ),&#10;        p_trace_level&#61;&gt;0 );&#10;    --&#10;    SPGMESSAGE.set_xml_offender_id    ( NULL );&#10;    SPGMESSAGE.set_xml_unique_id      ( NULL );&#10;    SPGMESSAGE.set_xml_msg_id         ( NULL );&#10;    SPGMessage.set_xml_target_provider( NULL );&#10;    --&#10;    RAISE;&#10;END get_gen_xml;&#10;--&#10;FUNCTION get_gen_xml(&#10;    p_bi_code     VARCHAR2,&#10;    p_pk_value    NUMBER  DEFAULT -1,&#10;    p_offender_id NUMBER  DEFAULT -1,&#10;    --&#10;    p_control_reference       NUMBER   DEFAULT 99999999999999,&#10;    p_receiver_ctl_reference  VARCHAR2 DEFAULT NULL,&#10;    p_sender_identity         VARCHAR2 DEFAULT &#39;XXX&#39;,&#10;    p_receiver_identity       VARCHAR2 DEFAULT &#39;ZZZ&#39;,&#10;    p_application_reference   VARCHAR2 DEFAULT &#39;NDELIUS&#39;,&#10;    p_test_indicator          VARCHAR2 DEFAULT &#39;Y&#39;,&#10;    p_spg_notification_id     NUMBER  DEFAULT -1 )&#10;RETURN CLOB&#10;IS&#10;    --&#10;    l_schema_version  SPG_xsd.xsd_version%TYPE;&#10;    l_schema_date     SPG_xsd.xsd_date%TYPE;&#10;    l_schema_number   SPG_xsd.xsd_number%TYPE;&#10;    l_ret             CLOB;&#10;    --&#10;    CURSOR cs IS&#10;      SELECT&#10;        BI.business_interaction_code,&#10;        PKG_DynSQL.get_xml_view_name(bixm.root_xml_message_id) AS table_name,&#10;        BIXM.xml_message_name                                  AS message_name,&#10;        PKG_LstUtl.get_array_2_list(Pkg_LstUtl.get_list_2_array(BIXM.include_xml_message_list), p_iterator_function&#61;&gt;&#39;PKG_DynSQL.get_xml_view_name(:p_xml_msg_id)&#39;)  AS inc_tab_list,&#10;        PKG_LstUtl.get_array_2_list(Pkg_LstUtl.get_list_2_array(BIXM.exclude_xml_message_list), p_iterator_function&#61;&gt;&#39;PKG_DynSQL.get_xml_view_name(:p_xml_msg_id)&#39;)  AS excl_tab_list,&#10;        BIXM.data_update_mode,&#10;        BIXM.root_xml_message_id,&#10;        BIXM.include_xml_message_list&#10;      FROM&#10;        business_int_xml_map BIXM,&#10;        business_interaction BI&#10;      WHERE BI.business_interaction_id &#61; BIXM.business_interaction_id&#10;        AND BI.business_interaction_code &#61; p_bi_code&#10;        AND BIXM.xsd_number &#61; l_schema_number;&#10;    l_rec cs%ROWTYPE;&#10;    --&#10;BEGIN&#10;    -- SET G_xsd_NUMBER based on sender_identity&#10;    G_RECEIVER_IDENTITY     :&#61; NVL(p_receiver_identity, &#39;ZZZ&#39;);&#10;    l_schema_number :&#61; SPGCONFIG.get_xsd_number(p_probation_area_code &#61;&gt; G_RECEIVER_IDENTITY);&#10;    SELECT xsd_version, xsd_date INTO l_schema_version, l_schema_date&#10;    FROM spg_xsd&#10;    WHERE xsd_number &#61; l_schema_number;&#10;    --&#10;    SPGMESSAGE.GC_SCHEMA_VERSION  :&#61;  l_schema_version;&#10;    SPGMESSAGE.GC_SCHEMA_DATE     :&#61;  TO_CHAR(l_schema_date, &#39;YYYY-MM-DD&#39;);&#10;    SPGMESSAGE.GC_SCHEMA_NUMBER   :&#61;  l_schema_number;&#10;    --&#10;    --    raise_application_error(-20001, &#39;l_schema_version&#61;&#39; || l_schema_version || &#39; l_schema_date&#61;&#39; || l_schema_date || &#39;l_schema_number&#61;&#39; || l_schema_number );&#10;    OPEN cs;&#10;    FETCH cs INTO l_rec;&#10;    IF cs%NOTFOUND THEN&#10;        CLOSE cs;&#10;        raise_error(&#39;FATAL ERROR: no data found within BUSINESS_INT_XML_MAP table for [BI&#61;&#39; || p_bi_code || &#39;][xsd_number&#61;&#39; || l_schema_number || &#39;]&#39;, &#39;GET_GEN_XML&#39;);&#10;    END IF;&#10;    CLOSE cs;&#10;    --&#10;    G_CONTROL_REFERENCE     :&#61; NVL(p_control_reference, 99999999999999);&#10;    G_RECEIVER_CTL_REFERENCE  :&#61; p_receiver_ctl_reference;&#10;    G_SENDER_IDENTITY       :&#61; NVL(p_sender_identity, &#39;XXX&#39;);&#10;    G_APPLICATION_REFERENCE :&#61; NVL(p_application_reference, &#39;NDELIUS&#39;);&#10;    G_TEST_INDICATOR        :&#61; NVL(p_test_indicator, &#39;Y&#39;);&#10;    --G_TOP_MSG_UPD_MODE      :&#61; CASE WHEN l_rec.business_interaction_code IN (&#39;CABI020&#39;/*AllocateOffender*/) THEN &#39;Y&#39; ELSE &#39;N&#39; END;&#10;    --&#10;    IF l_rec.data_update_mode &#61; &#39;D&#39; THEN&#10;        l_ret :&#61; SPGMESSAGE.get_del_msg(&#10;                          spgnotificationid_in        &#61;&gt; p_spg_notification_id,&#10;                          senderidentity_in           &#61;&gt; G_SENDER_IDENTITY,&#10;                          receiveridentity_in         &#61;&gt; G_RECEIVER_IDENTITY,&#10;                          sendercontrolreference_in   &#61;&gt; G_CONTROL_REFERENCE,&#10;                          receivercontrolreference_in &#61;&gt; G_RECEIVER_CTL_REFERENCE,&#10;                          applicationreference_in     &#61;&gt; &#39;NDELIUS&#39;,&#10;                          messagetype_in              &#61;&gt; &#39;DEL&#39;,&#10;                          messagereferencenumber_in   &#61;&gt; 1,&#10;                          messagerecordidentifier_in  &#61;&gt; &#39;&#39;);&#10;    ELSE&#10;        l_ret :&#61;  PKG_DYN_XML.get_gen_xml(&#10;            p_table                 &#61;&gt; l_rec.table_name,&#10;            p_offender_id           &#61;&gt; p_offender_id,&#10;            p_pk_value              &#61;&gt; p_pk_value,&#10;            p_inc_tab_list          &#61;&gt; l_rec.inc_tab_list,&#10;            p_excl_tab_list         &#61;&gt; l_rec.excl_tab_list,&#10;            p_compound_message_name &#61;&gt; CASE WHEN TO_CHAR(l_rec.root_xml_message_id) &lt;&gt; l_rec.include_xml_message_list THEN l_rec.message_name END,&#10;            --CASE WHEN l_rec.data_update_mode IN (&#39;I&#39;,&#39;U&#39;,&#39;D&#39;) THEN NULL ELSE l_rec.message_name END,&#10;            p_update_mode           &#61;&gt; CASE WHEN p_receiver_ctl_reference IS NULL THEN l_rec.data_update_mode ELSE &#39;R&#39; END,&#10;            p_headers_and_trailers  &#61;&gt; &#39;Y&#39;,&#10;            p_target_provider       &#61;&gt; p_receiver_identity );&#10;    END IF;&#10;    --&#10;    l_ret :&#61; REPLACE(l_ret, &#39;.000000&lt;/TimeOfPreparation&gt;&#39;, &#39;&lt;/TimeOfPreparation&gt;&#39;);&#10;    --&#10;    RETURN l_ret;&#10;    --&#10;END get_gen_xml;&#10;--&#10;--&#10;--&#10;-- PLSQL package Initialisation block&#10;--&#10;BEGIN&#10;    --&#10;    PKG_Global.do_init;&#10;    --&#10;    do_init_vars;&#10;    --&#10;END PKG_DYN_XML;</textarea>
                        </div>
                    </div>
                </section>
            </div>
            <!-- /.content-wrapper -->
            <footer class="main-footer">
                <div>
                    <div class="pull-right hidden-xs">
                        <a href="https://github.com/schemaspy/schemaspy" title="GitHub for SchemaSpy"><i class="fa fa-github-square fa-2x"></i></a>
                        <a href="http://stackoverflow.com/questions/tagged/schemaspy" title="StackOverflow for SchemaSpy"><i class="fa fa-stack-overflow fa-2x"></i></a>
                    </div>
                    <strong>Generated by <a href="http://schemaspy.org/" class="logo-text"><i class="fa fa-database"></i> SchemaSpy 6.2.4</a></strong>
                </div>
                <!-- /.container -->
            </footer>
        </div>
        <!-- ./wrapper -->

        <!-- jQuery 2.2.3 -->
        <script src="../bower/admin-lte/plugins/jQuery/jquery-2.2.3.min.js"></script>
        <script src="../bower/admin-lte/plugins/jQueryUI/jquery-ui.min.js"></script>
        <!-- Bootstrap 3.3.5 -->
        <script src="../bower/admin-lte/bootstrap/js/bootstrap.min.js"></script>
        <!-- DataTables -->
        <script src="../bower/datatables.net/jquery.dataTables.min.js"></script>
        <script src="../bower/datatables.net-bs/js/dataTables.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/dataTables.buttons.min.js"></script>
        <script src="../bower/datatables.net-buttons-bs/js/buttons.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.html5.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.print.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.colVis.min.js"></script>
        <!-- SheetJS -->
        <script src="../bower/js-xlsx/xlsx.full.min.js"></script>
        <!-- pdfmake -->
        <script src="../bower/pdfmake/pdfmake.min.js"></script>
        <script src="../bower/pdfmake/vfs_fonts.js"></script>
        <!-- SlimScroll -->
        <script src="../bower/admin-lte/plugins/slimScroll/jquery.slimscroll.min.js"></script>
        <!-- FastClick -->
        <script src="../bower/admin-lte/plugins/fastclick/fastclick.js"></script>
        <!-- Salvattore -->
        <script src="../bower/salvattore/salvattore.min.js"></script>
        <!-- AnchorJS -->
        <script src="../bower/anchor-js/anchor.min.js"></script>
        <!-- CodeMirror -->
        <script src="../bower/codemirror/codemirror.js"></script>
        <script src="../bower/codemirror/sql.js"></script>
        <!-- AdminLTE App -->
        <script src="../bower/admin-lte/dist/js/app.min.js"></script>
        <script src="routine.js"></script>
        <script src="../schemaSpy.js"></script>
    </body>
</html>