<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>TSTNDA.DELIUS_APP_SCHEMA</title>
        <!-- Tell the browser to be responsive to screen width -->
        <meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport">
        <link rel="icon" type="image/png" sizes="16x16" href="../favicon.png">
        <!-- Bootstrap 3.3.5 -->
        <link rel="stylesheet" href="../bower/admin-lte/bootstrap/css/bootstrap.min.css">
        <!-- Font Awesome -->
        <link rel="stylesheet" href="../bower/font-awesome/css/font-awesome.min.css">
        <!-- Ionicons -->
        <link rel="stylesheet" href="../bower/ionicons/css/ionicons.min.css">
        <!-- DataTables -->
        <link rel="stylesheet" href="../bower/datatables.net-bs/css/dataTables.bootstrap.min.css">
        <link rel="stylesheet" href="../bower/datatables.net-buttons-bs/css/buttons.bootstrap.min.css">
        <!-- Code Mirror -->
        <link rel="stylesheet" href="../bower/codemirror/codemirror.css">
        <!-- Fonts -->
        <link href='../fonts/indieflower/indie-flower.css' rel='stylesheet' type='text/css'>
        <link href='../fonts/source-sans-pro/source-sans-pro.css' rel='stylesheet' type='text/css'>

        <!-- Theme style -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/AdminLTE.min.css">
        <!-- Salvattore -->
        <link rel="stylesheet" href="../bower/salvattore/salvattore.css">
        <!-- AdminLTE Skins. Choose a skin from the css/skins
           folder instead of downloading all of them to reduce the load. -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/skins/_all-skins.min.css">
        <!-- SchemaSpy -->
        <link rel="stylesheet" href="../schemaSpy.css">

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
        <script src="../bower/html5shiv/html5shiv.min.js"></script>
        <script src="../bower/respond/respond.min.js"></script>
        <![endif]-->
    </head>
    <!-- ADD THE CLASS layout-top-nav TO REMOVE THE SIDEBAR. -->
    <body class="hold-transition skin-blue layout-top-nav">
        <div class="wrapper">
            <header class="main-header">
                <nav class="navbar navbar-static-top">
                    <div class="container">
                        <div class="navbar-header">
                            <a href="../index.html" class="navbar-brand"><b>TSTNDA</b></a><span class="navbar-brand" style="padding-left: 0">.DELIUS_APP_SCHEMA</span>
                            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse"><i class="fa fa-bars"></i></button>
                        </div>

                        <!-- Collect the nav links, forms, and other content for toggling -->
                        <div class="collapse navbar-collapse pull-left" id="navbar-collapse">
                            <ul class="nav navbar-nav">
                                <li><a href="../index.html">Tables <span class="sr-only">(current)</span></a></li>
                                <li><a href="../columns.html" title="All of the columns in the schema">Columns</a></li>
                                <li><a href="../constraints.html" title="Useful for diagnosing error messages that just give constraint name or number">Constraints</a></li>
                                <li><a href="../relationships.html" title="Diagram of table relationships">Relationships</a></li>
                                <li><a href="../orphans.html" title="View of tables with neither parents nor children">Orphan&nbsp;Tables</a></li>
                                <li><a href="../anomalies.html" title="Things that might not be quite right">Anomalies</a></li>
                                <li><a href="../routines.html" title="Procedures and functions">Routines</a></li>
                            </ul>
                        </div>
                        <!-- /.navbar-collapse -->
                        <!-- Navbar Right Menu -->
                    </div>
                    <!-- /.container-fluid -->
                </nav>
            </header>
            <!-- Main content -->
            <!-- Full Width Column -->
            <div class="content-wrapper">
                <!-- Content Header (Page header) -->
                <section class="content-header">
                    <h1>DELIUS_APP_SCHEMA.PKG_SPG_SUPPORT</h1><br />
                </section>
                <!-- Main content -->
                <section class="content">
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <span class="glyphicon glyphicon-list-alt" aria-hidden="true"></span>
                            <h3 id="Columns" class="box-title">Parameters</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <table id="standard_table" class="table table-bordered table-striped dataTable" role="grid">
                                <thead align='left'>
                                <tr>
                                    <th>Name</th>
                                    <th>Type</th>
                                    <th>Mode</th>
                                </tr>
                                </thead>
                                <tbody>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <i class="fa fa-file-code-o"></i>
                            <h3 id="RoutineDefinition" class="box-title">Definition</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <textarea id="sql-script-codemirror" name="sql-script-codemirror" rows="" style="display: none;">PACKAGE BODY PKG_SPG_SUPPORT&#10;AS&#10;--&#10;--&#10;--&#10;--&#10;    g_package_version CONSTANT VARCHAR2(30) :&#61; GC_VERSION;&#10;    g_component_code  CONSTANT VARCHAR2(3)  :&#61; &#39;SPG&#39;;&#10;    g_package_name    CONSTANT VARCHAR2(30) :&#61; &#39;PKG_SPG_SUPPORT&#39;;&#10;    g_instance_id     INTEGER :&#61; 0;&#10;    --&#10;    g_procedure_name  VARCHAR2(30)  :&#61; &#39;initial_value&#39;;&#10;    g_label           VARCHAR2(6)   :&#61; &#39;000000&#39;;&#10;    g_pdm             NUMBER;&#10;    g_unit_test       BOOLEAN       :&#61; FALSE;&#10;    --&#10;    G_TRACE_LEVEL CONSTANT INTEGER :&#61; 20;&#10;    --&#10;    -- message type&#10;    mt_information    CONSTANT NUMBER :&#61; 1;&#10;    mt_warning        CONSTANT NUMBER :&#61; 2;&#10;    mt_error          CONSTANT NUMBER :&#61; 3;&#10;    mt_fatal_error    CONSTANT NUMBER :&#61; 4;&#10;    --&#10;    g_rpt_TAB t_rpt_TAB_TYP;&#10;    --&#10;    G_TAB_CACHE_INIT_FLAG   BOOLEAN :&#61; FALSE;&#10;    G_SYSTEM_USER_DN        CONSTANT USER_.distinguished_name%TYPE :&#61; &#39;DELIUS_SYSTEM_USER&#39;;&#10;    --&#10;    g_spg_version_TAB        g_spg_version_tab_TYP :&#61; g_spg_version_tab_TYP();&#10;    --&#10;    TYPE g_rec_deferred_TYP IS RECORD(&#10;      source_table_name   VARCHAR2(30),&#10;      source_action_flag  VARCHAR2(1),&#10;      xml_view_name       VARCHAR2(30),&#10;      link_col_name       VARCHAR2(30),&#10;      search_by_key       VARCHAR2(200) );&#10;    --&#10;    TYPE g_tab_deferred_TYP     IS TABLE OF g_rec_deferred_TYP;&#10;    TYPE g_tab_deferred_ALL_TYP IS TABLE OF g_tab_deferred_TYP INDEX BY VARCHAR(100);&#10;    g_tab_deferred  g_tab_deferred_ALL_TYP;&#10;    --&#10;    pending_allocations   t_tab_ORGANISATIONS :&#61; t_tab_ORGANISATIONS();&#10;&#10;--&#10;--&#10;FUNCTION get_version RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN GC_VERSION;&#10;END get_version;&#10;&#10;&#10;--***************************************************&#10;--                                                  *&#10;-- PKG_COMMON wrappers                              *&#10;--                                                  *&#10;--***************************************************&#10;PROCEDURE procDebug(p_msg CLOB, p_trace_level INTEGER DEFAULT 15, p_print_flag VARCHAR2 DEFAULT &#39;N&#39;) IS&#10;BEGIN&#10;    IF NVL(p_trace_level, 15) &lt;&#61; G_TRACE_LEVEL THEN&#10;        PKG_Debug.procDebug(p_msg, p_print_flag);&#10;    END IF;&#10;END procDebug;&#10;--&#10;PROCEDURE message(p_msg VARCHAR2, p_trace_level INTEGER DEFAULT 15) IS&#10;BEGIN&#10;    procDebug(&#39;[&#39; || g_label || &#39;] &#39; || p_msg, p_trace_level&#61;&gt;p_trace_level, p_print_flag &#61;&gt; &#39;N&#39;);&#10;END message;&#10;--&#10;FUNCTION is_str_empty(p_str VARCHAR2, p_ignore_spaces_and_zeroes VARCHAR2 DEFAULT &#39;N&#39;) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.is_str_empty( p_str, p_ignore_spaces_and_zeroes );&#10;END is_str_empty;&#10;--&#10;FUNCTION empty2null(p_str VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.empty2null(p_str);&#10;END empty2null;&#10;&#10;FUNCTION nvlstr(p_str1 VARCHAR2, p_str2 VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.NVLSTR(p_str1, p_str2);&#10;END nvlstr;&#10;--&#10;PROCEDURE raise_error(p_err_msg VARCHAR2, p_proc VARCHAR2, p_label VARCHAR2 DEFAULT &#39;&#39;) IS&#10;BEGIN&#10;    procDebug(&#10;        p_proc || &#39; FAILED. [Step: &#39; || PKG_Common.nvl2(p_label, g_label, &#39;N/A&#39;) || &#39;]&#39; ||&#10;        --&#39;[&#39; || DBMS_UTILITY.format_error_backtrace || &#39;]: &#39; ||&#10;        &#39;[&#39; || DBMS_UTILITY.format_call_stack || &#39;]: &#39; ||&#10;        p_err_msg,&#10;        p_trace_level&#61;&gt; 0,&#10;        p_print_flag &#61;&gt; &#39;Y&#39; );&#10;    PKG_Common.raise_error( p_err_msg, p_proc, p_label );&#10;END raise_error;&#10;--&#10;--&#10;--***************************************************&#10;-- Helpers                                          *&#10;--***************************************************&#10;--&#10;-- Used to populate mtt_message_log with information type message&#10;PROCEDURE info (message_in VARCHAR2)&#10;IS&#10;BEGIN&#10;  IF SPGConfig.SPGInfoActive THEN&#10;    SPGConfig.insert_message_log( message_type_id_in  &#61;&gt; mt_information,&#10;                                  component_code_in   &#61;&gt; g_component_code,&#10;                                  package_name_in     &#61;&gt; g_package_name,&#10;                                  procedure_name_in   &#61;&gt; g_procedure_name,&#10;                                  label_in            &#61;&gt; g_label,&#10;                                  message_text_in     &#61;&gt; message_in);&#10;  END IF;&#10;END info;&#10;--&#10;-- Will populate mtt_message_log with warning message - will populate mtt_error_log if result of exception&#10;PROCEDURE warn (message_in VARCHAR2)&#10;IS&#10;BEGIN&#10;  IF SPGConfig.SPGWarnActive THEN&#10;    SPGConfig.record_error( message_type_id_in    &#61;&gt; mt_warning,&#10;                            component_code_in     &#61;&gt; g_component_code,&#10;                            package_name_in       &#61;&gt; g_package_name,&#10;                            procedure_name_in     &#61;&gt; g_procedure_name,&#10;                            label_in              &#61;&gt; g_label,&#10;                            message_text_in       &#61;&gt; message_in);&#10;  END IF;&#10;END warn;&#10;--&#10;-- Will populate mtt_message_log with error message and populate mtt_error_log with exception - used for log and continue&#10;PROCEDURE error (message_in VARCHAR2)&#10;IS&#10;BEGIN&#10;  SPGConfig.record_error( message_type_id_in    &#61;&gt; mt_error,&#10;                          component_code_in     &#61;&gt; g_component_code,&#10;                          package_name_in       &#61;&gt; g_package_name,&#10;                          procedure_name_in     &#61;&gt; g_procedure_name,&#10;                          label_in              &#61;&gt; g_label,&#10;                          message_text_in       &#61;&gt; message_in);&#10;END error;&#10;--&#10;-- Will populate mtt_message_log, mtt_error_log with error message and raise exception - used for log and halt&#10;PROCEDURE fatal (message_in VARCHAR2)&#10;IS&#10;BEGIN&#10;  SPGConfig.record_error( message_type_id_in    &#61;&gt; mt_fatal_error,&#10;                          component_code_in     &#61;&gt; g_component_code,&#10;                          package_name_in       &#61;&gt; g_package_name,&#10;                          procedure_name_in     &#61;&gt; g_procedure_name,&#10;                          label_in              &#61;&gt; g_label,&#10;                          message_text_in       &#61;&gt; message_in,&#10;                          raise_error_in        &#61;&gt; TRUE);&#10;END fatal;&#10;--&#10;--&#10;PROCEDURE do_init_tab_info IS&#10;BEGIN&#10;    IF NOT G_TAB_CACHE_INIT_FLAG THEN&#10;        PKG_DynSQL.init_tab_info(p_reset_flag &#61;&gt; &#39;Y&#39;);&#10;        G_TAB_CACHE_INIT_FLAG :&#61; TRUE;&#10;    END IF;&#10;END do_init_tab_info;&#10;--&#10;PROCEDURE do_init_vars IS&#10;BEGIN&#10;    G_TAB_CACHE_INIT_FLAG :&#61; FALSE;&#10;    --do_init_tab_info;&#10;END do_init_vars;&#10;--&#10;&#10;/*&#10;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#10;  DYNAMIC XML_MSG_*_V database views generation&#10;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#10;*/&#10;FUNCTION get_parsed_fld_lst(&#10;    p_table               VARCHAR2,&#10;    p_cr_view_mode        VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_src_tab_prefix_flag VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_delim               VARCHAR2 DEFAULT &#39;,&#39;,&#10;    p_source_tables       VARCHAR2 DEFAULT NULL,&#10;    p_update_mode         VARCHAR2 DEFAULT &#39;I&#39; )&#10;RETURN VARCHAR2&#10;IS&#10;    --&#10;    l_proc CONSTANT VARCHAR(100) :&#61; UPPER(&#39;get_parsed_fld_lst&#39;);&#10;    --&#10;    l_resolve_lup_flag      VARCHAR2(1);&#10;    l_use_fld_owner_flag    VARCHAR2(1);&#10;    l_use_aliases_flag      VARCHAR2(1);&#10;    l_change_col_case_flag  VARCHAR2(1);&#10;    --&#10;    l_lst           VARCHAR2(32767);&#10;    l_ret           VARCHAR2(32767);&#10;    l_elem          VARCHAR2(255);&#10;    l_fld_name      VARCHAR2(100);&#10;    l_fld_name1     VARCHAR2(100);&#10;    l_fld_name2     VARCHAR2(100);&#10;    l_fld_owner     VARCHAR2(100);&#10;    l_fld_alias     VARCHAR2(100);&#10;    l_ref_table     VARCHAR2(1024);&#10;    l_ref_key_fld   VARCHAR2(30);&#10;    l_ref_lup_fld   VARCHAR2(1024);&#10;    l_ret_fld       VARCHAR2(8192);&#10;    l_ret_fld_U     VARCHAR2(8192);&#10;    l_where         VARCHAR2(8192);&#10;    l_bind1         VARCHAR2(255);&#10;    --&#10;    l_xsd_data_type VARCHAR2(100);&#10;    --&#10;    TYPE l_tab_TYP IS TABLE OF INTEGER INDEX BY VARCHAR2(100);&#10;    l_tab l_tab_TYP;&#10;    --&#10;    l_source_table_LST VARCHAR2(4096);&#10;    l_source_table     VARCHAR2(30);&#10;    l_pk_key           VARCHAR2(200);&#10;    --&#10;BEGIN&#10;    --&#10;    IF NVLSTR(p_cr_view_mode, &#39;N&#39;) &#61; &#39;Y&#39; THEN&#10;        l_resolve_lup_flag     :&#61; &#39;N&#39;;&#10;        l_use_fld_owner_flag   :&#61; &#39;Y&#39;;&#10;        l_use_aliases_flag     :&#61; &#39;N&#39;;&#10;        l_change_col_case_flag :&#61; &#39;Y&#39;;&#10;    ELSE&#10;        l_resolve_lup_flag     :&#61; &#39;Y&#39;;&#10;        l_use_fld_owner_flag   :&#61; &#39;N&#39;;&#10;        l_use_aliases_flag     :&#61; &#39;Y&#39;;&#10;        l_change_col_case_flag :&#61; &#39;Y&#39;;&#10;    END IF;&#10;    --&#10;    BEGIN&#10;        do_init_tab_info;&#10;        IF p_update_mode &#61; &#39;D&#39; THEN&#10;            l_lst :&#61; PKG_DynSQL.get_tab_fld_lst_1(p_table);&#10;        ELSE&#10;            l_lst :&#61; PKG_DynSQL.get_tab_fld_lst(p_table);&#10;        END IF;&#10;    EXCEPTION WHEN OTHERS THEN&#10;        raise_application_error(-20001,&#10;            &#39;ERROR in PKG_DYN_XML.get_parsed_fld_lst(p_table&#61;&#39; || p_table || &#39;): &#39; || SQLERRM || CHR(10) ||&#10;            &#39;[&#39; || DBMS_UTILITY.format_error_backtrace || &#39;]&#39; );&#10;    END;&#10;    --&#10;    g_label :&#61; &#39;0100&#39;;&#10;    IF PKG_Debug.funcGetDebugActive THEN&#10;        message(l_proc || &#39;: [fld_lst&#61;&#39; || l_lst || &#39;]&#39;, p_trace_level&#61;&gt;10);&#10;    END IF;&#10;    --&#10;    LOOP&#10;        l_elem :&#61; REPLACE(PKG_LstUtl.list_next_elem(l_lst, &#39;,&#39;), &#39;#|#&#39;, &#39;,&#39;);&#10;        EXIT WHEN EMPTY2NULL(l_elem) IS NULL AND EMPTY2NULL(l_lst) IS NULL;&#10;        --&#10;        g_label :&#61; &#39;0110&#39;;&#10;        IF PKG_Debug.funcGetDebugActive THEN&#10;            message(l_proc || &#39;: [elem&#61;&#39; || l_elem || &#39;]&#39;, p_trace_level&#61;&gt;15);&#10;        END IF;&#10;        --&#10;        l_fld_name      :&#61; NULL;&#10;        l_fld_name1     :&#61; NULL;&#10;        l_fld_name2     :&#61; NULL;&#10;        l_fld_owner     :&#61; NULL;&#10;        l_fld_alias     :&#61; NULL;&#10;        l_ref_table     :&#61; NULL;&#10;        l_ref_key_fld   :&#61; NULL;&#10;        l_ref_lup_fld   :&#61; NULL;&#10;        l_ret_fld       :&#61; NULL;&#10;        l_ret_fld_U     :&#61; NULL;&#10;        l_where         :&#61; NULL;&#10;        l_bind1         :&#61; NULL;&#10;        --&#10;        IF l_elem LIKE &#39;% AS %&#39; THEN&#10;            l_fld_alias :&#61; TRIM(PKG_LstUtl.list_last_elem(l_elem, &#39; AS &#39;));&#10;        END IF;&#10;        --&#10;        IF l_elem LIKE &#39;%.%&#39; THEN&#10;            l_fld_owner :&#61; UPPER(TRIM(PKG_LstUtl.list_next_elem(l_elem, &#39;.&#39;)));&#10;        END IF;&#10;        --&#10;        IF l_elem LIKE &#39;%:%&#39; THEN&#10;            l_fld_name :&#61; UPPER(TRIM(PKG_LstUtl.list_next_elem(l_elem, &#39;:&#39;)));&#10;        ELSE&#10;            l_fld_name :&#61; l_elem;&#10;            l_elem :&#61; NULL;&#10;        END IF;&#10;        --&#10;        g_label :&#61; &#39;0120&#39;;&#10;        IF PKG_Debug.funcGetDebugActive THEN&#10;            message(l_proc || &#39;: [f_alias&#61;&#39; || l_fld_alias || &#39;][f_owner&#61;&#39; || l_fld_owner || &#39;][f_name&#61;&#39; || l_fld_name || &#39;]&#39;, p_trace_level&#61;&gt;15);&#10;        END IF;&#10;        --&#10;        IF EMPTY2NULL(l_elem) IS NOT NULL AND l_resolve_lup_flag &#61; &#39;Y&#39; THEN&#10;            IF INSTR(l_elem, &#39;:&#39;) &gt; 0 THEN&#10;                l_ref_table   :&#61; PKG_LstUtl.list_next_elem(l_elem, &#39;:&#39;);&#10;                l_ref_lup_fld :&#61; l_elem;&#10;            ELSE&#10;                l_ref_table   :&#61; l_elem;&#10;                l_ref_lup_fld :&#61; NULL;&#10;            END IF;&#10;            l_ref_table :&#61; UPPER(l_ref_table);&#10;            l_where :&#61; &#39;&#39;;&#10;            --&#10;            g_label :&#61; &#39;0130&#39;;&#10;            IF PKG_Debug.funcGetDebugActive THEN&#10;                message(l_proc || &#39;: [f_ref_tab&#61;&#39; || l_ref_table || &#39;][f_lup_fld&#61;&#39; || l_ref_lup_fld || &#39;]&#39;, p_trace_level&#61;&gt;15);&#10;            END IF;&#10;            --&#10;            IF RTRIM(l_ref_table, &#39;?&#39;) IN ( &#39;STDREF_CODE&#39;, &#39;STD_REF_CODE&#39;) THEN&#10;                g_label :&#61; &#39;0140&#39;;&#10;                l_ref_table   :&#61; &#39;R_STANDARD_REFERENCE_LIST&#39;;&#10;                l_ref_key_fld :&#61; &#39;standard_reference_list_id&#39;;&#10;                l_ref_lup_fld :&#61; NVLSTR(l_ref_lup_fld, &#39;code_value&#39;);&#10;            ELSIF RTRIM(l_ref_table, &#39;?&#39;) IN ( &#39;STDREF_DESC&#39;, &#39;STD_REF_DESC&#39;) THEN&#10;                g_label :&#61; &#39;0145&#39;;&#10;                l_ref_table   :&#61; &#39;R_STANDARD_REFERENCE_LIST&#39;;&#10;                l_ref_key_fld :&#61; &#39;standard_reference_list_id&#39;;&#10;                l_ref_lup_fld :&#61; NVLSTR(l_ref_lup_fld, &#39;code_description&#39;);&#10;            ELSIF RTRIM(l_ref_table, &#39;_&#39;) IN ( &#39;USER&#39;, &#39;USER.CODE&#39;) THEN&#10;                g_label :&#61; &#39;0150&#39;;&#10;                l_ref_table   :&#61; &#39;USER_&#39;;&#10;                l_ref_key_fld :&#61; &#39;user_id&#39;;&#10;                IF UPPER(l_ref_lup_fld) IN ( &#39;NAME&#39; ) THEN&#10;                    l_ref_lup_fld :&#61; &#39;PKG_LstUtl.concat(TRIM(surname), TRIM(forename), p_delim&#61;&gt;&#39;&#39;,&#39;&#39;)&#39;;&#10;                END IF;&#10;                l_ref_lup_fld :&#61; NVLSTR(l_ref_lup_fld, &#39;distinguished_name&#39;);&#10;            ELSIF l_ref_table &#61; &#39;TEAM&#39; THEN&#10;                g_label :&#61; &#39;0160&#39;;&#10;                IF UPPER(l_ref_lup_fld) &#61; &#39;PROBATION_AREA:CODE&#39; THEN&#10;                    g_label :&#61; &#39;0170&#39;;&#10;                    l_ref_key_fld :&#61; &#39;team_id&#39;;&#10;                    l_ref_lup_fld :&#61; &#39;PA.code&#39;;&#10;                    l_ref_table :&#61; &#39;TEAM T, PROBATION_AREA PA&#39;;&#10;                    l_where :&#61; &#39;PA.probation_area_id &#61; T.probation_area_id&#39;;&#10;                ELSE&#10;                    --l_ref_table   :&#61; &#39;TEAM&#39;;&#10;                    l_ref_key_fld :&#61; &#39;team_id&#39;;&#10;                    l_ref_lup_fld :&#61; NVLSTR(l_ref_lup_fld, &#39;code&#39;);&#10;                END IF;&#10;            ELSIF l_ref_table &#61; &#39;ALL_TEAM&#39; THEN&#10;                g_label :&#61; &#39;0180&#39;;&#10;                IF UPPER(l_ref_lup_fld) &#61; &#39;PROBATION_AREA:CODE&#39; THEN&#10;                    g_label :&#61; &#39;0190&#39;;&#10;                    l_ref_key_fld :&#61; &#39;trust_provider_flag&#39;;&#10;                    l_ref_lup_fld :&#61; &#39;PA.code&#39;;&#10;                    l_ref_table :&#61; &#39;ALL_TEAM T, PROBATION_AREA PA&#39;;&#10;                    l_fld_name1 :&#61; PKG_LstUtl.list_next_elem(l_fld_name, &#39;/&#39;);&#10;                    l_fld_name2 :&#61; l_fld_name;&#10;                    --&#10;                    l_fld_name  :&#61; &#39;(CASE WHEN &#39; || l_fld_name1 || &#39; IS NOT NULL THEN 0 ELSE 1 END)&#39;;&#10;                    l_where     :&#61; &#39;PA.probation_area_id &#61; T.probation_area_id AND T.trust_provider_team_id &#61; :p_trust_provider_team_id&#39;;&#10;                    l_bind1     :&#61; &#39;NVL(&#39; || l_fld_name1 || &#39;, &#39; || l_fld_name2 || &#39;)&#39;;&#10;                ELSE&#10;                    --l_ref_table   :&#61; &#39;TEAM&#39;;&#10;                    l_ref_key_fld :&#61; &#39;trust_provider_flag&#39;;&#10;                    l_ref_lup_fld :&#61; &#39;PKG_DYN_XML.get_team_or_provider_record(trust_provider_flag, trust_provider_team_id, &#39;&#39;&#39; || NVLSTR(l_ref_lup_fld, &#39;CODE&#39;) || &#39;&#39;&#39;)&#39;;&#10;                    l_fld_name1 :&#61; PKG_LstUtl.list_next_elem(l_fld_name, &#39;/&#39;);&#10;                    l_fld_name2 :&#61; l_fld_name;&#10;                    --&#10;                    l_fld_name  :&#61; &#39;(CASE WHEN &#39; || l_fld_name1 || &#39; IS NOT NULL THEN 0 ELSE 1 END)&#39;;&#10;                    l_where     :&#61; &#39;trust_provider_team_id &#61; :p_trust_provider_team_id&#39;;&#10;                    l_bind1     :&#61; &#39;NVL(&#39; || l_fld_name1 || &#39;, &#39; || l_fld_name2 || &#39;)&#39;;&#10;                    --&#10;                END IF;&#10;            ELSIF l_ref_table &#61; &#39;STAFF&#39; THEN&#10;                 g_label :&#61; &#39;0200&#39;;&#10;                --l_ref_table   :&#61; &#39;STAFF&#39;;&#10;                l_ref_key_fld :&#61; &#39;staff_id&#39;;&#10;                l_ref_lup_fld :&#61; NVLSTR(l_ref_lup_fld, &#39;officer_code&#39;);&#10;            ELSIF l_ref_table &#61; &#39;OFFICER&#39; THEN&#10;                 g_label :&#61; &#39;0210&#39;;&#10;                --l_ref_table   :&#61; &#39;OFFICER&#39;;&#10;                l_ref_key_fld :&#61; &#39;trust_provider_flag&#39;;&#10;                l_ref_lup_fld :&#61; &#39;PKG_DYN_XML.get_staff_or_provider_record(trust_provider_flag, staff_employee_id, &#39;&#39;&#39; || NVLSTR(l_ref_lup_fld, &#39;OFFICER_CODE|CODE&#39;) || &#39;&#39;&#39;)&#39;;&#10;                l_fld_name1 :&#61; PKG_LstUtl.list_next_elem(l_fld_name, &#39;/&#39;);&#10;                l_fld_name2 :&#61; l_fld_name;&#10;                --&#10;                l_fld_name  :&#61; &#39;(CASE WHEN &#39; || l_fld_name1 || &#39; IS NOT NULL THEN 0 ELSE 1 END)&#39;;&#10;                l_where     :&#61; &#39;staff_employee_id &#61; :p_staff_employee_id&#39;;&#10;                l_bind1     :&#61; &#39;NVL(&#39; || l_fld_name1 || &#39;, &#39; || l_fld_name2 || &#39;)&#39;;&#10;                --&#10;            ELSIF l_ref_lup_fld LIKE &#39;%:STDREF_CODE&#39; THEN&#10;                g_label :&#61; &#39;0215&#39;;&#10;                l_ref_key_fld :&#61; PKG_DynSQL.get_tab_pk_fld_lst(l_ref_table);&#10;                l_ref_table   :&#61; l_ref_table || &#39; T, R_STANDARD_REFERENCE_LIST STDREF&#39;;&#10;                l_where       :&#61; &#39;STDREF.standard_reference_list_id &#61; T.&#39; || PKG_LstUtl.list_num_elem(l_ref_lup_fld, &#39;:&#39;, 1);&#10;                l_ref_lup_fld :&#61; &#39;STDREF.code_value&#39;;&#10;            ELSE&#10;                g_label :&#61; &#39;0220&#39;;&#10;                do_init_tab_info;&#10;                --&#10;                IF INSTR(l_ref_table, &#39;.&#39;) &gt; 0 THEN&#10;                    -- An example: OFFLOC PRISON_CODE:R_INSTITUTION.NOMIS_CDE_CODE:CODE&#10;                    --   meaning: find matching record within R_INSTITUTION where CODE&#61;OFFLOC.prison_code&#10;                    --            return R_INSTITUTION.nomis_cde_code&#10;                    l_ref_key_fld :&#61; PKG_LstUtl.list_last_elem(l_ref_table, &#39;.&#39;);&#10;                ELSE&#10;                    l_ref_key_fld :&#61; PKG_DynSQL.get_tab_pk_fld_lst(l_ref_table);&#10;                END IF;&#10;                --&#10;                l_ref_lup_fld :&#61; NVLSTR(l_ref_lup_fld, &#39;code&#39;);&#10;                IF UPPER(l_ref_lup_fld) LIKE &#39;%:STDREF_CODE&#39; THEN&#10;                    l_ref_lup_fld :&#61; &#39;PKG_Lookups.funcgetTabRecord_CACHED(p_table &#61;&gt;&#39;&#39;R_STANDARD_REFERENCE_LIST&#39;&#39;, p_data_fld&#61;&gt;&#39;&#39;CODE_VALUE&#39;&#39;, p_ref_col&#61;&gt;&#39;&#39;STANDARD_REFERENCE_LIST_ID&#39;&#39;, p_ref_val&#61;&gt;TO_CHAR(&#39; || PKG_LstUtl.list_num_elem(l_ref_lup_fld, &#39;:&#39;, 1) || &#39;))&#39;;&#10;                END IF;&#10;                --&#10;            END IF;&#10;            --&#10;            g_label :&#61; &#39;0300&#39;;&#10;            IF PKG_Debug.funcGetDebugActive THEN&#10;                message(l_proc || &#39;: [f_ref_key_fld&#61;&#39; || l_ref_key_fld || &#39;][f_ref_lup_fld&#61;&#39; || l_ref_lup_fld || &#39;][f_name&#61;&#39; || l_fld_name || &#39;][f_name1&#61;&#39; || l_fld_name1 || &#39;][f_name2&#61;&#39; || l_fld_name2 || &#39;][where&#61;&#39; || l_where || &#39;][bind_var1&#61;&#39; || l_bind1 || &#39;]&#39;, p_trace_level&#61;&gt;15);&#10;            END IF;&#10;            --&#10;            l_ret_fld :&#61;&#10;                &#39;PKG_Lookups.funcgetTabRecord_CACHED( &#39; ||&#10;                --&#10;                PKG_LstUtl.concat(&#10;                        &#39;p_table&#61;&gt;&#39;&#39;&#39;           || l_ref_table    || &#39;&#39;&#39;&#39;,&#10;                        &#39;p_data_fld&#61;&gt;&#39;&#39;&#39;        || REPLACE(l_ref_lup_fld, &#39;&#39;&#39;&#39;, &#39;&#39;&#39;&#39;&#39;&#39;)  || &#39;&#39;&#39;&#39;,&#10;                        &#39;p_ref_col&#61;&gt;&#39;&#39;&#39;         || l_ref_key_fld  || &#39;&#39;&#39;&#39;,&#10;                        &#39;p_ref_val&#61;&gt;TO_CHAR(&#39;   || l_fld_name     || &#39;)&#39;,&#10;                        CASE WHEN EMPTY2NULL(l_where) IS NOT NULL THEN &#39;p_where&#61;&gt;&#39;&#39;&#39; || l_where || &#39;&#39;&#39;&#39;          END,&#10;                        CASE WHEN EMPTY2NULL(l_bind1) IS NOT NULL THEN &#39;p_bind_var1&#61;&gt;TO_CHAR(&#39; || l_bind1 || &#39;)&#39; END,&#10;                    --&#10;                    p_delim &#61;&gt; &#39;, &#39; )&#10;                --&#10;                || &#39; )&#39;;&#10;            --&#10;            IF l_use_aliases_flag &#61; &#39;Y&#39; AND EMPTY2NULL(l_fld_alias) IS NOT NULL THEN&#10;                l_ret_fld :&#61; l_ret_fld || &#39; AS &#39; || l_fld_alias;&#10;            END IF;&#10;            --&#10;            l_ret :&#61;&#10;                PKG_LstUtl.concat(&#10;                    l_ret,&#10;                    PKG_LstUtl.add_prefix((CASE WHEN p_src_tab_prefix_flag &#61; &#39;Y&#39; THEN UPPER(l_fld_owner) || &#39;#&#39; ELSE NULL END), l_ret_fld),&#10;                    p_delim&#61;&gt;NVLSTR(p_delim, &#39;, &#39;), p_max_len&#61;&gt;32767 );&#10;            --&#10;        ELSE&#10;            --&#10;            g_label :&#61; &#39;0300&#39;;&#10;            --&#10;            LOOP&#10;                l_ret_fld_U :&#61; TRIM(PKG_LstUtl.list_next_elem(l_fld_name, &#39;/&#39;));&#10;                --&#10;                IF l_change_col_case_flag &#61; &#39;Y&#39; THEN&#10;                    l_ret_fld_U :&#61; UPPER(l_ret_fld_U);&#10;                    l_ret_fld   :&#61; LOWER(l_ret_fld_U);&#10;                ELSE&#10;                    l_ret_fld   :&#61; l_ret_fld_U;&#10;                END IF;&#10;                --&#10;                l_fld_name :&#61; TRIM(l_fld_name);&#10;                EXIT WHEN EMPTY2NULL(l_ret_fld) IS NULL AND EMPTY2NULL(l_fld_name) IS NULL;&#10;                --&#10;                IF p_cr_view_mode &#61; &#39;N&#39; THEN&#10;                    IF l_tab.EXISTS(l_ret_fld_U) THEN&#10;                        l_tab(l_ret_fld_U) :&#61; l_tab(l_ret_fld_U) + 1;&#10;                    ELSE&#10;                        l_tab(l_ret_fld_U) :&#61; 1;&#10;                    END IF;&#10;                    IF l_tab(l_ret_fld_U) &gt; 1 THEN&#10;                        l_ret_fld :&#61; SUBSTR(l_ret_fld, 1, 28) || TO_CHAR(l_tab(l_ret_fld_U));&#10;                    END IF;&#10;                END IF;&#10;                --&#10;                IF l_use_fld_owner_flag &#61; &#39;Y&#39; AND EMPTY2NULL(l_fld_owner) IS NOT NULL THEN&#10;                    l_ret_fld :&#61; UPPER(l_fld_owner) || &#39;.&#39; || l_ret_fld;&#10;                END IF;&#10;                --&#10;                IF p_cr_view_mode &#61; &#39;N&#39; AND l_resolve_lup_flag &#61; &#39;Y&#39; THEN&#10;                    --&#10;                    l_xsd_data_type :&#61;&#10;                        PKG_Lookups.funcgetTabRecord_CACHED(&#10;                            p_table     &#61;&gt; &#39;BUSINESS_INT_XML_DETAIL&#39;,&#10;                            p_data_fld  &#61;&gt; &#39;XML_DATA_TYPE&#39;,&#10;                            p_ref_col   &#61;&gt; &#39;XML_MESSAGE_ID&#39;,&#10;                            p_ref_val   &#61;&gt; PKG_DynSQL.get_xml_message_id(p_table),&#10;                            p_where     &#61;&gt; &#39;XML_FIELD_NAME &#61; :p_xml_field_name AND xsd_number &#61; :p_xsd_number&#39;,&#10;                            p_bind_var1 &#61;&gt; REPLACE(l_fld_alias, &#39;&quot;&#39;, &#39;&#39;),&#10;                            p_bind_var2 &#61;&gt; TO_CHAR(NVL(SPGMESSAGE.GC_SCHEMA_NUMBER, 1)) );&#10;                    --&#10;                    /*IF PKG_Debug.funcGetDebugActive THEN&#10;                        message(&#39;xsd_data_type&#61;&#39;||l_xsd_data_type ||&#10;                            &#39;(xml_msg_id&#61;&#39; || PKG_DynSQL.get_xml_message_id(p_table) || &#39;)&#39; ||&#10;                            &#39;(XML_FIELD_NAME&#61;&#39; || REPLACE(l_fld_alias, &#39;&quot;&#39;, &#39;&#39;)  || &#39;)&#39;, p_trace_level&#61;&gt;15 );&#10;                    END IF;*/&#10;                    --&#10;                    IF l_xsd_data_type IN( &#39;datetime&#39;, &#39;DateTime_Type&#39; ) THEN&#10;                        l_ret_fld :&#61; &#39;REPLACE(TO_CHAR(&#39; || l_ret_fld || &#39;, &#39;&#39;YYYY-MM-DD HH24:MI:SS&#39;&#39;), &#39;&#39; &#39;&#39;, &#39;&#39;T&#39;&#39;)&#39;;&#10;                    ELSIF l_xsd_data_type IN( &#39;time&#39;, &#39;Time_Type&#39; ) THEN&#10;                        l_ret_fld :&#61; &#39;TO_CHAR(&#39; || l_ret_fld || &#39;, &#39;&#39;HH24:MI:SS&#39;&#39;)&#39;;&#10;                    ELSIF l_xsd_data_type IN( &#39;date&#39;, &#39;Date_Type&#39; ) THEN&#10;                        l_ret_fld :&#61; &#39;TO_CHAR(&#39; || l_ret_fld || &#39;, &#39;&#39;YYYY-MM-DD&#39;&#39;)&#39;;&#10;                    ELSIF l_xsd_data_type IN (&#39;CLOB&#39;, &#39;clob&#39;, &#39;Notes_Type&#39;) OR REPLACE(l_fld_alias, &#39;&quot;&#39;, &#39;&#39;) LIKE &#39;%TransferNotes&#39; THEN&#10;                        l_ret_fld :&#61; &#39;PKG_Common.empty2null(&#39; || l_ret_fld || &#39;, &#39;&#39;Y&#39;&#39;, &#39;&#39;&#39; || PKG_Global.GC_SPG_CR || &#39;&#39;&#39;,&#39;&#39;Y&#39;&#39;)&#39;;&#10;                    END IF;&#10;                    --&#10;                END IF;&#10;                --&#10;                IF l_use_aliases_flag &#61; &#39;Y&#39; AND EMPTY2NULL(l_fld_alias) IS NOT NULL THEN&#10;                    l_ret_fld :&#61; l_ret_fld || &#39; AS &#39; || l_fld_alias;&#10;                ELSIF l_use_aliases_flag &#61; &#39;N&#39; AND l_resolve_lup_flag &#61; &#39;N&#39; AND p_cr_view_mode &#61; &#39;Y&#39; THEN&#10;                    IF l_tab.EXISTS(l_ret_fld_U) THEN&#10;                        l_tab(l_ret_fld_U) :&#61; l_tab(l_ret_fld_U) + 1;&#10;                    ELSE&#10;                        l_tab(l_ret_fld_U) :&#61; 1;&#10;                    END IF;&#10;                    IF l_tab(l_ret_fld_U) &gt; 1 THEN&#10;                        l_ret_fld :&#61; l_ret_fld || &#39; AS &#39; || SUBSTR(l_ret_fld_U, 1, 28) || TO_CHAR(l_tab(l_ret_fld_U));&#10;                    END IF;&#10;                END IF;&#10;                --&#10;                IF SUBSTR(l_ret_fld, 1, 1) &lt;&gt; &#39;*&#39; -- Field Alias with the leading * (asterisk character) indicate that the field should not be part of the XML View&#10;                THEN&#10;                    l_ret :&#61;&#10;                        PKG_LstUtl.concat(&#10;                            l_ret,&#10;                            PKG_LstUtl.add_prefix((CASE WHEN p_src_tab_prefix_flag &#61; &#39;Y&#39; THEN UPPER(l_fld_owner) || &#39;#&#39; ELSE NULL END), l_ret_fld),&#10;                            p_delim&#61;&gt;NVLSTR(p_delim, &#39;, &#39;), p_max_len&#61;&gt;32767 );&#10;                END IF;&#10;                --&#10;            END LOOP;&#10;            --&#10;        END IF;&#10;        --&#10;    END LOOP;&#10;    --&#10;    g_label :&#61; &#39;0500&#39;;&#10;    IF PKG_Debug.funcGetDebugActive THEN&#10;        message(l_proc || &#39;: [RET&#61;&#39; || l_ret || &#39;]&#39;, p_trace_level&#61;&gt;10);&#10;    END IF;&#10;    --&#10;    IF p_cr_view_mode &#61; &#39;Y&#39; AND EMPTY2NULL(p_source_tables) IS NOT NULL THEN&#10;        l_source_table_LST :&#61; REPLACE(REPLACE(REPLACE(p_source_tables, CHR(13), &#39;&#39;), CHR(10), &#39; &#39;), &#39; &#39;, &#39;&#39;);&#10;        LOOP&#10;            l_source_table :&#61; TRIM(PKG_LstUtl.list_next_elem(l_source_table_LST, &#39;,&#39;));&#10;            EXIT WHEN EMPTY2NULL(l_source_table) IS NULL AND EMPTY2NULL(l_source_table_LST) IS NULL;&#10;            --&#10;            l_pk_key :&#61; PKG_DynSQL.get_tab_pk_fld_lst(l_source_table);&#10;            --&#10;            IF l_pk_key NOT LIKE &#39;%,%&#39;  AND&#10;               l_pk_key NOT LIKE &#39;%||%&#39; AND&#10;               REPLACE(UPPER(l_ret) || NVLSTR(p_delim, &#39;, &#39;), &#39; &#39;, &#39;&#39;) NOT LIKE REPLACE(&#39;%.&#39; || UPPER(l_pk_key) || NVLSTR(p_delim, &#39;, &#39;) || &#39;%&#39;, &#39; &#39;, &#39;&#39;)&#10;            THEN&#10;                l_ret :&#61; PKG_LstUtl.concat( l_ret, l_source_table || &#39;.&#39; || l_pk_key, p_delim&#61;&gt;NVLSTR(p_delim, &#39;, &#39;), p_max_len&#61;&gt;32767 );&#10;            END IF;&#10;        END LOOP;&#10;    END IF;&#10;    --&#10;    RETURN l_ret;&#10;    --&#10;END get_parsed_fld_lst;&#10;--&#10;PROCEDURE gen_xml_views(p_drop_only VARCHAR2 DEFAULT &#39;N&#39;, p_use_new_names VARCHAR2 DEFAULT &#39;N&#39;)&#10;IS&#10;    --&#10;    CURSOR csDrView IS&#10;      SELECT &#39;DROP VIEW &#39; || view_name&#10;      FROM user_views&#10;      WHERE 1&#61;1&#10;        AND ( ( view_name LIKE &#39;XML%_MSG_%_V&#39; AND REGEXP_LIKE(view_name,&#39;[[:digit:]]{4}&#39;) ) OR&#10;              ( view_name LIKE &#39;PRF\_%\_V&#39; ESCAPE &#39;\&#39; ) )&#10;        AND view_name NOT IN ( &#39;XML_MSG_MAPPING_RECONCILE_V&#39; )&#10;      ORDER BY view_name;&#10;    --&#10;    CURSOR csCrView IS&#10;      SELECT&#10;        &#39;CREATE OR REPLACE VIEW &#39; || PKG_DynSQL.get_xml_view_name(xml_message_id, p_xsd_number&#61;&gt;xsd_number, p_use_new_name&#61;&gt;p_use_new_names) || &#39; AS &#39; AS cr_view,&#10;        PKG_LstUtl.add_postfix(unique_key, &#39; AS UNIQUE_KEY&#39; ) AS unique_key,&#10;        PKG_LstUtl.add_postfix(fk_key    , &#39; AS FOREIGN_KEY&#39;) AS fk_key,&#10;        PKG_SPG_SUPPORT.get_parsed_fld_lst( PKG_DynSQL.get_xml_view_name(xml_message_id, p_xsd_number &#61;&gt; xsd_number), p_cr_view_mode&#61;&gt;&#39;Y&#39;, p_source_tables&#61;&gt;source_tables ) AS fld_lst,&#10;        &#39;FROM &#39; || source_tables AS from_clause,&#10;        where_clause             AS where_clause&#10;      FROM business_int_xml_summary&#10;      WHERE 1&#61;1&#10;        AND NOT xml_message_id BETWEEN 5000 AND 5999&#10;        AND ( NVL(p_use_new_names, &#39;N&#39;) &#61; &#39;N&#39;&#10;              OR&#10;              ( NOT xml_message_id BETWEEN 2001 AND 2004 ) AND&#10;              ( NOT xml_message_id BETWEEN 2012 AND 2014 ) AND&#10;              ( NOT xml_message_id BETWEEN 2022 AND 2024 ) AND&#10;              ( NOT xml_message_id BETWEEN 2101 AND 2102 ) AND&#10;              ( NOT xml_message_id BETWEEN 2131 AND 2138 ) AND&#10;              ( NOT xml_message_id BETWEEN 2222 AND 2224 ) AND&#10;              ( NOT xml_message_id BETWEEN 2225 AND 2235 ) )&#10;      ORDER BY hierarchy_level, level_order_by;&#10;    --&#10;    l_rec csCrView%ROWTYPE;&#10;    l_ddl CLOB;&#10;    --&#10;BEGIN&#10;    --&#10;    PKG_DynSQL.init_tab_info(p_reset_flag &#61;&gt; &#39;Y&#39;);&#10;    --&#10;    OPEN csDrView;&#10;    LOOP&#10;        FETCH csDrView INTO l_DDL;&#10;        EXIT WHEN csDrView%NOTFOUND;&#10;        --&#10;        PKG_DynSQL.exec_SQL(l_DDL, p_ignore_err_flag &#61;&gt; &#39;Y&#39;, p_print_SQL &#61;&gt; &#39;N&#39;);&#10;    END LOOP;&#10;    CLOSE csDrView;&#10;    --&#10;    IF p_drop_only &#61; &#39;N&#39; THEN&#10;        --&#10;        OPEN csCrView;&#10;        LOOP&#10;            FETCH csCrView INTO l_rec;&#10;            EXIT WHEN csCrView%NOTFOUND;&#10;            --&#10;            l_DDL :&#61;&#10;                PKG_LstUtl.concat_CLOB(&#10;                    TO_CLOB(l_rec.cr_view),&#10;                    TO_CLOB(&#39;SELECT&#39;),&#10;                    PKG_LstUtl.concat_CLOB(&#10;                        TO_CLOB(l_rec.unique_key),&#10;                        TO_CLOB(l_rec.fk_key),&#10;                        TO_CLOB(l_rec.fld_lst),&#10;                        p_delim&#61;&gt;&#39;, &#39; ),&#10;                    TO_CLOB(l_rec.from_clause),&#10;                    TO_CLOB(l_rec.where_clause),&#10;                    p_delim&#61;&gt;CHR(10) );&#10;            --&#10;            BEGIN&#10;                PKG_DynSQL.exec_DDL(l_DDL, p_ignore_err_flag &#61;&gt; &#39;N&#39;, p_print_SQL &#61;&gt; &#39;Y&#39;);&#10;            EXCEPTION WHEN OTHERS THEN&#10;                procDebug(&#39;ERROR in PKG_SUPPORT.gen_xml_views: &#39; || SQLERRM || CHR(10) || l_DDL);&#10;                RAISE;&#10;            END;&#10;            --&#10;        END LOOP;&#10;        CLOSE csCrView;&#10;        --&#10;    END IF;&#10;    --&#10;END gen_xml_views;&#10;--&#10;--&#10;--&#10;/*&#10;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#10;  XML TMM Reconciliation Report subroutines&#10;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#10;*/&#10;FUNCTION get_xml_mappings_TAB&#10;RETURN t_rpt_TAB_TYP PIPELINED&#10;IS&#10;BEGIN&#10;    FOR l_idx IN 1..g_rpt_TAB.COUNT LOOP&#10;        PIPE ROW ( g_rpt_TAB(l_idx) );&#10;    END LOOP;&#10;END get_xml_mappings_TAB;&#10;--&#10;PROCEDURE init_RPT&#10;IS&#10;BEGIN&#10;    g_rpt_TAB :&#61; t_rpt_TAB_TYP();&#10;END init_RPT;&#10;--&#10;FUNCTION set_rpt_element(&#10;  p_owner_flag                VARCHAR2,&#10;  p_level_flag                VARCHAR2,&#10;  --&#10;  p_bi_code                   BUSINESS_INTERACTION.business_interaction_code%TYPE,&#10;  p_xml_message_name1         BUSINESS_INT_XML_MAP.xml_message_name%TYPE,&#10;  p_data_update_mode          BUSINESS_INT_XML_MAP.data_update_mode%TYPE,&#10;  p_root_xml_message_id       BUSINESS_INT_XML_MAP.root_xml_message_id%TYPE,&#10;  p_include_xml_message_list  BUSINESS_INT_XML_MAP.include_xml_message_list%TYPE,&#10;  p_exclude_xml_message_list  BUSINESS_INT_XML_MAP.exclude_xml_message_list%TYPE,&#10;  --&#10;  p_xml_message_id        BUSINESS_INT_XML_DETAIL.xml_message_id%TYPE,&#10;  p_xml_message_name      BUSINESS_INT_XML_SUMMARY.xml_message_name%TYPE,&#10;  p_source_tables         VARCHAR2,&#10;  p_notes                 VARCHAR2,&#10;  p_notes1                VARCHAR2,&#10;  --&#10;  p_source_table          BUSINESS_INT_XML_DETAIL.source_table%TYPE,&#10;  p_source_column         BUSINESS_INT_XML_DETAIL.source_column%TYPE,&#10;  p_xml_field_name        BUSINESS_INT_XML_DETAIL.xml_field_name%TYPE,&#10;  p_xml_identifier_flag   BUSINESS_INT_XML_DETAIL.xml_identifier_flag%TYPE,&#10;  p_xml_data_type         BUSINESS_INT_XML_DETAIL.xml_data_type%TYPE,&#10;  p_xml_nillable          VARCHAR2,&#10;  p_xml_ref_data_flag     BUSINESS_INT_XML_DETAIL.reference_data_flag%TYPE,&#10;  p_xml_min_len           BUSINESS_INT_XML_DETAIL.xml_minimum_length%TYPE,&#10;  p_xml_max_len           BUSINESS_INT_XML_DETAIL.xml_maximum_length%TYPE,&#10;  p_xml_referential_flag  BUSINESS_INT_XML_DETAIL.referential_flag%TYPE,&#10;  p_include_in_del_msg    BUSINESS_INT_XML_DETAIL.include_in_delete_flag%TYPE )&#10;RETURN t_rpt_REC_TYP&#10;IS&#10;    l_rec t_rpt_REC_TYP;&#10;BEGIN&#10;    l_rec.owner_flag            :&#61; CASE WHEN UPPER(p_owner_flag) &#61; &#39;L&#39; THEN &#39;TMM_LM&#39;  WHEN UPPER(p_owner_flag) &#61; &#39;P&#39; THEN &#39;TMM_PM&#39;  ELSE UPPER(p_owner_flag) END;&#10;    l_rec.level_flag            :&#61; CASE WHEN UPPER(p_level_flag) &#61; &#39;M&#39; THEN &#39;BI_MAP&#39;  WHEN UPPER(p_level_flag) &#61; &#39;S&#39; THEN &#39;SUMMARY&#39; WHEN UPPER(p_level_flag) &#61; &#39;D&#39; THEN &#39;DETAILS&#39; ELSE UPPER(p_level_flag) END;&#10;    --&#10;    l_rec.bi_code                  :&#61; p_bi_code;&#10;    l_rec.xml_message_name1        :&#61; p_xml_message_name1;&#10;    l_rec.data_update_mode         :&#61; p_data_update_mode;&#10;    l_rec.root_xml_message_id      :&#61; p_root_xml_message_id;&#10;    l_rec.include_xml_message_list :&#61; p_include_xml_message_list;&#10;    l_rec.exclude_xml_message_list :&#61; p_exclude_xml_message_list;&#10;    --&#10;    l_rec.xml_message_id        :&#61; p_xml_message_id;&#10;    l_rec.xml_message_name      :&#61; p_xml_message_name;&#10;    l_rec.source_tables         :&#61; p_source_tables;&#10;    l_rec.notes                 :&#61; p_notes;&#10;    l_rec.notes1                :&#61; p_notes1;&#10;    --&#10;    l_rec.source_table          :&#61; p_source_table;&#10;    l_rec.source_column         :&#61; p_source_column;&#10;    l_rec.xml_field_name        :&#61; p_xml_field_name;&#10;    l_rec.xml_identifier_flag   :&#61; p_xml_identifier_flag;&#10;    l_rec.xml_data_type         :&#61; p_xml_data_type;&#10;    l_rec.xml_nillable          :&#61; p_xml_nillable;&#10;    l_rec.xml_ref_data_flag     :&#61; p_xml_ref_data_flag;&#10;    l_rec.xml_min_len           :&#61; p_xml_min_len;&#10;    l_rec.xml_max_len           :&#61; p_xml_max_len;&#10;    l_rec.xml_referential_flag  :&#61; p_xml_referential_flag;&#10;    l_rec.include_in_del_msg    :&#61; p_include_in_del_msg;&#10;    --&#10;    RETURN l_rec;&#10;END set_rpt_element;&#10;--&#10;FUNCTION set_rpt_element_D(&#10;  p_owner_flag            VARCHAR2,&#10;  p_xml_message_id        BUSINESS_INT_XML_DETAIL.xml_message_id%TYPE,&#10;  p_notes                 VARCHAR2,&#10;  p_notes1                VARCHAR2,&#10;  --&#10;  p_source_table          BUSINESS_INT_XML_DETAIL.source_table%TYPE,&#10;  p_source_column         BUSINESS_INT_XML_DETAIL.source_column%TYPE,&#10;  p_xml_field_name        BUSINESS_INT_XML_DETAIL.xml_field_name%TYPE,&#10;  p_xml_identifier_flag   BUSINESS_INT_XML_DETAIL.xml_identifier_flag%TYPE,&#10;  p_xml_data_type         BUSINESS_INT_XML_DETAIL.xml_data_type%TYPE,&#10;  p_xml_nillable          VARCHAR2,&#10;  p_xml_ref_data_flag     BUSINESS_INT_XML_DETAIL.reference_data_flag%TYPE,&#10;  p_xml_min_len           BUSINESS_INT_XML_DETAIL.xml_minimum_length%TYPE,&#10;  p_xml_max_len           BUSINESS_INT_XML_DETAIL.xml_maximum_length%TYPE,&#10;  p_xml_referential_flag  BUSINESS_INT_XML_DETAIL.referential_flag%TYPE,&#10;  p_include_in_del_msg    BUSINESS_INT_XML_DETAIL.include_in_delete_flag%TYPE )&#10;RETURN t_rpt_REC_TYP&#10;IS&#10;BEGIN&#10;    RETURN&#10;        set_rpt_element(&#10;            p_owner_flag            &#61;&gt; p_owner_flag,&#10;            p_level_flag            &#61;&gt; &#39;D&#39;,&#10;            --&#10;            p_bi_code                   &#61;&gt; NULL,&#10;            p_xml_message_name1         &#61;&gt; NULL,&#10;            p_data_update_mode          &#61;&gt; NULL,&#10;            p_root_xml_message_id       &#61;&gt; NULL,&#10;            p_include_xml_message_list  &#61;&gt; NULL,&#10;            p_exclude_xml_message_list  &#61;&gt; NULL,&#10;            --&#10;            p_xml_message_id        &#61;&gt; p_xml_message_id,&#10;            p_xml_message_name      &#61;&gt; NULL,&#10;            p_source_tables         &#61;&gt; NULL,&#10;            p_notes                 &#61;&gt; p_notes,&#10;            p_notes1                &#61;&gt; p_notes1,&#10;            --&#10;            p_source_table          &#61;&gt; p_source_table,&#10;            p_source_column         &#61;&gt; p_source_column,&#10;            p_xml_field_name        &#61;&gt; p_xml_field_name,&#10;            p_xml_identifier_flag   &#61;&gt; p_xml_identifier_flag,&#10;            p_xml_data_type         &#61;&gt; p_xml_data_type,&#10;            p_xml_nillable          &#61;&gt; p_xml_nillable,&#10;            p_xml_ref_data_flag     &#61;&gt; p_xml_ref_data_flag,&#10;            p_xml_min_len           &#61;&gt; p_xml_min_len,&#10;            p_xml_max_len           &#61;&gt; p_xml_max_len,&#10;            p_xml_referential_flag  &#61;&gt; p_xml_referential_flag,&#10;            p_include_in_del_msg    &#61;&gt; p_include_in_del_msg&#10;        );&#10;END set_rpt_element_D;&#10;--&#10;FUNCTION set_rpt_element_S(&#10;  p_owner_flag            VARCHAR2,&#10;  p_xml_message_id        BUSINESS_INT_XML_DETAIL.xml_message_id%TYPE,&#10;  p_xml_message_name      BUSINESS_INT_XML_SUMMARY.xml_message_name%TYPE,&#10;  p_source_tables         VARCHAR2,&#10;  p_notes                 VARCHAR2 )&#10;RETURN t_rpt_REC_TYP&#10;IS&#10;BEGIN&#10;    RETURN&#10;        set_rpt_element(&#10;            p_owner_flag            &#61;&gt; p_owner_flag,&#10;            p_level_flag            &#61;&gt; &#39;S&#39;,&#10;            --&#10;            p_bi_code                   &#61;&gt; NULL,&#10;            p_xml_message_name1         &#61;&gt; NULL,&#10;            p_data_update_mode          &#61;&gt; NULL,&#10;            p_root_xml_message_id       &#61;&gt; NULL,&#10;            p_include_xml_message_list  &#61;&gt; NULL,&#10;            p_exclude_xml_message_list  &#61;&gt; NULL,&#10;            --&#10;            p_xml_message_id        &#61;&gt; p_xml_message_id,&#10;            p_xml_message_name      &#61;&gt; p_xml_message_name,&#10;            p_source_tables         &#61;&gt; p_source_tables,&#10;            p_notes                 &#61;&gt; p_notes,&#10;            p_notes1                &#61;&gt; NULL,&#10;            --&#10;            p_source_table          &#61;&gt; NULL,&#10;            p_source_column         &#61;&gt; NULL,&#10;            p_xml_field_name        &#61;&gt; NULL,&#10;            p_xml_identifier_flag   &#61;&gt; NULL,&#10;            p_xml_data_type         &#61;&gt; NULL,&#10;            p_xml_nillable          &#61;&gt; NULL,&#10;            p_xml_ref_data_flag     &#61;&gt; NULL,&#10;            p_xml_min_len           &#61;&gt; NULL,&#10;            p_xml_max_len           &#61;&gt; NULL,&#10;            p_xml_referential_flag  &#61;&gt; NULL,&#10;            p_include_in_del_msg    &#61;&gt; NULL&#10;        );&#10;END set_rpt_element_S;&#10;--&#10;FUNCTION set_rpt_element_M(&#10;  p_owner_flag                VARCHAR2,&#10;  p_bi_code                   BUSINESS_INTERACTION.business_interaction_code%TYPE,&#10;  p_xml_message_name          BUSINESS_INT_XML_MAP.xml_message_name%TYPE,&#10;  p_data_update_mode          BUSINESS_INT_XML_MAP.data_update_mode%TYPE,&#10;  p_root_xml_message_id       BUSINESS_INT_XML_MAP.root_xml_message_id%TYPE,&#10;  p_include_xml_message_list  BUSINESS_INT_XML_MAP.include_xml_message_list%TYPE,&#10;  p_exclude_xml_message_list  BUSINESS_INT_XML_MAP.exclude_xml_message_list%TYPE )&#10;RETURN t_rpt_REC_TYP IS&#10;BEGIN&#10;    RETURN&#10;        set_rpt_element(&#10;            p_owner_flag            &#61;&gt; p_owner_flag,&#10;            p_level_flag            &#61;&gt; &#39;M&#39;,&#10;            --&#10;            p_bi_code                   &#61;&gt; p_bi_code,&#10;            p_xml_message_name1         &#61;&gt; p_xml_message_name,&#10;            p_data_update_mode          &#61;&gt; p_data_update_mode,&#10;            p_root_xml_message_id       &#61;&gt; p_root_xml_message_id,&#10;            p_include_xml_message_list  &#61;&gt; p_include_xml_message_list,&#10;            p_exclude_xml_message_list  &#61;&gt; p_exclude_xml_message_list,&#10;            --&#10;            p_xml_message_id        &#61;&gt; NULL,&#10;            p_xml_message_name      &#61;&gt; p_xml_message_name,&#10;            p_source_tables         &#61;&gt; NULL,&#10;            p_notes                 &#61;&gt; NULL,&#10;            p_notes1                &#61;&gt; NULL,&#10;            --&#10;            p_source_table          &#61;&gt; NULL,&#10;            p_source_column         &#61;&gt; NULL,&#10;            p_xml_field_name        &#61;&gt; NULL,&#10;            p_xml_identifier_flag   &#61;&gt; NULL,&#10;            p_xml_data_type         &#61;&gt; NULL,&#10;            p_xml_nillable          &#61;&gt; NULL,&#10;            p_xml_ref_data_flag     &#61;&gt; NULL,&#10;            p_xml_min_len           &#61;&gt; NULL,&#10;            p_xml_max_len           &#61;&gt; NULL,&#10;            p_xml_referential_flag  &#61;&gt; NULL,&#10;            p_include_in_del_msg    &#61;&gt; NULL&#10;        );&#10;END set_rpt_element_M;&#10;--&#10;PROCEDURE add_rpt_element(p_rec t_rpt_REC_TYP)&#10;IS&#10;BEGIN&#10;    g_rpt_TAB.EXTEND;&#10;    g_rpt_TAB(g_rpt_TAB.COUNT) :&#61; p_rec;&#10;END add_rpt_element;&#10;--&#10;--&#10;FUNCTION do_compare_values(p_fld_name VARCHAR2, p_val1 VARCHAR2, p_val2 VARCHAR2) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN&#10;        CASE WHEN NVLSTR(p_val1, &#39;xyz#%^&#39;) &lt;&gt; NVL(p_val2, &#39;xyz#%^&#39;) THEN&#10;            &#39;(&#39; || p_fld_name || &#39;: &#39; || &#39;[TMM&#61;&#39; || p_val1 || &#39;]&lt;&gt;[XML&#61;&#39; || p_val2 || &#39;])&#39;&#10;        END;&#10;END do_compare_values;&#10;--&#10;FUNCTION get_LM_2_PM_cmp(&#10;    p_reconcile_level  VARCHAR2,&#10;    p_xml_message_id   BUSINESS_INT_XML_DETAIL.xml_message_id%TYPE,&#10;    p_xml_field_name   BUSINESS_INT_XML_DETAIL.xml_field_name%TYPE,&#10;    p_source_table     BUSINESS_INT_XML_DETAIL.source_table%TYPE,&#10;    p_bi_code          BUSINESS_INTERACTION.business_interaction_code%TYPE,&#10;    p_data_update_mode VARCHAR2 )&#10;RETURN VARCHAR2&#10;IS&#10;    TYPE l_cur_TYP IS REF CURSOR;&#10;    l_cur l_cur_TYP;&#10;    l_cmp_det VARCHAR2(32000);&#10;    l_res     VARCHAR2(32000);&#10;BEGIN&#10;    IF p_reconcile_level &#61; &#39;BI_MAP&#39; THEN&#10;        OPEN l_cur FOR&#10;          WITH t1 AS (&#10;            SELECT&#10;              bi_code,&#10;              xml_message_name,&#10;              data_update_mode,&#10;              root_xml_message_id,&#10;              include_xml_message_list,&#10;              exclude_xml_message_list&#10;            FROM TABLE( PKG_SPG_SUPPORT.get_xml_mappings_TAB )&#10;            WHERE owner_flag &#61; &#39;TMM_LM&#39;&#10;              AND level_flag &#61; &#39;BI_MAP&#39;&#10;              AND bi_code &#61; p_bi_code&#10;              AND data_update_mode &#61; p_data_update_mode ),&#10;          t2 AS (&#10;            SELECT&#10;              bi_code,&#10;              xml_message_name,&#10;              data_update_mode,&#10;              root_xml_message_id,&#10;              include_xml_message_list,&#10;              exclude_xml_message_list&#10;            FROM TABLE( PKG_SPG_SUPPORT.get_xml_mappings_TAB )&#10;            WHERE owner_flag &#61; &#39;TMM_PM&#39;&#10;              AND level_flag &#61; &#39;BI_MAP&#39;&#10;              AND bi_code &#61; p_bi_code&#10;              AND data_update_mode &#61; p_data_update_mode ),&#10;          t3 AS (&#10;            SELECT *&#10;            FROM (&#10;              SELECT&#10;                T1.xml_message_name         AS xml_message_name_1,&#10;                T2.xml_message_name         AS xml_message_name_2,&#10;                T1.bi_code                  AS bi_code_1,&#10;                T2.bi_code                  AS bi_code_2,&#10;                T1.data_update_mode         AS data_update_mode_1,&#10;                T2.data_update_mode         AS data_update_mode_2,&#10;                T1.root_xml_message_id      AS root_xml_message_id_1,&#10;                T2.root_xml_message_id      AS root_xml_message_id_2,&#10;                T1.include_xml_message_list AS include_xml_message_list_1,&#10;                T2.include_xml_message_list AS include_xml_message_list_2,&#10;                T1.exclude_xml_message_list AS exclude_xml_message_list_1,&#10;                T2.exclude_xml_message_list AS exclude_xml_message_list_2&#10;              FROM t1 LEFT OUTER JOIN t2 ON T2.bi_code &#61; T1.bi_code&#10;              UNION&#10;              SELECT&#10;                T1.xml_message_name         AS xml_message_name_1,&#10;                T2.xml_message_name         AS xml_message_name_2,&#10;                T1.bi_code                  AS bi_code_1,&#10;                T2.bi_code                  AS bi_code_2,&#10;                T1.data_update_mode         AS data_update_mode_1,&#10;                T2.data_update_mode         AS data_update_mode_2,&#10;                T1.root_xml_message_id      AS root_xml_message_id_1,&#10;                T2.root_xml_message_id      AS root_xml_message_id_2,&#10;                T1.include_xml_message_list AS include_xml_message_list_1,&#10;                T2.include_xml_message_list AS include_xml_message_list_2,&#10;                T1.exclude_xml_message_list AS exclude_xml_message_list_1,&#10;                T2.exclude_xml_message_list AS exclude_xml_message_list_2&#10;              FROM t2 LEFT OUTER JOIN t1 ON T2.bi_code &#61; T1.bi_code )&#10;          )&#10;          --&#10;          SELECT&#10;            PKG_LstUtl.concat(&#10;                PKG_SPG_SUPPORT.do_compare_values(&#39;BI_CODE&#39;        , T3.bi_code_1                 , T3.bi_code_2),&#10;                PKG_SPG_SUPPORT.do_compare_values(&#39;XML_MSG_NAME&#39;   , T3.xml_message_name_1        , T3.xml_message_name_2),&#10;                PKG_SPG_SUPPORT.do_compare_values(&#39;UPD_MODE&#39;       , T3.data_update_mode_1        , T3.data_update_mode_2),&#10;                PKG_SPG_SUPPORT.do_compare_values(&#39;ROOT_MSG_ID&#39;    , T3.root_xml_message_id_1     , T3.root_xml_message_id_2),&#10;                PKG_SPG_SUPPORT.do_compare_values(&#39;INCLUDE_MSG_LST&#39;, T3.include_xml_message_list_1, T3.include_xml_message_list_2),&#10;                PKG_SPG_SUPPORT.do_compare_values(&#39;EXCLUDE_MSG_LST&#39;, T3.exclude_xml_message_list_1, T3.exclude_xml_message_list_2),&#10;                p_delim &#61;&gt; &#39;; &#39; )&#10;          INTO l_res&#10;          FROM T3;&#10;        --&#10;        LOOP&#10;            FETCH l_cur INTO l_cmp_det;&#10;            EXIT WHEN l_cur%NOTFOUND;&#10;            --&#10;            l_res :&#61; PKG_LstUtl.concat( l_res, l_cmp_det, p_max_len &#61;&gt; 32000 );&#10;        END LOOP;&#10;        CLOSE l_cur;&#10;    ELSIF p_reconcile_level &#61; &#39;SUMMARY&#39; THEN&#10;        OPEN l_cur FOR&#10;          WITH t1 AS (&#10;            SELECT&#10;              xml_message_id,&#10;              xml_message_name,&#10;              RTRIM(RTRIM(NVL(source_tables, &#39;NULL&#39;), CHR(10)), CHR(13)) source_tables,&#10;              RTRIM(RTRIM(NVL(NULL, &#39;NULL&#39;), CHR(10)), CHR(13)) notes,&#10;              RTRIM(RTRIM(NVL(NULL, &#39;NULL&#39;), CHR(10)), CHR(13)) notes1&#10;            FROM TABLE( PKG_SPG_SUPPORT.get_xml_mappings_TAB )&#10;            WHERE owner_flag &#61; &#39;TMM_LM&#39;&#10;              AND level_flag &#61; &#39;SUMMARY&#39;&#10;              AND xml_message_id &#61; p_xml_message_id ),&#10;          t2 AS (&#10;            SELECT&#10;              xml_message_id,&#10;              xml_message_name,&#10;              RTRIM(RTRIM(NVL(source_tables, &#39;NULL&#39;), CHR(10)), CHR(13)) source_tables,&#10;              RTRIM(RTRIM(NVL(NULL, &#39;NULL&#39;), CHR(10)), CHR(13)) notes,&#10;              RTRIM(RTRIM(NVL(NULL, &#39;NULL&#39;), CHR(10)), CHR(13)) notes1&#10;            FROM TABLE( PKG_SPG_SUPPORT.get_xml_mappings_TAB )&#10;            WHERE owner_flag &#61; &#39;TMM_PM&#39;&#10;              AND level_flag &#61; &#39;SUMMARY&#39;&#10;              AND xml_message_id &#61; p_xml_message_id ),&#10;          t3 AS (&#10;            SELECT *&#10;            FROM (&#10;              SELECT&#10;                T1.xml_message_name AS xml_message_name_1,&#10;                T2.xml_message_name AS xml_message_name_2,&#10;                T1.source_tables    AS source_tables_1,&#10;                T2.source_tables    AS source_tables_2,&#10;                T1.notes            AS notes_1,&#10;                T2.notes            AS notes_2,&#10;                T1.notes1           AS notes1_1,&#10;                T2.notes1           AS notes1_2&#10;              FROM t1 LEFT OUTER JOIN t2 ON T2.xml_message_id &#61; T1.xml_message_id&#10;              UNION&#10;              SELECT&#10;                T1.xml_message_name AS xml_message_name_1,&#10;                T2.xml_message_name AS xml_message_name_2,&#10;                T1.source_tables    AS source_tables_1,&#10;                T2.source_tables    AS source_tables_2,&#10;                T1.notes            AS notes_1,&#10;                T2.notes            AS notes_2,&#10;                T1.notes1           AS notes1_1,&#10;                T2.notes1           AS notes1_2&#10;              FROM t2 LEFT OUTER JOIN t1 ON T2.xml_message_id &#61; T1.xml_message_id )&#10;          )&#10;          --&#10;          SELECT&#10;            PKG_LstUtl.concat(&#10;                PKG_SPG_SUPPORT.do_compare_values(&#39;XML_MSG_NAME&#39; , T3.xml_message_name_1, T3.xml_message_name_2),&#10;                PKG_SPG_SUPPORT.do_compare_values(&#39;SOURCE_TABLES&#39;, T3.source_tables_1   , T3.source_tables_2),&#10;                PKG_SPG_SUPPORT.do_compare_values(&#39;NOTES&#39;        , T3.notes_1           , T3.notes_2),&#10;                PKG_SPG_SUPPORT.do_compare_values(&#39;NOTES1&#39;       , T3.notes1_1          , T3.notes1_2),&#10;                p_delim &#61;&gt; &#39;; &#39; )&#10;          INTO l_res&#10;          FROM T3;&#10;        --&#10;        LOOP&#10;            FETCH l_cur INTO l_cmp_det;&#10;            EXIT WHEN l_cur%NOTFOUND;&#10;            --&#10;            l_res :&#61; PKG_LstUtl.concat( l_res, l_cmp_det, p_max_len &#61;&gt; 32000 );&#10;        END LOOP;&#10;        CLOSE l_cur;&#10;    ELSIF p_reconcile_level &#61; &#39;DETAILS&#39; THEN&#10;        OPEN l_cur FOR&#10;          WITH t1 AS (&#10;            SELECT&#10;              xml_message_id,&#10;              source_table,&#10;              source_column,&#10;              xml_field_name,&#10;              xml_identifier_flag,&#10;              xml_data_type,&#10;              xml_nillable,&#10;              xml_ref_data_flag,&#10;              xml_min_len,&#10;              xml_max_len,&#10;              xml_referential_flag,&#10;              include_in_del_msg,&#10;              RTRIM(RTRIM(NVL(notes, &#39;NULL&#39;), CHR(10)), CHR(13)) xml_notes,&#10;              RTRIM(RTRIM(NVL(notes1, &#39;NULL&#39;), CHR(10)), CHR(13)) xml_notes1&#10;            FROM TABLE( PKG_SPG_SUPPORT.get_xml_mappings_TAB )&#10;            WHERE owner_flag &#61; &#39;TMM_LM&#39;&#10;              AND level_flag &#61; &#39;DETAILS&#39;&#10;              AND xml_message_id &#61; p_xml_message_id&#10;              AND xml_field_name &#61; p_xml_field_name&#10;              AND source_table   &#61; p_source_table ),&#10;            t2 AS (&#10;            SELECT&#10;              xml_message_id,&#10;              source_table,&#10;              source_column,&#10;              xml_field_name,&#10;              xml_identifier_flag,&#10;              xml_data_type,&#10;              xml_nillable,&#10;              xml_ref_data_flag,&#10;              xml_min_len,&#10;              xml_max_len,&#10;              xml_referential_flag,&#10;              include_in_del_msg,&#10;              RTRIM(RTRIM(NVL(notes, &#39;NULL&#39;), CHR(10)), CHR(13)) xml_notes,&#10;              RTRIM(RTRIM(NVL(notes1, &#39;NULL&#39;), CHR(10)), CHR(13)) xml_notes1&#10;            FROM TABLE( PKG_SPG_SUPPORT.get_xml_mappings_TAB )&#10;            WHERE owner_flag &#61; &#39;TMM_PM&#39;&#10;              AND level_flag &#61; &#39;DETAILS&#39;&#10;              AND xml_message_id &#61; p_xml_message_id&#10;              AND xml_field_name &#61; p_xml_field_name&#10;              AND source_table   &#61; p_source_table ),&#10;          t3 AS (&#10;            SELECT *&#10;            FROM (&#10;              SELECT&#10;                T1.source_table         AS source_table_1,&#10;                T2.source_table         AS source_table_2,&#10;                T1.source_column        AS source_column_1,&#10;                T2.source_column        AS source_column_2,&#10;                T1.xml_identifier_flag  AS xml_identifier_flag_1,&#10;                T2.xml_identifier_flag  AS xml_identifier_flag_2,&#10;                T1.xml_data_type        AS xml_data_type_1,&#10;                T2.xml_data_type        AS xml_data_type_2,&#10;                T1.xml_nillable         AS xml_nillable_1,&#10;                T2.xml_nillable         AS xml_nillable_2,&#10;                T1.xml_ref_data_flag    AS xml_ref_data_flag_1,&#10;                T2.xml_ref_data_flag    AS xml_ref_data_flag_2,&#10;                T1.xml_min_len          AS xml_min_len_1,&#10;                T2.xml_min_len          AS xml_min_len_2,&#10;                T1.xml_max_len          AS xml_max_len_1,&#10;                T2.xml_max_len          AS xml_max_len_2,&#10;                T1.xml_referential_flag AS xml_referential_flag_1,&#10;                T2.xml_referential_flag AS xml_referential_flag_2,&#10;                T1.include_in_del_msg   AS include_in_del_msg_1,&#10;                T2.include_in_del_msg   AS include_in_del_msg_2,&#10;                T1.xml_notes            AS xml_notes_1,&#10;                T2.xml_notes            AS xml_notes_2,&#10;                T1.xml_notes1           AS xml_notes1_1,&#10;                T2.xml_notes1           AS xml_notes1_2&#10;              FROM t1 LEFT OUTER JOIN t2 ON  T2.xml_message_id &#61; T1.xml_message_id AND T2.xml_field_name &#61; T1.xml_field_name AND T2.source_table &#61; T1.source_table&#10;              UNION&#10;              SELECT&#10;                T1.source_table         AS source_table_1,&#10;                T2.source_table         AS source_table_2,&#10;                T1.source_column        AS source_column_1,&#10;                T2.source_column        AS source_column_2,&#10;                T1.xml_identifier_flag  AS xml_identifier_flag_1,&#10;                T2.xml_identifier_flag  AS xml_identifier_flag_2,&#10;                T1.xml_data_type        AS xml_data_type_1,&#10;                T2.xml_data_type        AS xml_data_type_2,&#10;                T1.xml_nillable         AS xml_nillable_1,&#10;                T2.xml_nillable         AS xml_nillable_2,&#10;                T1.xml_ref_data_flag    AS xml_ref_data_flag_1,&#10;                T2.xml_ref_data_flag    AS xml_ref_data_flag_2,&#10;                T1.xml_min_len          AS xml_min_len_1,&#10;                T2.xml_min_len          AS xml_min_len_2,&#10;                T1.xml_max_len          AS xml_max_len_1,&#10;                T2.xml_max_len          AS xml_max_len_2,&#10;                T1.xml_referential_flag AS xml_referential_flag_1,&#10;                T2.xml_referential_flag AS xml_referential_flag_2,&#10;                T1.include_in_del_msg   AS include_in_del_msg_1,&#10;                T2.include_in_del_msg   AS include_in_del_msg_2,&#10;                T1.xml_notes            AS xml_notes_1,&#10;                T2.xml_notes            AS xml_notes_2,&#10;                T1.xml_notes1           AS xml_notes1_1,&#10;                T2.xml_notes1           AS xml_notes1_2&#10;              FROM t2 LEFT OUTER JOIN t1 ON  T2.xml_message_id &#61; T1.xml_message_id AND T2.xml_field_name &#61; T1.xml_field_name AND T2.source_table &#61; T1.source_table )&#10;          )&#10;          --&#10;          SELECT&#10;            PKG_LstUtl.concat(&#10;                PKG_SPG_SUPPORT.do_compare_values(&#39;SOURCE_TABLE&#39;        , T3.source_table_1        , T3.source_table_2),&#10;                PKG_SPG_SUPPORT.do_compare_values(&#39;SOURCE_COLUMN&#39;       , T3.source_column_1       , T3.source_column_2),&#10;                PKG_SPG_SUPPORT.do_compare_values(&#39;IDENTIFIER_FLAG&#39;     , T3.xml_identifier_flag_1 , T3.xml_identifier_flag_2),&#10;                PKG_SPG_SUPPORT.do_compare_values(&#39;XML_DATA_TYPE&#39;       , T3.xml_data_type_1       , T3.xml_data_type_2),&#10;                PKG_SPG_SUPPORT.do_compare_values(&#39;XML_NILLABLE&#39;        , T3.xml_nillable_1        , T3.xml_nillable_2),&#10;                PKG_SPG_SUPPORT.do_compare_values(&#39;REF_DATA_FLAG&#39;       , T3.xml_ref_data_flag_1   , T3.xml_ref_data_flag_2),&#10;                PKG_SPG_SUPPORT.do_compare_values(&#39;XML_MIN_LEN&#39;         , T3.xml_min_len_1         , T3.xml_min_len_2),&#10;                PKG_SPG_SUPPORT.do_compare_values(&#39;XML_MAX_LEN&#39;         , T3.xml_max_len_1         , T3.xml_max_len_2),&#10;                PKG_SPG_SUPPORT.do_compare_values(&#39;XML_REFERENTIAL_FLAG&#39;, T3.xml_referential_flag_1, T3.xml_referential_flag_2),&#10;                PKG_SPG_SUPPORT.do_compare_values(&#39;INCLUDE_IN_DEL_MSG&#39;  , T3.include_in_del_msg_1  , T3.include_in_del_msg_2),&#10;                PKG_SPG_SUPPORT.do_compare_values(&#39;NOTES&#39;               , T3.xml_notes_1           , T3.xml_notes_2),&#10;                PKG_SPG_SUPPORT.do_compare_values(&#39;NOTES1&#39;              , T3.xml_notes1_1          , T3.xml_notes1_2),&#10;                p_delim &#61;&gt; &#39;; &#39; )&#10;          INTO l_res&#10;          FROM T3;&#10;          --WHERE ROWNUM &lt;&#61; 1&#10;        --&#10;        LOOP&#10;            FETCH l_cur INTO l_cmp_det;&#10;            EXIT WHEN l_cur%NOTFOUND;&#10;            --&#10;            l_res :&#61; PKG_LstUtl.concat( l_res, l_cmp_det, p_max_len &#61;&gt; 32000 );&#10;        END LOOP;&#10;        CLOSE l_cur;&#10;    ELSE&#10;        l_res :&#61; &#39;ERROR: unknown P_RECONCILE_LEVEL value (&#39; || p_reconcile_level || &#39;)&#39;;&#10;    END IF;&#10;    --&#10;    RETURN l_res;&#10;EXCEPTION WHEN OTHERS THEN&#10;    IF l_cur%ISOPEN THEN&#10;        CLOSE l_cur;&#10;    END IF;&#10;    --raise_application_error(-20001,&#10;    procDebug(&#10;        &#39;ERROR in PKG_SPG_SUPPORT.get_LM_2_PM_cmp(&#39; ||&#10;        p_reconcile_level || &#39;, &#39; ||&#10;        p_xml_message_id || &#39;, &#39; ||&#10;        p_xml_field_name || &#39;, &#39; ||&#10;        p_source_table || &#39;, &#39; ||&#10;        p_bi_code || &#39;, &#39; ||&#10;        p_data_update_mode || &#39;): &#39; ||&#10;        SQLERRM,&#10;        p_trace_level&#61;&gt;0 );&#10;    RAISE;&#10;END get_LM_2_PM_cmp;&#10;--&#10;--&#10;PROCEDURE persist_xml_to_disk(&#10;    spg_notification_id_in NUMBER,&#10;    p_export_caseload_flag VARCHAR2 DEFAULT &#39;N&#39; )&#10;IS&#10;    --&#10;    CURSOR cur IS&#10;      SELECT&#10;        S.spg_notification_id,&#10;        S.business_interaction_id,&#10;        S.offender_id,&#10;        S.unique_id,&#10;        S.date_created, /*row_version,*/&#10;        S.processed_flag,&#10;        S.processed_datetime,&#10;        S.message_id,&#10;        S.error_flag,&#10;        S.error_message,&#10;        S.aq_message_id,&#10;        S.aq_datetime,&#10;        S.control_reference,&#10;        S.sender_identity_id,&#10;        S.receiver_identity_id,&#10;        S.xml_message,&#10;        --&#10;        CASE&#10;            WHEN p_export_caseload_flag &#61; &#39;Y&#39; THEN&#10;                PA.code || &#39;_&#39; || BI.business_interaction_code || &#39;_&#39; || O.crn || &#39;_&#39; || S.control_reference || &#39;.xml&#39;&#10;            ELSE&#10;                S.control_reference || &#39;.xml&#39;&#10;        END AS xml_file_name&#10;      FROM&#10;        spg_notification S&#10;          INNER JOIN business_interaction BI ON BI.business_interaction_id &#61; S.business_interaction_id&#10;          INNER JOIN probation_area PA ON PA.probation_area_id &#61; S.receiver_identity_id&#10;          LEFT OUTER JOIN offender O ON O.offender_id &#61; S.offender_id&#10;      WHERE spg_notification_id &#61; spg_notification_id_in;&#10;    --&#10;    cur_rec   cur%ROWTYPE;&#10;    doc       DBMS_XMLDOM.DOMDocument;&#10;    --&#10;    no_directory  EXCEPTION;&#10;    PRAGMA EXCEPTION_INIT(no_directory, -29280);&#10;    --&#10;BEGIN&#10;    OPEN cur;&#10;    FETCH cur INTO cur_rec;&#10;    IF cur_rec.spg_notification_id IS NOT NULL THEN&#10;        doc :&#61; DBMS_XMLDOM.NewDOMDocument(cur_rec.xml_message);&#10;        DBMS_XMLDOM.writetofile(doc, &#39;SPGXMLDIR/&#39; || cur_rec.xml_file_name);&#10;        --&#10;        info(&#39;spg_notification_id &#61;&gt; &#39; || cur_rec.spg_notification_id || &#39; persisted to disk&#39;);&#10;    END IF;&#10;    CLOSE cur;&#10;    --&#10;EXCEPTION&#10;    WHEN no_directory THEN&#10;        fatal(&#39;SPGXMLDIR directory not available to process&#39;);&#10;    WHEN OTHERS THEN&#10;        fatal(&#39;Unhandled error detected: &#39; || SQLERRM);&#10;END persist_xml_to_disk;&#10;--&#10;--&#10;PROCEDURE document_to_disk(document_id_in IN NUMBER) IS&#10;    l_blob      BLOB;&#10;    l_start     NUMBER :&#61; 1;&#10;    l_bytelen   NUMBER :&#61; 32000;&#10;    l_len       NUMBER;&#10;    l_vr        RAW(32000);&#10;    x           NUMBER;&#10;    l_filename  VARCHAR2(100);&#10;    l_output    UTL_FILE.file_type;&#10;    l_extension VARCHAR2(30);&#10;    --&#10;    no_directory  EXCEPTION;&#10;    PRAGMA EXCEPTION_INIT(no_directory, -29280);&#10;    --&#10;    doc_xml   XMLTYPE;&#10;    doc       DBMS_XMLDOM.DOMDocument;&#10;BEGIN&#10;    g_procedure_name  :&#61; &#39;document_to_disk&#39;;&#10;    g_label           :&#61; &#39;120000&#39;;&#10;&#10;    info(&#39;Commence document_to_disk [document_id&#61;&gt;&#39; || TO_CHAR(document_id_in) || &#39;]&#39;);&#10;    l_start :&#61; 1;&#10;    l_bytelen :&#61; 32000;&#10;    -- get length of blob&#10;    SELECT&#10;      0 /*DBMS_LOB.getlength(document)*/ AS document_length,&#10;      CASE WHEN SUBSTR(document_name, NULLIF(INSTR(document_name,&#39;.&#39;, -1) +1, 1) ) IS NULL THEN LOWER(document_name) || &#39;.doc&#39; ELSE LOWER(document_name) END AS document_name,&#10;      NVL(substr(document_name,   nullif( instr(document_name,&#39;.&#39;, -1) +1, 1) ),&#39;doc&#39;) AS extension&#10;    INTO l_len, l_filename, l_extension&#10;    FROM document&#10;    WHERE document_id &#61; document_id_in;&#10;    -- save blob length&#10;    x :&#61; l_len;&#10;    -- select blob into variable&#10;    /*SELECT document INTO l_blob&#10;    FROM document&#10;    WHERE document_id &#61; document_id_in;*/&#10;    -- define output directory&#10;    l_output :&#61; UTL_FILE.fopen(&#39;SPG_DOCUMENT&#39;, TO_CHAR(document_id_in) || &#39;.&#39; || l_extension,&#39;wb&#39;, 32760);&#10;    -- if small enough for a single write&#10;    IF l_len &lt; 32760 THEN&#10;        UTL_FILE.put_raw(l_output,l_blob);&#10;        UTL_FILE.fflush(l_output);&#10;    ELSE -- write in pieces&#10;        l_start :&#61; 1;&#10;        WHILE l_start &lt; l_len and l_bytelen &gt; 0&#10;        LOOP&#10;            DBMS_LOB.read(l_blob,l_bytelen,l_start,l_vr);&#10;            UTL_FILE.put_raw(l_output,l_vr);&#10;            UTL_FILE.fflush(l_output);&#10;            -- set the start position for the next cut&#10;            l_start :&#61; l_start + l_bytelen;&#10;            -- set the end position if less than 32000 bytes&#10;            x :&#61; x - l_bytelen;&#10;            IF x &lt; 32000 THEN&#10;                l_bytelen :&#61; x;&#10;            END IF;&#10;        END LOOP;&#10;    END IF;&#10;    UTL_FILE.fclose(l_output);&#10;    info(&#39;Document created [&#39; || TO_CHAR(document_id_in) || &#39;.&#39; || l_extension || &#39;]&#39; );&#10;    --&#10;    SELECT&#10;      XMLELEMENT (name &quot;properties&quot;,&#10;                    XMLELEMENT (name &quot;entry&quot;, XMLATTRIBUTES(&#39;documentID&#39; AS &quot;key&quot;), d.document_id || &#39;.&#39; || l_extension),&#10;                    XMLELEMENT (name &quot;entry&quot;, XMLATTRIBUTES(&#39;caseReferenceNumber&#39; AS &quot;key&quot;), o.crn),&#10;                    XMLELEMENT (name &quot;entry&quot;, XMLATTRIBUTES(&#39;documentName&#39; AS &quot;key&quot;), l_filename),&#10;                    XMLELEMENT (name &quot;entry&quot;, XMLATTRIBUTES(&#39;templateName&#39; AS &quot;key&quot;), d.template_name)&#10;                  )&#10;    INTO doc_xml&#10;    FROM&#10;      document d&#10;        INNER JOIN offender o ON d.offender_id &#61; o.offender_id&#10;    WHERE document_id &#61; document_id_in;&#10;    doc :&#61; DBMS_XMLDOM.NewDOMDocument(doc_xml);&#10;    DBMS_XMLDOM.setdoctype(doc &#61;&gt; doc, name &#61;&gt; &#39;properties&#39;, sysid &#61;&gt; &#39;http://java.sun.com/dtd/properties.dtd&#39;, pubid &#61;&gt; &#39;&#39;);&#10;    DBMS_XMLDOM.writetofile(doc, &#39;SPG_DOCUMENT/&#39; || TO_CHAR(document_id_in) || &#39;.&#39; || l_extension || &#39;.metadata.properties.xml&#39;, &#39;UTF-8&#39;);&#10;    info(&#39;Metadata file created [&#39; || TO_CHAR(document_id_in) || &#39;.&#39; || l_extension || &#39;.metadata.properties.xml&#39; || &#39;]&#39;);&#10;    --&#10;    info(&#39;Completed document_to_disk [document_id&#61;&gt;&#39; || TO_CHAR(document_id_in) || &#39;]&#39;);&#10;    --&#10;EXCEPTION&#10;    WHEN no_directory THEN&#10;        fatal(&#39;SPG_DOCUMENT directory not available to process&#39;);&#10;    WHEN OTHERS THEN&#10;        fatal(&#39;Unhandled error detected: &#39; || SQLERRM);&#10;END document_to_disk;&#10;--&#10;--&#10;PROCEDURE offender_documents_to_disk(offender_id_in NUMBER, document_id_in NUMBER DEFAULT NULL)&#10;IS&#10;    CURSOR cur (offender_id_in NUMBER, document_id_in NUMBER) IS&#10;      SELECT  offender_id, document_id&#10;      FROM document&#10;      WHERE offender_id &#61; offender_id_in&#10;        AND  document_id &#61; NVL(document_id_in, document_id);&#10;    --&#10;    cur_rec   cur%ROWTYPE;&#10;    --&#10;BEGIN&#10;    OPEN cur(offender_id_in &#61;&gt; offender_id_in, document_id_in &#61;&gt; document_id_in);&#10;    LOOP&#10;        FETCH cur INTO cur_rec;&#10;        EXIT WHEN cur%NOTFOUND;&#10;        IF cur_rec.document_id IS NOT NULL THEN&#10;            document_to_disk(document_id_in &#61;&gt; cur_rec.document_id);&#10;        END IF;&#10;    END LOOP;&#10;    CLOSE cur;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    fatal(&#39;Unhandled error detected: &#39; || SQLERRM);&#10;END offender_documents_to_disk;&#10;&#10;--&#10;-- Responsible TEAM / OFFICER functions&#10;--&#10;FUNCTION get_responsible_team(&#10;    p_team_id          NUMBER,&#10;    p_provider_team_id NUMBER,&#10;    p_default_value    VARCHAR2 DEFAULT NULL )&#10;RETURN VARCHAR2&#10;IS&#10;    l_ret VARCHAR2(255);&#10;BEGIN&#10;    IF EMPTY2NULL(LTRIM(TRIM(p_default_value), &#39;/&#39;)) IS NOT NULL THEN&#10;        l_ret :&#61; p_default_value;&#10;    ELSIF p_team_id IS NOT NULL THEN&#10;        l_ret :&#61;&#10;            PKG_Lookups.funcgetTabRecord_CACHED(&#10;                p_table    &#61;&gt; &#39;team&#39;,&#10;                p_ref_col  &#61;&gt; &#39;team_id&#39;,&#10;                p_ref_val  &#61;&gt; TO_CHAR(p_team_id),&#10;                p_data_fld &#61;&gt; &#39;CODE || &#39;&#39;/&#39;&#39; || DESCRIPTION&#39; );&#10;    ELSIF p_provider_team_id IS NOT NULL THEN&#10;        l_ret :&#61;&#10;            PKG_Lookups.funcgetTabRecord_CACHED(&#10;                p_table    &#61;&gt; &#39;provider_team&#39;,&#10;                p_ref_col  &#61;&gt; &#39;provider_team_id&#39;,&#10;                p_ref_val  &#61;&gt; TO_CHAR(p_provider_team_id),&#10;                p_data_fld &#61;&gt; &#39;CODE || &#39;&#39;/&#39;&#39; || NAME&#39; );&#10;    END IF;&#10;    --&#10;    RETURN TEAMSUPPORT.formatTeamDescription(l_ret);&#10;END get_responsible_team;&#10;--&#10;FUNCTION get_responsible_staff(&#10;    p_staff_id             NUMBER,&#10;    p_provider_employee_id NUMBER,&#10;    p_default_value        VARCHAR2 DEFAULT NULL )&#10;RETURN VARCHAR2&#10;IS&#10;    l_ret VARCHAR2(255);&#10;BEGIN&#10;    IF EMPTY2NULL(LTRIM(TRIM(p_default_value), &#39;/&#39;)) IS NOT NULL THEN&#10;        l_ret :&#61; p_default_value;&#10;    ELSIF p_staff_id IS NOT NULL THEN&#10;        l_ret :&#61;&#10;            PKG_Lookups.funcgetTabRecord_CACHED(&#10;                p_table    &#61;&gt; &#39;staff&#39;,&#10;                p_ref_col  &#61;&gt; &#39;staff_id&#39;,&#10;                p_ref_val  &#61;&gt; TO_CHAR(p_staff_id),&#10;                p_data_fld &#61;&gt; &#39;Pkg_LstUtl.concat(officer_code, Pkg_LstUtl.concat(TRIM(surname), TRIM(forename), TRIM(forename2), p_delim&#61;&gt;&#39;&#39;,&#39;&#39;), p_delim&#61;&gt;&#39;&#39;/&#39;&#39;, p_max_len&#61;&gt;80)&#39; );&#10;    ELSIF p_provider_employee_id IS NOT NULL THEN&#10;        l_ret :&#61;&#10;            PKG_Lookups.funcgetTabRecord_CACHED(&#10;                p_table    &#61;&gt; &#39;provider_employee&#39;,&#10;                p_ref_col  &#61;&gt; &#39;provider_employee_id&#39;,&#10;                p_ref_val  &#61;&gt; TO_CHAR(p_provider_employee_id),&#10;                p_data_fld &#61;&gt; &#39;Pkg_LstUtl.concat(code, Pkg_LstUtl.concat(TRIM(surname), TRIM(forename), TRIM(forename2), p_delim&#61;&gt;&#39;&#39;,&#39;&#39;), p_delim&#61;&gt;&#39;&#39;/&#39;&#39;, p_max_len&#61;&gt;80)&#39; );&#10;    END IF;&#10;    --&#10;    RETURN STAFFSUPPORT.formatStaffDescription(l_ret);&#10;END get_responsible_staff;&#10;--&#10;FUNCTION get_office_location(&#10;    p_office_location_id   NUMBER,&#10;    p_default_value        VARCHAR2 DEFAULT NULL )&#10;RETURN VARCHAR2&#10;IS&#10;    l_ret VARCHAR2(255);&#10;BEGIN&#10;    IF EMPTY2NULL(LTRIM(TRIM(p_default_value), &#39;/&#39;)) IS NOT NULL THEN&#10;        l_ret :&#61; p_default_value;&#10;    ELSIF p_office_location_id IS NOT NULL THEN&#10;        l_ret :&#61;&#10;            PKG_Lookups.funcgetTabRecord_CACHED(&#10;                p_table    &#61;&gt; &#39;office_location&#39;,&#10;                p_ref_col  &#61;&gt; &#39;office_location_id&#39;,&#10;                p_ref_val  &#61;&gt; TO_CHAR(p_office_location_id),&#10;                p_data_fld &#61;&gt; &#39;code || &#39;&#39;/&#39;&#39; || description&#39; );&#10;    END IF;&#10;    --&#10;    RETURN LOCATIONSUPPORT.formatLocationDescription(l_ret);&#10;END get_office_location;&#10;&#10;--&#10;-- GUID Support Subroutines&#10;--&#10;FUNCTION get_spg_root_table(p_message_id NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN&#10;        PKG_Lookups.funcgetTabRecord_CACHED(&#10;            p_table    &#61;&gt; &#39;business_int_xml_summary&#39;,&#10;            p_ref_col  &#61;&gt; &#39;xml_message_id&#39;,&#10;            p_ref_val  &#61;&gt; TO_CHAR(p_message_id),&#10;            p_data_fld &#61;&gt; &#39;UPPER(TRIM(PKG_LstUtl.list_num_elem(unique_key, &#39;&#39;.&#39;&#39;, 1)))&#39;,&#10;            p_where    &#61;&gt; &#39;xsd_number &#61; 1&#39; );&#10;END get_spg_root_table;&#10;--&#10;FUNCTION get_spg_version_CNT RETURN INTEGER IS&#10;BEGIN&#10;    RETURN CASE WHEN g_spg_version_TAB IS NULL THEN -1 ELSE g_spg_version_TAB.COUNT END;&#10;END get_spg_version_CNT;&#10;--&#10;FUNCTION get_spg_version_TAB RETURN g_spg_version_tab_TYP PIPELINED&#10;IS&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;get_spg_version_TAB&#39;;&#10;    l_rec g_spg_version_rec_TYP;&#10;    --&#10;    l_xml_message_id NUMBER;&#10;    --&#10;    PROCEDURE do_debug IS&#10;    BEGIN&#10;        IF PKG_Debug.funcGetDebugActive THEN&#10;            procDebug(&#10;                l_proc || &#39;: &#39; ||&#10;                &#39;(src_tab&#61;&#39;     || l_rec.source_table_name  || &#39;)&#39; ||&#10;                &#39;(src_action&#61;&#39;  || l_rec.source_action_flag || &#39;)&#39; ||&#10;                &#39;(xml_view&#61;&#39;    || l_rec.xml_view_name      || &#39;)&#39; ||&#10;                &#39;(offender_id&#61;&#39; || l_rec.offender_id        || &#39;)&#39; ||&#10;                &#39;(primary_key&#61;&#39; || l_rec.primary_key_id     || &#39;)&#39;,&#10;                p_trace_level&#61;&gt;15 );&#10;        END IF;&#10;    END do_debug;&#10;    --&#10;BEGIN&#10;    FOR l_idx IN 1..get_spg_version_CNT LOOP&#10;        l_rec :&#61; g_spg_version_TAB(l_idx);&#10;        --&#10;        do_debug;&#10;        --&#10;        PIPE ROW( l_rec );&#10;        --&#10;        l_xml_message_id :&#61; PKG_DynSQL.get_xml_message_id(l_rec.xml_view_name);&#10;        IF l_xml_message_id IN (2002, 2003, 2004, 1023) THEN&#10;            --l_rec :&#61; NULL;&#10;            l_rec.source_table_name   :&#61; l_rec.xml_view_name;&#10;            l_rec.source_action_flag  :&#61; &#39;U&#39;;&#10;            l_rec.xml_view_name       :&#61; PKG_DynSQL.get_xml_view_name(1008);&#10;            --l_rec.offender_id         :&#61; ;&#10;            --l_rec.primary_key_id      :&#61; ;&#10;            --&#10;            do_debug;&#10;            --&#10;            PIPE ROW( l_rec );&#10;            --&#10;        END IF;&#10;        --&#10;    END LOOP;&#10;END get_spg_version_TAB;&#10;--&#10;FUNCTION get_list_of_primary_id_values(&#10;    p_source_table_name  VARCHAR2,&#10;    p_source_action_flag VARCHAR2,&#10;    p_xml_view_name      VARCHAR2,&#10;    p_link_col_name      VARCHAR2,&#10;    p_search_by_key      VARCHAR2,&#10;    p_debug_flag         VARCHAR2 DEFAULT &#39;Y&#39; )&#10;RETURN g_spg_version_tab_TYP PIPELINED&#10;IS&#10;    --&#10;    PRAGMA AUTONOMOUS_TRANSACTION;&#10;    --&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;GET_LIST_OF_PRIMARY_ID_VALUES&#39;;&#10;    --&#10;    l_tab g_spg_version_tab_TYP;&#10;    l_CNT NUMBER;&#10;    l_SQL CLOB;&#10;    --&#10;BEGIN&#10;    IF p_debug_flag &#61; &#39;Y&#39; THEN&#10;        PKG_Debug.procrecordDbStats_START;&#10;    END IF;&#10;    --&#10;    l_SQL :&#61;&#10;       &#39;SELECT&#10;          &#39;&#39;&#39; || p_source_table_name  || &#39;&#39;&#39; AS SOURCE_TABLE_NAME,&#10;          &#39;&#39;&#39; || p_source_action_flag || &#39;&#39;&#39; AS SOURCE_ACTION_FLAG,&#10;          &#39;&#39;&#39; || p_xml_view_name      || &#39;&#39;&#39; AS XML_VIEW_NAME,&#10;          offender_id                        AS OFFENDER_ID,&#10;          unique_key                         AS PRIMARY_KEY_ID&#10;        FROM &#39; || p_xml_view_name || &#39;&#10;        WHERE &#39; || p_link_col_name || &#39; &#61; :p_search_by_key&#39;;&#10;    --&#10;    EXECUTE IMMEDIATE l_SQL BULK COLLECT INTO l_TAB&#10;    USING p_search_by_key;&#10;    --&#10;    l_CNT :&#61; CASE WHEN l_TAB IS NULL THEN -1 ELSE l_TAB.COUNT END;&#10;    --&#10;    FOR l_idx IN 1..l_CNT LOOP&#10;        PIPE ROW( l_TAB(l_idx) );&#10;    END LOOP;&#10;    --&#10;    IF p_debug_flag &#61; &#39;Y&#39; AND PKG_Debug.funcGetDebugActive THEN&#10;        procDebug(&#10;            l_proc || &#39; (rows&#61;&#39; || l_TAB.COUNT  || &#39;)(&#39; || PKG_Debug.funcgetDbStats || &#39;): &#39; ||&#10;            &#39;(src_table&#61;&#39;      || p_source_table_name  || &#39;)&#39; ||&#10;            &#39;(src_action&#61;&#39;     || p_source_action_flag || &#39;)&#39; ||&#10;            &#39;(xml_view_name&#61;&#39;  || p_xml_view_name      || &#39;)&#39; ||&#10;            &#39;(lnk_col&#61;&#39;        || p_link_col_name      || &#39;)&#39; ||&#10;            &#39;(lnk_key&#61;&#39;        || p_search_by_key      || &#39;)&#39; || CHR(10) ||&#10;            l_SQL,&#10;            p_trace_level&#61;&gt;5 );&#10;    END IF;&#10;    --&#10;END get_list_of_primary_id_values;&#10;--&#10;FUNCTION get_guid_tab_deferred_key(p_source_table_name VARCHAR2, p_xml_view_name VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN UPPER(p_source_table_name || &#39;|&#39; || p_xml_view_name);&#10;END get_guid_tab_deferred_key;&#10;--&#10;PROCEDURE update_guid_value(&#10;    p_source_table_name  VARCHAR2,&#10;    p_source_action_flag VARCHAR2,&#10;    p_xml_view_name      VARCHAR2,&#10;    p_link_col_name      VARCHAR2,&#10;    p_search_by_key      VARCHAR2,&#10;    p_deferred_flag      VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_immediate_run_flag VARCHAR2 DEFAULT &#39;N&#39; )&#10;IS&#10;    --&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;UPDATE_GUID_VALUE&#39;;&#10;    --&#10;    l_spg_version SPG_VERSION_ENTRY.spg_version%TYPE;&#10;    l_offender_id SPG_VERSION_ENTRY.offender_id%TYPE;&#10;    l_user_id     USER_.user_id%TYPE;&#10;    l_rows        INTEGER;&#10;    --&#10;    l_SQL VARCHAR2(2048);&#10;    --&#10;    l_rec_deferred g_rec_deferred_TYP;&#10;    l_tab_deferred g_tab_deferred_TYP;&#10;    l_key          VARCHAR2(100);&#10;    --&#10;BEGIN&#10;    --&#10;    IF p_source_action_flag &#61; &#39;D&#39; AND p_source_table_name &#61; &#39;OFFENDER&#39; AND p_deferred_flag &#61; &#39;Y&#39; THEN&#10;        -- Top Level OFFENDER records is being deleted&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    l_key :&#61; get_guid_tab_deferred_key(p_source_table_name, p_xml_view_name);&#10;    --&#10;    l_user_id :&#61; PKG_LOOKUPS.getUserID( p_distinguished_name &#61;&gt; NVL(SYS_CONTEXT(&#39;USERENV&#39;, &#39;CLIENT_IDENTIFIER&#39;), G_SYSTEM_USER_DN) );&#10;    --&#10;    IF NVLSTR(p_deferred_flag, &#39;N&#39;) &#61; &#39;Y&#39; THEN&#10;        --&#10;        IF NOT g_tab_deferred.EXISTS(l_key) THEN&#10;            g_tab_deferred(l_key) :&#61; g_tab_deferred_TYP();&#10;        END IF;&#10;        --&#10;        l_tab_deferred :&#61; g_tab_deferred(l_key);&#10;        --&#10;        l_rec_deferred.source_table_name  :&#61; p_source_table_name;&#10;        l_rec_deferred.source_action_flag :&#61; p_source_action_flag;&#10;        l_rec_deferred.xml_view_name      :&#61; p_xml_view_name;&#10;        l_rec_deferred.link_col_name      :&#61; p_link_col_name;&#10;        l_rec_deferred.search_by_key      :&#61; p_search_by_key;&#10;        l_tab_deferred.EXTEND;&#10;        l_tab_deferred(l_tab_deferred.COUNT) :&#61; l_rec_deferred;&#10;        --&#10;        g_tab_deferred(l_key) :&#61; l_tab_deferred;&#10;        --&#10;        IF p_immediate_run_flag &#61; &#39;Y&#39; THEN&#10;            PKG_SPG_SUPPORT.update_guid_value(&#10;                p_source_table_name  &#61;&gt; p_source_table_name,&#10;                p_source_action_flag &#61;&gt; p_source_action_flag,&#10;                p_xml_view_name      &#61;&gt; p_xml_view_name,&#10;                p_link_col_name      &#61;&gt; p_link_col_name,&#10;                p_search_by_key      &#61;&gt; p_search_by_key,&#10;                p_deferred_flag      &#61;&gt; &#39;N&#39; );&#10;        END IF;&#10;        --&#10;    ELSE&#10;        IF g_tab_deferred.EXISTS(l_key) THEN&#10;            --&#10;            l_tab_deferred :&#61; g_tab_deferred(l_key);&#10;            --&#10;            FOR l_idx IN 1..l_tab_deferred.COUNT LOOP&#10;                --&#10;                l_rec_deferred :&#61; l_tab_deferred(l_idx);&#10;                --&#10;                PKG_Debug.procrecordDbStats_START;&#10;                --&#10;                IF UPPER(p_source_action_flag) &#61; &#39;D&#39; THEN&#10;                    l_SQL :&#61;&#10;                       &#39;SELECT&#10;                          source_table_name,&#10;                          source_action_flag,&#10;                          xml_view_name,&#10;                          offender_id,&#10;                          primary_key_id&#10;                        FROM TABLE( PKG_SPG_SUPPORT.get_list_of_primary_id_values(&#10;                                        p_source_table_name  &#61;&gt; &#39;&#39;&#39; || l_rec_deferred.source_table_name  || &#39;&#39;&#39;,&#10;                                        p_source_action_flag &#61;&gt; &#39;&#39;&#39; || l_rec_deferred.source_action_flag || &#39;&#39;&#39;,&#10;                                        p_xml_view_name      &#61;&gt; &#39;&#39;&#39; || l_rec_deferred.xml_view_name      || &#39;&#39;&#39;,&#10;                                        p_link_col_name      &#61;&gt; &#39;&#39;&#39; || l_rec_deferred.link_col_name      || &#39;&#39;&#39;,&#10;                                        p_search_by_key      &#61;&gt; :p_search_by_key,&#10;                                        p_debug_flag         &#61;&gt; &#39;&#39;N&#39;&#39; ) )&#39;;&#10;                ELSE&#10;                    l_SQL :&#61;&#10;                       &#39;SELECT DISTINCT&#10;                          &#39;&#39;&#39; || l_rec_deferred.source_table_name  || &#39;&#39;&#39; AS SOURCE_TABLE_NAME,&#10;                          &#39;&#39;&#39; || l_rec_deferred.source_action_flag || &#39;&#39;&#39; AS SOURCE_ACTION_FLAG,&#10;                          &#39;&#39;&#39; || l_rec_deferred.xml_view_name      || &#39;&#39;&#39; AS XML_VIEW_NAME,&#10;                          offender_id                                     AS OFFENDER_ID,&#10;                          unique_key                                      AS PRIMARY_KEY_ID&#10;                        FROM &#39; || l_rec_deferred.xml_view_name || &#39;&#10;                        WHERE &#39; || l_rec_deferred.link_col_name || &#39; &#61; :p_search_by_key&#39;;&#10;                END IF;&#10;                --&#10;                EXECUTE IMMEDIATE l_SQL BULK COLLECT INTO g_spg_version_TAB&#10;                USING l_rec_deferred.search_by_key;&#10;                --&#10;                IF g_spg_version_TAB IS NOT NULL AND g_spg_version_TAB.COUNT &gt; 0 THEN&#10;                    l_offender_id :&#61; g_spg_version_TAB(1).offender_id;&#10;                    l_spg_version :&#61; SYS_GUID();&#10;                    l_rows        :&#61; g_spg_version_TAB.COUNT;&#10;                ELSE&#10;                    l_offender_id :&#61; -1;&#10;                    l_rows        :&#61; 0;&#10;                END IF;&#10;                --&#10;                IF PKG_Debug.funcGetDebugActive THEN&#10;                    procDebug(&#10;                        l_proc || &#39; (rows_1&#61;&#39; || l_rows  || &#39;)(&#39; || PKG_Debug.funcgetDbStats || &#39;): &#39; ||&#10;                        &#39;(src_table&#61;&#39;      || l_rec_deferred.source_table_name  || &#39;)&#39; ||&#10;                        &#39;(src_action&#61;&#39;     || l_rec_deferred.source_action_flag || &#39;)&#39; ||&#10;                        &#39;(xml_view_name&#61;&#39;  || l_rec_deferred.xml_view_name      || &#39;)&#39; ||&#10;                        &#39;(lnk_col&#61;&#39;        || l_rec_deferred.link_col_name      || &#39;)&#39; ||&#10;                        &#39;(lnk_key&#61;&#39;        || l_rec_deferred.search_by_key      || &#39;)&#39; ||&#10;                        &#39;(GUID&#61;&#39;           || TO_CHAR(l_spg_version)            || &#39;)&#39; ||&#10;                        &#39;(offender_id&#61;&#39;    || l_offender_id                     || &#39;)&#39; || CHR(10) ||&#10;                        l_SQL,&#10;                        p_trace_level&#61;&gt;5 );&#10;                END IF;&#10;                --&#10;                PKG_Debug.procrecordDbStats_START;&#10;                --&#10;                l_SQL :&#61;&#10;                   &#39;MERGE INTO spg_version_entry T&#10;                    USING (&#10;                      SELECT DISTINCT source_table_name, source_action_flag, xml_view_name, offender_id, primary_key_id&#10;                      FROM TABLE( PKG_SPG_SUPPORT.get_spg_version_TAB )&#10;                      WHERE xml_view_name  IS NOT NULL&#10;                        AND primary_key_id IS NOT NULL&#10;                    ) T1&#10;                    ON ( T.current_record_flag &#61; &#39;&#39;Y&#39;&#39;            AND&#10;                         T.table_name          &#61; T1.xml_view_name AND&#10;                         T.primary_key_id      &#61; T1.primary_key_id&#10;                       )&#10;                    WHEN NOT MATCHED THEN&#10;                      INSERT ( spg_version_entry_id            , source_table_name   , source_action_flag   , table_name      , offender_id   , primary_key_id   , action_flag, current_record_flag, spg_version   , row_version, created_datetime, last_updated_datetime, last_updated_user_id )&#10;                      VALUES ( spg_version_entry_ID_SEQ.NEXTVAL, T1.source_table_name, T1.source_action_flag, T1.xml_view_name, T1.offender_id, T1.primary_key_id,       &#39;&#39;I&#39;&#39;,               &#39;&#39;Y&#39;&#39;, :p_spg_version,           0,          SYSDATE, SYSDATE, :p_last_updated_user_id )&#10;                    WHEN MATCHED THEN&#10;                      UPDATE SET&#10;                        --current_record_flag   &#61; &#39;&#39;Y&#39;&#39;,&#10;                        source_table_name     &#61; T1.source_table_name,&#10;                        source_action_flag    &#61; T1.source_action_flag,&#10;                        action_flag           &#61; &#39;&#39;U&#39;&#39;,&#10;                        spg_version           &#61; ( CASE WHEN T1.source_action_flag &#61; &#39;&#39;D&#39;&#39; THEN spg_version ELSE :p_spg_version END ),&#10;                        row_version           &#61; NVL(row_version, 0) + 1,&#10;                        last_updated_datetime &#61; SYSDATE,&#10;                        last_updated_user_id  &#61; :p_last_updated_user_id&#39;&#10;                ;&#10;                --&#10;                EXECUTE IMMEDIATE l_SQL&#10;                USING&#10;                  l_spg_version,&#10;                  l_user_id,&#10;                  --l_rec_deferred.source_table_name,&#10;                  --l_rec_deferred.source_action_flag,&#10;                  --l_rec_deferred.source_action_flag,&#10;                  l_spg_version,&#10;                  l_user_id&#10;                ;&#10;                l_rows :&#61; SQL%ROWCOUNT;&#10;                --&#10;                IF PKG_Debug.funcGetDebugActive THEN&#10;                    procDebug(&#10;                        l_proc || &#39; (rows_2&#61;&#39; || l_rows  || &#39;)(&#39; || PKG_Debug.funcgetDbStats || &#39;): &#39; ||&#10;                        &#39;(src_table&#61;&#39;      || l_rec_deferred.source_table_name  || &#39;)&#39; ||&#10;                        &#39;(src_action&#61;&#39;     || l_rec_deferred.source_action_flag || &#39;)&#39; ||&#10;                        &#39;(xml_view_name&#61;&#39;  || l_rec_deferred.xml_view_name || &#39;)&#39; ||&#10;                        &#39;(lnk_col&#61;&#39;        || l_rec_deferred.link_col_name || &#39;)&#39; ||&#10;                        &#39;(lnk_key&#61;&#39;        || l_rec_deferred.search_by_key || &#39;)&#39; ||&#10;                        &#39;(GUID&#61;&#39;           || CASE WHEN p_source_action_flag &#61; &#39;D&#39; THEN &#39;UNCHANGED&#39; ELSE TO_CHAR(l_spg_version) END || &#39;)&#39; ||&#10;                        &#39;(offender_id&#61;&#39;    || l_offender_id                || &#39;)&#39; || CHR(10) ||&#10;                        l_SQL,&#10;                        p_trace_level&#61;&gt;5 );&#10;                END IF;&#10;                --&#10;            END LOOP; --FOR l_idx IN 1..l_tab_deferred.COUNT&#10;            --&#10;            g_tab_deferred.DELETE(l_key);&#10;            --&#10;        END IF; --IF g_tab_deferred.EXISTS(l_key)&#10;        --&#10;    END IF; --IF NVLSTR(p_deferred_flag, &#39;N&#39;) &#61; &#39;Y&#39;&#10;    --&#10;EXCEPTION WHEN NO_DATA_FOUND THEN&#10;    procDebug(&#10;        l_proc || &#39; WARNING: &#39; || SQLERRM ||&#10;        &#39;(deferred_flag&#61;&#39;  || p_deferred_flag                   || &#39;)&#39; ||&#10;        &#39;(src_table&#61;&#39;      || l_rec_deferred.source_table_name  || &#39;)&#39; ||&#10;        &#39;(src_action&#61;&#39;     || l_rec_deferred.source_action_flag || &#39;)&#39; ||&#10;        &#39;(xml_view_name&#61;&#39;  || p_xml_view_name                   || &#39;)&#39; ||&#10;        &#39;(lnk_col&#61;&#39;        || p_link_col_name                   || &#39;)&#39; ||&#10;        &#39;(lnk_key&#61;&#39;        || p_search_by_key                   || &#39;)&#39; ||&#10;        &#39;(GUID&#61;&#39;           || CASE WHEN p_source_action_flag &#61; &#39;D&#39; THEN &#39;UNCHANGED&#39; ELSE TO_CHAR(l_spg_version) END || &#39;)&#39; ||&#10;        &#39;(offender_id&#61;&#39;    || l_offender_id                     || &#39;)&#39; || CHR(10) ||&#10;        l_SQL,&#10;        p_trace_level&#61;&gt;0);&#10;WHEN OTHERS THEN&#10;    procDebug(&#10;        l_proc || &#39; ERROR: &#39; || SQLERRM ||&#10;        &#39;(deferred_flag&#61;&#39;  || p_deferred_flag                   || &#39;)&#39; ||&#10;        &#39;(src_table&#61;&#39;      || l_rec_deferred.source_table_name  || &#39;)&#39; ||&#10;        &#39;(src_action&#61;&#39;     || l_rec_deferred.source_action_flag || &#39;)&#39; ||&#10;        &#39;(xml_view_name&#61;&#39;  || p_xml_view_name                   || &#39;)&#39; ||&#10;        &#39;(lnk_col&#61;&#39;        || p_link_col_name                   || &#39;)&#39; ||&#10;        &#39;(lnk_key&#61;&#39;        || p_search_by_key                   || &#39;)&#39; ||&#10;        &#39;(GUID&#61;&#39;           || CASE WHEN p_source_action_flag &#61; &#39;D&#39; THEN &#39;UNCHANGED&#39; ELSE TO_CHAR(l_spg_version) END || &#39;)&#39; ||&#10;        &#39;(offender_id&#61;&#39;    || l_offender_id                     || &#39;)&#39; || CHR(10) ||&#10;        l_SQL,&#10;        p_trace_level&#61;&gt;0);&#10;    RAISE;&#10;END update_guid_value;&#10;--&#10;FUNCTION get_update_guid_pending_cnt(p_source_table_name VARCHAR2, p_xml_view_name VARCHAR2) RETURN NUMBER&#10;IS&#10;    l_key VARCHAR2(100);&#10;    l_cnt NUMBER;&#10;BEGIN&#10;    l_key :&#61; get_guid_tab_deferred_key(p_source_table_name, p_xml_view_name);&#10;    IF g_tab_deferred.EXISTS(l_key) THEN&#10;        l_cnt :&#61; g_tab_deferred(l_key).COUNT;&#10;    ELSE&#10;        l_cnt :&#61; 0;&#10;    END IF;&#10;    --&#10;    RETURN l_cnt;&#10;END get_update_guid_pending_cnt;&#10;--&#10;PROCEDURE do_insert_spg_version(p_xml_message_id NUMBER, p_search_by_key VARCHAR2, p_spg_version SPG_VERSION_ENTRY.spg_version%TYPE)&#10;IS&#10;    --&#10;    PRAGMA AUTONOMOUS_TRANSACTION;&#10;    --&#10;    l_view_name   VARCHAR2(30) :&#61; PKG_DynSQL.get_xml_view_name(p_xml_message_id &#61;&gt; p_xml_message_id, p_xsd_number &#61;&gt; 1);&#10;    l_offender_id NUMBER;&#10;    l_user_id     NUMBER;&#10;    --&#10;BEGIN&#10;    --&#10;    l_offender_id :&#61;&#10;        PKG_Lookups.funcgetTabRecord(&#10;            p_table       &#61;&gt; l_view_name,&#10;            p_ref_col     &#61;&gt; &#39;UNIQUE_KEY&#39;,&#10;            p_ref_val     &#61;&gt; p_search_by_key,&#10;            p_data_fld    &#61;&gt; &#39;offender_id&#39;,&#10;            p_default_val &#61;&gt; &#39;-1&#39; );&#10;    --&#10;    IF l_offender_id &gt; 0 THEN&#10;        --&#10;        l_user_id :&#61; PKG_LOOKUPS.getUserID( p_distinguished_name &#61;&gt; NVL(SYS_CONTEXT(&#39;USERENV&#39;, &#39;CLIENT_IDENTIFIER&#39;), G_SYSTEM_USER_DN) );&#10;        --&#10;        INSERT INTO spg_version_entry(&#10;          spg_version_entry_id,&#10;          table_name,&#10;          primary_key_id,&#10;          spg_version,&#10;          action_flag,&#10;          current_record_flag,&#10;          row_version,&#10;          created_datetime,&#10;          last_updated_datetime,&#10;          offender_id,&#10;          business_interaction_id,&#10;          source_table_name,&#10;          source_action_flag,&#10;          last_updated_user_id&#10;        ) VALUES (&#10;          spg_version_entry_id_seq.NEXTVAL,&#10;          l_view_name,&#10;          p_search_by_key,&#10;          p_spg_version,&#10;          &#39;I&#39;,&#10;          &#39;Y&#39;,&#10;          0,&#10;          SYSDATE,&#10;          SYSDATE,&#10;          l_offender_id,&#10;          &#39;&#39;,&#10;          &#39;LAZY_SEED&#39;,&#10;          &#39;I&#39;,&#10;          l_user_id );&#10;        --&#10;        COMMIT;&#10;    END IF;&#10;END do_insert_spg_version;&#10;--&#10;FUNCTION get_guid_value(p_xml_message_id NUMBER, p_search_by_key VARCHAR2, p_persist_flag VARCHAR2 DEFAULT &#39;Y&#39;) RETURN VARCHAR2 --SPG_VERSION_ENTRY.spg_version%TYPE&#10;IS&#10;    --&#10;    l_table_name VARCHAR2(30);&#10;    l_GUID       SPG_VERSION_ENTRY.spg_version%TYPE;&#10;    --&#10;    CURSOR cs IS&#10;      SELECT spg_version&#10;      FROM SPG_VERSION_ENTRY&#10;      WHERE primary_key_id &#61; p_search_by_key&#10;        AND current_record_flag &#61; &#39;Y&#39;&#10;        AND table_name &#61; l_table_name;&#10;    --&#10;BEGIN&#10;    l_table_name :&#61; PKG_DynSQL.get_xml_view_name(p_xml_message_id, p_xsd_number&#61;&gt;1);&#10;    OPEN cs;&#10;    FETCH cs INTO l_GUID;&#10;    --&#10;    IF cs%NOTFOUND THEN&#10;        l_GUID :&#61; SYS_GUID();&#10;        IF p_persist_flag &#61; &#39;Y&#39; THEN&#10;            do_insert_spg_version(p_xml_message_id, p_search_by_key, l_GUID);&#10;        END IF;&#10;    END IF;&#10;    --&#10;    IF cs%ISOPEN THEN&#10;        CLOSE cs;&#10;    END IF;&#10;    --&#10;    RETURN RAWTOHEX(l_GUID);&#10;END get_guid_value;&#10;--&#10;PROCEDURE update_guid_values_for_CLOB(&#10;    p_table_name    VARCHAR2,&#10;    p_search_by_key VARCHAR2,&#10;    p_pk_fld_name   VARCHAR2,&#10;    p_clob_fld_name VARCHAR2,&#10;    p_trigger_name  VARCHAR2 DEFAULT NULL )&#10;IS&#10;    lc_proc CONSTANT VARCHAR2(30) :&#61; &#39;update_guid_values_for_CLOB&#39;;&#10;    --&#10;    CURSOR cs IS&#10;      SELECT&#10;        xml_message_id,&#10;        PKG_DynSQL.get_xml_view_name(xml_message_id) AS xml_view_name&#10;      FROM business_int_xml_detail T&#10;      WHERE xsd_number &#61; 1&#10;        AND source_table &#61; UPPER(p_table_name)&#10;        AND source_column &#61; UPPER(p_clob_fld_name)&#10;        AND EXISTS(&#10;            SELECT 1 FROM business_int_xml_detail&#10;            WHERE xml_message_id &#61; T.xml_message_id&#10;              AND source_column &#61; UPPER(p_pk_fld_name)&#10;              AND xsd_number &#61; T.xsd_number );&#10;    l_rec cs%ROWTYPE;&#10;    --&#10;BEGIN&#10;    --&#10;    IF PKG_Debug.funcGetDebugActive THEN&#10;        procDebug(&#39;PKG_SPG_SUPPORT.&#39; || lc_proc || &#39;(&#39; ||&#10;            p_table_name    || &#39;, &#39; ||&#10;            p_search_by_key || &#39;, &#39; ||&#10;            p_pk_fld_name   || &#39;, &#39; ||&#10;            p_clob_fld_name || &#39;, &#39; ||&#10;            p_trigger_name  || &#39;)&#39;,&#10;            --&#10;            p_trace_level &#61;&gt; 5 );&#10;    END IF;&#10;    --&#10;    OPEN cs;&#10;    LOOP&#10;        FETCH cs INTO l_rec;&#10;        EXIT WHEN cs%NOTFOUND;&#10;        --&#10;        IF PKG_Debug.funcGetDebugActive THEN&#10;            procDebug(&#10;                NVLSTR(p_trigger_name, UPPER(lc_proc)) || &#39;.PKG_SPG_SUPPORT.update_guid_value(&#39; ||&#10;                p_table_name || &#39;, &#39; ||&#10;                &#39;U&#39; || &#39;, &#39; ||&#10;                l_rec.xml_view_name || &#39;, &#39; ||&#10;                p_pk_fld_name || &#39;, &#39; ||&#10;                p_search_by_key || &#39;, &#39; ||&#10;                &#39;deferred_flag&#61;Y)&#39;,&#10;                --&#10;                p_trace_level &#61;&gt; 5 );&#10;        END IF;&#10;        --&#10;        PKG_SPG_SUPPORT.update_guid_value(&#10;            p_source_table_name  &#61;&gt; p_table_name,&#10;            p_source_action_flag &#61;&gt; &#39;U&#39;,&#10;            p_xml_view_name      &#61;&gt; l_rec.xml_view_name,&#10;            p_link_col_name      &#61;&gt; UPPER(p_pk_fld_name),&#10;            p_search_by_key      &#61;&gt; p_search_by_key,&#10;            p_deferred_flag      &#61;&gt; &#39;Y&#39; );&#10;        --&#10;    END LOOP;&#10;    IF cs%ISOPEN THEN&#10;        CLOSE cs;&#10;    END IF;&#10;    --&#10;END update_guid_values_for_CLOB;&#10;&#10;--&#10;FUNCTION compare_inbound_guid(xmlmessagename_in IN VARCHAR2, searchkey_in IN VARCHAR2, inboundguidvalue_in IN VARCHAR2) RETURN NUMBER&#10;IS&#10;  l_ret           NUMBER :&#61; 0;&#10;BEGIN&#10;  IF get_guid_value(  p_xml_message_id &#61;&gt; SPGCONFIG.get_xml_message_id( xmlmessagename_in ),&#10;                      p_search_by_key &#61;&gt; searchkey_in) &#61; inboundguidvalue_in THEN&#10;    l_ret :&#61; 1;&#10;  END IF;&#10;  --&#10;  RETURN l_ret;&#10;  --&#10;END compare_inbound_guid;&#10;--&#10;FUNCTION get_username_value(p_xml_message_id NUMBER, p_search_by_key VARCHAR2) RETURN VARCHAR2&#10;IS&#10;    --&#10;    l_table_name VARCHAR2(30);&#10;    l_spg_user   VARCHAR2(70);&#10;    --&#10;    CURSOR cs IS&#10;      SELECT PKG_LOOKUPS.getusername(p_user_id &#61;&gt; last_updated_user_id)&#10;      FROM SPG_VERSION_ENTRY&#10;      WHERE primary_key_id &#61; p_search_by_key&#10;        AND current_record_flag &#61; &#39;Y&#39;&#10;        AND table_name &#61; l_table_name;&#10;    --&#10;BEGIN&#10;    l_table_name :&#61; PKG_DynSQL.get_xml_view_name(p_xml_message_id);&#10;    OPEN cs;&#10;    FETCH cs INTO l_spg_user;&#10;    --&#10;    IF cs%NOTFOUND THEN&#10;        l_spg_user :&#61; PKG_LOOKUPS.getusername(p_user_id &#61;&gt; 1);&#10;    END IF;&#10;    --&#10;    RETURN l_spg_user;&#10;END get_username_value;&#10;--&#10;--&#10;FUNCTION get_delete_elements(xmlmessageid_in IN VARCHAR2) RETURN delete_elements_tab_TYP&#10;IS&#10;    --&#10;    delete_elements PKG_SPG_SUPPORT.delete_elements_tab_TYP;&#10;    --&#10;    CURSOR cs(p_message_id IN NUMBER) IS&#10;              SELECT  BIXS.xml_message_id,&#10;                      BIXS.xml_message_name,&#10;                      BIXS.xml_message_name || CASE WHEN BIXS.xml_message_id IN (2022, 2023, 2024) THEN&#10;                                                   &#39;Details&#39;&#10;                                               ELSE&#10;                                                   &#39;DetailsD&#39;&#10;                                               END root_element_name,&#10;                      CASE&#10;                        WHEN BIXS.xml_message_id &#61; 1007 THEN&#10;                            &#39;ProposedRequirementD&#39;&#10;                        WHEN BIXS.xml_message_id &#61; 1020 THEN&#10;                            &#39;CommunityRequirementD&#39;&#10;                        WHEN BIXS.xml_message_id &#61; 1022 THEN&#10;                            &#39;PSSRequirementD&#39;&#10;                        WHEN BIXS.xml_message_id &#61; 1024 THEN&#10;                            &#39;CustodyKeyDateD&#39;&#10;                        WHEN BIXS.xml_message_id &#61; 1026 THEN&#10;                            &#39;AdditionalSentenceD&#39;&#10;                        WHEN BIXS.xml_message_id &#61; 1048 THEN&#10;                            &#39;ProcessContactD&#39;&#10;                        WHEN BIXS.xml_message_id &#61; 1055 THEN&#10;                            &#39;RateCardInterventionD&#39;&#10;                        WHEN BIXS.xml_message_id &#61; 1060 THEN&#10;                            &#39;ProviderLAODetailsD&#39;&#10;                        WHEN BIXS.xml_message_id &#61; 1061 THEN&#10;                            &#39;NatOffenderAlertD&#39;&#10;                        WHEN BIXS.xml_message_id &#61; 2022 THEN&#10;                            &#39;CustodyReleaseUndo&#39;&#10;                        WHEN BIXS.xml_message_id &#61; 2023 THEN&#10;                            &#39;CustodyRecallUndo&#39;&#10;                        WHEN BIXS.xml_message_id &#61; 2024 THEN&#10;                            &#39;CustodyPSSUndo&#39;&#10;                        WHEN UPPER(SUBSTR(BIXS.unique_key,1,3)) IN ( &#39;UPW&#39;, &#39;PSS&#39;) THEN&#10;                            REPLACE(REPLACE(INITCAP(SUBSTR(BIXS.unique_key,1,INSTR(BIXS.unique_key,&#39;.&#39;)-1)),&#39;_&#39;) || &#39;D&#39;, INITCAP(SUBSTR(BIXS.unique_key,1,3)), UPPER(SUBSTR(BIXS.unique_key,1,3)))&#10;                        WHEN BIXS.xml_message_id IN (1013,1026) THEN&#10;                            &#39;Offender&#39; || REPLACE(INITCAP(SUBSTR(BIXS.unique_key,1,INSTR(BIXS.unique_key,&#39;.&#39;)-1)),&#39;_&#39;) || &#39;D&#39;&#10;                        ELSE REPLACE(INITCAP(SUBSTR(BIXS.unique_key,1,INSTR(BIXS.unique_key,&#39;.&#39;)-1)),&#39;_&#39;) || &#39;D&#39;&#10;                      END group_element_name,&#10;                      BIXS.unique_key,&#10;                      BIXD.xml_field_name&#10;              FROM&#10;                business_int_xml_summary BIXS&#10;                  INNER JOIN business_int_xml_detail BIXD&#10;                    ON BIXS.xml_message_id &#61; BIXD.xml_message_id&#10;                       AND BIXD.include_in_delete_flag &#61; &#39;Y&#39;&#10;                       AND BIXD.xsd_number &#61; BIXS.xsd_number&#10;              WHERE EXISTS (  SELECT 1&#10;                              FROM business_int_xml_detail BIXD1&#10;                              WHERE BIXD1.xml_message_id &#61; BIXS.xml_message_id&#10;                                AND BIXD1.include_in_delete_flag &#61; &#39;Y&#39;&#10;                                AND BIXD1.xsd_number &#61; BIXS.xsd_number )&#10;                AND BIXS.xml_message_id &#61; p_message_id&#10;                AND BIXS.xsd_number &#61; NVL(SPGMESSAGE.GC_SCHEMA_NUMBER, 1)&#10;              ORDER BY BIXS.xml_message_id, BIXD.xml_field_id;&#10;    --&#10;    not_enough_elements   EXCEPTION;&#10;    PRAGMA EXCEPTION_INIT (not_enough_elements, -20100);&#10;BEGIN&#10;    g_procedure_name :&#61; &#39;get_delete_elements&#39;;&#10;    g_label :&#61; &#39;001000&#39;;&#10;    --&#10;    info(&#39;Opening cursor for delete elements [&#39; || xmlmessageid_in || &#39;]&#39; );&#10;    OPEN cs(p_message_id &#61;&gt; xmlmessageid_in);&#10;      FETCH cs BULK COLLECT INTO delete_elements LIMIT 5;&#10;      g_label :&#61; &#39;001010&#39;;&#10;      info(delete_elements.COUNT || &#39; elements returned&#39;);&#10;    CLOSE cs;&#10;    --&#10;    IF delete_elements.COUNT &lt;&gt; 5 THEN&#10;        RAISE not_enough_elements;&#10;    END IF;&#10;    --&#10;    RETURN delete_elements;&#10;    --&#10;EXCEPTION&#10;  WHEN not_enough_elements THEN&#10;      fatal(&#39;Insufficient delete elements returned for message_id&#39;);&#10;  WHEN OTHERS THEN&#10;      RAISE;&#10;END get_delete_elements;&#10;--&#10;-- SPG_SEED_METADATA support subroutines&#10;--&#10;PROCEDURE do_ins_S(&#10;    p_xml_message_id        VARCHAR2,&#10;    p_xml_message_name      VARCHAR2,&#10;    p_source_tables         VARCHAR2,&#10;    p_where_clause          VARCHAR2,&#10;    p_where_clause1         VARCHAR2,&#10;    p_hier_level            NUMBER,&#10;    p_level_order_by        NUMBER,&#10;    p_unique_key            VARCHAR2,&#10;    p_fk_key                VARCHAR2,&#10;    p_parent_xml_message_id VARCHAR2,&#10;    p_Notes                 VARCHAR2,&#10;    p_xsd_number      NUMBER DEFAULT 1)&#10;IS&#10;BEGIN&#10;    INSERT INTO business_int_xml_summary(&#10;      xml_message_id,&#10;      xml_message_name,&#10;      source_tables,&#10;      where_clause,&#10;      where_clause1,&#10;      hierarchy_level,&#10;      level_order_by,&#10;      unique_key,&#10;      fk_key,&#10;      parent_xml_message_id,&#10;      Notes,&#10;      xsd_number&#10;    ) VALUES (&#10;      p_xml_message_id,&#10;      p_xml_message_name,&#10;      p_source_tables,&#10;      p_where_clause,&#10;      p_where_clause1,&#10;      p_hier_level,&#10;      p_level_order_by,&#10;      p_unique_key,&#10;      p_fk_key,&#10;      p_parent_xml_message_id,&#10;      p_Notes,&#10;      p_xsd_number );&#10;END do_ins_S;&#10;--&#10;PROCEDURE do_ins_D(&#10;    p_xml_message_id      VARCHAR2,&#10;    p_xml_field_id        NUMBER,&#10;    p_source_table        VARCHAR2,&#10;    p_source_column       VARCHAR2,&#10;    p_target_sql_expr     VARCHAR2,&#10;    p_target_table        VARCHAR2,&#10;    p_xml_field_name      VARCHAR2,&#10;    p_xml_identifier_flag VARCHAR2,&#10;    p_xml_data_type       VARCHAR2,&#10;    p_xml_min_occurs      NUMBER,&#10;    p_xml_max_occurs      NUMBER,&#10;    p_ref_data_flag       VARCHAR2,&#10;    p_xml_min_length      NUMBER,&#10;    p_xml_max_length      NUMBER,&#10;    p_referential_flag    VARCHAR2,&#10;    p_Notes               VARCHAR2,&#10;    p_include_in_del_msg  VARCHAR2,&#10;    p_xsd_number    NUMBER DEFAULT 1)&#10;IS&#10;BEGIN&#10;    INSERT INTO business_int_xml_detail(&#10;      business_int_xml_detail_ID,&#10;      xml_message_id, xml_field_id, source_table, source_column, target_sql_expression, target_table,&#10;      xml_field_name, xml_identifier_flag, xml_data_type, xml_minimum_occurances, xml_maximum_occurances,&#10;      reference_data_flag, xml_minimum_length, xml_maximum_length, referential_flag, Notes,&#10;      include_in_delete_flag, xsd_number&#10;    ) VALUES (&#10;      business_int_xml_detail_ID_SEQ.NEXTVAL,&#10;      p_xml_message_id, p_xml_field_id, p_source_table, p_source_column, p_target_sql_expr, p_target_table,&#10;      p_xml_field_name, NVL(p_xml_identifier_flag, &#39;N&#39;), p_xml_data_type, p_xml_min_occurs, p_xml_max_occurs,&#10;      p_ref_data_flag, p_xml_min_length, p_xml_max_length, p_referential_flag, p_Notes,&#10;      p_include_in_del_msg, p_xsd_number );&#10;END do_ins_D;&#10;--&#10;PROCEDURE do_ins_M(&#10;      p_business_interaction_id NUMBER,&#10;      p_root_xml_message_id     VARCHAR2,&#10;      p_xml_message_name        VARCHAR2,&#10;      p_inc_xml_msg_list        VARCHAR2,&#10;      p_excl_xml_msg_list       VARCHAR2,&#10;      p_data_update_mode        VARCHAR2,&#10;      p_xsd_number              NUMBER )&#10;IS&#10;BEGIN&#10;    INSERT INTO business_int_xml_map(&#10;      business_int_xml_map_ID,&#10;      business_interaction_id, root_xml_message_id, xml_message_name,&#10;      include_xml_message_list, exclude_xml_message_list, data_update_mode, xsd_number&#10;    ) VALUES (&#10;      business_int_xml_map_ID_SEQ.NEXTVAL,&#10;      p_business_interaction_id, p_root_xml_message_id, p_xml_message_name,&#10;      p_inc_xml_msg_list, p_excl_xml_msg_list, p_data_update_mode, p_xsd_number );&#10;END do_ins_M;&#10;--&#10;--&#10;FUNCTION bisCRCExport (offenderid_in IN NUMBER) RETURN BOOLEAN&#10;IS&#10;BEGIN&#10;    RETURN&#10;        ( &#39;Y&#39; &#61;&#10;          PKG_Lookups.funcgetTabRecord(&#10;              p_table    &#61;&gt; &#39;offender_crc_export&#39;,&#10;              p_ref_col  &#61;&gt; &#39;offender_id&#39;,&#10;              p_ref_val  &#61;&gt; TO_CHAR(offenderid_in),&#10;              p_data_fld &#61;&gt; &#39;CASE WHEN COUNT(1) &gt; 0 THEN &#39;&#39;Y&#39;&#39; ELSE &#39;&#39;N&#39;&#39; END&#39;,&#10;              p_default_val &#61;&gt; &#39;&#39;&#39;N&#39;&#39;&#39; )&#10;        );&#10;END bisCRCExport;&#10;--&#10;--&#10;FUNCTION isCRCExport (offenderid_in IN NUMBER) RETURN VARCHAR2&#10;IS&#10;  l_ret   VARCHAR2(1) :&#61; &#39;N&#39;;&#10;BEGIN&#10;  IF bisCRCExport(offenderid_in) THEN&#10;    l_ret :&#61; &#39;Y&#39;;&#10;  END IF;&#10;  --&#10;  RETURN l_ret;&#10;END isCRCExport;&#10;--&#10;--&#10;PROCEDURE change_capture_case_allocation(caseAllocationID_in NUMBER)&#10;IS&#10;    --&#10;    l_case_allocation_id          CASE_ALLOCATION.case_allocation_id%TYPE;&#10;    l_existing                    VARCHAR2(1);&#10;    --&#10;    l_referral_id                 REFERRAL.referral_id%TYPE;&#10;    l_assessment_id               ASSESSMENT.assessment_id%TYPE;&#10;    --&#10;    l_referral_type_id            REFERRAL.referral_type_id%TYPE;&#10;    l_referral_source_id          REFERRAL.referral_source_id%TYPE;&#10;    l_generic_referral_outcome_id REFERRAL.generic_referral_outcome_id%TYPE;&#10;    --&#10;    l_assessment_type_id          ASSESSMENT.assessment_type_id%TYPE;&#10;    l_assessment_code             R_STANDARD_REFERENCE_LIST.code_value%TYPE;&#10;    l_assessment_outcome_id       R_ASSESSMENT_OUTCOME.assessment_outcome_id%TYPE;&#10;    --&#10;BEGIN&#10;    --&#10;    -- NDM-140: suppress REFERRAL/ASSESSMENT creation during the new MMS Offender Merge run&#10;    IF PKG_MERGE_OFFENDER.get_merge_running_flag &#61; &#39;Y&#39; THEN&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    l_case_allocation_id :&#61; caseAllocationID_in;&#10;    --&#10;    BEGIN&#10;      SELECT case_allocation_link.referral_id, NVL(assessment.assessment_id,ASSESSMENT_ID_SEQ.NEXTVAL)  INTO l_referral_id, l_assessment_id&#10;      FROM case_allocation_link&#10;      LEFT OUTER JOIN assessment&#10;      ON case_allocation_link.referral_id &#61; assessment.referral_id&#10;      WHERE case_allocation_id &#61; l_case_allocation_id;&#10;      --&#10;      l_existing :&#61; &#39;Y&#39;;&#10;      --&#10;    EXCEPTION WHEN no_data_found THEN&#10;        --&#10;        l_existing :&#61; &#39;N&#39;;&#10;        --&#10;        l_referral_id :&#61; REFERRAL_ID_SEQ.NEXTVAL;&#10;        l_assessment_id :&#61; ASSESSMENT_ID_SEQ.NEXTVAL;&#10;        --INSERT INTO case_allocation_link(case_allocation_id, referral_id) VALUES (l_case_allocation_id, l_referral_id);&#10;    END;&#10;    --&#10;    SELECT referral_type_id INTO l_referral_type_id&#10;    FROM r_referral_type&#10;    WHERE code &#61; &#39;RSRCA&#39;;&#10;    --&#10;    SELECT referral_source_id INTO l_referral_source_id&#10;    FROM r_referral_source&#10;    WHERE code &#61; &#39;CDC&#39;;&#10;    --&#10;    SELECT standard_reference_list_id INTO l_generic_referral_outcome_id&#10;    FROM r_standard_reference_list&#10;    WHERE code_value &#61; &#39;GR01&#39;&#10;    AND reference_data_master_id &#61; (SELECT reference_data_master_id&#10;                                    FROM r_reference_data_master&#10;                                    WHERE code_set_name &#61; &#39;GENERIC REFERRAL OUTCOME&#39;);&#10;    --&#10;    --&#10;    SELECT r1.code_value INTO l_assessment_code&#10;    FROM case_allocation ca&#10;    INNER JOIN r_standard_reference_list r1&#10;    ON ca.allocation_decision_id &#61; r1.standard_reference_list_id&#10;    WHERE ca.case_allocation_id &#61; l_case_allocation_id;&#10;    --&#10;    UPDATE r_assessment_outcome&#10;      SET code &#61; code&#10;    WHERE code &#61; l_assessment_code&#10;    RETURNING assessment_outcome_id INTO l_assessment_outcome_id;&#10;    --&#10;    IF sql%rowcount &#61; 0 THEN&#10;      INSERT INTO r_assessment_outcome&#10;        (assessment_outcome_id, code, description, selectable, assessment_open_to_edit,&#10;        created_by_user_id, training_session_id, last_updated_user_id, row_version,&#10;        created_datetime, last_updated_datetime)&#10;      SELECT  assessment_outcome_id_seq.NEXTVAL, code_value, code_description, &#39;N&#39;, &#39;N&#39;,&#10;              created_by_user_id, training_session_id, last_updated_user_id, 0,&#10;              created_datetime, last_updated_datetime&#10;      FROM r_standard_reference_list&#10;      WHERE code_value &#61; l_assessment_code&#10;      AND reference_data_master_id &#61;  ( SELECT reference_data_master_id&#10;                                        FROM r_reference_data_master&#10;                                        WHERE code_set_name &#61; &#39;ALLOCATION DECISION&#39;);&#10;      --&#10;      UPDATE r_assessment_outcome&#10;      SET code &#61; code&#10;      WHERE code &#61; l_assessment_code&#10;      RETURNING assessment_outcome_id INTO l_assessment_outcome_id;&#10;    END IF;&#10;    --&#10;    MERGE INTO referral t0&#10;    USING (SELECT   l_assessment_id                                 AS assessment_id,&#10;                    l_referral_id                                   AS referral_id,&#10;                    NVL(ca.rsr_assessor_date, ca.created_datetime)  AS referral_date,&#10;                    &#39;N&#39;                                             AS attended,&#10;                    NULL                                            AS source_notes,&#10;                    NULL                                            AS notes,&#10;                    ca.event_id,&#10;                    ca.rsr_assessor_team_id                         AS ref_to_team_id,&#10;                    ca.rsr_assessor_staff_id                        AS ref_to_staff_id,&#10;                    0                                               AS partition_area_id,&#10;                    NULL                                            AS ref_to_provider_employee_id,&#10;                    0                                               AS soft_deleted,&#10;                    0                                               AS row_version,&#10;                    NULL                                            AS treatment_aim_id,&#10;                    NULL                                            AS ref_to_provider_team_id,&#10;                    l_referral_type_id                              AS referral_type_id,&#10;                    l_referral_source_id                            AS referral_source_id,&#10;                    ca.created_by_user_id                           AS created_by_user_id,&#10;                    ca.created_datetime                             AS created_datetime,&#10;                    ca.last_updated_user_id                         AS last_updated_user_id,&#10;                    ca.last_updated_datetime                        AS last_updated_datetime,&#10;                    l_generic_referral_outcome_id                   AS generic_referral_outcome_id,&#10;                    NULL                                            AS training_session_id,&#10;                    ca.offender_id&#10;            FROM case_allocation ca&#10;            WHERE ca.case_allocation_id &#61; l_case_allocation_id) t1&#10;    ON (t0.referral_id &#61; t1.referral_id)&#10;    WHEN MATCHED THEN&#10;      UPDATE SET&#10;        referral_date &#61; t1.referral_date, attended &#61; t1.attended, source_notes &#61; t1.source_notes, notes &#61; t1.notes,&#10;        event_id &#61; t1.event_id, ref_to_team_id &#61; t1.ref_to_team_id, ref_to_staff_id &#61; t1.ref_to_staff_id, partition_area_id &#61; t1.partition_area_id,&#10;        ref_to_provider_employee_id &#61; t1.ref_to_provider_employee_id, soft_deleted &#61; t1.soft_deleted, row_version &#61; t1.row_version, treatment_aim_id &#61; t1.treatment_aim_id,&#10;        ref_to_provider_team_id &#61; t1.ref_to_provider_team_id, referral_type_id &#61; t1.referral_type_id, referral_source_id &#61; t1.referral_source_id,&#10;        created_by_user_id &#61; t1.created_by_user_id, created_datetime &#61; t1.created_datetime, last_updated_user_id &#61; t1.last_updated_user_id,&#10;        last_updated_datetime &#61; t1.last_updated_datetime, generic_referral_outcome_id &#61; t1.generic_referral_outcome_id, training_session_id &#61; t1.training_session_id,&#10;        offender_id &#61; t1.offender_id&#10;    WHEN NOT MATCHED THEN&#10;      INSERT  (referral_id, referral_date, attended, source_notes, notes, event_id, ref_to_team_id, ref_to_staff_id, partition_area_id,&#10;              ref_to_provider_employee_id, soft_deleted, row_version, treatment_aim_id, ref_to_provider_team_id, referral_type_id,&#10;              referral_source_id, created_by_user_id, created_datetime, last_updated_user_id, last_updated_datetime,&#10;              generic_referral_outcome_id, training_session_id, offender_id)&#10;      VALUES  (t1.referral_id, t1.referral_date, t1.attended, t1.source_notes, t1.notes, t1.event_id, t1.ref_to_team_id, t1.ref_to_staff_id, t1.partition_area_id,&#10;              t1.ref_to_provider_employee_id, t1.soft_deleted, t1.row_version, t1.treatment_aim_id, t1.ref_to_provider_team_id, t1.referral_type_id,&#10;              t1.referral_source_id, t1.created_by_user_id, t1.created_datetime, t1.last_updated_user_id, t1.last_updated_datetime,&#10;              t1.generic_referral_outcome_id, t1.training_session_id, t1.offender_id);&#10;    --&#10;    --&#10;    SELECT assessment_type_id INTO l_assessment_type_id&#10;    FROM r_assessment_type&#10;    WHERE code &#61; &#39;RSRCA&#39;;&#10;    --&#10;    MERGE INTO assessment t0&#10;    USING ( SELECT  l_assessment_id                                         AS assessment_id,&#10;                    l_referral_id                                           AS referral_id,&#10;                    NVL(CA.allocation_decision_date, CA.created_datetime)   AS assessment_date,&#10;                    &#39;U&#39;                                                     AS offenders_agreement,&#10;                    NULL                                                    AS notes,&#10;                    NVL(CA.decision_team_id, CA.rsr_assessor_team_id)       AS team_id,&#10;                    NVL(CA.decision_staff_id, CA.rsr_assessor_staff_id)     AS staff_id,&#10;                    NULL                                                    AS provider_employee_id,&#10;                    0                                                       AS soft_deleted,&#10;                    &#39;U&#39;                                                     AS offender_required_to_attend,&#10;                    &#39;N&#39;                                                     AS offender_attended,&#10;                    0                                                       AS partition_area_id,&#10;                    0                                                       AS row_version,&#10;                    l_assessment_type_id                                    AS assessment_type_id,&#10;                    NULL                                                    AS provider_team_id,&#10;                    CA.rsr_score score,&#10;                    0 duration_minutes,&#10;                    CA.created_by_user_id                                   AS created_by_user_id,&#10;                    CA.created_datetime                                     AS created_datetime,&#10;                    CA.last_updated_user_id                                 AS last_updated_user_id,&#10;                    CA.last_updated_datetime                                AS last_updated_datetime,&#10;                    l_assessment_outcome_id                                 AS assessment_outcome_id,&#10;                    NULL                                                    AS training_session_id,&#10;                    CA.offender_id&#10;              FROM case_allocation CA&#10;              WHERE CA.case_allocation_id &#61; l_case_allocation_id) t1&#10;      ON (t0.assessment_id &#61; t1.assessment_id)&#10;      WHEN MATCHED THEN&#10;        UPDATE SET&#10;          assessment_date &#61; t1.assessment_date, offenders_agreement &#61; t1.offenders_agreement, notes &#61; t1.notes, team_id &#61; t1.team_id, staff_id &#61; t1.staff_id,&#10;          provider_employee_id &#61; t1.provider_employee_id, soft_deleted &#61; t1.soft_deleted, offender_required_to_attend &#61; t1.offender_required_to_attend,&#10;          offender_attended &#61; t1.offender_attended, partition_area_id &#61; t1.partition_area_id, row_version &#61; t1.row_version, assessment_type_id &#61; t1.assessment_type_id,&#10;          provider_team_id &#61; t1.provider_team_id, score &#61; t1.score, duration_minutes &#61; t1.duration_minutes, created_by_user_id &#61; t1.created_by_user_id,&#10;          created_datetime &#61; t1.created_datetime, last_updated_user_id &#61; t1.last_updated_user_id, last_updated_datetime &#61; t1.last_updated_datetime,&#10;          assessment_outcome_id &#61; t1.assessment_outcome_id, training_session_id &#61; t1.training_session_id, offender_id &#61; t1.offender_id&#10;      WHEN NOT MATCHED THEN&#10;        INSERT  (assessment_id, referral_id, assessment_date, offenders_agreement, notes, team_id, staff_id, provider_employee_id, soft_deleted, offender_required_to_attend,&#10;                offender_attended, partition_area_id, row_version, assessment_type_id, provider_team_id, score, duration_minutes, created_by_user_id,&#10;                created_datetime, last_updated_user_id, last_updated_datetime, assessment_outcome_id, training_session_id, offender_id)&#10;        VALUES  (t1.assessment_id, t1.referral_id, t1.assessment_date, t1.offenders_agreement, t1.notes, t1.team_id, t1.staff_id, t1.provider_employee_id, t1.soft_deleted, t1.offender_required_to_attend,&#10;                t1.offender_attended, t1.partition_area_id, t1.row_version, t1.assessment_type_id, t1.provider_team_id, t1.score, t1.duration_minutes, t1.created_by_user_id,&#10;                t1.created_datetime, t1.last_updated_user_id, t1.last_updated_datetime, t1.assessment_outcome_id, t1.training_session_id, t1.offender_id);&#10;    --&#10;    IF l_existing &#61; &#39;N&#39; THEN&#10;        --&#10;        INSERT INTO case_allocation_link(case_allocation_id, referral_id) VALUES (l_case_allocation_id, l_referral_id);&#10;        --&#10;    END IF;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    error(&#39;Unhandled error while processing case_allocation_id [&#39; || l_case_allocation_id || &#39;]&#39;);&#10;END change_capture_case_allocation;&#10;--&#10;--&#10;-- Case ALLOCATION support subroutines&#10;--&#10;PROCEDURE addAllocation2Queue(caseAllocationID_in IN NUMBER)&#10;IS&#10;BEGIN&#10;  pending_allocations.EXTEND;&#10;  pending_allocations(pending_allocations.LAST) :&#61; caseAllocationID_in;&#10;END addAllocation2Queue;&#10;--&#10;--&#10;PROCEDURE processAllocationQueue&#10;IS&#10;  unique_allocations  t_tab_ORGANISATIONS :&#61; t_tab_ORGANISATIONS();&#10;BEGIN&#10;  unique_allocations :&#61; SET(pending_allocations);&#10;  FOR i IN 1..unique_allocations.COUNT&#10;  LOOP&#10;    change_capture_case_allocation(caseAllocationID_in &#61;&gt; unique_allocations(i));&#10;  END LOOP;&#10;  --&#10;  unique_allocations.DELETE;&#10;  pending_allocations.DELETE;&#10;END processAllocationQueue;&#10;--&#10;--&#10;-- JMS send message support subroutines&#10;--&#10;FUNCTION get_max_jms_threads(p_date_time DATE DEFAULT SYSDATE) RETURN INTEGER&#10;IS&#10;    l_peak_start_time INTEGER;&#10;    l_peak_end_time   INTEGER;&#10;    l_ret             INTEGER;&#10;BEGIN&#10;    l_peak_start_time :&#61; PKG_Lookups.funcgetNDParameterValue(&#39;PEAK_START_TIME&#39;, 9  * 3600000 );&#10;    l_peak_end_time   :&#61; PKG_Lookups.funcgetNDParameterValue(&#39;PEAK_END_TIME&#39;  , 18 * 3600000 );&#10;    IF ( (p_date_time - TRUNC(p_date_time)) * 24 * 3600000 BETWEEN l_peak_start_time AND l_peak_end_time ) THEN&#10;        l_ret :&#61; PKG_Lookups.funcgetNDParameterValue(&#39;MAXIMUM_NUMBER_OF_PEAK_THREADS&#39;, &#39;25&#39;);&#10;    ELSE&#10;        l_ret :&#61; PKG_Lookups.funcgetNDParameterValue(&#39;MAXIMUM_NUMBER_OF_OFF_PEAK_THREADS&#39;, &#39;50&#39;);&#10;    END IF;&#10;    --&#10;    RETURN l_ret;&#10;END get_max_jms_threads;&#10;--&#10;FUNCTION get_jms_threads RETURN INTEGER IS&#10;BEGIN&#10;    RETURN GLOBAL_CACHE_MGR.spg_get_jms_threads;&#10;END get_jms_threads;&#10;--&#10;PROCEDURE set_jms_threads(p_inc INTEGER DEFAULT 1)&#10;IS&#10;    --&#10;    l_inc INTEGER;&#10;    --&#10;    lc_lock_name  CONSTANT  VARCHAR2(30) :&#61; &#39;SPG_SET_JMS_THREADS&#39;;&#10;    --&#10;    l_lock_handle VARCHAR2(128);&#10;    l_dummy_int    PLS_INTEGER;&#10;    --&#10;--YF: added here&#10;    PROCEDURE do_allocate_soft_lock IS&#10;    BEGIN&#10;        DBMS_LOCK.allocate_unique(lc_lock_name, l_lock_handle);&#10;        l_dummy_int :&#61; DBMS_LOCK.request(l_lock_handle, DBMS_LOCK.x_mode, DBMS_LOCK.maxwait, FALSE);&#10;    END do_allocate_soft_lock;&#10;    --&#10;    PROCEDURE do_release_soft_lock IS&#10;    BEGIN&#10;        l_dummy_int :&#61; DBMS_LOCK.release(l_lock_handle);&#10;    EXCEPTION WHEN OTHERS THEN&#10;        NULL;&#10;    END do_release_soft_lock;&#10;    --&#10;BEGIN&#10;    --&#10;    --YF: added here&#10;    do_allocate_soft_lock;&#10;    --&#10;    IF p_inc IS NULL THEN&#10;        l_inc :&#61; 1;&#10;    ELSE&#10;        l_inc :&#61; p_inc;&#10;    END IF;&#10;    --&#10;    GLOBAL_CACHE_MGR.spg_set_jms_threads( get_jms_threads + l_inc );&#10;    --&#10;    --YF: added here&#10;    do_release_soft_lock;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    --&#10;    --YF: added here&#10;    do_release_soft_lock;&#10;    --&#10;END set_jms_threads;&#10;--&#10;PROCEDURE do_allocate_jms_thread&#10;IS&#10;    --&#10;    lc_proc       CONSTANT VARCHAR2(30) :&#61; &#39;DO_ALLOCATE_JMS_THREAD&#39;;&#10;    --&#10;    lc_timeout    CONSTANT INTEGER :&#61; 60*60;&#10;    --&#10;    l_wait       NUMBER;&#10;    l_total_wait NUMBER :&#61; 0;&#10;    --&#10;    l_dummy       VARCHAR2(1);&#10;    l_tries       INTEGER :&#61; 0;&#10;    l_threads     INTEGER;&#10;    l_max_threads INTEGER;&#10;    l_success     BOOLEAN :&#61; FALSE;&#10;    --&#10;    lc_lock_name  CONSTANT  VARCHAR2(30) :&#61; &#39;SPG_ALLOCATE_JMS_THREADS&#39;;&#10;    --&#10;    l_lock_handle VARCHAR2(128);&#10;    l_dummy_int   PLS_INTEGER;&#10;    --&#10;    --YF: added here&#10;    PROCEDURE do_allocate_soft_lock IS&#10;    BEGIN&#10;        DBMS_LOCK.allocate_unique(lc_lock_name, l_lock_handle);&#10;        l_dummy_int :&#61; DBMS_LOCK.request(l_lock_handle, DBMS_LOCK.x_mode, DBMS_LOCK.maxwait, FALSE);&#10;    END do_allocate_soft_lock;&#10;    --&#10;    PROCEDURE do_release_soft_lock IS&#10;    BEGIN&#10;        l_dummy_int :&#61; DBMS_LOCK.release(l_lock_handle);&#10;    EXCEPTION WHEN OTHERS THEN&#10;        NULL;&#10;    END do_release_soft_lock;&#10;    --&#10;BEGIN&#10;    --&#10;    IF SPGConfig.SPGMultiThreadActive THEN&#10;        set_jms_threads(1);&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    g_procedure_name :&#61; lc_proc;&#10;    g_label :&#61; &#39;10000&#39;;&#10;    --&#10;    l_max_threads :&#61; get_max_jms_threads;&#10;    --&#10;    IF l_max_threads &lt;&#61; 0 THEN&#10;        l_success :&#61; TRUE;&#10;    END IF;&#10;    --&#10;    LOOP&#10;        EXIT WHEN l_success;&#10;        --&#10;        g_label :&#61; &#39;10010&#39;;&#10;        l_tries :&#61; l_tries + 1;&#10;        BEGIN&#10;            --YF: added here&#10;            do_allocate_soft_lock;&#10;            --&#10;            IF l_total_wait &gt; lc_timeout THEN&#10;                --l_success :&#61; TRUE;&#10;                g_label :&#61; &#39;10020&#39;;&#10;                fatal(&#39;TIMEOUT ERROR: timeout&#61;&#39; || lc_timeout || &#39;; num_of_attempts&#61;&#39; || l_tries || &#39;; num_of_threads_max&#61;&#39; || l_max_threads);&#10;                raise_error(&#39;TIMEOUT ERRROR in &#39; || lc_proc || &#39;: please see SPG_ERROR_LOG and SPG_MESSAGE_LOG for more details&#39;, lc_proc, g_label);&#10;            ELSE&#10;                g_label :&#61; &#39;10030&#39;;&#10;                l_threads :&#61; get_jms_threads;&#10;                IF l_threads &lt; l_max_threads THEN&#10;                    g_label :&#61; &#39;10040&#39;;&#10;                    l_success :&#61; TRUE;&#10;                END IF;&#10;            END IF;&#10;            --&#10;            --YF: added here&#10;            do_release_soft_lock;&#10;            --&#10;        EXCEPTION WHEN OTHERS THEN&#10;            --YF: added here&#10;            do_release_soft_lock;&#10;            RAISE;&#10;        END;&#10;        --&#10;        g_label :&#61; &#39;10050&#39;;&#10;        --&#10;        IF NOT l_success THEN&#10;            g_label :&#61; &#39;10070&#39;;&#10;            --DBMS_RANDOM.seed(val &#61;&gt; 0);&#10;            l_wait :&#61; ROUND(DBMS_RANDOM.value(low &#61;&gt; 0.01, high &#61;&gt; 1), 2);&#10;            l_total_wait :&#61; l_total_wait + l_wait;&#10;            --&#10;            IF PKG_Debug.funcGetDebugActive THEN&#10;                procDebug(lc_proc || &#39;: (num_of_attempt&#61;&#39; || l_tries || &#39;)(wait&#61;&#39; || l_wait || &#39;)(total_wait&#61;&#39; || l_total_wait || &#39;)&#39;);&#10;            END IF;&#10;            --&#10;            DBMS_LOCK.sleep(l_wait);&#10;        END IF;&#10;        --&#10;    END LOOP;&#10;    --&#10;    IF l_success THEN&#10;        g_label :&#61; &#39;10080&#39;;&#10;        set_jms_threads(1);&#10;    END IF;&#10;    --&#10;    g_label :&#61; &#39;10090&#39;;&#10;    --&#10;END do_allocate_jms_thread;&#10;--&#10;PROCEDURE do_release_jms_thread&#10;IS&#10;    l_threads INTEGER;&#10;BEGIN&#10;    --&#10;    IF SPGConfig.SPGMultiThreadActive THEN&#10;        set_jms_threads(-1);&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    l_threads :&#61; get_jms_threads;&#10;    IF l_threads &gt; 0 THEN&#10;        set_jms_threads(-1);&#10;    END IF;&#10;END do_release_jms_thread;&#10;--&#10;FUNCTION sendUpdateTOJMS(&#10;    msgClob                 CLOB,&#10;    jmsUrl                  VARCHAR2,&#10;    queueName               VARCHAR2,&#10;    senderControlReference  VARCHAR2,&#10;    JMSPriority             NUMBER,&#10;    SenderIdentity          VARCHAR2 )&#10;RETURN VARCHAR2&#10;IS&#10;    l_ret VARCHAR2(100);&#10;BEGIN&#10;    --&#10;    --do_allocate_jms_thread;&#10;    --&#10;    --BEGIN&#10;        l_ret :&#61;&#10;            sendJMSMessage(&#10;                msgString              &#61;&gt; msgClob,&#10;                jmsUrl                 &#61;&gt; jmsUrl,&#10;                queueName              &#61;&gt; queueName,&#10;                senderControlReference &#61;&gt; senderControlReference,&#10;                JMSPriority            &#61;&gt; JMSPriority,&#10;                SenderIdentity         &#61;&gt; SenderIdentity );&#10;        --YF: already called in SPGMessage.process_q_msg&#10;        --do_release_jms_thread;&#10;    --EXCEPTION WHEN OTHERS THEN&#10;    --    do_release_jms_thread;&#10;    --END;&#10;    --&#10;    RETURN l_ret;&#10;END sendUpdateTOJMS;&#10;--&#10;FUNCTION sendUpdateToJMS(&#10;    msgClob                 CLOB,&#10;    jmsUser                     VARCHAR2,&#10;    jmsPass                     VARCHAR2,&#10;    jmsUrl                      VARCHAR2,&#10;    queueName                   VARCHAR2,&#10;    senderControlReference  VARCHAR2,&#10;    JMSPriority               NUMBER,&#10;    SenderIdentity          VARCHAR2)&#10;RETURN VARCHAR2&#10;IS&#10;    l_ret VARCHAR2(100);&#10;BEGIN&#10;    --&#10;    --do_allocate_jms_thread;&#10;    --&#10;    --BEGIN&#10;        l_ret :&#61;&#10;            sendJMSMessage(&#10;                msgString                 &#61;&gt; msgClob,&#10;                jmsUser                     &#61;&gt; jmsUser,&#10;                jmsPass                     &#61;&gt; jmsPass,&#10;                jmsUrl                      &#61;&gt; jmsUrl,&#10;                queueName                   &#61;&gt; queueName,&#10;                senderControlReference  &#61;&gt; senderControlReference,&#10;                JMSPriority               &#61;&gt; JMSPriority,&#10;                SenderIdentity            &#61;&gt; SenderIdentity );&#10;        --YF: already called in SPGMessage.process_q_msg&#10;        --do_release_jms_thread;&#10;    --EXCEPTION WHEN OTHERS THEN&#10;    --    do_release_jms_thread;&#10;    --END;&#10;    --&#10;    RETURN l_ret;&#10;END sendUpdateTOJMS;&#10;--&#10;--&#10;PROCEDURE create_crc_export_batch(&#10;    p_probation_area_id           NUMBER,&#10;    p_team_id                     NUMBER    DEFAULT -1,&#10;    p_staff_id                    NUMBER    DEFAULT -1,&#10;    p_excl_already_extracted_flag VARCHAR2  DEFAULT &#39;N&#39;,&#10;    p_incl_already_extracted_flag VARCHAR2  DEFAULT &#39;N&#39;,&#10;    p_crc_export_date_from        DATE      DEFAULT NULL,&#10;    p_crc_export_date_to          DATE      DEFAULT NULL,&#10;    p_crn                         VARCHAR2  DEFAULT NULL,&#10;    p_status_export_flag          SMALLINT  DEFAULT 0,&#10;    p_debug_flag                  VARCHAR2  DEFAULT &#39;Y&#39;,&#10;    --&#10;    p_max_rows                    INTEGER   DEFAULT -1,&#10;    p_max_rows_L1                 INTEGER   DEFAULT -1,&#10;    p_max_rows_L3                 INTEGER   DEFAULT -1,&#10;    --&#10;    p_async_flag                  VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_spg_notification_id         NUMBER   DEFAULT NULL )&#10;IS&#10;BEGIN&#10;    PKG_SPG_EXPORT.create_crc_export_batch(&#10;        p_probation_area_id           &#61;&gt; p_probation_area_id,&#10;        p_team_id                     &#61;&gt; p_team_id,&#10;        p_staff_id                    &#61;&gt; p_staff_id,&#10;        p_excl_already_extracted_flag &#61;&gt; p_excl_already_extracted_flag,&#10;        p_incl_already_extracted_flag &#61;&gt; p_incl_already_extracted_flag,&#10;        p_crc_export_date_from        &#61;&gt; p_crc_export_date_from,&#10;        p_crc_export_date_to          &#61;&gt; p_crc_export_date_to,&#10;        p_crn                         &#61;&gt; p_crn,&#10;        p_status_export_flag          &#61;&gt; p_status_export_flag,&#10;        p_debug_flag                  &#61;&gt; p_debug_flag,&#10;        --&#10;        p_max_rows                    &#61;&gt; p_max_rows,&#10;        p_max_rows_L1                 &#61;&gt; p_max_rows_L1,&#10;        p_max_rows_L3                 &#61;&gt; p_max_rows_L3,&#10;        --&#10;        p_async_flag                  &#61;&gt; p_async_flag,&#10;        p_spg_notification_id         &#61;&gt; p_spg_notification_id );&#10;    --&#10;END create_crc_export_batch;&#10;--&#10;PROCEDURE resubmit_failed_messages(p_spg_notification_id_LST CLOB)&#10;IS&#10;    l_TAB                 T_TAB_ORGANISATIONS;&#10;    l_spg_notification_id NUMBER;&#10;BEGIN&#10;    --&#10;    l_TAB :&#61; PKG_LstUtl.get_list_2_array(REPLACE(REPLACE(REPLACE(REPLACE(p_spg_notification_id_LST, CHR(13), &#39;&#39;), CHR(10), &#39;&#39;), CHR(9), &#39;&#39;), &#39; &#39;, &#39;&#39;));&#10;    --&#10;    FOR l_idx IN 1..l_TAB.COUNT LOOP&#10;        l_spg_notification_id :&#61; l_tab(l_idx);&#10;        SPGMessage.retry_msg( x_spg_notification_id&#61;&gt;l_spg_notification_id, p_new_record_flag&#61;&gt;&#39;N&#39; );&#10;    END LOOP;&#10;    --&#10;END resubmit_failed_messages;&#10;--&#10;FUNCTION get_off_interested_CRCs( p_offender_id NUMBER, p_area_code_flag VARCHAR2 DEFAULT &#39;N&#39; )&#10;RETURN T_TAB_ORGANISATIONS&#10;IS&#10;    --l_area_rec  PKG_Search.trecInterestedAreas;&#10;    --l_area_tab  PKG_Search.ttabInterestedAreas;&#10;    l_TAB       T_TAB_ORGANISATIONS;&#10;BEGIN&#10;    EXECUTE IMMEDIATE&#10;      &#39;SELECT DISTINCT &#39; || CASE WHEN p_area_code_flag &#61; &#39;Y&#39; THEN &#39;CODE&#39; ELSE &#39;probation_area_id&#39; END || &#39; &#39; ||&#10;      &#39;FROM TABLE( PKG_Search.procGetInterestedCRCsTAB( TO_CHAR(:p_offender_id) ) )&#39;&#10;    BULK COLLECT INTO l_TAB&#10;    USING p_offender_id&#10;    ;&#10;    --&#10;    RETURN l_TAB;&#10;END get_off_interested_CRCs;&#10;&#10;PROCEDURE submit_data_script_message(&#10;    p_data_script_message_id    NUMBER,&#10;    p_business_interaction_id   NUMBER,&#10;    p_offender_id               NUMBER,&#10;    p_unique_id                 NUMBER,&#10;    p_event_id                  NUMBER   DEFAULT NULL,&#10;    p_disposal_termination_date DATE     DEFAULT NULL,&#10;    p_data_script_name          VARCHAR2 DEFAULT NULL,&#10;    p_debug_mode                VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_area_TAB                 T_TAB_ORGANISATIONS DEFAULT NULL )&#10;IS&#10;    --&#10;    l_area_TAB            T_TAB_ORGANISATIONS;&#10;    l_spg_notification_id NUMBER;&#10;    l_control_reference   SPG_NOTIFICATION.control_reference%TYPE;&#10;    --&#10;    l_area_code     PROBATION_AREA.code%TYPE;&#10;    --&#10;    l_L1            NUMBER;&#10;    l_L2            NUMBER;&#10;    l_L3            NUMBER;&#10;    --&#10;BEGIN&#10;    /*&#10;    DATA_SCRIPT_MESSAGE(&#10;&#9;data_script_message_id integer not null ,&#10;&#9;data_script_name     varchar2(100) not null ,&#10;&#9;created_datetime     date default  sysdate  not null ,&#10;&#9;offender_id          integer not null ,&#10;&#9;event_id             integer not null ,&#10;&#9;disposal_termination_date date null ,&#10;&#9;unique_id            integer not null ,&#10;&#9;business_interaction_id )&#10;    */&#10;    --&#10;    g_procedure_name :&#61; &#39;submit_data_script_message&#39;;&#10;    g_label :&#61; &#39;001000&#39;;&#10;    --&#10;    info(&#10;        &#39;START generate SPG Outbound messages for &#39;   ||&#10;        &#39;script&#61;&#39;       || p_data_script_name   ||&#10;        &#39; offender_id&#61;&#39; || p_offender_id        ||&#10;        &#39;, unique_id&#61;&#39;  || p_unique_id          ||&#10;        &#39;, BI_code&#61;&#39;    || PKG_Lookups.funcGetBusinessInteraction(p_business_interaction_id) );&#10;    --&#10;    l_area_TAB :&#61; get_off_interested_CRCs(p_offender_id);&#10;    -- DST-5999: Restrict Interested CRCs list to only those that are secified in P_AREA_TAB&#10;    IF p_area_TAB IS NOT NULL THEN&#10;        l_area_TAB :&#61; PKG_Common.funcMultisetIntersect(l_area_TAB, p_area_TAB);&#10;    END IF;&#10;    --&#10;    FOR l_idx IN 1..l_area_TAB.COUNT LOOP&#10;        --&#10;        l_area_code :&#61; PKG_Lookups.funcgetTabRecord_CACHED(p_table&#61;&gt;&#39;PROBATION_AREA&#39;, p_ref_col&#61;&gt;&#39;probation_area_ID&#39;, p_ref_val&#61;&gt;l_area_TAB(l_idx), p_data_fld&#61;&gt;&#39;code&#39;);&#10;        --&#10;        PKG_RBAC.do_set_rbac_levels(&#10;            p_offender_id &#61;&gt; p_offender_id,&#10;            p_L1          &#61;&gt; l_L1,&#10;            p_L2          &#61;&gt; l_L2,&#10;            p_L3          &#61;&gt; l_L3,&#10;            p_username    &#61;&gt; l_area_code);&#10;        --&#10;        info(&#10;            &#39;CRC: &#39;          || l_area_code        ||&#10;            &#39;, script&#61;&#39;      || p_data_script_name ||&#10;            &#39;, offender_id&#61;&#39; || p_offender_id      ||&#10;            &#39;, RBAC_L1&#61;&#39;     || l_L1               ||&#10;            &#39;, RBAC_L3&#61;&#39;     || l_L3 );&#10;        --&#10;        IF NOT ( p_disposal_termination_date IS NOT NULL AND NVL(l_L3, 0) &#61; 1 AND NVL(l_L1, 0) &#61; 0 ) THEN&#10;            --&#10;            IF p_debug_mode &#61; &#39;Y&#39; THEN&#10;                info(&#10;                    &#39;[DEBUG_MODE][INSERT INTO spg_notification]&#39; ||&#10;                    &#39; CRC: &#39;         || l_area_code        ||&#10;                    &#39;, script&#61;&#39;      || p_data_script_name ||&#10;                    &#39;, offender_id&#61;&#39; || p_offender_id      ||&#10;                    &#39;, RBAC_L1&#61;&#39;     || l_L1               ||&#10;                    &#39;, RBAC_L3&#61;&#39;     || l_L3 );&#10;&#10;            ELSE&#10;                INSERT INTO spg_notification (&#10;                  spg_notification_id,&#10;                  business_interaction_id,&#10;                  offender_id,&#10;                  unique_id,&#10;                  date_created,&#10;                  message_direction,&#10;                  sender_identity_id,&#10;                  receiver_identity_id,&#10;                  control_reference,&#10;                  --&#10;                  data_script_message_id&#10;                  --&#10;                ) VALUES (&#10;                  spg_notification_id_seq.NEXTVAL,&#10;                  p_business_interaction_id,&#10;                  p_offender_id,&#10;                  p_unique_id,&#10;                  SYSDATE,&#10;                  &#39;O&#39;,&#10;                  PKG_Lookups.funcgetTabRecord_CACHED(p_table&#61;&gt;&#39;PROBATION_AREA&#39;, p_ref_col&#61;&gt;&#39;code&#39;, p_ref_val&#61;&gt;&#39;N00&#39;, p_data_fld&#61;&gt;&#39;probation_area_ID&#39;),&#10;                  l_area_TAB(l_idx),&#10;                  SPGConfig.getnextcontrolreference(&#39;N00&#39;),&#10;                  --&#10;                  p_data_script_message_id&#10;                  --&#10;                )&#10;                RETURNING spg_notification_id, control_reference&#10;                INTO l_spg_notification_id, l_control_reference;&#10;                --&#10;                g_label :&#61; &#39;001010&#39;;&#10;                info(&#10;                    &#39;CRC: &#39; || l_area_code ||&#10;                    &#39;, spg_notification_id&#61;&#39; || l_spg_notification_id ||&#10;                    &#39;, SCR&#61;&#39;                 || l_control_reference );&#10;            END IF;&#10;            --&#10;        ELSE&#10;            info(&#10;                &#39;CRC: &#39; || l_area_code ||&#10;                &#39; SPG Outbound Message NOT generated&#39; ||&#10;                &#39;, DISPOSAL_TERM_DATE&#61;&#39; || TO_CHAR(p_disposal_termination_date, &#39;YYYY-MM-DD&#39;) ||&#10;                &#39;, RBAC_LEVEL&#61;3&#39; );&#10;        END IF;&#10;        --&#10;    END LOOP;&#10;    --&#10;    g_label :&#61; &#39;001900&#39;;&#10;    info(&#10;        &#39;TOTAL of &#39; || l_area_TAB.COUNT || &#39; messages have been generated for &#39;   ||&#10;        &#39;script&#61;&#39;        || p_data_script_name   ||&#10;        &#39;, offender_id&#61;&#39; || p_offender_id        ||&#10;        &#39;, unique_id&#61;&#39;   || p_unique_id          ||&#10;        &#39;, BI_code&#61;&#39;     ||  PKG_Lookups.funcGetBusinessInteraction(p_business_interaction_id) );&#10;    --&#10;END submit_data_script_message;&#10;&#10;PROCEDURE procGetRelatedSPGMessages(&#10;    p_spg_notification_id           NUMBER DEFAULT NULL,&#10;    p_errors_only                 CHAR DEFAULT &#39;N&#39;,&#10;    p_outcursor               OUT SYS_REFCURSOR )&#10;IS&#10;BEGIN&#10;    OPEN p_outcursor FOR&#10;      select&#10;        n.spg_notification_id, bi.BUSINESS_INTERACTION_CODE, bi.description, n.offender_id, n.unique_id,&#10;        n.date_created, n.receiver_identity_id, rpa.code, n.sender_identity_id, spa.code, type.code_value, type.CODE_DESCRIPTION, n.control_reference, n.processed_datetime,&#10;        (select LISTAGG (bi2.BUSINESS_INTERACTION_CODE, &#39;,&#39;) WITHIN GROUP (ORDER BY bi2.BUSINESS_INTERACTION_CODE ASC)&#10;        from spg_notification n2&#10;        join business_interaction bi2 on bi2.business_interaction_id &#61; n2.business_interaction_id and bi2.business_interaction_code like &#39;SPGISN%&#39;&#10;        join probation_area spa2 on spa2.probation_area_id &#61; n2.SENDER_IDENTITY_ID and spa2.code &lt;&gt; &#39;SPG&#39;&#10;        where n2.receiver_control_reference &#61; (select control_reference from spg_notification where spg_notification_id &#61; n.SPG_NOTIFICATION_ID)) as po_responses,&#10;        (select LISTAGG (bi2.BUSINESS_INTERACTION_CODE, &#39;,&#39;) WITHIN GROUP (ORDER BY bi2.BUSINESS_INTERACTION_CODE ASC)&#10;        from spg_notification n2&#10;        join business_interaction bi2 on bi2.business_interaction_id &#61; n2.business_interaction_id and bi2.business_interaction_code like &#39;SPGISN%&#39;&#10;        join probation_area spa2 on spa2.probation_area_id &#61; n2.SENDER_IDENTITY_ID and spa2.code &#61; &#39;SPG&#39;&#10;        where n2.receiver_control_reference &#61; (select control_reference from spg_notification where spg_notification_id &#61; n.SPG_NOTIFICATION_ID)) as spg_responses,&#10;        case when bm.data_update_mode &#61; &#39;I&#39; then &#39;INS&#39; when bm.data_update_mode &#61; &#39;U&#39; then &#39;UPD&#39; when bm.data_update_mode &#61; &#39;D&#39; then &#39;DEL&#39; when bm.data_update_mode &#61; &#39;S&#39; then &#39;SYS&#39; else bm.data_update_mode end,&#10;        spge.spg_error_id&#10;    from&#10;      spg_notification n&#10;        join business_interaction bi on bi.business_interaction_id &#61; n.business_interaction_id&#10;        join probation_area rpa on rpa.probation_area_id &#61; n.receiver_identity_id&#10;        join probation_area spa on spa.probation_area_id &#61; n.sender_identity_id&#10;          join r_spg_xsd_probation_area xpa on xpa.probation_area_id &#61; rpa.probation_area_id&#10;            join spg_xsd xsd on xsd.SPG_XSD_ID &#61; xpa.SPG_XSD_ID&#10;              join business_int_xml_map bm on bm.business_interaction_id &#61; bi.BUSINESS_INTERACTION_ID and bm.XSD_NUMBER &#61; xsd.xsd_number&#10;                left outer join r_standard_reference_list type on type.code_value &#61; &#39;&#39; || bm.ROOT_XML_MESSAGE_ID&#10;        left outer join spg_error spge on spge.spg_notification_id &#61; n.spg_notification_id&#10;          join r_reference_data_master rm on type.REFERENCE_DATA_MASTER_ID &#61; rm.REFERENCE_DATA_MASTER_ID and rm.CODE_SET_NAME &#61; &#39;SPG MESSAGE TYPE&#39;,&#10;      (&#10;        select n.business_interaction_id, n.offender_id, n.unique_id, xsd.xsd_number, n.receiver_identity_id, n.sender_identity_id, n.message_direction&#10;        from spg_notification n&#10;        join business_interaction bi on bi.business_interaction_id &#61; n.business_interaction_id&#10;        join probation_area rpa on rpa.probation_area_id &#61; n.receiver_identity_id&#10;        join r_spg_xsd_probation_area xpa on rpa.probation_area_id &#61; xpa.probation_area_id&#10;        join spg_xsd xsd on xpa.spg_xsd_id &#61; xsd.spg_xsd_id&#10;        where n.spg_notification_id &#61; p_spg_notification_id&#10;      ) t1&#10;    where 1&#61;1&#10;      and n.business_interaction_id in (&#10;          select bm.business_interaction_id&#10;          from&#10;            business_int_xml_map bm&#10;              join business_interaction bi on bi.business_interaction_id &#61; bm.business_interaction_id&#10;        where 1&#61;1&#10;          and bm.root_xml_message_id in (&#10;              select root_xml_message_id&#10;              from&#10;                business_int_xml_map bm&#10;                  join business_interaction bi on bi.business_interaction_id &#61; bm.business_interaction_id&#10;              where 1&#61;1&#10;                and bm.xsd_number &#61; xsd.xsd_number&#10;                and bm.business_interaction_id &#61; t1.business_interaction_id&#10;          )&#10;          and bm.xsd_number &#61; xsd.xsd_number&#10;      )&#10;      and n.offender_id &#61; t1.offender_id&#10;      and n.unique_id &#61; t1.unique_id&#10;      and t1.sender_identity_id in (n.receiver_identity_id, n.sender_identity_id) and t1.receiver_identity_id in (n.receiver_identity_id, n.sender_identity_id)&#10;      and n.spg_notification_id &lt;&gt; p_spg_notification_id&#10;      and (p_errors_only &#61; &#39;N&#39; or (p_errors_only &#61; &#39;Y&#39; and spge.spg_error_id is not null))&#10;    order by n.date_created desc&#10;    ;&#10;&#10;END procGetRelatedSPGMessages;&#10;&#10;--&#10;--&#10;-- PLSQL package Initialisation block&#10;--&#10;BEGIN&#10;    --&#10;    PKG_Global.do_init;&#10;    --&#10;    do_init_vars;&#10;    --&#10;END PKG_SPG_SUPPORT;</textarea>
                        </div>
                    </div>
                </section>
            </div>
            <!-- /.content-wrapper -->
            <footer class="main-footer">
                <div>
                    <div class="pull-right hidden-xs">
                        <a href="https://github.com/schemaspy/schemaspy" title="GitHub for SchemaSpy"><i class="fa fa-github-square fa-2x"></i></a>
                        <a href="http://stackoverflow.com/questions/tagged/schemaspy" title="StackOverflow for SchemaSpy"><i class="fa fa-stack-overflow fa-2x"></i></a>
                    </div>
                    <strong>Generated by <a href="http://schemaspy.org/" class="logo-text"><i class="fa fa-database"></i> SchemaSpy 6.2.4</a></strong>
                </div>
                <!-- /.container -->
            </footer>
        </div>
        <!-- ./wrapper -->

        <!-- jQuery 2.2.3 -->
        <script src="../bower/admin-lte/plugins/jQuery/jquery-2.2.3.min.js"></script>
        <script src="../bower/admin-lte/plugins/jQueryUI/jquery-ui.min.js"></script>
        <!-- Bootstrap 3.3.5 -->
        <script src="../bower/admin-lte/bootstrap/js/bootstrap.min.js"></script>
        <!-- DataTables -->
        <script src="../bower/datatables.net/jquery.dataTables.min.js"></script>
        <script src="../bower/datatables.net-bs/js/dataTables.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/dataTables.buttons.min.js"></script>
        <script src="../bower/datatables.net-buttons-bs/js/buttons.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.html5.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.print.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.colVis.min.js"></script>
        <!-- SheetJS -->
        <script src="../bower/js-xlsx/xlsx.full.min.js"></script>
        <!-- pdfmake -->
        <script src="../bower/pdfmake/pdfmake.min.js"></script>
        <script src="../bower/pdfmake/vfs_fonts.js"></script>
        <!-- SlimScroll -->
        <script src="../bower/admin-lte/plugins/slimScroll/jquery.slimscroll.min.js"></script>
        <!-- FastClick -->
        <script src="../bower/admin-lte/plugins/fastclick/fastclick.js"></script>
        <!-- Salvattore -->
        <script src="../bower/salvattore/salvattore.min.js"></script>
        <!-- AnchorJS -->
        <script src="../bower/anchor-js/anchor.min.js"></script>
        <!-- CodeMirror -->
        <script src="../bower/codemirror/codemirror.js"></script>
        <script src="../bower/codemirror/sql.js"></script>
        <!-- AdminLTE App -->
        <script src="../bower/admin-lte/dist/js/app.min.js"></script>
        <script src="routine.js"></script>
        <script src="../schemaSpy.js"></script>
    </body>
</html>