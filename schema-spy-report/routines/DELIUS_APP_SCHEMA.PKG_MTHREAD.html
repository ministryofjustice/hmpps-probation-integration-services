<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>TSTNDA.DELIUS_APP_SCHEMA</title>
        <!-- Tell the browser to be responsive to screen width -->
        <meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport">
        <link rel="icon" type="image/png" sizes="16x16" href="../favicon.png">
        <!-- Bootstrap 3.3.5 -->
        <link rel="stylesheet" href="../bower/admin-lte/bootstrap/css/bootstrap.min.css">
        <!-- Font Awesome -->
        <link rel="stylesheet" href="../bower/font-awesome/css/font-awesome.min.css">
        <!-- Ionicons -->
        <link rel="stylesheet" href="../bower/ionicons/css/ionicons.min.css">
        <!-- DataTables -->
        <link rel="stylesheet" href="../bower/datatables.net-bs/css/dataTables.bootstrap.min.css">
        <link rel="stylesheet" href="../bower/datatables.net-buttons-bs/css/buttons.bootstrap.min.css">
        <!-- Code Mirror -->
        <link rel="stylesheet" href="../bower/codemirror/codemirror.css">
        <!-- Fonts -->
        <link href='../fonts/indieflower/indie-flower.css' rel='stylesheet' type='text/css'>
        <link href='../fonts/source-sans-pro/source-sans-pro.css' rel='stylesheet' type='text/css'>

        <!-- Theme style -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/AdminLTE.min.css">
        <!-- Salvattore -->
        <link rel="stylesheet" href="../bower/salvattore/salvattore.css">
        <!-- AdminLTE Skins. Choose a skin from the css/skins
           folder instead of downloading all of them to reduce the load. -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/skins/_all-skins.min.css">
        <!-- SchemaSpy -->
        <link rel="stylesheet" href="../schemaSpy.css">

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
        <script src="../bower/html5shiv/html5shiv.min.js"></script>
        <script src="../bower/respond/respond.min.js"></script>
        <![endif]-->
    </head>
    <!-- ADD THE CLASS layout-top-nav TO REMOVE THE SIDEBAR. -->
    <body class="hold-transition skin-blue layout-top-nav">
        <div class="wrapper">
            <header class="main-header">
                <nav class="navbar navbar-static-top">
                    <div class="container">
                        <div class="navbar-header">
                            <a href="../index.html" class="navbar-brand"><b>TSTNDA</b></a><span class="navbar-brand" style="padding-left: 0">.DELIUS_APP_SCHEMA</span>
                            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse"><i class="fa fa-bars"></i></button>
                        </div>

                        <!-- Collect the nav links, forms, and other content for toggling -->
                        <div class="collapse navbar-collapse pull-left" id="navbar-collapse">
                            <ul class="nav navbar-nav">
                                <li><a href="../index.html">Tables <span class="sr-only">(current)</span></a></li>
                                <li><a href="../columns.html" title="All of the columns in the schema">Columns</a></li>
                                <li><a href="../constraints.html" title="Useful for diagnosing error messages that just give constraint name or number">Constraints</a></li>
                                <li><a href="../relationships.html" title="Diagram of table relationships">Relationships</a></li>
                                <li><a href="../orphans.html" title="View of tables with neither parents nor children">Orphan&nbsp;Tables</a></li>
                                <li><a href="../anomalies.html" title="Things that might not be quite right">Anomalies</a></li>
                                <li><a href="../routines.html" title="Procedures and functions">Routines</a></li>
                            </ul>
                        </div>
                        <!-- /.navbar-collapse -->
                        <!-- Navbar Right Menu -->
                    </div>
                    <!-- /.container-fluid -->
                </nav>
            </header>
            <!-- Main content -->
            <!-- Full Width Column -->
            <div class="content-wrapper">
                <!-- Content Header (Page header) -->
                <section class="content-header">
                    <h1>DELIUS_APP_SCHEMA.PKG_MTHREAD</h1><br />
                </section>
                <!-- Main content -->
                <section class="content">
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <span class="glyphicon glyphicon-list-alt" aria-hidden="true"></span>
                            <h3 id="Columns" class="box-title">Parameters</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <table id="standard_table" class="table table-bordered table-striped dataTable" role="grid">
                                <thead align='left'>
                                <tr>
                                    <th>Name</th>
                                    <th>Type</th>
                                    <th>Mode</th>
                                </tr>
                                </thead>
                                <tbody>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <i class="fa fa-file-code-o"></i>
                            <h3 id="RoutineDefinition" class="box-title">Definition</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <textarea id="sql-script-codemirror" name="sql-script-codemirror" rows="" style="display: none;">PACKAGE BODY pkg_mthread&#10;AS&#10;--&#10;--&#10;&#10;&#10;--&#10;-- Global variables&#10;--&#10;g_component_code  VARCHAR2(30);&#10;g_procedure_name  VARCHAR2(30)  :&#61; &#39;pkg_mthread&#39;;&#10;g_label           VARCHAR2(5)   :&#61; &#39;00000&#39;;&#10;--g_connection_name VARCHAR2(30)  :&#61; &#39;nd_lup&#39;;&#10;&#10;--&#10;g_package_version CONSTANT VARCHAR2(30) :&#61; GC_VERSION;&#10;g_package_name    CONSTANT VARCHAR2(30) :&#61; &#39;PKG_MTHREAD&#39;;&#10;&#10;TYPE g_instance_TAB_TYP IS TABLE OF INTEGER INDEX BY VARCHAR2(30);&#10;g_instance_TAB g_instance_TAB_TYP;&#10;&#10;--&#10;-- message type&#10;mt_information    CONSTANT NUMBER :&#61; 1;&#10;mt_warning        CONSTANT NUMBER :&#61; 2;&#10;mt_error          CONSTANT NUMBER :&#61; 3;&#10;mt_fatal_error    CONSTANT NUMBER :&#61; 4;&#10;&#10;&#10;--&#10;-- Wrapper for generic Raise Error procedure&#10;--&#10;--***************************************************&#10;--                                                  *&#10;-- PKG_COMMON wrappers                              *&#10;--                                                  *&#10;--***************************************************&#10;FUNCTION get_version RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN g_package_name || &#39;[version &#61;&gt; &#39; || g_package_version || &#39;]&#39;;&#10;END get_version;&#10;--&#10;PROCEDURE procDebug(p_msg CLOB, p_print_flag VARCHAR2 DEFAULT &#39;N&#39;) IS&#10;BEGIN&#10;    PKG_Debug.procDebug(p_msg, p_print_flag);&#10;END procDebug;&#10;--&#10;FUNCTION funcgetDebugMode RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Debug.funcgetDebugMode;&#10;END funcgetDebugMode;&#10;--&#10;PROCEDURE message(p_msg VARCHAR2, p_trace_level INTEGER DEFAULT 0) IS&#10;BEGIN&#10;    procDebug(&#39;[&#39; || g_label || &#39;] &#39; || p_msg, p_print_flag &#61;&gt; &#39;Y&#39;);&#10;END message;&#10;--&#10;FUNCTION is_str_empty(p_str VARCHAR2, p_ignore_spaces_and_zeroes VARCHAR2 DEFAULT &#39;N&#39;) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.is_str_empty( p_str, p_ignore_spaces_and_zeroes );&#10;END is_str_empty;&#10;--&#10;FUNCTION empty2null(p_str VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.empty2null(p_str);&#10;END empty2null;&#10;--&#10;FUNCTION nvlstr(p_str1 VARCHAR2, p_str2 VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;   RETURN PKG_Common.NVLSTR(p_str1 &#61;&gt; p_str1, p_str2 &#61;&gt; p_str2);&#10;END nvlstr;&#10;--&#10;PROCEDURE raise_error(p_err_msg VARCHAR2, p_proc VARCHAR2, p_label VARCHAR2 DEFAULT NULL) IS&#10;BEGIN&#10;    procDebug(&#10;        p_proc || &#39; FAILED. [Step: &#39; || PKG_Common.nvl2(p_label, g_label, &#39;N/A&#39;) || &#39;]&#39; ||&#10;        --&#39;[&#39; || DBMS_UTILITY.format_error_backtrace || &#39;]: &#39; ||&#10;        &#39;[&#39; || DBMS_UTILITY.format_call_stack || &#39;]: &#39; ||&#10;        p_err_msg,&#10;        p_print_flag &#61;&gt; &#39;Y&#39; );&#10;    PKG_Common.raise_error( p_err_msg, p_proc, p_label );&#10;END raise_error;&#10;--&#10;--&#10;--***************************************************&#10;-- Helpers                                          *&#10;--***************************************************&#10;--&#10;-- Used to populate mtt_message_log with information type message&#10;PROCEDURE info (message_in VARCHAR2)&#10;IS&#10;BEGIN&#10;    IF SPGConfig.SPGInfoActive THEN&#10;        SPGConfig.insert_message_log(&#10;            message_type_id_in  &#61;&gt; mt_information,&#10;            component_code_in   &#61;&gt; g_component_code,&#10;            package_name_in     &#61;&gt; g_package_name,&#10;            procedure_name_in   &#61;&gt; g_procedure_name,&#10;            label_in            &#61;&gt; g_label,&#10;            message_text_in     &#61;&gt; message_in );&#10;    END IF;&#10;END info;&#10;--&#10;-- Will populate mtt_message_log with warning message - will populate mtt_error_log if result of exception&#10;PROCEDURE warn (message_in VARCHAR2)&#10;IS&#10;BEGIN&#10;    IF SPGConfig.SPGWarnActive THEN&#10;        SPGConfig.record_error(&#10;            message_type_id_in    &#61;&gt; mt_warning,&#10;            component_code_in     &#61;&gt; g_component_code,&#10;            package_name_in       &#61;&gt; g_package_name,&#10;            procedure_name_in     &#61;&gt; g_procedure_name,&#10;            label_in              &#61;&gt; g_label,&#10;            message_text_in       &#61;&gt; message_in );&#10;    END IF;&#10;END warn;&#10;--&#10;-- Will populate mtt_message_log with error message and populate mtt_error_log with exception - used for log and continue&#10;PROCEDURE error (message_in VARCHAR2)&#10;IS&#10;BEGIN&#10;    SPGConfig.record_error(&#10;        message_type_id_in    &#61;&gt; mt_error,&#10;        component_code_in     &#61;&gt; g_component_code,&#10;        package_name_in       &#61;&gt; g_package_name,&#10;        procedure_name_in     &#61;&gt; g_procedure_name,&#10;        label_in              &#61;&gt; g_label,&#10;        message_text_in       &#61;&gt; message_in );&#10;END error;&#10;--&#10;-- Will populate mtt_message_log, mtt_error_log with error message and raise exception - used for log and halt&#10;PROCEDURE fatal (message_in VARCHAR2)&#10;IS&#10;BEGIN&#10;    SPGConfig.record_error(&#10;        message_type_id_in    &#61;&gt; mt_fatal_error,&#10;        component_code_in     &#61;&gt; g_component_code,&#10;        package_name_in       &#61;&gt; g_package_name,&#10;        procedure_name_in     &#61;&gt; g_procedure_name,&#10;        label_in              &#61;&gt; g_label,&#10;        message_text_in       &#61;&gt; message_in,&#10;        raise_error_in        &#61;&gt; TRUE );&#10;END fatal;&#10;--&#10;-- -----------------------------------&#10;-- Multi-thread Support subroutines --&#10;--------------------------------------&#10;--&#10;--&#10;PROCEDURE get_current_session_details(p_inst_name IN OUT VARCHAR2, p_sid IN OUT NUMBER, p_serial# IN OUT NUMBER) IS&#10;BEGIN&#10;    --&#10;    p_sid :&#61; DBMS_DEBUG_JDWP.current_session_id;&#10;    p_serial# :&#61; DBMS_DEBUG_JDWP.current_session_serial;&#10;    --&#10;--    SELECT sid, serial#&#10;--    INTO p_sid, p_serial#&#10;--    FROM v$session&#10;--    WHERE sid &#61; SYS_CONTEXT(&#39;USERENV&#39;, &#39;SID&#39;);&#10;    --&#10;    SELECT /*+RESULT_CACHE*/ instance_name&#10;    INTO p_inst_name&#10;    FROM v$instance;&#10;    --&#10;--    -- PG version&#10;--    SELECT&#10;--      PKG_Common.get_session_id,&#10;--      PKG_Common.get_session_id,&#10;--      &#39;master&#39;&#10;--    INTO&#10;--      p_sid,&#10;--      p_serial#,&#10;--      p_inst_name&#10;--    FROM dual;&#10;    --&#10;END get_current_session_details;&#10;--&#10;--&#10;FUNCTION check_heartbeat(p_component_id PDT_THREAD.component_id%TYPE, p_thread_id PDT_THREAD.thread_id%TYPE) RETURN BOOLEAN&#10;IS&#10;    --&#10;    l_sid       NUMBER;&#10;    l_serial   NUMBER;&#10;    l_inst_id   NUMBER;&#10;    l_inst_name PDT_THREAD.instance_name%TYPE;&#10;    --&#10;    l_heartbeat_int  INTEGER;&#10;    l_heartbeat_flag BOOLEAN :&#61; FALSE;&#10;    l_sid_count      INTEGER;&#10;    --&#10;    l_sql VARCHAR2(4000);&#10;    l_ret VARCHAR2(4000);&#10;    --&#10;    CURSOR csThread IS&#10;      SELECT /*+PARALLEL(PDT_thread, 1)*/&#10;        (CASE WHEN T.last_heartbeat_dt &gt;&#61; NVL(T.last_heartbeat_check_dt, TO_DATE(&#39;01/01/1900&#39;, &#39;dd/mm/yyyy&#39;)) THEN 1 ELSE 0 END) HEARTBEAT_FLAG,&#10;        T.sid,&#10;        T.serial#,&#10;        --I.inst_id,&#10;        T.instance_name&#10;      FROM PDT_thread T&#10;        --, gv$instance I&#10;      WHERE T.component_id  &#61; p_component_id&#10;        AND T.thread_id     &#61; p_thread_id&#10;        --AND I.instance_name &#61; T.instance_name&#10;        AND T.status &#61; 1&#10;        AND ROWNUM &lt;&#61; 1;&#10;    --&#10;    CURSOR csInstance IS&#10;      SELECT /*+RESULT_CACHE*/ inst_id&#10;      FROM gv$instance&#10;      WHERE instance_name &#61; l_inst_name;&#10;    --&#10;BEGIN&#10;    --&#10;    OPEN csThread;&#10;    FETCH csThread INTO&#10;      l_heartbeat_int,&#10;      l_sid,&#10;      l_serial,&#10;      l_inst_name&#10;    ;&#10;    IF csThread%NOTFOUND THEN&#10;        CLOSE csThread;&#10;        RETURN TRUE;&#10;    END IF;&#10;    CLOSE csThread;&#10;    --&#10;    --&#10;    -- PG version&#10;--    SELECT&#10;--      (CASE WHEN T.last_heartbeat_dt &gt;&#61; NVL(T.last_heartbeat_check_dt, TO_DATE(&#39;01/01/1900&#39;, &#39;dd/mm/yyyy&#39;)) THEN 1 ELSE 0 END) AS heartbeat_flag,&#10;--      T.sid,&#10;--      T.serial#,&#10;--      1 AS inst_id&#10;--    INTO&#10;--      l_heartbeat_int,&#10;--      l_sid,&#10;--      l_serial,&#10;--      l_inst_id&#10;--    FROM pdt_thread T&#10;--    WHERE T.component_id  &#61; p_component_id&#10;--      AND T.thread_id     &#61; p_thread_id&#10;--      AND ROWNUM &lt;&#61; 1;&#10;    --&#10;    IF l_heartbeat_int &#61; 1 THEN&#10;        l_heartbeat_flag :&#61; TRUE;&#10;    END IF;&#10;    --&#10;    IF NOT l_heartbeat_flag THEN&#10;        --&#10;        IF TRIM(l_inst_name) IS NULL THEN&#10;            l_inst_id :&#61; 1;&#10;        ELSIF g_instance_TAB.EXISTS(l_inst_name) THEN&#10;            l_inst_id :&#61; g_instance_TAB(l_inst_name);&#10;        ELSE&#10;            OPEN csInstance;&#10;            FETCH csInstance INTO l_inst_id;&#10;            IF csInstance%FOUND THEN&#10;                g_instance_TAB(l_inst_name) :&#61; l_inst_id;&#10;            ELSE&#10;                CLOSE csInstance;&#10;                raise_application_error(-20001, &#39;FATAL ERROR in PDT_THREAD.check_heartbeat: failed to locate the [&#39; || l_inst_name || &#39;] in GV$INSTANCE&#39;);&#10;            END IF;&#10;            CLOSE csInstance;&#10;        END IF;&#10;        --&#10;        SELECT COUNT(1)&#10;        INTO l_sid_count&#10;        FROM gv$session&#10;        WHERE sid     &#61; l_sid&#10;          AND serial# &#61; l_serial&#10;          AND inst_id &#61; l_inst_id&#10;          AND NVL(UPPER(status), &#39;X&#39;) !&#61; &#39;KILLED&#39;;&#10;        --&#10;        -- PG version&#10;--        SELECT COUNT(1)&#10;--        INTO l_sid_count&#10;--        FROM pg_stat_activity p&#10;--        WHERE p.pid &#61; l_sid&#10;--          AND LOWER(state) &#61; &#39;active&#39;;&#10;        --&#10;        IF l_sid_count &gt; 0 THEN&#10;            l_heartbeat_flag :&#61; TRUE;&#10;        ELSE&#10;            -- Double check if the PDT_THREAD.status is still set to 1?&#10;            OPEN csThread;&#10;            FETCH csThread INTO&#10;              l_heartbeat_int,&#10;              l_sid,&#10;              l_serial,&#10;              l_inst_name&#10;            ;&#10;            IF csThread%NOTFOUND THEN&#10;                l_heartbeat_flag :&#61; TRUE;&#10;            END IF;&#10;            CLOSE csThread;&#10;        END IF;&#10;        --&#10;    END IF;&#10;    --&#10;    PKG_DynSQL.exec_SQL_atnm(&#10;       &#39;UPDATE PDT_thread SET last_heartbeat_check_dt &#61; SYSDATE&#10;        WHERE component_id &#61; TO_NUMBER(:p_param_1)&#10;          AND thread_id    &#61; TO_NUMBER(:p_param_2)&#39;,&#10;        p_param_1 &#61;&gt; TO_CHAR(p_component_id),&#10;        p_param_2 &#61;&gt; TO_CHAR(p_thread_id) );&#10;    --&#10;    RETURN l_heartbeat_flag;&#10;    --&#10;END check_heartbeat;&#10;--&#10;PROCEDURE check_heartbeat_ALL( p_component_id PDT_THREAD.component_id%TYPE, p_thread_id PDT_THREAD.thread_id%TYPE DEFAULT NULL )&#10;IS&#10;    --&#10;    l_component_id INTEGER;&#10;    l_thread_id    INTEGER;&#10;    --&#10;    CURSOR cs IS&#10;      SELECT DISTINCT component_id, thread_id&#10;      FROM pdt_thread&#10;      WHERE component_id &#61; p_component_id&#10;        AND thread_id &#61; NVL(p_thread_id, thread_id)&#10;        AND status &#61; 1;&#10;    --&#10;BEGIN&#10;    --&#10;    OPEN cs;&#10;    LOOP&#10;        FETCH cs INTO l_component_id, l_thread_id;&#10;        EXIT WHEN cs%NOTFOUND;&#10;        --&#10;        IF ( get_thread_status(p_component_id &#61;&gt; l_component_id, p_thread_id &#61;&gt; l_thread_id) &#61; 1 ) AND&#10;           ( NOT check_heartbeat(p_component_id &#61;&gt; l_component_id, p_thread_id &#61;&gt; l_thread_id)   )&#10;        THEN&#10;            IF get_thread_status(p_component_id &#61;&gt; l_component_id, p_thread_id &#61;&gt; l_thread_id) &#61; 1 THEN&#10;                update_thread_status( p_component_id &#61;&gt; l_component_id,&#10;                                      p_thread_id &#61;&gt; l_thread_id,&#10;                                      p_status &#61;&gt; 2,&#10;                                      p_err_msg &#61;&gt; &#39;Dead thread detected [&#39; || TO_CHAR(l_component_id) || &#39;:&#39; || TO_CHAR(l_thread_id) || &#39;]&#39;,&#10;                                      p_info_msg  &#61;&gt; &#39;&#39;);&#10;                --&#10;                warn( &#39;WARNING: Dead thread detected [&#39; || TO_CHAR(l_component_id) || &#39;:&#39; || TO_CHAR(l_thread_id) || &#39;]&#39; );&#10;                --&#10;            END IF;&#10;        END IF;&#10;    END LOOP;&#10;    --&#10;    IF cs%ISOPEN THEN&#10;        CLOSE cs;&#10;    END IF;&#10;    --&#10;END check_heartbeat_ALL;&#10;--&#10;PROCEDURE create_thread_process(&#10;    p_component_id    PDT_THREAD.component_id%TYPE,&#10;    p_thread_id       PDT_THREAD.thread_id%TYPE,&#10;    p_min_id_val      NUMBER   DEFAULT NULL,&#10;    p_max_id_val      NUMBER   DEFAULT NULL,&#10;    p_current_id_val  NUMBER   DEFAULT NULL,&#10;    p_program_action  VARCHAR2 DEFAULT &#39;no_program_action&#39;,&#10;    p_job_name        VARCHAR2 DEFAULT NULL,&#10;    p_thread_label    VARCHAR2 DEFAULT NULL,&#10;    p_fixit_proc      VARCHAR2 DEFAULT NULL,&#10;    p_instance_number INTEGER   DEFAULT 1,&#10;    --&#10;    p_autonomous_trx  VARCHAR2 DEFAULT &#39;N&#39; )&#10;IS&#10;    --&#10;    l_status INTEGER;&#10;    --&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;CREATE_THREAD_PROCESS&#39;;&#10;    l_prog_name VARCHAR2(100);&#10;    l_job_name  VARCHAR2(100);&#10;    --&#10;    l_calling_procedure VARCHAR2(30);&#10;    --&#10;    l_program_action  PDT_THREAD.program_action%TYPE;&#10;    --&#10;    CURSOR cs IS&#10;      SELECT status&#10;      FROM pdt_thread&#10;      WHERE component_id &#61; p_component_id&#10;        AND thread_id &#61; p_thread_id;&#10;    --&#10;BEGIN&#10;    l_calling_procedure :&#61; g_procedure_name;&#10;    g_procedure_name  :&#61; &#39;create_thread_process&#39;;&#10;    g_label           :&#61; &#39;10000&#39;;&#10;    --&#10;    g_label :&#61; &#39;10010&#39;;&#10;    g_component_code :&#61; TO_CHAR(p_component_id);&#10;    --info(&#39;commence....&#39;);&#10;    --&#10;    g_label :&#61; &#39;10020&#39;;&#10;    IF p_thread_id &lt; 1 THEN&#10;        raise_error(&#39;P_THREAD_ID parameter value must be &gt; than 0&#39;, l_proc);&#10;    END IF;&#10;    --&#10;    IF NVLSTR(p_autonomous_trx, &#39;N&#39;) &#61; &#39;N&#39; THEN&#10;        g_label :&#61; &#39;20030&#39;;&#10;        --&#10;        PKG_DynSQL.exec_SQL_atnm(&#10;           &#39;BEGIN&#10;               PKG_mthread.create_thread_process(&#10;                   p_component_id    &#61;&gt; TO_NUMBER(:p_param_1),&#10;                   p_thread_id       &#61;&gt; TO_NUMBER(:p_param_2),&#10;                   p_min_id_val      &#61;&gt; TO_NUMBER(:p_param_3),&#10;                   p_max_id_val      &#61;&gt; TO_NUMBER(:p_param_4),&#10;                   p_current_id_val  &#61;&gt; TO_NUMBER(:p_param_5),&#10;                   p_instance_number &#61;&gt; TO_NUMBER(:p_param_6),&#10;                   p_program_action  &#61;&gt; :p_param_7,&#10;                   p_job_name        &#61;&gt; :p_param_8,&#10;                   p_thread_label    &#61;&gt; :p_param_9,&#10;                   p_fixit_proc      &#61;&gt; :p_param_10,&#10;                   --&#10;                   p_autonomous_trx &#61;&gt; &#39;&#39;Y&#39;&#39; );&#10;            END;&#39;,&#10;            --&#10;            p_param_1  &#61;&gt; TO_CHAR(p_component_id),&#10;            p_param_2  &#61;&gt; TO_CHAR(p_thread_id),&#10;            p_param_3  &#61;&gt; TO_CHAR(p_min_id_val),&#10;            p_param_4  &#61;&gt; TO_CHAR(p_max_id_val),&#10;            p_param_5  &#61;&gt; TO_CHAR(p_current_id_val),&#10;            p_param_6  &#61;&gt; TO_CHAR(p_instance_number),&#10;            p_param_7  &#61;&gt; REPLACE(p_program_action, &#39;&#39;&#39;&#39;, &#39;@&quot;@&#39;),&#10;            p_param_8  &#61;&gt; REPLACE(p_job_name      , &#39;&#39;&#39;&#39;, &#39;@&quot;@&#39;),&#10;            p_param_9  &#61;&gt; REPLACE(p_thread_label  , &#39;&#39;&#39;&#39;, &#39;@&quot;@&#39;),&#10;            p_param_10 &#61;&gt; REPLACE(p_fixit_proc    , &#39;&#39;&#39;&#39;, &#39;@&quot;@&#39;) );&#10;        --&#10;    ELSE&#10;        --&#10;        -- Check if there are any residual records for the current Thread ID&#10;        g_label :&#61; &#39;10030&#39;;&#10;        --info(&#39;checking for residual records&#39;);&#10;        OPEN cs;&#10;        FETCH cs INTO l_status;&#10;        IF cs%NOTFOUND THEN&#10;            l_status :&#61; 0;&#10;        END IF;&#10;        CLOSE cs;&#10;        --info(&#39;l_status &#61;&gt; [&#39; || TO_CHAR(l_status) || &#39;]&#39;);&#10;        --&#10;        g_label :&#61; &#39;10040&#39;;&#10;        IF l_status &#61; 1 THEN&#10;            raise_error(&#39;Thread [component_id&#61;&#39; || p_component_id || &#39;][thread_id&#61;&#39; || p_thread_id || &#39;] is still running - please check the PDT_THREAD table&#39;, l_proc);&#10;        ELSIF l_status &lt;&gt; 0 THEN&#10;            info(&#39;removing pdt_thread rows&#39;);&#10;            g_label :&#61; &#39;10050&#39;;&#10;            -- Remove record if status in (2,3)&#10;            DELETE FROM pdt_thread&#10;            WHERE component_id &#61; p_component_id&#10;              AND thread_id &#61; p_thread_id;&#10;            --&#10;        END IF;&#10;        --&#10;        info(&#39;inserting row into pdt_thread for job&#39;);&#10;        g_label :&#61; &#39;10055&#39;;&#10;        l_program_action :&#61; CASE WHEN p_program_action &#61; &#39;no_program_action&#39; THEN p_job_name ELSE p_program_action END;&#10;        g_label :&#61; &#39;10060&#39;;&#10;        --&#10;        INSERT INTO PDT_thread(&#10;          component_id,&#10;          thread_id,&#10;          status,&#10;          start_id_val,&#10;          end_id_val,&#10;          current_id_val,&#10;          num_of_rows,&#10;          start_date,&#10;          finish_date,&#10;          program_action,&#10;          thread_label,&#10;          thread_fixit_job,&#10;          last_heartbeat_dt&#10;        ) VALUES (&#10;          p_component_id,&#10;          p_thread_id,&#10;          1,&#10;          p_min_id_val,&#10;          p_max_id_val,&#10;          p_current_id_val,&#10;          0,&#10;          SYSDATE,&#10;          NULL,&#10;          REPLACE(l_program_action, &#39;@&quot;@&#39;, &#39;&#39;&#39;&#39;),&#10;          REPLACE(p_thread_label  , &#39;@&quot;@&#39;, &#39;&#39;&#39;&#39;),&#10;          REPLACE(p_fixit_proc    , &#39;@&quot;@&#39;, &#39;&#39;&#39;&#39;),&#10;          SYSDATE );&#10;        --&#10;        COMMIT;&#10;        --&#10;        IF p_program_action !&#61; &#39;no_program_action&#39; THEN&#10;            -- Create DBMS_SCHEDULE job&#10;            g_label :&#61; &#39;10070&#39;;&#10;            l_prog_name :&#61; &#39;SPG_&#39; || p_component_id || &#39;_&#39; || p_thread_id;&#10;            l_job_name  :&#61; l_prog_name;&#10;            info(&#39;generating program_name &#61;&gt; [&#39; || l_prog_name || &#39;] job_name &#61;&gt; [&#39; || l_job_name || &#39;]&#39;);&#10;            --&#10;            -- Drop the program in case if it does already exist&#10;            g_label :&#61; &#39;10080&#39;;&#10;            --info(&#39;drop program&#39;);&#10;            BEGIN&#10;                DBMS_SCHEDULER.drop_program(program_name &#61;&gt; l_prog_name, force &#61;&gt; TRUE);&#10;            EXCEPTION WHEN OTHERS THEN&#10;                --info(&#39;drop program error handled [&#39; || SQLERRM || &#39;]&#39;);&#10;                NULL;&#10;            END;&#10;            -- Drop the job in case if it does already exist&#10;            --&#10;            g_label :&#61; &#39;10090&#39;;&#10;            --info(&#39;drop job&#39;);&#10;            BEGIN&#10;                DBMS_SCHEDULER.drop_job(job_name &#61;&gt; l_job_name, force &#61;&gt; TRUE);&#10;            EXCEPTION WHEN OTHERS THEN&#10;            --    info(&#39;drop job error handled [&#39; || SQLERRM || &#39;]&#39;);&#10;                NULL;&#10;            END;&#10;&#10;            -- Create the regular job&#10;            g_label :&#61; &#39;10100&#39;;&#10;            info(&#39;creating job( job_action&#61;&gt;[&#39; || REPLACE(p_program_action, &#39;@&quot;@&#39;, &#39;&#39;&#39;&#39;) || &#39;] )&#39;);&#10;            DBMS_SCHEDULER.create_job(&#10;                job_name        &#61;&gt; l_job_name,&#10;                job_type        &#61;&gt; &#39;PLSQL_BLOCK&#39;,&#10;                job_action      &#61;&gt; REPLACE(p_program_action, &#39;@&quot;@&#39;, &#39;&#39;&#39;&#39;),&#10;                comments        &#61;&gt; &#39;C&#39; || p_component_id || &#39; parallel worker (thread# &#39; || p_thread_id || &#39;)&#39;,&#10;                --&#10;                enabled         &#61;&gt; FALSE,&#10;                auto_drop       &#61;&gt; TRUE&#10;                --&#10;                --start_date      &#61;&gt; SYSDATE&#10;            );&#10;            --&#10;            g_label :&#61; &#39;10110&#39;;&#10;            IF p_instance_number IS NOT NULL THEN&#10;                -- Set job attribute to single instance number&#10;                DBMS_SCHEDULER.set_attribute(&#10;                    name      &#61;&gt; l_job_name,&#10;                    attribute &#61;&gt; &#39;instance_id&#39;,&#10;                    value     &#61;&gt; p_instance_number);&#10;            END IF;&#10;            --&#10;            g_label :&#61; &#39;10120&#39;;&#10;            --info(&#39;enabling job&#39;);&#10;            --&#10;            DBMS_SCHEDULER.enable(name &#61;&gt; l_job_name );&#10;            --&#10;        END IF;&#10;        --&#10;        COMMIT;&#10;        --&#10;    END IF;&#10;    --&#10;    g_procedure_name :&#61; l_calling_procedure;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    warn(SQLERRM);&#10;    RAISE;&#10;END create_thread_process;&#10;--&#10;PROCEDURE update_thread_progress(&#10;    p_component_id    PDT_THREAD.component_id%TYPE,&#10;    p_thread_id       PDT_THREAD.thread_id%TYPE,&#10;    p_rows            PDT_THREAD.num_of_rows%TYPE DEFAULT 0,&#10;    p_current_id_val  NUMBER                      DEFAULT NULL,&#10;    p_info_msg        VARCHAR2                    DEFAULT NULL,&#10;    --&#10;    p_autonomous_trx  VARCHAR2                    DEFAULT &#39;N&#39; )&#10;IS&#10;    --&#10;    l_inst_name VARCHAR2(30);&#10;    l_sid       NUMBER;&#10;    l_serial   NUMBER;&#10;    --&#10;    l_calling_procedure VARCHAR2(30);&#10;    --&#10;BEGIN&#10;    g_component_code    :&#61; p_component_id;&#10;    l_calling_procedure :&#61; g_procedure_name;&#10;    g_procedure_name    :&#61; &#39;update_thread_progress&#39;;&#10;    --&#10;    g_label           :&#61; &#39;20000&#39;;&#10;    --&#10;    IF NVLSTR(p_autonomous_trx, &#39;N&#39;) &#61; &#39;N&#39; THEN&#10;        g_label :&#61; &#39;20030&#39;;&#10;        --&#10;        PKG_DynSQL.exec_SQL_atnm(&#10;           &#39;BEGIN&#10;               PKG_mthread.update_thread_progress(&#10;                   p_component_id   &#61;&gt; TO_NUMBER(:p_param_1),&#10;                   p_thread_id      &#61;&gt; TO_NUMBER(:p_param_2),&#10;                   p_rows           &#61;&gt; TO_NUMBER(:p_param_3),&#10;                   p_current_id_val &#61;&gt; TO_NUMBER(:p_param_4),&#10;                   p_info_msg       &#61;&gt; :p_param_5,&#10;                   --&#10;                   p_autonomous_trx &#61;&gt; &#39;&#39;Y&#39;&#39; );&#10;            END;&#39;,&#10;            --&#10;            p_param_1 &#61;&gt; TO_CHAR(p_component_id),&#10;            p_param_2 &#61;&gt; TO_CHAR(p_thread_id),&#10;            p_param_3 &#61;&gt; TO_CHAR(p_rows),&#10;            p_param_4 &#61;&gt; TO_CHAR(p_current_id_val),&#10;            p_param_5 &#61;&gt; REPLACE(p_info_msg, &#39;&#39;&#39;&#39;, &#39;@&quot;@&#39;) );&#10;        --&#10;    ELSE&#10;        --&#10;        get_current_session_details(l_inst_name, l_sid, l_serial);&#10;        --&#10;        UPDATE pdt_thread SET&#10;          num_of_rows       &#61; p_rows,&#10;          current_id_val    &#61; p_current_id_val,&#10;          info_message      &#61; REPLACE(p_info_msg, &#39;@&quot;@&#39;, &#39;&#39;&#39;&#39;),&#10;          --&#10;          instance_name     &#61; l_inst_name,&#10;          sid               &#61; l_sid,&#10;          serial#           &#61; l_serial,&#10;          last_heartbeat_dt &#61; SYSDATE&#10;          --&#10;        WHERE component_id &#61; p_component_id&#10;          AND thread_id &#61; p_thread_id;&#10;        --&#10;        COMMIT;&#10;        --&#10;    END IF;&#10;    --&#10;    g_procedure_name :&#61; l_calling_procedure;&#10;    --&#10;END update_thread_progress;&#10;--&#10;PROCEDURE reset_threads(&#10;    p_component_id    PDT_THREAD.component_id%TYPE,&#10;    p_thread_id       PDT_THREAD.thread_id%TYPE DEFAULT NULL,&#10;    --&#10;    p_autonomous_trx  VARCHAR2                  DEFAULT &#39;N&#39; )&#10;IS&#10;    l_calling_procedure VARCHAR2(30);&#10;BEGIN&#10;    g_component_code    :&#61; p_component_id;&#10;    l_calling_procedure :&#61; g_procedure_name;&#10;    g_procedure_name    :&#61; &#39;reset_threads&#39;;&#10;    --&#10;    g_label             :&#61; &#39;30000&#39;;&#10;    IF NVLSTR(p_autonomous_trx, &#39;N&#39;) &#61; &#39;N&#39; THEN&#10;        PKG_DynSQL.exec_SQL_atnm(&#10;           &#39;BEGIN&#10;               PKG_mthread.reset_threads(&#10;                   p_component_id   &#61;&gt; TO_NUMBER(:p_param_1),&#10;                   p_thread_id      &#61;&gt; TO_NUMBER(:p_param_2),&#10;                   --&#10;                   p_autonomous_trx &#61;&gt; &#39;&#39;Y&#39;&#39; );&#10;            END;&#39;,&#10;            --&#10;            p_param_1 &#61;&gt; TO_CHAR(p_component_id),&#10;            p_param_2 &#61;&gt; TO_CHAR(p_thread_id)&#10;        );&#10;        --&#10;    ELSE&#10;        g_label :&#61; &#39;30035&#39;;&#10;        DELETE FROM pdt_thread&#10;        WHERE component_id &#61; p_component_id&#10;          AND thread_id &#61; NVL(p_thread_id, thread_id);&#10;        --&#10;        info (TO_CHAR(SQL%ROWCOUNT) || &#39; rows deleted from pdt_thread [&#39; || TO_CHAR(p_component_id) || &#39;][&#39; || TO_CHAR(p_thread_id) || &#39;]&#39; );&#10;        --&#10;        COMMIT;&#10;        --&#10;    END IF;&#10;    --&#10;    g_label :&#61; &#39;30040&#39;;&#10;    g_procedure_name :&#61; l_calling_procedure;&#10;    --&#10;END reset_threads;&#10;--&#10;PROCEDURE reset_failed_threads(&#10;    p_component_id    PDT_THREAD.component_id%TYPE,&#10;    p_autonomous_trx  VARCHAR2  DEFAULT &#39;N&#39; )&#10;IS&#10;    l_calling_procedure  VARCHAR2(30);&#10;BEGIN&#10;    --&#10;    l_calling_procedure :&#61; g_procedure_name;&#10;    g_procedure_name  :&#61; &#39;reset_failed_threads&#39;;&#10;    g_label           :&#61; &#39;150000&#39;;&#10;    --&#10;    g_label :&#61; &#39;150010&#39;;&#10;    IF NVLSTR(p_autonomous_trx, &#39;N&#39;) &#61; &#39;N&#39; THEN&#10;        PKG_DynSQL.exec_SQL_atnm(&#10;           &#39;BEGIN&#10;               PKG_mthread.reset_failed_threads(&#10;                   p_component_id   &#61;&gt; TO_NUMBER(:p_param_1),&#10;                   --&#10;                   p_autonomous_trx &#61;&gt; &#39;&#39;Y&#39;&#39; );&#10;            END;&#39;,&#10;            --&#10;            p_param_1 &#61;&gt; TO_CHAR(p_component_id));&#10;        --&#10;    ELSE&#10;        g_label :&#61; &#39;150020&#39;;&#10;        DELETE FROM pdt_thread&#10;        WHERE component_id &#61; p_component_id&#10;          AND status &#61; 2&#10;          AND ( last_heartbeat_dt &lt; NVL(last_heartbeat_check_dt, SYSDATE)&#10;                OR&#10;                NOT EXISTS (SELECT 1 FROM gv$session WHERE sid &#61; PDT_THREAD.sid AND serial# &#61; PDT_THREAD.serial# AND status &#61; &#39;ACTIVE&#39;)&#10;              )&#10;        ;&#10;        --&#10;        info (TO_CHAR(SQL%ROWCOUNT) || &#39; rows deleted from pdt_thread [&#39; || TO_CHAR(p_component_id) || &#39;]&#39; );&#10;        --&#10;        COMMIT;&#10;        --&#10;    END IF;&#10;    --&#10;    g_label :&#61; &#39;150030&#39;;&#10;    g_procedure_name :&#61; l_calling_procedure;&#10;    --&#10;END reset_failed_threads;&#10;&#10;--&#10;-- This function is in preparation for coding round robin multi-threading&#10;--&#10;-- When called the function will return the next available thread_id which&#10;-- can then be used by the CREATE_THREAD_PROCESS.&#10;-- The function has three exit points&#10;--         1) Thread available&#10;--               returns thread_id&#10;--         2) Timeout&#10;--               returns 0 if processing time exceeds timeout parameter&#10;--         3) Semaphore&#10;--               raises error if &#39;STOP&#39; is committed to PDT_SEMAPHORE table&#10;--&#10;-- The p_wait configuration is the amount of time the functions sleeps between&#10;-- checking for available threads. If p_timeout is set &lt;&#61; 0 then the function&#10;-- will not timeout.&#10;--&#10;FUNCTION get_max_threads(p_max_threads NUMBER)&#10;RETURN NUMBER IS&#10;BEGIN&#10;    RETURN&#10;        CASE WHEN NVL(p_max_threads, 0) &lt;&#61; 0&#10;            THEN get_cpu_count&#10;        ELSE&#10;            LEAST(p_max_threads, get_cpu_count * 10 * get_db_inst_count)&#10;        END;&#10;END get_max_threads;&#10;--&#10;FUNCTION get_available_thread(&#10;    p_component_id PDT_THREAD.component_id%TYPE,&#10;    p_wait         INTEGER DEFAULT 1,&#10;    p_timeout      INTEGER DEFAULT 30,&#10;    p_max_threads  INTEGER DEFAULT 0)&#10;RETURN NUMBER&#10;IS&#10;    --&#10;    PRAGMA AUTONOMOUS_TRANSACTION;&#10;    --&#10;    l_calling_procedure VARCHAR2(30);&#10;    --&#10;    l_max_threads       INTEGER;&#10;    l_available_thread  INTEGER :&#61; 0;&#10;    l_thread_count      INTEGER :&#61; 0;&#10;    l_wait              INTEGER;&#10;    l_start             NUMBER;&#10;    --&#10;    l_loop_count        INTEGER :&#61; 0;&#10;    --&#10;    CURSOR cs IS&#10;      SELECT MIN(thread_id)&#10;      FROM pdt_thread&#10;      WHERE component_id &#61; p_component_id&#10;        AND thread_id &lt;&#61; l_max_threads&#10;        AND ( ( finish_date IS NULL     AND status &lt;&gt; 1 ) OR&#10;              ( finish_date IS NOT NULL AND status  &#61; 2 ) OR&#10;              ( finish_date IS NOT NULL AND status  &#61; 3 )&#10;            );&#10;    --&#10;    CURSOR cs1 IS&#10;      SELECT thread_id, status, finish_date&#10;      FROM pdt_thread&#10;      WHERE component_id &#61; p_component_id&#10;        AND thread_id &lt;&#61; l_max_threads&#10;      ORDER BY 1, 2;&#10;    --&#10;    l_rec1 cs1%ROWTYPE;&#10;    TYPE l_TAB_TYP1 IS TABLE OF cs1%ROWTYPE;&#10;    l_TAB1 l_TAB_TYP1;&#10;    --&#10;    TYPE l_tab_TYP IS TABLE OF cs1%ROWTYPE INDEX BY PLS_INTEGER;&#10;    l_tab l_tab_TYP;&#10;    --&#10;    l_thread_id INTEGER;&#10;    --&#10;BEGIN&#10;    --&#10;    g_component_code    :&#61; p_component_id;&#10;    l_calling_procedure :&#61; g_procedure_name;&#10;    g_procedure_name    :&#61; &#39;get_available_thread&#39;;&#10;    --&#10;    l_max_threads :&#61; get_max_threads(p_max_threads);&#10;    --&#10;    OPEN cs1;&#10;    FETCH cs1 BULK COLLECT INTO l_tab1;&#10;    CLOSE cs1;&#10;    --&#10;    --info(&#39;Threads status for [component_id&#61;&#39; || p_component_id || &#39;]:&#39;);&#10;    FOR l_idx IN 1..l_tab1.COUNT LOOP&#10;        l_rec1 :&#61; l_tab1(l_idx);&#10;        l_tab(l_rec1.thread_id) :&#61; l_rec1;&#10;        info(&#39;[component_id&#61;&#39; || p_component_id || &#39;][thread_id&#61;&#39; || l_rec1.thread_id || &#39;][status&#61;&#39; || l_rec1.status || &#39;][finish_date&#61;&#39; || TO_CHAR(l_rec1.finish_date, &#39;YYYYMMDD HH24:MI:SS&#39;) || &#39;]&#39;);&#10;    END LOOP;&#10;    --&#10;    l_start :&#61; DBMS_UTILITY.get_time;&#10;    l_wait  :&#61; GREATEST(LEAST(60, p_wait), 0.1);&#10;    --&#10;    l_thread_count :&#61; NVL(l_TAB1.COUNT, 0);&#10;    info(&#39;component_id&#61;&#39; || p_component_id || &#39;: [COUNT_OF_THREADS&#61;&#39; || l_thread_count || &#39;][max_threads&#61;&#39; || l_max_threads || &#39;]&#39;);&#10;    --&#10;    l_available_thread :&#61; -1;&#10;    --&#10;    IF l_thread_count &#61; 0 THEN&#10;        l_available_thread :&#61; 1;&#10;    ELSIF l_thread_count &lt; l_max_threads THEN&#10;        --&#10;        FOR l_thread_id IN 1..l_max_threads LOOP&#10;            IF NOT l_TAB.EXISTS(l_thread_id) THEN&#10;                l_available_thread :&#61; l_thread_id;&#10;                EXIT;&#10;            END IF;&#10;        END LOOP;&#10;        --&#10;    END IF;&#10;    --&#10;    IF l_available_thread &lt;&#61; 0 THEN&#10;        --&#10;--        IF l_thread_count &gt; l_max_threads THEN&#10;--            info(&#39;clean up obsolete threads for [component_id&#61;&#39; || p_component_id || &#39;][thread_id &gt; &#39; || l_max_threads || &#39;]: thread count [&#39; || l_thread_count || &#39;] &gt; max threads [&#39; || l_max_threads || &#39;]&#39;);&#10;--            PKG_DynSQL.exec_SQL_atnm(&#10;--                &#39;DELETE FROM pdt_thread&#10;--                 WHERE component_id &#61; TO_NUMBER(:p_param_1) AND thread_id &gt; TO_NUMBER(:p_param_2)&#10;--                   AND ( ( finish_date IS NULL     AND status &lt;&gt; 1 ) OR&#10;--                         ( finish_date IS NOT NULL AND status  &#61; 2 ) OR&#10;--                         ( finish_date IS NOT NULL AND status  &#61; 3 ) )&#39;,&#10;--                p_param_1 &#61;&gt; TO_CHAR(p_component_id),&#10;--                p_param_2 &#61;&gt; TO_CHAR(l_max_threads) );&#10;--        END IF;&#10;        --&#10;        LOOP&#10;            --&#10;            OPEN cs;&#10;            FETCH cs INTO l_available_thread;&#10;            IF cs%NOTFOUND THEN&#10;                l_available_thread :&#61; 0;&#10;            END IF;&#10;            CLOSE cs;&#10;            --&#10;            l_loop_count :&#61; l_loop_count + 1;&#10;            IF MOD(l_loop_count, 10) &#61; 0 THEN&#10;                check_heartbeat_ALL(p_component_id);&#10;            END IF;&#10;            --&#10;            EXIT WHEN l_available_thread &gt; 0;&#10;            --&#10;            -- Wait for a number of seconds (default 0.1)&#10;            SYS.DBMS_LOCK.sleep(l_wait);&#10;            --&#10;            -- Exit if the semaphore flag is set&#10;            IF check_semaphore(TO_CHAR(p_component_id), &#39;STOP&#39;) &#61; &#39;Y&#39; THEN&#10;                raise_error(&#39;WARNING: STOP signal has been detected in PDT_SEMAPHORE&#39;, &#39;GET_AVAILABLE_THREAD&#39;);&#10;            END IF;&#10;            --&#10;            -- Exit and return 0 if thread unavailable after timeout (default 30 minutes)&#10;            IF ((DBMS_UTILITY.get_time - l_start) / 100) / 60 &gt; p_timeout AND p_timeout &gt; 0 THEN&#10;                l_available_thread :&#61; -1;&#10;                EXIT;&#10;            END IF;&#10;        END LOOP;&#10;    END IF;&#10;    --&#10;    g_procedure_name :&#61; l_calling_procedure;&#10;    --&#10;    RETURN l_available_thread;&#10;END get_available_thread;&#10;--&#10;FUNCTION get_thread_status(p_component_id PDT_THREAD.component_id%TYPE, p_thread_id PDT_THREAD.thread_id%TYPE) RETURN INTEGER&#10;IS&#10;    --&#10;    CURSOR cs IS&#10;      SELECT status&#10;      FROM pdt_thread&#10;      WHERE component_id &#61; p_component_id&#10;        AND thread_id &#61; p_thread_id;&#10;    --&#10;    l_status NUMBER;&#10;    --&#10;BEGIN&#10;    --&#10;    g_component_code :&#61; p_component_id;&#10;    --&#10;    OPEN cs;&#10;    FETCH cs INTO l_status;&#10;    IF cs%NOTFOUND THEN&#10;        l_status :&#61; -1;&#10;    END IF;&#10;    CLOSE cs;&#10;    --&#10;    RETURN l_status;&#10;END get_thread_status;&#10;--&#10;FUNCTION get_num_of_failed_threads(p_component_id PDT_THREAD.component_id%TYPE) RETURN INTEGER&#10;IS&#10;    l_cnt INTEGER;&#10;BEGIN&#10;    g_component_code :&#61; p_component_id;&#10;    --&#10;    SELECT COUNT(1)&#10;    INTO l_cnt&#10;    FROM pdt_thread&#10;    WHERE component_id &#61; p_component_id&#10;      AND NVL(status, 2) NOT IN (1, 3);&#10;    --&#10;    RETURN l_cnt;&#10;END get_num_of_failed_threads;&#10;--&#10;PROCEDURE update_thread_status(&#10;    p_component_id    PDT_THREAD.component_id%TYPE,&#10;    p_thread_id       PDT_THREAD.thread_id%TYPE,&#10;    p_status          PDT_THREAD.status%TYPE,&#10;    p_err_msg         VARCHAR2 DEFAULT NULL,&#10;    p_info_msg        VARCHAR2 DEFAULT NULL,&#10;    p_run_fixit_job   VARCHAR2 DEFAULT &#39;Y&#39;,&#10;    --&#10;    p_autonomous_trx  VARCHAR2 DEFAULT &#39;N&#39; )&#10;IS&#10;    --&#10;    l_inst_name         VARCHAR2(30);&#10;    l_sid               NUMBER;&#10;    l_serial           NUMBER;&#10;    l_call_procedure    VARCHAR2(30);&#10;    l_thread_fixit_job  PDT_THREAD.thread_fixit_job%TYPE;&#10;    l_current_id_val    PDT_THREAD.current_id_val%TYPE;&#10;    --&#10;BEGIN&#10;    l_call_procedure :&#61; g_procedure_name;&#10;    g_procedure_name :&#61; &#39;update_thread_status&#39;;&#10;    g_component_code :&#61; p_component_id;&#10;    --&#10;    g_label :&#61; &#39;10110&#39;;&#10;    --info(&#39;commencing...&#39;);&#10;    --&#10;    IF NVLSTR(p_autonomous_trx, &#39;N&#39;) &#61; &#39;N&#39; THEN&#10;        g_label :&#61; &#39;70040&#39;;&#10;        --&#10;        PKG_DynSQL.exec_SQL_atnm(&#10;           &#39;BEGIN&#10;               PKG_mthread.update_thread_status(&#10;                   p_component_id   &#61;&gt; TO_NUMBER(:p_param_1),&#10;                   p_thread_id      &#61;&gt; TO_NUMBER(:p_param_2),&#10;                   p_status         &#61;&gt; TO_NUMBER(:p_param_3),&#10;                   p_err_msg        &#61;&gt; :p_param_4,&#10;                   p_info_msg       &#61;&gt; :p_param_5,&#10;                   --&#10;                   p_autonomous_trx &#61;&gt; &#39;&#39;Y&#39;&#39; );&#10;            END;&#39;,&#10;            --&#10;            p_param_1 &#61;&gt; TO_CHAR(p_component_id),&#10;            p_param_2 &#61;&gt; TO_CHAR(p_thread_id),&#10;            p_param_3 &#61;&gt; TO_CHAR(p_status),&#10;            p_param_4 &#61;&gt; REPLACE(p_err_msg, &#39;&#39;&#39;&#39;, &#39;@&quot;@&#39;),&#10;            p_param_5 &#61;&gt; REPLACE(p_info_msg, &#39;&#39;&#39;&#39;, &#39;@&quot;@&#39;)&#10;        );&#10;        --&#10;    ELSE&#10;        g_label :&#61; &#39;70070&#39;;&#10;        get_current_session_details(l_inst_name, l_sid, l_serial);&#10;        UPDATE pdt_thread SET&#10;          status            &#61; p_status,&#10;          finish_date       &#61; DECODE(p_status, 1, finish_date, SYSDATE),&#10;          error_message     &#61; REPLACE(p_err_msg, &#39;@&quot;@&#39;, &#39;&#39;&#39;&#39;),&#10;          info_message      &#61; REPLACE(p_info_msg, &#39;@&quot;@&#39;, &#39;&#39;&#39;&#39;),&#10;          instance_name     &#61; l_inst_name,&#10;          sid               &#61; l_sid,&#10;          serial#           &#61; l_serial,&#10;          last_heartbeat_dt &#61; SYSDATE&#10;        WHERE component_id  &#61; p_component_id&#10;          AND thread_id &#61; p_thread_id&#10;        RETURNING current_id_val, thread_fixit_job INTO l_current_id_val, l_thread_fixit_job;&#10;        --&#10;        --info(TO_CHAR(SQL%ROWCOUNT) || &#39; rows updated in pdt_thread [&#39; || TO_CHAR(p_component_id) || &#39;][&#39; || TO_CHAR(p_thread_id) || &#39;]&#39;);&#10;        --&#10;        IF p_status &#61; 2                               AND&#10;           EMPTY2NULL(l_thread_fixit_job) IS NOT NULL AND&#10;           NVLSTR(p_run_fixit_job, &#39;Y&#39;) &#61; &#39;Y&#39;&#10;        THEN&#10;            --&#10;            BEGIN&#10;                info( &#39;Running Thread FixIt job: &#39; ||&#10;                    l_thread_fixit_job ||&#10;                    &#39;[component_id&#61;&#39;   || TO_CHAR(p_component_id)   || &#39;]&#39; ||&#10;                    &#39;[thread_id&#61;&#39;      || TO_CHAR(p_thread_id)      || &#39;]&#39; ||&#10;                    &#39;[current_id&#61;&#39;     || TO_CHAR(l_current_id_val) || &#39;]&#39; );&#10;                --&#10;                EXECUTE IMMEDIATE&#10;                  &#39;BEGIN &#39; || l_thread_fixit_job || &#39;(:p_component_id, :p_thread_id, :p_id); END;&#39;&#10;                USING p_component_id, p_thread_id, l_current_id_val;&#10;            EXCEPTION WHEN OTHERS THEN&#10;                warn(&#39;ERROR when attempted to run Thread FixIt job[component_id&#61;&#39; || p_component_id || &#39;][thread_id&#61;&#39; || p_thread_id || &#39;][id&#61;&#39; || l_current_id_val || &#39;]: &#39; || SQLERRM);&#10;            END;&#10;            --&#10;        END IF;&#10;        --&#10;        COMMIT;&#10;        --&#10;    END IF;&#10;    --&#10;    g_label :&#61; &#39;70080&#39;;&#10;    g_procedure_name :&#61; l_call_procedure ;&#10;    --&#10;END update_thread_status;&#10;--&#10;PROCEDURE wait_for_threads_to_finish(p_component_id PDT_THREAD.component_id%TYPE, p_thread_id PDT_THREAD.thread_id%TYPE DEFAULT -1, p_wait INTEGER DEFAULT 1)&#10;IS&#10;    --&#10;    l_cnt           INTEGER;&#10;    l_wait          INTEGER;&#10;    l_loop_count    INTEGER;&#10;    l_component_id  NUMBER;&#10;    l_thread_id     NUMBER;&#10;    l_proc          VARCHAR2(30) :&#61; &#39;WAIT_FOR_THREADS_TO_FINISH&#39;;&#10;    l_label         VARCHAR2(10);&#10;    --&#10;BEGIN&#10;    l_label :&#61; &#39;10000&#39;;&#10;    --&#10;    g_component_code :&#61; p_component_id;&#10;    --&#10;    l_cnt :&#61; 0;&#10;    l_loop_count :&#61; 0;&#10;    l_wait :&#61; GREATEST(LEAST(60, p_wait), 0.1);&#10;    --&#10;    LOOP&#10;        --&#10;        BEGIN&#10;            l_label :&#61; &#39;10000&#39;;&#10;            SELECT COUNT(1)&#10;            INTO l_cnt&#10;            FROM pdt_thread&#10;            WHERE component_id &#61; p_component_id&#10;              AND (thread_id &#61; p_thread_id OR p_thread_id &#61; -1)&#10;              AND status &#61; 1;&#10;            --&#10;            l_label :&#61; &#39;10010&#39;;&#10;            l_loop_count :&#61; l_loop_count + 1;&#10;            l_label :&#61; &#39;10020&#39;;&#10;            IF MOD(l_loop_count,10) &#61; 0 THEN&#10;                l_label :&#61; &#39;10030&#39;;&#10;                check_heartbeat_ALL(p_component_id);&#10;            END IF;&#10;            --&#10;            l_label :&#61; &#39;10040&#39;;&#10;            EXIT WHEN l_cnt &#61; 0;&#10;        EXCEPTION WHEN OTHERS THEN&#10;            SPGCONFIG.debug(&#39;Error raised waiting for threads [p_component_id &#61;&gt; &#39; || p_component_id || &#39;][p_thread_id &#61;&gt; &#39; || p_thread_id || &#39;][p_wait &#61;&gt; &#39; || p_wait || &#39;] &#39; || SQLERRM );&#10;        END;&#10;        --&#10;        SYS.DBMS_LOCK.sleep(l_wait);&#10;    END LOOP;&#10;END wait_for_threads_to_finish;&#10;--&#10;PROCEDURE stop_all_threads(p_component_id PDT_THREAD.component_id%TYPE)&#10;IS&#10;BEGIN&#10;    --&#10;    g_component_code :&#61; p_component_id;&#10;    --&#10;    UPDATE pdt_thread SET&#10;      status      &#61; 2,&#10;      finish_date &#61; SYSDATE&#10;    WHERE component_id &#61; p_component_id;&#10;    --&#10;END stop_all_threads;&#10;--&#10;FUNCTION check_semaphore(p_component_code VARCHAR2, p_signal VARCHAR2 DEFAULT &#39;STOP&#39;) RETURN VARCHAR2&#10;IS&#10;    l_ret VARCHAR2(1);&#10;BEGIN&#10;    --&#10;    SELECT /*+RESULT_CACHE*/ CASE WHEN COUNT(1) &gt; 0 THEN &#39;Y&#39; ELSE &#39;N&#39; END AS semaphore_flag&#10;    INTO l_ret&#10;    FROM pdt_semaphore&#10;    WHERE component_code LIKE UPPER(p_component_code)&#10;      AND NVL(signal, &#39;STOP&#39;) &#61; p_signal;&#10;    --&#10;    RETURN l_ret;&#10;EXCEPTION WHEN NO_DATA_FOUND THEN&#10;    RETURN &#39;N&#39;;&#10;END check_semaphore;&#10;--&#10;FUNCTION get_cpu_count RETURN INTEGER IS&#10;BEGIN&#10;    --&#10;    RETURN&#10;        PKG_Lookups.funcgetTabRecord_CACHED(&#10;            p_table       &#61;&gt; &#39;V$PARAMETER&#39;,&#10;            p_data_fld    &#61;&gt; &#39;NVL(TRIM(value), 1)&#39;,&#10;            p_default_val &#61;&gt; 1,&#10;            p_ref_col     &#61;&gt; &#39;name&#39;,&#10;            p_ref_val     &#61;&gt; &#39;cpu_count&#39; );&#10;    --&#10;--    -- PG version&#10;--    RETURN NVL(SPGCONFIG.get_cpu_count, 2);&#10;END get_cpu_count;&#10;--&#10;FUNCTION get_db_inst_count RETURN INTEGER&#10;IS&#10;BEGIN&#10;    RETURN&#10;        NVL(&#10;            PKG_Lookups.funcgetTabRecord(&#10;                p_table &#61;&gt; &#39;GV$INSTANCE&#39;,&#10;                p_data_fld &#61;&gt; &#39;COUNT(1)&#39;,&#10;                p_ref_col  &#61;&gt; &#39;status&#39;,&#10;                p_ref_val &#61;&gt; &#39;OPEN&#39; ),&#10;            1 );&#10;--    -- PG version&#10;--    RETURN 1;&#10;END get_db_inst_count;&#10;--&#10;--&#10;-- Global Initialisation Block&#10;BEGIN&#10;    PKG_Global.do_init;&#10;--&#10;--&#10;END pkg_mthread;</textarea>
                        </div>
                    </div>
                </section>
            </div>
            <!-- /.content-wrapper -->
            <footer class="main-footer">
                <div>
                    <div class="pull-right hidden-xs">
                        <a href="https://github.com/schemaspy/schemaspy" title="GitHub for SchemaSpy"><i class="fa fa-github-square fa-2x"></i></a>
                        <a href="http://stackoverflow.com/questions/tagged/schemaspy" title="StackOverflow for SchemaSpy"><i class="fa fa-stack-overflow fa-2x"></i></a>
                    </div>
                    <strong>Generated by <a href="http://schemaspy.org/" class="logo-text"><i class="fa fa-database"></i> SchemaSpy 6.2.4</a></strong>
                </div>
                <!-- /.container -->
            </footer>
        </div>
        <!-- ./wrapper -->

        <!-- jQuery 2.2.3 -->
        <script src="../bower/admin-lte/plugins/jQuery/jquery-2.2.3.min.js"></script>
        <script src="../bower/admin-lte/plugins/jQueryUI/jquery-ui.min.js"></script>
        <!-- Bootstrap 3.3.5 -->
        <script src="../bower/admin-lte/bootstrap/js/bootstrap.min.js"></script>
        <!-- DataTables -->
        <script src="../bower/datatables.net/jquery.dataTables.min.js"></script>
        <script src="../bower/datatables.net-bs/js/dataTables.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/dataTables.buttons.min.js"></script>
        <script src="../bower/datatables.net-buttons-bs/js/buttons.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.html5.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.print.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.colVis.min.js"></script>
        <!-- SheetJS -->
        <script src="../bower/js-xlsx/xlsx.full.min.js"></script>
        <!-- pdfmake -->
        <script src="../bower/pdfmake/pdfmake.min.js"></script>
        <script src="../bower/pdfmake/vfs_fonts.js"></script>
        <!-- SlimScroll -->
        <script src="../bower/admin-lte/plugins/slimScroll/jquery.slimscroll.min.js"></script>
        <!-- FastClick -->
        <script src="../bower/admin-lte/plugins/fastclick/fastclick.js"></script>
        <!-- Salvattore -->
        <script src="../bower/salvattore/salvattore.min.js"></script>
        <!-- AnchorJS -->
        <script src="../bower/anchor-js/anchor.min.js"></script>
        <!-- CodeMirror -->
        <script src="../bower/codemirror/codemirror.js"></script>
        <script src="../bower/codemirror/sql.js"></script>
        <!-- AdminLTE App -->
        <script src="../bower/admin-lte/dist/js/app.min.js"></script>
        <script src="routine.js"></script>
        <script src="../schemaSpy.js"></script>
    </body>
</html>