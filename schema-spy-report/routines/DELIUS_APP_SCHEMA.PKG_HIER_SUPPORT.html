<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>TSTNDA.DELIUS_APP_SCHEMA</title>
        <!-- Tell the browser to be responsive to screen width -->
        <meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport">
        <link rel="icon" type="image/png" sizes="16x16" href="../favicon.png">
        <!-- Bootstrap 3.3.5 -->
        <link rel="stylesheet" href="../bower/admin-lte/bootstrap/css/bootstrap.min.css">
        <!-- Font Awesome -->
        <link rel="stylesheet" href="../bower/font-awesome/css/font-awesome.min.css">
        <!-- Ionicons -->
        <link rel="stylesheet" href="../bower/ionicons/css/ionicons.min.css">
        <!-- DataTables -->
        <link rel="stylesheet" href="../bower/datatables.net-bs/css/dataTables.bootstrap.min.css">
        <link rel="stylesheet" href="../bower/datatables.net-buttons-bs/css/buttons.bootstrap.min.css">
        <!-- Code Mirror -->
        <link rel="stylesheet" href="../bower/codemirror/codemirror.css">
        <!-- Fonts -->
        <link href='../fonts/indieflower/indie-flower.css' rel='stylesheet' type='text/css'>
        <link href='../fonts/source-sans-pro/source-sans-pro.css' rel='stylesheet' type='text/css'>

        <!-- Theme style -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/AdminLTE.min.css">
        <!-- Salvattore -->
        <link rel="stylesheet" href="../bower/salvattore/salvattore.css">
        <!-- AdminLTE Skins. Choose a skin from the css/skins
           folder instead of downloading all of them to reduce the load. -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/skins/_all-skins.min.css">
        <!-- SchemaSpy -->
        <link rel="stylesheet" href="../schemaSpy.css">

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
        <script src="../bower/html5shiv/html5shiv.min.js"></script>
        <script src="../bower/respond/respond.min.js"></script>
        <![endif]-->
    </head>
    <!-- ADD THE CLASS layout-top-nav TO REMOVE THE SIDEBAR. -->
    <body class="hold-transition skin-blue layout-top-nav">
        <div class="wrapper">
            <header class="main-header">
                <nav class="navbar navbar-static-top">
                    <div class="container">
                        <div class="navbar-header">
                            <a href="../index.html" class="navbar-brand"><b>TSTNDA</b></a><span class="navbar-brand" style="padding-left: 0">.DELIUS_APP_SCHEMA</span>
                            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse"><i class="fa fa-bars"></i></button>
                        </div>

                        <!-- Collect the nav links, forms, and other content for toggling -->
                        <div class="collapse navbar-collapse pull-left" id="navbar-collapse">
                            <ul class="nav navbar-nav">
                                <li><a href="../index.html">Tables <span class="sr-only">(current)</span></a></li>
                                <li><a href="../columns.html" title="All of the columns in the schema">Columns</a></li>
                                <li><a href="../constraints.html" title="Useful for diagnosing error messages that just give constraint name or number">Constraints</a></li>
                                <li><a href="../relationships.html" title="Diagram of table relationships">Relationships</a></li>
                                <li><a href="../orphans.html" title="View of tables with neither parents nor children">Orphan&nbsp;Tables</a></li>
                                <li><a href="../anomalies.html" title="Things that might not be quite right">Anomalies</a></li>
                                <li><a href="../routines.html" title="Procedures and functions">Routines</a></li>
                            </ul>
                        </div>
                        <!-- /.navbar-collapse -->
                        <!-- Navbar Right Menu -->
                    </div>
                    <!-- /.container-fluid -->
                </nav>
            </header>
            <!-- Main content -->
            <!-- Full Width Column -->
            <div class="content-wrapper">
                <!-- Content Header (Page header) -->
                <section class="content-header">
                    <h1>DELIUS_APP_SCHEMA.PKG_HIER_SUPPORT</h1><br />
                </section>
                <!-- Main content -->
                <section class="content">
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <span class="glyphicon glyphicon-list-alt" aria-hidden="true"></span>
                            <h3 id="Columns" class="box-title">Parameters</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <table id="standard_table" class="table table-bordered table-striped dataTable" role="grid">
                                <thead align='left'>
                                <tr>
                                    <th>Name</th>
                                    <th>Type</th>
                                    <th>Mode</th>
                                </tr>
                                </thead>
                                <tbody>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <i class="fa fa-file-code-o"></i>
                            <h3 id="RoutineDefinition" class="box-title">Definition</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <textarea id="sql-script-codemirror" name="sql-script-codemirror" rows="" style="display: none;">PACKAGE BODY PKG_hier_support&#10;AS&#10;--&#10;--&#10;--&#10;--&#10;&#10;lc_max_vchar_size  CONSTANT INTEGER :&#61; 32767;&#10;&#10;g_label        VARCHAR2(30);&#10;--&#10;&#10;G_TAB_INFO_INIT_FLAG BOOLEAN :&#61; FALSE;&#10;--&#10;-- Data types for OFFENDER_RECORDS_ITERATOR&#10;--&#10;TYPE g_tab2_info_rec_TYP IS RECORD(&#10;  offender_id_col_exists VARCHAR2(1),&#10;  child_tables           g_tab2_hier_tab_TYP );&#10;TYPE g_tab2_info_TYP IS TABLE OF g_tab2_info_rec_TYP INDEX BY VARCHAR2(30);&#10;G_TAB2_INFO g_tab2_info_TYP;&#10;&#10;--&#10;g_off_data_nodes_ROWNUM INTEGER :&#61; 0;&#10;g_off_data_nodes_TAB    ttab_data_node_TYP1;&#10;g_idx_TAB               ttab_idx_TYP;&#10;&#10;&#10;--&#10;-- Package version function&#10;--&#10;FUNCTION get_version RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN GC_VERSION;&#10;END get_version;&#10;&#10;--&#10;-- PKG_COMMON wrappers&#10;--&#10;PROCEDURE procDebug(p_msg CLOB, p_print_flag VARCHAR2 DEFAULT &#39;N&#39;) IS&#10;BEGIN&#10;    PKG_Debug.procDebug(p_msg, p_print_flag);&#10;END procDebug;&#10;--&#10;PROCEDURE message(p_msg VARCHAR2, p_trace_level NUMBER DEFAULT 0) IS&#10;BEGIN&#10;    PKG_Common.print_message(&#10;        p_msg         &#61;&gt; p_msg,&#10;        p_trace_level &#61;&gt; NVL(p_trace_level, PKG_Common.GC_TRACE_LEVEL),&#10;        p_label       &#61;&gt; g_label );&#10;END message;&#10;--&#10;FUNCTION empty2null(p_str VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.empty2null(p_str);&#10;END empty2null;&#10;&#10;FUNCTION nvlstr(p_str1 VARCHAR2, p_str2 VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.NVLSTR(p_str1, p_str2);&#10;END nvlstr;&#10;&#10;FUNCTION is_str_empty(p_str VARCHAR2, p_ignore_spaces_and_zeroes VARCHAR2 DEFAULT &#39;N&#39;) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.is_str_empty( p_str, p_ignore_spaces_and_zeroes );&#10;END is_str_empty;&#10;--&#10;PROCEDURE raise_error(p_err_msg VARCHAR2, p_proc VARCHAR2 DEFAULT NULL, p_label VARCHAR2 DEFAULT NULL ) IS&#10;BEGIN&#10;    PKG_Common.raise_error( p_err_msg, &#39;PKG_DynSQL.&#39; || p_proc, p_label );&#10;END raise_error;&#10;--&#10;--&#10;--&#10;--&#10;PROCEDURE init_tab_info_PRIV(p_table_name VARCHAR2 DEFAULT NULL, p_force_flag VARCHAR2 DEFAULT &#39;N&#39;)&#10;IS&#10;    --&#10;    PROCEDURE do_populate_tab2&#10;    IS&#10;        --&#10;        --/*00*/ table_name          VARCHAR2(30),&#10;        ----&#10;        --/*01*/ constraint_name     VARCHAR2(30),&#10;        --/*02*/ r_constraint_name   VARCHAR2(30),&#10;        --/*03*/ constraint_type     VARCHAR2(3),&#10;        ----&#10;        --/*04*/ parent_table        VARCHAR2(30),&#10;        ----&#10;        --/*05*/ FK_fld              VARCHAR2(4000),&#10;        --/*06*/ parent_PK_fld       VARCHAR2(4000),&#10;        ----&#10;        --/*07*/ where_clause        VARCHAR2(4000),&#10;        --/*08*/ not_null_col_name   VARCHAR2(30),&#10;        ----&#10;        --/*09*/ order_by            NUMBER,&#10;        --/*10*/ hier_level          NUMBER,&#10;        --/*11*/ hier_order_by       NUMBER,&#10;        ----&#10;        --/*12*/ offender_id_col_exists VARCHAR2(1)&#10;        --&#10;        CURSOR csChldTab IS&#10;          SELECT /*+ RESULT_CACHE */&#10;            /*00*/ table_name,&#10;            --&#10;            /*01*/ constraint_name,&#10;            /*02*/ r_constraint_name,&#10;            /*03*/ constraint_type,&#10;            --&#10;            /*04*/ parent_table,&#10;            --&#10;            /*05*/ fk_fld,&#10;            /*06*/ parent_pk_fld,&#10;            --&#10;            /*07*/ where_clause,&#10;            /*08*/ not_null_col_name,&#10;            --&#10;            /*09*/ order_by,&#10;            /*10*/ hier_level,&#10;            /*11*/ hier_order_by,&#10;            --&#10;            /*12*/ offender_id_col_exists&#10;          FROM offender_hierarchy&#10;          WHERE 1&#61;1&#10;          ORDER BY&#10;            parent_table,&#10;            order_by;&#10;        --&#10;        l_tab_CHLD_ALL g_tab2_hier_TAB_TYP :&#61; g_tab2_hier_TAB_TYP();&#10;        l_tab_CHLD     g_tab2_hier_TAB_TYP :&#61; g_tab2_hier_TAB_TYP();&#10;        --&#10;        l_last_parent_table VARCHAR2(30);&#10;        --&#10;        FUNCTION get_tab2_info_summary(p_parent_tab VARCHAR2) RETURN VARCHAR2&#10;        IS&#10;            l_tab2_rec1 g_tab2_info_rec_TYP;&#10;            l_tab_CHLD1 g_tab2_hier_TAB_TYP;&#10;        BEGIN&#10;            l_tab2_rec1 :&#61; G_TAB2_INFO(p_parent_tab);&#10;            l_tab_CHLD1 :&#61; l_tab2_rec1.child_tables;&#10;            RETURN&#10;                &#39;[table&#61;&#39;             || p_parent_tab                       || &#39;]&#39; ||&#10;                &#39;[off_id_col_exists&#61;&#39; || l_tab2_rec1.offender_id_col_exists || &#39;]&#39; ||&#10;                &#39;[chld_tab_CNT&#61;&#39;      || l_tab_CHLD1.COUNT                  || &#39;]&#39;;&#10;        --EXCEPTION WHEN OTHERS THEN&#10;        --    raise_application_error(-20001, &#39;ERROR in GET_TAB2_INFO_SUMMARY[&#39; || p_parent_tab || &#39;]: &#39; || SQLERRM);&#10;        END get_tab2_info_summary;&#10;        --&#10;        PROCEDURE do_check_curr_parent_tab(p_parent_tab VARCHAR2, p_force_flag VARCHAR2 DEFAULT &#39;N&#39;)&#10;        IS&#10;            l_tab_info_rec g_tab2_info_rec_TYP;&#10;        BEGIN&#10;            IF p_parent_tab &lt;&gt; l_last_parent_table OR p_force_flag &#61; &#39;Y&#39; THEN&#10;                --&#10;                l_tab_info_rec :&#61; NULL;&#10;                --&#10;                BEGIN&#10;                    SELECT /*+ RESULT_CACHE */ &#39;Y&#39;&#10;                    INTO l_tab_info_rec.offender_id_col_exists&#10;                    FROM user_tab_columns&#10;                    WHERE table_name &#61; l_last_parent_table&#10;                      AND column_name &#61; &#39;OFFENDER_ID&#39;;&#10;                EXCEPTION WHEN NO_DATA_FOUND THEN&#10;                    l_tab_info_rec.offender_id_col_exists :&#61; &#39;N&#39;;&#10;                END;&#10;                --&#10;                l_tab_info_rec.child_tables :&#61; l_tab_CHLD;&#10;                --&#10;                G_TAB2_INFO(l_last_parent_table) :&#61; l_tab_info_rec;&#10;                --&#10;                l_tab_CHLD.DELETE;&#10;                --&#10;                --raise_application_error(-20001, &#39;DO_POPULATE_TAB2.do_check_curr_parent_tab: &#39; || get_tab2_info_summary(l_last_parent_table) );&#10;                --&#10;                l_last_parent_table :&#61; p_parent_tab;&#10;                --&#10;            END IF;&#10;        END do_check_curr_parent_tab;&#10;        --&#10;    BEGIN&#10;        --&#10;        OPEN csChldTab;&#10;        FETCH csChldTab BULK COLLECT INTO l_tab_CHLD_ALL;&#10;        CLOSE csChldTab;&#10;        --&#10;        IF NVL(l_tab_CHLD_ALL.COUNT, 0) &#61; 0 THEN&#10;            RETURN;&#10;        END IF;&#10;        --&#10;        l_last_parent_table :&#61; l_tab_CHLD_ALL(1).parent_table;&#10;        --&#10;        FOR l_idx IN 1..l_tab_CHLD_ALL.COUNT LOOP&#10;            do_check_curr_parent_tab(l_tab_CHLD_ALL(l_idx).parent_table);&#10;            l_tab_CHLD.EXTEND;&#10;            l_tab_CHLD(l_tab_CHLD.COUNT) :&#61; l_tab_CHLD_ALL(l_idx);&#10;        END LOOP;&#10;        --&#10;        do_check_curr_parent_tab(NULL, &#39;Y&#39;);&#10;        --&#10;--        raise_application_error(-20001, &#39;DO_POPULATE_TAB2: &#39; ||&#10;--            G_TAB2_INFO.COUNT || CHR(10) ||&#10;--            get_tab2_info_summary(&#39;OFFENDER&#39;) || CHR(10) ||&#10;--            get_tab2_info_summary(&#39;EVENT&#39;) || CHR(10) );&#10;        --&#10;    END do_populate_tab2;&#10;    --&#10;BEGIN&#10;    --&#10;    IF NOT G_TAB_INFO_INIT_FLAG THEN&#10;        --&#10;        procDebug(&#39;PKG_DynSQL.init_tab_info_PRIV.do_populate_tab2: START&#39;);&#10;        do_populate_tab2;&#10;        procDebug(&#39;PKG_DynSQL.init_tab_info_PRIV: FINISHED&#39;);&#10;        --&#10;        --print_tab_hier_priv(&#39;OFFENDER&#39;);&#10;        G_TAB_INFO_INIT_FLAG :&#61; TRUE;&#10;        --&#10;    END IF;&#10;    --&#10;END init_tab_info_PRIV;&#10;--&#10;PROCEDURE init_tab_info(p_reset_flag VARCHAR2 DEFAULT &#39;N&#39;)&#10;IS&#10;    --&#10;    l_entry_is_cached BOOLEAN;&#10;    --l_tab_info_CLOB   VARCHAR2(32767);&#10;    --&#10;BEGIN&#10;    IF p_reset_flag &#61; &#39;Y&#39; THEN&#10;        --procDebug(&#39;PKG_DynSQL.init_tab_info(P_RESET_FLAG&#61;Y)&#39;);&#10;        g_tab2_info.DELETE;&#10;        G_TAB_INFO_INIT_FLAG :&#61; FALSE;&#10;        --&#10;        init_tab_info_PRIV;&#10;        --&#10;    ELSE&#10;        --&#10;        init_tab_info_PRIV;&#10;        --&#10;    END IF;&#10;    --&#10;END init_tab_info;&#10;--&#10;--&#10;PROCEDURE do_process_current_record(&#10;    p_offender_id     NUMBER,&#10;    p_tab_name        VARCHAR2,&#10;    p_dest_table      VARCHAR2,&#10;    p_row_id          ROWID,&#10;    p_dyn_SQL         VARCHAR2,&#10;    p_debug_message   VARCHAR2 DEFAULT NULL,&#10;    p_recursive_level INTEGER  DEFAULT 1,&#10;    p_parent_table    VARCHAR2 DEFAULT NULL,&#10;    p_parent_row_id   VARCHAR2 DEFAULT NULL )&#10;IS&#10;    --&#10;    TYPE l_cur_TYP IS REF CURSOR;&#10;    l_cur l_cur_TYP;&#10;    --&#10;    l_cols VARCHAR2(4000);&#10;    l_vals VARCHAR2(4000);&#10;    l_SQL  VARCHAR2(4000);&#10;    --&#10;    l_debug_flag BOOLEAN :&#61; PKG_Debug.funcGetDebugActive;&#10;    --&#10;BEGIN&#10;    --&#10;    IF l_debug_flag THEN&#10;        BEGIN&#10;            --&#10;            l_cols :&#61; PKG_Lookups.funcGetTabPkFields( p_table_name &#61;&gt; p_tab_name, p_delim &#61;&gt; &#39;,&#39; );&#10;            --&#10;            l_SQL :&#61;&#10;               &#39;SELECT SUBSTR(&#39; || REPLACE(l_cols, &#39;,&#39;, &#39;||&#39;&#39;,&#39;&#39;||&#39;) || &#39;, 1, 4000) PK_KEY_VAL&#10;                FROM &#39; || p_dest_table || &#39;&#10;                WHERE ROWID &#61; :p_row_id&#39;&#10;            ;&#10;            --message(l_sql);&#10;            --&#10;            EXECUTE IMMEDIATE l_SQL INTO l_vals USING p_row_id;&#10;            procDebug( &#39;OFFENDER_RECORDS_ITERATOR.do_process_current_record &#39; ||&#10;                &#39;[offender_id&#61;&#39; || p_offender_id           || &#39;]&#39; ||&#10;                CASE WHEN p_debug_message IS NOT NULL    THEN &#39;[&#39; || p_debug_message || &#39;] &#39; END || &#39;:&#39; ||&#10;                &#39;[parent_tab&#61;&#39; || p_parent_table           || &#39;]&#39; ||&#10;                &#39;[table&#61;&#39;      || p_dest_table             || &#39;]&#39; ||&#10;                &#39;[level&#61;&#39;      || p_recursive_level        || &#39;]&#39; ||&#10;                &#39;[FK: &#39;        || p_parent_row_id          || &#39;]&#39; ||&#10;                &#39;[PK: &#39;        || l_cols || &#39;&#61;&#39; || l_vals  || &#39;]&#39; );&#10;        EXCEPTION WHEN NO_DATA_FOUND THEN&#10;            procDebug( &#39;OFFENDER_RECORDS_ITERATOR.do_process_current_record &#39; ||&#10;                &#39;[offender_id&#61;&#39; || p_offender_id           || &#39;]&#39; ||&#10;                CASE WHEN p_debug_message IS NOT NULL    THEN &#39;[&#39; || p_debug_message || &#39;] &#39; END || &#39;:&#39; ||&#10;                &#39;[parent_tab&#61;&#39; || p_parent_table           || &#39;]&#39; ||&#10;                &#39;[table&#61;&#39;      || p_dest_table             || &#39;]&#39; ||&#10;                &#39;[level&#61;&#39;      || p_recursive_level        || &#39;]&#39; ||&#10;                &#39;[FK: &#39;        || p_parent_row_id          || &#39;]&#39; ||&#10;                &#39;[PK: &#39;        || p_row_id                 || &#39;]&#39; ||&#10;                &#39;[WARNING: NO_DATA_FOUND&#39;                  || &#39;]&#39; );&#10;        END;&#10;    END IF;&#10;    --&#10;    l_SQL :&#61; p_dyn_SQL;&#10;    EXECUTE IMMEDIATE l_SQL USING p_parent_table, p_dest_table, p_offender_id, p_parent_row_id, p_row_id, p_recursive_level;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    --ROLLBACK;&#10;    DECLARE&#10;        l_err_msg VARCHAR2(32000);&#10;    BEGIN&#10;        --&#10;        l_err_msg :&#61; SUBSTRB(&#10;            &#39;ERROR in OFFENDER_RECORDS_ITERATOR.do_process_current_record &#39; ||&#10;            --&#39;[SQL: &#39;             || l_SQL               || &#39;]&#39;  ||&#10;            CHR(10) ||&#10;            &#39;[row_id&#61;&#39;           || p_row_id            || &#39;]&#39;  ||&#10;            &#39;[offender_id&#61;&#39;      || p_offender_id       || &#39;]&#39;  ||&#10;            &#39;[table&#61;&#39;            || p_dest_table        || &#39;]&#39;  ||&#10;            &#39;[parent_table&#61;&#39;     || p_parent_table      || &#39;]&#39;  ||&#10;            &#39;[parent_row_id&#61;&#39;    || p_parent_row_id     || &#39;]&#39;  ||&#10;            &#39;[level&#61;&#39;            || p_recursive_level   || &#39;]&#39;  || CHR(10) ||&#10;            CASE WHEN l_cols IS NOT NULL THEN&#10;                &#39;[&#39; || l_cols || &#39;&#61;&#39; || l_vals          || &#39;]&#39;  || CHR(10)&#10;            END ||&#10;            &#39;[&#39; || DBMS_UTILITY.format_error_backtrace  || &#39;]: &#39; ||&#10;            &#39;[ERROR: &#39; || C08001_PDT_SUPPORT.get_dq_message(SQLERRM) || &#39;]&#39;,&#10;            --&#10;            1, 32000);&#10;        --&#10;        PKG_Common.print_message(&#10;            p_msg         &#61;&gt; &#39;FATAL ERROR in OFFENDER_RECORDS_ITERATOR.do_process_current_record:&#39; || CHR(10) || l_err_msg,&#10;            p_trace_level &#61;&gt; 0,&#10;            p_label       &#61;&gt; g_label );&#10;        --&#10;        IF l_debug_flag THEN&#10;            procDebug(l_err_msg);&#10;        END IF;&#10;        --&#10;        raise_application_error(-20001, &#39;ERROR in OFFENDER_RECORDS_ITERATOR.do_process_current_record (please see details above)&#39;);&#10;        --&#10;    END;&#10;    --&#10;END do_process_current_record;&#10;--&#10;PROCEDURE offender_records_iterator(&#10;    p_offender_id            NUMBER,&#10;    p_tab_name               VARCHAR2,&#10;    p_row_id                 ROWID,&#10;    p_dyn_SQL                VARCHAR2,&#10;    p_when_to_execute        VARCHAR2 DEFAULT &#39;POST&#39;,&#10;    p_debug_message          VARCHAR2 DEFAULT NULL,&#10;    p_recursive_level        INTEGER  DEFAULT 1,&#10;    p_parent_table           VARCHAR2 DEFAULT NULL,&#10;    p_parent_row_id          ROWID    DEFAULT NULL,&#10;    p_skip_subtrees          VARCHAR2 DEFAULT NULL,&#10;    p_check_offender_id_flag VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_actual_offender_id     NUMBER   DEFAULT NULL,&#10;    p_ignore_where_clause    VARCHAR2 DEFAULT &#39;N&#39;,&#10;    --&#10;    p_exclude_merged         VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_include_merged         VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_include_merged_level   INTEGER  DEFAULT NULL,&#10;    --&#10;    p_offender_id_1          NUMBER   DEFAULT NULL )&#10;IS&#10;    l_proc VARCHAR2(32) :&#61; &#39;OFFENDER_RECORDS_ITERATOR&#39;;&#10;    --&#10;    recursive_limit_exception EXCEPTION;&#10;    lc_max_recursion CONSTANT NUMBER :&#61; 200;&#10;    --&#10;    TYPE  l_cur_TYP IS REF CURSOR;&#10;    l_cur l_cur_TYP;&#10;    --&#10;    l_SQL        VARCHAR2(10000);&#10;    --&#10;    l_tab_idx INTEGER;&#10;    l_row_idx INTEGER;&#10;    --&#10;    l_skip_subtrees VARCHAR2(4000) :&#61; &#39;,&#39; ||&#10;                                      LTRIM(RTRIM(TRIM(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(p_skip_subtrees, &#39;--&#39;, &#39;&#39;), CHR(10), &#39;&#39;), CHR(13), &#39;&#39;), CHR(9), &#39; &#39;), &#39; &#39;, &#39;&#39;)), &#39;,&#39;), &#39;,&#39;) ||&#10;                                      &#39;,&#39;;&#10;    --&#10;    --/*00*/ table_name          VARCHAR2(30),&#10;    --/*01*/ constraint_name     VARCHAR2(30),&#10;    --/*02*/ r_constraint_name   VARCHAR2(30),&#10;    --/*03*/ constraint_type     VARCHAR2(3),&#10;    --/*04*/ parent_table        VARCHAR2(30),&#10;    --/*05*/ FK_fld              VARCHAR2(4000),&#10;    --/*06*/ parent_PK_fld       VARCHAR2(4000),&#10;    --/*07*/ where_clause        VARCHAR2(4000),&#10;    --/*08*/ not_null_col_name   VARCHAR2(30),&#10;    --/*09*/ order_by            NUMBER,&#10;    --/*10*/ hier_level          NUMBER,&#10;    --/*11*/ hier_order_by       NUMBER,&#10;    --/*12*/ offender_id_col_exists VARCHAR2(1)&#10;    --&#10;    CURSOR csChldTab(p_parent_table1 VARCHAR2) IS&#10;      SELECT /*+ RESULT_CACHE */&#10;        /*00*/ table_name,&#10;        --&#10;        /*01*/ constraint_name,&#10;        /*02*/ r_constraint_name,&#10;        /*03*/ constraint_type,&#10;        --&#10;        /*04*/ parent_table,&#10;        --&#10;        /*05*/ fk_fld,&#10;        /*06*/ parent_pk_fld,&#10;        --&#10;        /*07*/ where_clause,&#10;        /*08*/ not_null_col_name,&#10;        --&#10;        /*09*/ order_by,&#10;        /*10*/ hier_level,&#10;        /*11*/ hier_order_by,&#10;        --&#10;        /*12*/ offender_id_col_exists&#10;      FROM offender_hierarchy&#10;      WHERE parent_table &#61; p_parent_table1&#10;      ORDER BY order_by;&#10;    --&#10;    l_tab_info_rec g_tab2_info_rec_TYP;&#10;    l_tab_CHLD     g_tab2_hier_TAB_TYP;&#10;    --&#10;    TYPE l_rec_row_TYP IS RECORD(&#10;      row_id ROWID,&#10;      offender_id NUMBER );&#10;    TYPE l_tab_row_TYP IS TABLE OF l_rec_row_TYP;&#10;    l_tab_rows l_tab_row_TYP;&#10;    --&#10;    l_debug_flag BOOLEAN :&#61; PKG_Debug.funcGetDebugActive;&#10;    --&#10;BEGIN&#10;    --&#10;    IF (p_recursive_level &gt;&#61; lc_max_recursion) THEN&#10;        IF l_debug_flag THEN&#10;            procDebug(&#39;ERROR while trying to PROCESS current record FROM &#39; || p_tab_name || &#39;: &#39; ||&#10;                &#39;Count no. of recursive calls [&#39; || p_recursive_level || &#39;] - must not exceed the maximum of &#39; || lc_max_recursion);&#10;        END IF;&#10;        --&#10;        RAISE recursive_limit_exception;&#10;    END IF;&#10;    --&#10;    IF NVL(INSTR(l_skip_subtrees, &#39;,&#39; || &#39;*&#39; || &#39;/&#39; || p_tab_name || &#39;,&#39;), 0) &gt; 0 THEN&#10;        IF l_debug_flag THEN&#10;            procDebug(&#10;                &#39;OFFENDER_RECORDS_ITERATOR &#39; ||&#10;                &#39;[offender_id&#61;&#39;             || p_offender_id                    || &#39;]&#39; ||&#10;                &#39;[actual_offender_id&#61;&#39;      || p_actual_offender_id             || &#39;]&#39; ||&#10;                &#39;[ignore_where_clause&#61;&#39;     || p_ignore_where_clause            || &#39;]&#39; ||&#10;                &#39;[exclude_merged&#61;&#39;          || p_exclude_merged                 || &#39;]&#39; ||&#10;                &#39;[include_merged&#61;&#39;          || p_include_merged                 || &#39;]&#39; ||&#10;                &#39;[table&#61;&#39;                   || p_tab_name                       || &#39;]&#39; ||&#10;                &#39;[&#39;                         || TO_CHAR(p_recursive_level + 1)   || &#39;]&#39; ||&#10;                &#39;[parent_tab&#61;&#39;              || p_parent_table                   || &#39;]&#39; ||&#10;                &#39;[check_offender_id_flag&#61;&#39;  || p_check_offender_id_flag         || &#39;]&#39; ||&#10;                &#39;a */&lt;table&gt; type of a terminal node has been detected&#39; );&#10;        END IF;&#10;        --&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    init_tab_info_PRIV;&#10;    --&#10;    -- Get next dependant table name (new p-table) for p-table from offender hierarchy&#10;    IF G_TAB2_INFO.EXISTS(p_tab_name) THEN&#10;        l_tab_info_rec :&#61; G_TAB2_INFO(p_tab_name);&#10;        l_tab_CHLD     :&#61; l_tab_info_rec.child_tables;&#10;    ELSE&#10;        IF l_debug_flag THEN&#10;            procDebug(&#39;Caching Table Hierarchy info for &#39; || p_tab_name || &#39; table&#39;);&#10;        END IF;&#10;        --&#10;        OPEN csChldTab(p_tab_name);&#10;        FETCH csChldTab BULK COLLECT INTO l_tab_CHLD;&#10;        CLOSE csChldTab;&#10;        --&#10;        BEGIN&#10;            SELECT /*+ RESULT_CACHE */ &#39;Y&#39;&#10;            INTO l_tab_info_rec.offender_id_col_exists&#10;            FROM user_tab_columns&#10;            WHERE table_name &#61; p_tab_name&#10;              AND column_name &#61; &#39;OFFENDER_ID&#39;;&#10;        EXCEPTION WHEN NO_DATA_FOUND THEN&#10;            l_tab_info_rec.offender_id_col_exists :&#61; &#39;N&#39;;&#10;        END;&#10;        --&#10;        l_tab_info_rec.child_tables :&#61; l_tab_CHLD;&#10;        --&#10;        G_TAB2_INFO(p_tab_name) :&#61; l_tab_info_rec;&#10;        --&#10;    END IF;&#10;    --&#10;    IF p_recursive_level &#61; 1 AND l_debug_flag THEN&#10;        procDebug(&#10;            &#39;OFFENDER_RECORDS_ITERATOR &#39; ||&#10;            &#39;[offender_id&#61;&#39;             || p_offender_id            || &#39;]&#39; ||&#10;            &#39;[table&#61;&#39;                   || p_tab_name               || &#39;]&#39; ||&#10;            &#39;[parent_tab&#61;&#39;              || p_parent_table           || &#39;]&#39; ||&#10;            &#39;[ignore_where_clause&#61;&#39;     || p_ignore_where_clause    || &#39;]&#39; ||&#10;            &#39;[exclude_merged&#61;&#39;          || p_exclude_merged         || &#39;]&#39; ||&#10;            &#39;[include_merged&#61;&#39;          || p_include_merged         || &#39;]&#39; ||&#10;            &#39;[check_offender_id_flag&#61;&#39;  || p_check_offender_id_flag || &#39;]&#39; ||&#10;            &#39;[skip_subtrees&#61;&#39;           || p_skip_subtrees          || &#39;]&#39; ||&#10;            &#39;START&#39; );&#10;    END IF;&#10;    --&#10;    IF p_when_to_execute &#61; &#39;PRE&#39; THEN&#10;        --&#10;        IF p_check_offender_id_flag &#61; &#39;Y&#39; AND l_debug_flag THEN&#10;            procDebug(&#10;                &#39;OFFENDER_RECORDS_ITERATOR.check_offender_id &#39; ||&#10;                &#39;[offender_id&#61;&#39;             || p_offender_id            || &#39;]&#39; ||&#10;                &#39;[actual_offender_id&#61;&#39;      || p_actual_offender_id     || &#39;]&#39; ||&#10;                &#39;[table&#61;&#39;                   || p_tab_name               || &#39;]&#39; ||&#10;                &#39;[&#39; || TO_CHAR(p_recursive_level)                       || &#39;]&#39; ||&#10;                &#39;[parent_tab&#61;&#39;              || p_parent_table           || &#39;]&#39; ||&#10;                &#39;[ignore_where_clause&#61;&#39;     || p_ignore_where_clause    || &#39;]&#39; ||&#10;                &#39;[exclude_merged&#61;&#39;          || p_exclude_merged         || &#39;]&#39; ||&#10;                &#39;[include_merged&#61;&#39;          || p_include_merged         || &#39;]&#39; ||&#10;                &#39;[check_offender_id_flag&#61;&#39;  || p_check_offender_id_flag || &#39;]&#39; );&#10;        END IF;&#10;        --&#10;        IF NVL(p_check_offender_id_flag, &#39;N&#39;) &#61; &#39;N&#39;&#10;           OR&#10;           NOT ( ( p_check_offender_id_flag &#61; &#39;Y&#39; AND l_tab_info_rec.offender_id_col_exists &#61; &#39;N&#39; ) OR&#10;                 ( p_check_offender_id_flag &#61; &#39;Y&#39; AND p_actual_offender_id &#61; p_offender_id )&#10;               )&#10;        THEN&#10;            do_process_current_record(&#10;                p_offender_id     &#61;&gt; p_offender_id,&#10;                p_tab_name        &#61;&gt; p_tab_name,&#10;                p_dest_table      &#61;&gt; p_tab_name,&#10;                p_row_id          &#61;&gt; p_row_id,&#10;                p_dyn_SQL         &#61;&gt; p_dyn_SQL,&#10;                p_debug_message   &#61;&gt; p_debug_message,&#10;                p_recursive_level &#61;&gt; p_recursive_level,&#10;                p_parent_table    &#61;&gt; p_parent_table,&#10;                p_parent_row_id   &#61;&gt; p_parent_row_id );&#10;        END IF;&#10;    END IF;&#10;    --&#10;    FOR l_tab_idx IN 1..l_tab_CHLD.COUNT&#10;    LOOP&#10;        --&#10;        --IF p_tab_name &#61; &#39;EVENT&#39; THEN&#10;--            DBMS_OUTPUT.put_line(&#10;--                &#39;OFFENDER_RECORDS_ITERATOR &#39; ||&#10;--                &#39;[offender_id&#61;&#39;             || p_offender_id            || &#39;]&#39; ||&#10;--                &#39;[table&#61;&#39;                   || p_tab_name               || &#39;]&#39; ||&#10;--                &#39;[chld_table&#61;&#39;              || l_tab_CHLD(l_tab_idx).table_name || &#39;]&#39; ||&#10;--                &#39;[parent_tab&#61;&#39;              || p_parent_table           || &#39;]&#39; ||&#10;--                &#39;[ignore_where_clause&#61;&#39;     || p_ignore_where_clause    || &#39;]&#39; ||&#10;--                &#39;[exclude_merged&#61;&#39;          || p_exclude_merged         || &#39;]&#39; ||&#10;--                &#39;[include_merged&#61;&#39;          || p_include_merged         || &#39;]&#39; ||&#10;--                &#39;[check_offender_id_flag&#61;&#39;  || p_check_offender_id_flag || &#39;]&#39; ||&#10;--                &#39;[skip_subtrees&#61;&#39;           || p_skip_subtrees          || &#39;]&#39; ||&#10;--                &#39;START&#39; );&#10;        --END IF;&#10;        --&#10;        IF NVL(INSTR(l_skip_subtrees, &#39;,&#39; || p_tab_name || &#39;/&#39; || &#39;*&#39;                              || &#39;,&#39;), 0) &#61; 0 AND&#10;           NVL(INSTR(l_skip_subtrees, &#39;,&#39; || p_tab_name || &#39;/&#39; || l_tab_CHLD(l_tab_idx).table_name || &#39;,&#39;), 0) &#61; 0 AND&#10;           NVL(INSTR(l_skip_subtrees, &#39;,&#39; || &#39;*&#39;        || &#39;/&#39; || l_tab_CHLD(l_tab_idx).table_name || &#39;,&#39;), 0) &#61; 0&#10;        THEN&#10;            l_SQL :&#61;&#10;               &#39;SELECT&#10;                  ROWID row_id,&#10;                  &#39; || CASE WHEN l_tab_CHLD(l_tab_idx).offender_id_col_exists &#61; &#39;Y&#39; THEN &#39;offender_id&#39; ELSE &#39;NULL AS offender_id&#39; END || &#39;&#10;                FROM &#39; || l_tab_CHLD(l_tab_idx).table_name || &#39;&#10;                WHERE (&#39; || l_tab_CHLD(l_tab_idx).FK_fld || &#39;) IN (&#10;                       SELECT &#39; || l_tab_CHLD(l_tab_idx).parent_PK_fld || &#39;&#10;                       FROM &#39; || l_tab_CHLD(l_tab_idx).parent_table || &#39;&#10;                       WHERE ROWID &#61; :p_row_id)&#39;;&#10;            --&#10;            IF ( l_tab_CHLD(l_tab_idx).where_clause IS NOT NULL ) AND&#10;               ( NVL(p_ignore_where_clause, &#39;N&#39;) !&#61; &#39;Y&#39;&#10;                 OR&#10;                 UPPER(l_tab_CHLD(l_tab_idx).where_clause) LIKE UPPER(&#39;table_name%&#61;%&#39;&#39;%&#39;&#39;&#39;)&#10;               )&#10;            THEN&#10;                l_SQL :&#61; l_SQL || &#39;&#10;                  AND ( &#39; || l_tab_CHLD(l_tab_idx).where_clause || &#39; )&#39;;&#10;            END IF;&#10;            --&#10;            IF p_exclude_merged &#61; &#39;Y&#39; THEN&#10;                l_SQL :&#61; l_SQL || &#39;&#10;                  AND NOT EXISTS(&#10;                      SELECT 1&#10;                      FROM offender_merge_details&#10;                      WHERE source_offender_id &#61; :p_src_offender_id&#10;                        /*AND target_offender_id &#61; :p_tgt_offender_id*/&#10;                        AND table_name &#61; &#39;&#39;&#39; || l_tab_CHLD(l_tab_idx).table_name || &#39;&#39;&#39;&#10;                        AND target_pk_value &#61; &#39; || PKG_DynSQL.get_tab_pk_fld_lst(l_tab_CHLD(l_tab_idx).table_name, &#39; || &#39;&#39;:&#39;&#39; || &#39;, -1) || &#39; )&#39;;&#10;            ELSIF p_include_merged &#61; &#39;Y&#39; THEN&#10;                IF NVL(p_include_merged_level, 9999) &gt;&#61; (p_recursive_level/*-1*/) THEN&#10;                    l_SQL :&#61; l_SQL || &#39;&#10;                      AND EXISTS(&#10;                          SELECT 1&#10;                          FROM offender_merge_details&#10;                          WHERE target_offender_id &#61; :p_tgt_offender_id&#10;                            AND source_offender_id &#61; :p_src_offender_id&#10;                            AND table_name &#61; &#39;&#39;&#39; || l_tab_CHLD(l_tab_idx).table_name || &#39;&#39;&#39;&#10;                            AND target_pk_value &#61; &#39; || PKG_DynSQL.get_tab_pk_fld_lst(l_tab_CHLD(l_tab_idx).table_name, &#39; || &#39;&#39;:&#39;&#39; || &#39;, -1) || &#39; )&#39;;&#10;                ELSIF l_tab_CHLD(l_tab_idx).table_name &#61; &#39;ADDRESS_ASSESSMENT&#39; THEN&#10;                    --raise_application_error(-20001, &#39;OFF_RECORDS_ITERATOR: [tab&#61;&#39; || l_tab_CHLD(l_tab_idx).table_name || &#39;][parent&#61;&#39; || p_tab_name || &#39;][rec_level&#61;&#39; || p_recursive_level || &#39;][p_include_merged_level&#61;&#39; || p_include_merged_level || &#39;]&#39;);&#10;                    NULL;&#10;                END IF;&#10;            END IF;&#10;            --&#10;            IF l_tab_CHLD(l_tab_idx).not_null_col_name IS NOT NULL THEN&#10;                l_SQL :&#61; l_SQL || &#39;&#10;                  AND ( &#39; || l_tab_CHLD(l_tab_idx).not_null_col_name || &#39; IS NOT NULL )&#39;;&#10;            END IF;&#10;            --&#10;            IF l_tab_CHLD(l_tab_idx).table_name IN ( &#39;EVENT&#39;, &#39;RESPONSIBLE_OFFICER&#39;, &#39;PRISON_OFFENDER_MANAGER&#39; ) THEN&#10;                l_SQL :&#61; l_SQL || CHR(10) || &#39;ORDER BY created_datetime&#39;;&#10;            END IF;&#10;            --&#10;            BEGIN&#10;                IF p_exclude_merged &#61; &#39;Y&#39; THEN&#10;                    OPEN l_cur FOR l_SQL&#10;                    USING&#10;                      p_row_id,&#10;                      p_offender_id--, p_offender_id_1&#10;                    ;&#10;                ELSIF p_include_merged &#61; &#39;Y&#39; AND NVL(p_include_merged_level, 9999) &gt;&#61; (p_recursive_level/*-1*/) THEN&#10;                    OPEN l_cur FOR l_SQL&#10;                    USING&#10;                      p_row_id,&#10;                      p_offender_id, p_offender_id_1&#10;                    ;&#10;                ELSE&#10;                    OPEN l_cur FOR l_SQL USING p_row_id;&#10;                END IF;&#10;                FETCH l_cur BULK COLLECT INTO l_tab_rows;&#10;                CLOSE l_cur;&#10;                --&#10;                IF l_debug_flag THEN&#10;                    procDebug(&#39;OFFENDER_RECORDS_ITERATOR.scan_chld_table &#39; ||&#10;                                &#39;[offender_id&#61;&#39;         || p_offender_id                      || &#39;]&#39; ||&#10;                                --&#39;[actual_offender_id&#61;&#39; || p_actual_offender_id              || &#39;]&#39; ||&#10;                                &#39;[child_tab&#61;&#39;           || l_tab_CHLD(l_tab_idx).table_name   || &#39;]&#39; ||&#10;                                &#39;[rows&#61;&#39;                || l_tab_rows.COUNT                   || &#39;]&#39; ||&#10;                                &#39;[parent&#61;&#39;              || p_tab_name                         || &#39;]&#39; ||&#10;                                --&#39;[&#39; || p_row_id                                             || &#39;]&#39; ||&#10;                                &#39;[level&#61;&#39;               || TO_CHAR(p_recursive_level + 1)     || &#39;]&#39; ||&#10;                                --&#10;                                &#39;[parent_tab&#61;&#39;          || l_tab_CHLD(l_tab_idx).parent_table || &#39;]&#39; ||&#10;                                &#39;[ignore_where_clause&#61;&#39; || p_ignore_where_clause              || &#39;]&#39; ||&#10;                                &#39;[exclude_merged&#61;&#39;      || p_exclude_merged                   || &#39;]&#39; ||&#10;                                &#39;[include_merged&#61;&#39;      || p_include_merged                   || &#39;]&#39; ||&#10;                                --&#39;[parent_row_id&#61;&#39;     || p_row_id                           || &#39;]&#39; ||&#10;                                CHR(10) || &#39;[SQL&#61;&#39;      || l_SQL                              || &#39;]&#39;&#10;                            );&#10;                END IF;&#10;                --&#10;                FOR l_row_idx IN 1..l_tab_rows.COUNT&#10;                LOOP&#10;                    /*IF l_debug_flag THEN&#10;                        procDebug(&#10;                            &#39;OFFENDER_RECORDS_ITERATOR &#39; ||&#10;                            &#39;[offender_id&#61;&#39; || p_offender_id                      || &#39;]&#39; ||&#10;                            &#39;[parent_actual_offender_id&#61;&#39; || p_actual_offender_id || &#39;]&#39; ||&#10;                            &#39;[&#39; || l_tab_CHLD(l_tab_idx).table_name               || &#39;]&#39; ||&#10;                            &#39;[row_id&#61;&#39; || ROWIDTOCHAR(l_tab_rows(l_row_idx).row_id)             || &#39;]&#39; ||&#10;                            &#39;[actual_offender_id&#61;&#39; || ROWIDTOCHAR(l_tab_rows(l_row_idx).row_id) || &#39;]&#39; ||&#10;                            --&#39;[&#39; || l_dep_rec.pk_key_val                         || &#39;]&#39; ||&#10;                            &#39;[&#39; || TO_CHAR(p_recursive_level + 1)                 || &#39;]&#39; ||&#10;                            &#39;&#39;&#10;                        );&#10;                        g_label :&#61; &#39;1075&#39;;&#10;                    END IF;*/&#10;                    --&#10;                    offender_records_iterator(&#10;                        --&#10;                        p_offender_id            &#61;&gt; p_offender_id,&#10;                        p_offender_id_1          &#61;&gt; p_offender_id_1,&#10;                        --&#10;                        p_tab_name               &#61;&gt; l_tab_CHLD(l_tab_idx).table_name,&#10;                        p_row_id                 &#61;&gt; l_tab_rows(l_row_idx).row_id,&#10;                        p_when_to_execute        &#61;&gt; p_when_to_execute,&#10;                        p_dyn_SQL                &#61;&gt; p_dyn_SQL,&#10;                        p_debug_message          &#61;&gt; p_debug_message,&#10;                        p_recursive_level        &#61;&gt; p_recursive_level + 1,&#10;                        p_parent_table           &#61;&gt; p_tab_name,&#10;                        p_parent_row_id          &#61;&gt; p_row_id,&#10;                        p_skip_subtrees          &#61;&gt; p_skip_subtrees,&#10;                        p_check_offender_id_flag &#61;&gt; p_check_offender_id_flag,&#10;                        p_actual_offender_id     &#61;&gt; l_tab_rows(l_row_idx).offender_id,&#10;                        p_ignore_where_clause    &#61;&gt; p_ignore_where_clause,&#10;                        --&#10;                        p_exclude_merged         &#61;&gt; p_exclude_merged,&#10;                        p_include_merged         &#61;&gt; p_include_merged,&#10;                        p_include_merged_level   &#61;&gt; p_include_merged_level );&#10;                    --&#10;                END LOOP;&#10;            EXCEPTION&#10;                WHEN recursive_limit_exception THEN&#10;                    raise_application_error(&#10;                        -20001,&#10;                        &#39;ERROR in OFFENDER_RECORDS_ITERATOR [&#39; || p_tab_name || &#39;]: recursive call stack has exceeded the maximum limit of &#39; || lc_max_recursion&#10;                    );&#10;                WHEN OTHERS THEN&#10;--                    IF l_tab_CHLD(l_tab_idx).table_name  LIKE &#39;CONTACT_%ES_%&#39; THEN&#10;--                        DBMS_OUTPUT.put_line(&#10;--                            &#39;ERROR in OFFENDER_RECORDS_ITERATOR [&#39; || p_tab_name || &#39;]:&#39; || CHR(10) ||&#10;--                            SQLERRM || CHR(10) ||&#10;--                            &#39;[&#39; || DBMS_UTILITY.format_error_backtrace || &#39;]: &#39; || CHR(10) ||&#10;--                            --                    END IF;&#10;                    --&#10;                    raise_application_error(&#10;                        -20001,&#10;                        &#39;ERROR in OFFENDER_RECORDS_ITERATOR [&#39; || p_tab_name || &#39;]:&#39; || CHR(10) ||&#10;                        SQLERRM || CHR(10) ||&#10;                        &#39;[&#39; || DBMS_UTILITY.format_error_backtrace || &#39;]: &#39; || CHR(10) ||&#10;                        l_SQL );&#10;            END;&#10;            --&#10;        END IF; --IF NVL(INSTR(l_skip_subtrees, &#39;,&#39; || p_tab_name || &#39;/&#39; || l_tab_CHLD(l_tab_idx).table_name || &#39;,&#39;), 0) &#61; 0&#10;        --&#10;    END LOOP;&#10;    --&#10;    IF p_when_to_execute &#61; &#39;POST&#39; THEN&#10;        --&#10;        IF p_check_offender_id_flag &#61; &#39;Y&#39; AND l_debug_flag THEN&#10;            procDebug(&#10;                &#39;OFFENDER_RECORDS_ITERATOR.check_offender_id &#39; ||&#10;                &#39;[offender_id&#61;&#39;             || p_offender_id            || &#39;]&#39; ||&#10;                &#39;[actual_offender_id&#61;&#39;      || p_actual_offender_id     || &#39;]&#39; ||&#10;                &#39;[table&#61;&#39;                   || p_tab_name               || &#39;]&#39; ||&#10;                &#39;[&#39; || TO_CHAR(p_recursive_level)                       || &#39;]&#39; ||&#10;                &#39;[parent_tab&#61;&#39;              || p_parent_table           || &#39;]&#39; ||&#10;                &#39;[ignore_where_clause&#61;&#39;     || p_ignore_where_clause    || &#39;]&#39; ||&#10;                &#39;[check_offender_id_flag&#61;&#39;  || p_check_offender_id_flag || &#39;]&#39; );&#10;        END IF;&#10;        --&#10;        IF NVL(p_check_offender_id_flag, &#39;N&#39;) &#61; &#39;N&#39;&#10;           OR&#10;           NOT ( ( p_check_offender_id_flag &#61; &#39;Y&#39; AND l_tab_info_rec.offender_id_col_exists &#61; &#39;N&#39; ) OR&#10;                 ( p_check_offender_id_flag &#61; &#39;Y&#39; AND p_actual_offender_id &#61; p_offender_id )&#10;               )&#10;        THEN&#10;            do_process_current_record(&#10;                p_offender_id     &#61;&gt; p_offender_id,&#10;                p_tab_name        &#61;&gt; p_tab_name,&#10;                p_dest_table      &#61;&gt; p_tab_name,&#10;                p_row_id          &#61;&gt; p_row_id,&#10;                p_dyn_SQL         &#61;&gt; p_dyn_SQL,&#10;                p_debug_message   &#61;&gt; p_debug_message,&#10;                p_recursive_level &#61;&gt; p_recursive_level,&#10;                p_parent_table    &#61;&gt; p_parent_table,&#10;                p_parent_row_id   &#61;&gt; p_parent_row_id );&#10;        END IF;&#10;        --&#10;    END IF;&#10;    --&#10;END offender_records_iterator;&#10;--&#10;PROCEDURE seed_tab_hierarchy IS&#10;BEGIN&#10;    --&#10;    DELETE FROM offender_hierarchy;&#10;    --&#10;    INSERT INTO offender_hierarchy(&#10;      /*00*/ table_name,&#10;      --&#10;      /*01*/ constraint_name,&#10;      /*02*/ r_constraint_name,&#10;      /*03*/ constraint_type,&#10;      --&#10;      /*04*/ parent_table,&#10;      --&#10;      /*05*/ fk_fld,&#10;      /*06*/ parent_pk_fld,&#10;      --&#10;      /*07*/ where_clause,&#10;      /*08*/ not_null_col_name,&#10;      --&#10;      /*09*/ order_by,&#10;      /*10*/ hier_level,&#10;      /*11*/ hier_order_by,&#10;      --&#10;      /*12*/ offender_id_col_exists )&#10;    --&#10;    WITH TH_FLAT_0 AS (&#10;      SELECT DISTINCT table_name, hier_level&#10;      FROM TABLE(PKG_DynSQL.GET_TAB_LIST)&#10;      WHERE table_type &#61; &#39;O&#39; ),&#10;    TH_FLAT_1 AS (&#10;      SELECT&#10;        /*00*/ table_name,&#10;        --&#10;        /*01*/ NULL AS constraint_name,&#10;        /*02*/ NULL AS r_constraint_name,&#10;        /*03*/ &#39;R&#39; AS constraint_type,&#10;        --&#10;        /*04*/ parent_table,&#10;        --&#10;        /*05*/ fk_col_name                                 AS fk_fld,&#10;        /*06*/ PKG_DynSQL.get_tab_pk_fld_lst(parent_table) AS parent_pk_fld,&#10;        --&#10;        /*07*/ where_clause,&#10;        /*08*/ not_null_col_name,&#10;        --&#10;        /*09*/ order_by,&#10;        /*10*/ hier_level,&#10;        /*11*/ hier_order_by&#10;        --&#10;      FROM TABLE( PKG_DynSQL.GET_TAB_LIST )&#10;      WHERE table_type &#61; &#39;O&#39;&#10;        --AND parent_table &#61; p_parent_table1&#10;        AND parent_table IN (SELECT DISTINCT table_name FROM TH_FLAT_0)&#10;    ),&#10;    TH_FLAT_2 AS (&#10;      SELECT&#10;        /*00*/ UC.table_name,&#10;        --&#10;        /*01*/ UC.constraint_name,&#10;        /*02*/ UC.r_constraint_name,&#10;        /*03*/ UC.constraint_type,&#10;        --&#10;        /*04*/ UC_P.table_name AS parent_table,&#10;        --&#10;        /*05*/ PKG_Lookups.funcgetTabRecord_CACHED(&#10;            p_table      &#61;&gt; &#39;user_constraints C, user_cons_columns CC&#39;,&#10;            p_ref_col    &#61;&gt; &#39;1&#39;, p_ref_val &#61;&gt; &#39;1&#39;,&#10;            p_data_fld   &#61;&gt; &#39;CC.column_name&#39;,&#10;            p_where      &#61;&gt; &#39;C.constraint_name &#61; :p_con AND cc.table_name &#61; c.table_name AND cc.constraint_name &#61; c.constraint_name&#39;,&#10;            p_bind_var1  &#61;&gt; UC.constraint_name,&#10;            p_order_by   &#61;&gt; &#39;CC.position&#39;,&#10;            p_all_records &#61;&gt; &#39;Y&#39;, p_delim &#61;&gt; &#39;:&#39; ) FK_fld,&#10;        --&#10;        /*06*/ PKG_Lookups.funcgetTabRecord_CACHED(&#10;            p_table      &#61;&gt; &#39;user_constraints C, user_cons_columns CC&#39;,&#10;            p_ref_col    &#61;&gt; &#39;1&#39;, p_ref_val &#61;&gt; &#39;1&#39;,&#10;            p_data_fld   &#61;&gt; &#39;CC.column_name&#39;,&#10;            p_where      &#61;&gt; &#39;C.constraint_name &#61; :p_con AND cc.table_name &#61; c.table_name AND cc.constraint_name &#61; c.constraint_name&#39;,&#10;            p_bind_var1  &#61;&gt; UC_P.constraint_name,&#10;            p_order_by   &#61;&gt; &#39;CC.position&#39;,&#10;            p_all_records &#61;&gt; &#39;Y&#39;, p_delim &#61;&gt; &#39;:&#39; ) parent_PK_fld,&#10;        --&#10;        /*07*/ NULL AS where_clause,&#10;        /*08*/ NULL AS not_null_col_name,&#10;        --&#10;        /*09*/ 9999 AS order_by,&#10;        /*10*/ CASE WHEN UC_P.table_name &#61; &#39;OFFENDER&#39; THEN 1&#10;             WHEN UC_P.table_name &#61; &#39;EVENT&#39;    THEN 2&#10;             ELSE 9999&#10;        END AS hier_level,&#10;        /*11*/ 9999 AS hier_order_by&#10;        --&#10;      FROM&#10;        user_constraints UC&#10;          INNER JOIN user_constraints UC_P ON&#10;            UC_P.constraint_name &#61; UC.r_constraint_name&#10;            AND UC_P.table_name IN ( SELECT DISTINCT table_name FROM TABLE(PKG_DynSQL.GET_TAB_LIST) WHERE table_type &#61; &#39;O&#39; )&#10;            AND&#10;            ( UC_P.table_name NOT IN (&#39;OFFENDER&#39;)&#10;              OR&#10;              EXISTS(&#10;                SELECT 1&#10;                FROM TH_FLAT_0&#10;                WHERE hier_level &#61; 1&#10;                  AND table_name &#61; UC.table_name )&#10;              OR&#10;              NOT EXISTS(&#10;                SELECT 1&#10;                FROM TH_FLAT_0&#10;                WHERE table_name &#61; UC.table_name )&#10;            )&#10;      WHERE 1&#61;1&#10;        AND UC.constraint_type &#61; &#39;R&#39;&#10;        --AND UC_P.table_name &#61; p_parent_table1&#10;        AND UC_P.table_name IN (SELECT DISTINCT table_name FROM TH_FLAT_0)&#10;        AND NOT EXISTS(&#10;          SELECT 1 FROM TH_FLAT_1&#10;          WHERE table_name &#61; UC.table_name&#10;            AND parent_table &#61; UC_P.table_name )&#10;    ),&#10;    TH_FLAT AS (&#10;      SELECT * FROM TH_FLAT_1&#10;      UNION&#10;      SELECT * FROM TH_FLAT_2&#10;    )&#10;    --&#10;    SELECT&#10;      /*00*/ table_name,&#10;      --&#10;      /*01*/ constraint_name,&#10;      /*02*/ r_constraint_name,&#10;      /*03*/ constraint_type,&#10;      --&#10;      /*04*/ parent_table,&#10;      --&#10;      /*05*/ FK_fld,&#10;      /*06*/ parent_PK_fld,&#10;      --&#10;      /*07*/ where_clause,&#10;      /*08*/ not_null_col_name,&#10;      --&#10;      /*09*/ order_by,&#10;      /*10*/ hier_level,&#10;      /*11*/ hier_order_by,&#10;      --&#10;      /*12*/ PKG_Lookups.funcgetTabRecord_CACHED(&#10;          p_data_fld &#61;&gt; &#39;&#39;&#39;Y&#39;&#39;&#39;, p_default_val &#61;&gt; &#39;N&#39;,&#10;          p_table    &#61;&gt; &#39;user_tab_columns&#39;,&#10;          p_ref_col  &#61;&gt; &#39;table_name&#39;,&#10;          p_ref_val  &#61;&gt; table_name,&#10;          p_where    &#61;&gt; &#39;column_name &#61; &#39;&#39;OFFENDER_ID&#39;&#39;&#39;&#10;      ) AS offender_id_col_exists&#10;    FROM TH_FLAT&#10;    ORDER BY&#10;      hier_level, order_by;&#10;    --&#10;END seed_tab_hierarchy;&#10;--&#10;FUNCTION get_offender_hierarchy_tab RETURN g_tab2_hier_TAB_TYP PIPELINED&#10;IS&#10;    --&#10;    l_table_name VARCHAR2(30);&#10;    l_tab_CHLD   g_tab2_hier_tab_TYP;&#10;    --&#10;BEGIN&#10;    --&#10;    init_tab_info_PRIV;&#10;    --&#10;    l_table_name :&#61; G_TAB2_INFO.FIRST;&#10;    LOOP&#10;        EXIT WHEN l_table_name IS NULL;&#10;        --&#10;        l_tab_CHLD :&#61; G_TAB2_INFO(l_table_name).child_tables;&#10;        FOR l_idx IN 1..l_tab_CHLD.COUNT LOOP&#10;            PIPE ROW (l_tab_CHLD(l_idx));&#10;        END LOOP;&#10;        --&#10;        l_table_name :&#61; G_TAB2_INFO.NEXT(l_table_name);&#10;    END LOOP;&#10;    --&#10;END get_offender_hierarchy_tab;&#10;&#10;--&#10;-- Offender records hierarchy summary report&#10;--&#10;--TYPE trec_data_node_TYP IS RECORD(&#10;--  row_num      INTEGER,&#10;--  table_key    VARCHAR2(100),&#10;--  table_name   VARCHAR2(100),&#10;--  hier_level   INTEGER,&#10;--  parent_table VARCHAR2(100),&#10;--  row_count    INTEGER,&#10;--  id_list      CLOB );&#10;--TYPE ttab_data_node_TYP IS TABLE OF trec_data_node_TYP;&#10;--TYPE ttab_data_node_TYP1 IS TABLE OF trec_data_node_TYP INDEX BY VARCHAR2(100);&#10;&#10;FUNCTION get_off_data_nodes_summary(&#10;    p_crn                  VARCHAR2,&#10;    p_skip_nodes           VARCHAR2 DEFAULT NULL,&#10;    p_include_merged       VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_include_merged_level INTEGER DEFAULT NULL,&#10;    p_crn1                 VARCHAR2 DEFAULT NULL )&#10;RETURN ttab_data_node_TYP PIPELINED&#10;IS&#10;    --&#10;    l_key VARCHAR2(100);&#10;    l_rec trec_data_node_TYP;&#10;    --&#10;BEGIN&#10;    --&#10;    do_off_data_nodes_init;&#10;    do_off_data_nodes_populate(p_crn, p_skip_nodes, p_include_merged, p_include_merged_level, p_crn1);&#10;    --&#10;    l_key :&#61; g_off_data_nodes_TAB.FIRST;&#10;    LOOP&#10;        EXIT WHEN l_key IS NULL;&#10;        --&#10;        l_rec :&#61; g_off_data_nodes_TAB(l_key);&#10;        PIPE ROW (l_rec);&#10;        --&#10;        l_key :&#61; g_off_data_nodes_TAB.NEXT(l_key);&#10;    END LOOP;&#10;    --&#10;END get_off_data_nodes_summary;&#10;--&#10;PROCEDURE do_off_data_nodes_init IS&#10;BEGIN&#10;    g_off_data_nodes_ROWNUM :&#61; 0;&#10;    g_off_data_nodes_TAB.DELETE;&#10;    g_idx_TAB.DELETE;&#10;END do_off_data_nodes_init;&#10;--&#10;PROCEDURE do_off_data_nodes_inc(&#10;    p_parent_table    VARCHAR2,&#10;    p_table           VARCHAR2,&#10;    p_offender_id     NUMBER,&#10;    p_parent_row_id   ROWID,&#10;    p_row_id          ROWID,&#10;    p_recursive_level NUMBER )&#10;IS&#10;    --&#10;    l_key VARCHAR2(100);&#10;    l_idx INTEGER;&#10;    --&#10;    l_id  VARCHAR2(100);&#10;    l_rec trec_data_node_TYP;&#10;    --&#10;BEGIN&#10;    --&#10;    l_key :&#61;&#10;        PKG_LstUtl.concat(&#10;            p_table,&#10;            LPAD(TO_CHAR(p_recursive_level-1), 4, &#39;0&#39;),&#10;            p_delim&#61;&gt;&#39;:&#39; );&#10;    --&#10;    EXECUTE IMMEDIATE&#10;      &#39;SELECT &#39; || PKG_DynSQL.get_tab_pk_fld_lst(p_table, &#39; || &#39;&#39;:&#39;&#39; || &#39;, -1) || CHR(10) ||&#10;      &#39;FROM &#39; || p_table || CHR(10) ||&#10;      &#39;WHERE ROWID &#61; :p_row_id&#39;&#10;    INTO l_id&#10;    USING p_row_id;&#10;    --&#10;    IF g_idx_TAB.EXISTS(l_key) THEN&#10;        --&#10;        l_idx :&#61; g_idx_TAB(l_key);&#10;        l_rec :&#61; g_off_data_nodes_TAB(l_idx);&#10;        l_rec.row_count    :&#61; l_rec.row_count + 1;&#10;        l_rec.id_list      :&#61; l_rec.id_list || &#39;,&#39; || l_id;&#10;        --&#10;    ELSE&#10;        --&#10;        g_off_data_nodes_ROWNUM :&#61; g_off_data_nodes_ROWNUM + 1;&#10;        l_idx :&#61; g_off_data_nodes_ROWNUM;&#10;        g_idx_TAB(l_key) :&#61; l_idx;&#10;        --&#10;        l_rec.table_name :&#61; UPPER(TRIM(p_table));&#10;        l_rec.hier_level :&#61; p_recursive_level-1;&#10;        l_rec.parent_table :&#61; p_parent_table;&#10;        l_rec.row_count    :&#61; 1;&#10;        l_rec.id_list      :&#61; l_id;&#10;        --&#10;    END IF;&#10;    --&#10;    g_off_data_nodes_TAB(l_idx) :&#61; l_rec;&#10;    --&#10;END do_off_data_nodes_inc;&#10;--&#10;PROCEDURE do_off_data_nodes_populate(&#10;    p_crn                  VARCHAR2,&#10;    p_skip_nodes           VARCHAR2 DEFAULT NULL,&#10;    p_include_merged       VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_include_merged_level INTEGER  DEFAULT NULL,&#10;    p_crn1                 VARCHAR2 DEFAULT NULL )&#10;IS&#10;    --&#10;    l_offender_id   NUMBER;&#10;    l_row_id        ROWID;&#10;    --&#10;    l_offender_id_1 NUMBER;&#10;    --&#10;BEGIN&#10;    --&#10;    SELECT ROWID, offender_id&#10;    INTO l_row_id, l_offender_id&#10;    FROM offender&#10;    WHERE crn &#61; p_crn;&#10;    --&#10;    IF p_crn1 IS NOT NULL THEN&#10;        SELECT offender_id INTO l_offender_id_1&#10;        FROM offender&#10;        WHERE crn &#61; p_crn1;&#10;    ELSE&#10;        l_offender_id_1 :&#61; l_offender_id;&#10;    END IF;&#10;    --&#10;    PKG_hier_support.offender_records_iterator(&#10;        --&#10;        p_offender_id         &#61;&gt; l_offender_id,&#10;        p_offender_id_1       &#61;&gt; l_offender_id_1,&#10;        --&#10;        p_tab_name            &#61;&gt; &#39;OFFENDER&#39;,&#10;        p_row_id              &#61;&gt; l_row_id,&#10;        p_recursive_level     &#61;&gt; 1,&#10;        --&#10;        p_when_to_execute     &#61;&gt; &#39;PRE&#39;,&#10;        p_ignore_where_clause &#61;&gt; &#39;N&#39;,&#10;        --&#10;        p_include_merged      &#61;&gt; p_include_merged,&#10;        p_include_merged_level&#61;&gt; p_include_merged_level,&#10;        --&#10;        p_dyn_SQL             &#61;&gt;&#10;           &#39;DECLARE&#10;                --&#10;                l_parent_table    VARCHAR2(30) :&#61; :p_parent_table;&#10;                l_table           VARCHAR2(30) :&#61; :p_table;&#10;                l_offender_id     NUMBER       :&#61; :p_offender_id;&#10;                l_parent_row_id   ROWID        :&#61; :p_parent_row_id;&#10;                l_row_id          ROWID        :&#61; :p_row_id;&#10;                l_recursive_level INTEGER      :&#61; :p_recursive_level;&#10;                --&#10;            BEGIN&#10;                PKG_HIER_SUPPORT.do_off_data_nodes_inc(&#10;                        p_parent_table    &#61;&gt; l_parent_table,&#10;                        p_table           &#61;&gt; l_table,&#10;                        p_offender_id     &#61;&gt; l_offender_id,&#10;                        p_parent_row_id   &#61;&gt; l_parent_row_id,&#10;                        p_row_id          &#61;&gt; l_row_id,&#10;                        p_recursive_level &#61;&gt; l_recursive_level );&#10;            END;&#39;,&#10;            --&#10;            p_skip_subtrees &#61;&gt; p_skip_nodes ); --PKG_MERGE_OFFENDER.get_merge_skip_subtree_list&#10;    --&#10;END do_off_data_nodes_populate;&#10;--&#10;&#10;&#10;--&#10;--&#10;--&#10;PROCEDURE do_init IS&#10;BEGIN&#10;    --&#10;    NULL;&#10;    --&#10;END do_init;&#10;--&#10;--&#10;--&#10;BEGIN&#10;--&#10;--&#10;    PKG_Global.do_init;&#10;    do_init;&#10;--&#10;--&#10;END PKG_hier_support;</textarea>
                        </div>
                    </div>
                </section>
            </div>
            <!-- /.content-wrapper -->
            <footer class="main-footer">
                <div>
                    <div class="pull-right hidden-xs">
                        <a href="https://github.com/schemaspy/schemaspy" title="GitHub for SchemaSpy"><i class="fa fa-github-square fa-2x"></i></a>
                        <a href="http://stackoverflow.com/questions/tagged/schemaspy" title="StackOverflow for SchemaSpy"><i class="fa fa-stack-overflow fa-2x"></i></a>
                    </div>
                    <strong>Generated by <a href="http://schemaspy.org/" class="logo-text"><i class="fa fa-database"></i> SchemaSpy 6.2.4</a></strong>
                </div>
                <!-- /.container -->
            </footer>
        </div>
        <!-- ./wrapper -->

        <!-- jQuery 2.2.3 -->
        <script src="../bower/admin-lte/plugins/jQuery/jquery-2.2.3.min.js"></script>
        <script src="../bower/admin-lte/plugins/jQueryUI/jquery-ui.min.js"></script>
        <!-- Bootstrap 3.3.5 -->
        <script src="../bower/admin-lte/bootstrap/js/bootstrap.min.js"></script>
        <!-- DataTables -->
        <script src="../bower/datatables.net/jquery.dataTables.min.js"></script>
        <script src="../bower/datatables.net-bs/js/dataTables.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/dataTables.buttons.min.js"></script>
        <script src="../bower/datatables.net-buttons-bs/js/buttons.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.html5.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.print.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.colVis.min.js"></script>
        <!-- SheetJS -->
        <script src="../bower/js-xlsx/xlsx.full.min.js"></script>
        <!-- pdfmake -->
        <script src="../bower/pdfmake/pdfmake.min.js"></script>
        <script src="../bower/pdfmake/vfs_fonts.js"></script>
        <!-- SlimScroll -->
        <script src="../bower/admin-lte/plugins/slimScroll/jquery.slimscroll.min.js"></script>
        <!-- FastClick -->
        <script src="../bower/admin-lte/plugins/fastclick/fastclick.js"></script>
        <!-- Salvattore -->
        <script src="../bower/salvattore/salvattore.min.js"></script>
        <!-- AnchorJS -->
        <script src="../bower/anchor-js/anchor.min.js"></script>
        <!-- CodeMirror -->
        <script src="../bower/codemirror/codemirror.js"></script>
        <script src="../bower/codemirror/sql.js"></script>
        <!-- AdminLTE App -->
        <script src="../bower/admin-lte/dist/js/app.min.js"></script>
        <script src="routine.js"></script>
        <script src="../schemaSpy.js"></script>
    </body>
</html>