<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>TSTNDA.DELIUS_APP_SCHEMA</title>
        <!-- Tell the browser to be responsive to screen width -->
        <meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport">
        <link rel="icon" type="image/png" sizes="16x16" href="../favicon.png">
        <!-- Bootstrap 3.3.5 -->
        <link rel="stylesheet" href="../bower/admin-lte/bootstrap/css/bootstrap.min.css">
        <!-- Font Awesome -->
        <link rel="stylesheet" href="../bower/font-awesome/css/font-awesome.min.css">
        <!-- Ionicons -->
        <link rel="stylesheet" href="../bower/ionicons/css/ionicons.min.css">
        <!-- DataTables -->
        <link rel="stylesheet" href="../bower/datatables.net-bs/css/dataTables.bootstrap.min.css">
        <link rel="stylesheet" href="../bower/datatables.net-buttons-bs/css/buttons.bootstrap.min.css">
        <!-- Code Mirror -->
        <link rel="stylesheet" href="../bower/codemirror/codemirror.css">
        <!-- Fonts -->
        <link href='../fonts/indieflower/indie-flower.css' rel='stylesheet' type='text/css'>
        <link href='../fonts/source-sans-pro/source-sans-pro.css' rel='stylesheet' type='text/css'>

        <!-- Theme style -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/AdminLTE.min.css">
        <!-- Salvattore -->
        <link rel="stylesheet" href="../bower/salvattore/salvattore.css">
        <!-- AdminLTE Skins. Choose a skin from the css/skins
           folder instead of downloading all of them to reduce the load. -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/skins/_all-skins.min.css">
        <!-- SchemaSpy -->
        <link rel="stylesheet" href="../schemaSpy.css">

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
        <script src="../bower/html5shiv/html5shiv.min.js"></script>
        <script src="../bower/respond/respond.min.js"></script>
        <![endif]-->
    </head>
    <!-- ADD THE CLASS layout-top-nav TO REMOVE THE SIDEBAR. -->
    <body class="hold-transition skin-blue layout-top-nav">
        <div class="wrapper">
            <header class="main-header">
                <nav class="navbar navbar-static-top">
                    <div class="container">
                        <div class="navbar-header">
                            <a href="../index.html" class="navbar-brand"><b>TSTNDA</b></a><span class="navbar-brand" style="padding-left: 0">.DELIUS_APP_SCHEMA</span>
                            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse"><i class="fa fa-bars"></i></button>
                        </div>

                        <!-- Collect the nav links, forms, and other content for toggling -->
                        <div class="collapse navbar-collapse pull-left" id="navbar-collapse">
                            <ul class="nav navbar-nav">
                                <li><a href="../index.html">Tables <span class="sr-only">(current)</span></a></li>
                                <li><a href="../columns.html" title="All of the columns in the schema">Columns</a></li>
                                <li><a href="../constraints.html" title="Useful for diagnosing error messages that just give constraint name or number">Constraints</a></li>
                                <li><a href="../relationships.html" title="Diagram of table relationships">Relationships</a></li>
                                <li><a href="../orphans.html" title="View of tables with neither parents nor children">Orphan&nbsp;Tables</a></li>
                                <li><a href="../anomalies.html" title="Things that might not be quite right">Anomalies</a></li>
                                <li><a href="../routines.html" title="Procedures and functions">Routines</a></li>
                            </ul>
                        </div>
                        <!-- /.navbar-collapse -->
                        <!-- Navbar Right Menu -->
                    </div>
                    <!-- /.container-fluid -->
                </nav>
            </header>
            <!-- Main content -->
            <!-- Full Width Column -->
            <div class="content-wrapper">
                <!-- Content Header (Page header) -->
                <section class="content-header">
                    <h1>DELIUS_APP_SCHEMA.PKG_LOOKUPS</h1><br />
                </section>
                <!-- Main content -->
                <section class="content">
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <span class="glyphicon glyphicon-list-alt" aria-hidden="true"></span>
                            <h3 id="Columns" class="box-title">Parameters</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <table id="standard_table" class="table table-bordered table-striped dataTable" role="grid">
                                <thead align='left'>
                                <tr>
                                    <th>Name</th>
                                    <th>Type</th>
                                    <th>Mode</th>
                                </tr>
                                </thead>
                                <tbody>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <i class="fa fa-file-code-o"></i>
                            <h3 id="RoutineDefinition" class="box-title">Definition</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <textarea id="sql-script-codemirror" name="sql-script-codemirror" rows="" style="display: none;">PACKAGE BODY pkg_Lookups&#10;AS&#10;--&#10;&#10;--Global Constants&#10;gc_plsqlcache_rebuild_ctx CONSTANT VARCHAR2(30) :&#61; &#39;PLSQLCACHE_REBUILD_&#39;;&#10;--&#10;-- Global variables&#10;--&#10;g_label VARCHAR2(100);&#10;&#10;g_cache_miss_cnt  NUMBER :&#61; 0;&#10;g_cache_flush_cnt NUMBER :&#61; 0;&#10;&#10;-- Global PL/SQL cache tables&#10;TYPE g_cache_TAB_TYP IS TABLE OF VARCHAR2(4000) INDEX BY VARCHAR2(4000);&#10;g_cache_TAB g_cache_TAB_TYP;&#10;g_current_SCN NUMBER :&#61; 0;&#10;&#10;g_cache_max_size INTEGER :&#61; 1000;&#10;&#10;TYPE contact_enf_tab_TYP IS TABLE OF VARCHAR2(1) INDEX BY VARCHAR2(100);&#10;g_contact_enf_tab contact_enf_tab_TYP;&#10;&#10;PROCEDURE procDebug(p_msg VARCHAR2) IS&#10;BEGIN&#10;    PKG_Debug.procDebug(p_msg);&#10;END procDebug;&#10;&#10;--&#10;-- PKG_COMMON wrappers&#10;--&#10;PROCEDURE message(p_msg VARCHAR2, p_trace_level INTEGER DEFAULT 0) IS&#10;BEGIN&#10;    PKG_Common.print_message(&#10;        p_msg         &#61;&gt; p_msg,&#10;        p_trace_level &#61;&gt; NVL(p_trace_level, PKG_Common.GC_TRACE_LEVEL),&#10;        p_label       &#61;&gt; g_label );&#10;END message;&#10;--&#10;FUNCTION empty2null(p_str VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.empty2null(p_str);&#10;END empty2null;&#10;&#10;FUNCTION nvlstr(p_str1 VARCHAR2, p_str2 VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.NVLSTR(p_str1, p_str2);&#10;END nvlstr;&#10;&#10;FUNCTION is_str_empty(p_str VARCHAR2, p_ignore_spaces_and_zeroes VARCHAR2 DEFAULT &#39;N&#39;) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.is_str_empty( p_str, p_ignore_spaces_and_zeroes );&#10;END is_str_empty;&#10;--&#10;PROCEDURE raise_error(p_err_msg VARCHAR2, p_proc VARCHAR2, p_label VARCHAR2 DEFAULT NULL) IS&#10;BEGIN&#10;    PKG_Common.raise_error( p_err_msg, p_proc, p_label );&#10;END raise_error;&#10;--&#10;--------------------------------------------------------------------------------&#10;--&#10;-- Generic subroutines&#10;--&#10;--------------------------------------------------------------------------------&#10;--&#10;FUNCTION get_cache_miss_cnt RETURN NUMBER IS&#10;BEGIN&#10;    RETURN g_cache_miss_cnt;&#10;END get_cache_miss_cnt;&#10;--&#10;FUNCTION get_cache_flush_cnt RETURN NUMBER IS&#10;BEGIN&#10;    RETURN g_cache_flush_cnt;&#10;END get_cache_flush_cnt;&#10;--&#10;FUNCTION funcgetTabRecord(&#10;    p_table       VARCHAR2,&#10;    p_ref_col     VARCHAR2,&#10;    p_ref_val     VARCHAR2,&#10;    p_data_fld    VARCHAR2,&#10;    p_default_val VARCHAR2 DEFAULT NULL,&#10;    p_where       VARCHAR2 DEFAULT NULL,&#10;    p_order_by    VARCHAR2 DEFAULT NULL,&#10;    p_bind_var1   VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING, p_bind_var2 VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING, p_bind_var3 VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING,  p_bind_var4 VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING, p_bind_var5  VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING,&#10;    p_bind_var6   VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING, p_bind_var7 VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING, p_bind_var8 VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING,  p_bind_var9 VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING, p_bind_var10 VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING,&#10;    p_all_records VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_delim       VARCHAR2 DEFAULT CHR(10),&#10;    p_max_len     INTEGER  DEFAULT 4000)&#10;RETURN VARCHAR2 IS&#10;    TYPE l_cur_TYP IS REF CURSOR;&#10;    l_cur    l_cur_TYP;&#10;    l_SQL    VARCHAR2(10000);&#10;    l_ret    VARCHAR2(30000);&#10;    l_ret1   VARCHAR2(4000);&#10;BEGIN&#10;    l_SQL :&#61;&#10;        &#39;SELECT &#39; || p_data_fld || CHR(10) ||&#10;        &#39;FROM &#39; || p_table || CHR(10) ||&#10;        &#39;WHERE &#39; || p_ref_col || &#39; &#61; :p_ref_val&#39;;&#10;    --&#10;    IF empty2null(p_where) IS NOT NULL THEN&#10;        l_SQL :&#61; l_SQL || CHR(10) || &#39;  AND &#39; || p_where;&#10;    END IF;&#10;    IF empty2null(p_order_by) IS NOT NULL THEN&#10;        l_SQL :&#61; l_SQL || CHR(10) || &#39;ORDER BY &#39; || p_order_by;&#10;    END IF;&#10;    --&#10;    IF    NVLSTR(p_bind_var10, &#39;X&#39;) &lt;&gt; GC_LUP_BIND_VAR_MISSING THEN&#10;        OPEN l_cur FOR l_SQL USING p_ref_val, p_bind_var1, p_bind_var2, p_bind_var3, p_bind_var4, p_bind_var5, p_bind_var6, p_bind_var7, p_bind_var8, p_bind_var9, p_bind_var10;&#10;    ELSIF NVLSTR(p_bind_var9, &#39;X&#39;) &lt;&gt; GC_LUP_BIND_VAR_MISSING THEN&#10;        OPEN l_cur FOR l_SQL USING p_ref_val, p_bind_var1, p_bind_var2, p_bind_var3, p_bind_var4, p_bind_var5, p_bind_var6, p_bind_var7, p_bind_var8, p_bind_var9;&#10;    ELSIF NVLSTR(p_bind_var8, &#39;X&#39;) &lt;&gt; GC_LUP_BIND_VAR_MISSING THEN&#10;        OPEN l_cur FOR l_SQL USING p_ref_val, p_bind_var1, p_bind_var2, p_bind_var3, p_bind_var4, p_bind_var5, p_bind_var6, p_bind_var7, p_bind_var8;&#10;    ELSIF NVLSTR(p_bind_var7, &#39;X&#39;) &lt;&gt; GC_LUP_BIND_VAR_MISSING THEN&#10;        OPEN l_cur FOR l_SQL USING p_ref_val, p_bind_var1, p_bind_var2, p_bind_var3, p_bind_var4, p_bind_var5, p_bind_var6, p_bind_var7;&#10;    ELSIF NVLSTR(p_bind_var6, &#39;X&#39;) &lt;&gt; GC_LUP_BIND_VAR_MISSING THEN&#10;        OPEN l_cur FOR l_SQL USING p_ref_val, p_bind_var1, p_bind_var2, p_bind_var3, p_bind_var4, p_bind_var5, p_bind_var6;&#10;    ELSIF NVLSTR(p_bind_var5, &#39;X&#39;) &lt;&gt; GC_LUP_BIND_VAR_MISSING THEN&#10;        OPEN l_cur FOR l_SQL USING p_ref_val, p_bind_var1, p_bind_var2, p_bind_var3, p_bind_var4, p_bind_var5;&#10;    ELSIF NVLSTR(p_bind_var4, &#39;X&#39;) &lt;&gt; GC_LUP_BIND_VAR_MISSING THEN&#10;        OPEN l_cur FOR l_SQL USING p_ref_val, p_bind_var1, p_bind_var2, p_bind_var3, p_bind_var4;&#10;    ELSIF NVLSTR(p_bind_var3, &#39;X&#39;) &lt;&gt; GC_LUP_BIND_VAR_MISSING THEN&#10;        OPEN l_cur FOR l_SQL USING p_ref_val, p_bind_var1, p_bind_var2, p_bind_var3;&#10;    ELSIF NVLSTR(p_bind_var2, &#39;X&#39;) &lt;&gt; GC_LUP_BIND_VAR_MISSING THEN&#10;        OPEN l_cur FOR l_SQL USING p_ref_val, p_bind_var1, p_bind_var2;&#10;    ELSIF NVLSTR(p_bind_var1, &#39;X&#39;) &lt;&gt; GC_LUP_BIND_VAR_MISSING THEN&#10;        OPEN l_cur FOR l_SQL USING p_ref_val, p_bind_var1;&#10;    ELSE&#10;        OPEN l_cur FOR l_SQL USING p_ref_val;&#10;    END IF;&#10;    --&#10;    FETCH l_cur INTO l_ret;&#10;    IF p_all_records &#61; &#39;Y&#39; THEN&#10;        LOOP&#10;            FETCH l_cur INTO l_ret1;&#10;            EXIT WHEN l_cur%NOTFOUND;&#10;            --&#10;            l_ret :&#61; SUBSTR(l_ret || p_delim || l_ret1, 1, p_max_len);&#10;        END LOOP;&#10;    END IF;&#10;    IF p_all_records &#61; &#39;N&#39; THEN&#10;        IF l_cur%NOTFOUND THEN&#10;            l_ret :&#61; p_default_val;&#10;        END IF;&#10;    END IF;&#10;    CLOSE l_cur;&#10;    --&#10;    RETURN NVLSTR(l_ret, p_default_val);&#10;EXCEPTION WHEN OTHERS THEN&#10;    raise_application_error(-20000, &#39;ERROR in GET_TAB_RECORD: &#39; || SQLERRM || CHR(10) || l_SQL || CHR(10) ||&#10;        &#39;Bind Variables: [&#39; || p_ref_val    || &#39;]&#39; ||&#10;                        &#39;[&#39; || p_bind_var1  || &#39;]&#39; ||&#10;                        &#39;[&#39; || p_bind_var2  || &#39;]&#39; ||&#10;                        &#39;[&#39; || p_bind_var3  || &#39;]&#39; ||&#10;                        &#39;[&#39; || p_bind_var4  || &#39;]&#39; ||&#10;                        &#39;[&#39; || p_bind_var5  || &#39;]&#39; ||&#10;                        &#39;[&#39; || p_bind_var6  || &#39;]&#39; ||&#10;                        &#39;[&#39; || p_bind_var7  || &#39;]&#39; ||&#10;                        &#39;[&#39; || p_bind_var8  || &#39;]&#39; ||&#10;                        &#39;[&#39; || p_bind_var9  || &#39;]&#39; ||&#10;                        &#39;[&#39; || p_bind_var10 || &#39;]&#39;);&#10;END funcgetTabRecord;&#10;--&#10;FUNCTION funcgetTabRecord_CACHED(&#10;    p_table       VARCHAR2,&#10;    p_ref_col     VARCHAR2,&#10;    p_ref_val     VARCHAR2,&#10;    p_data_fld    VARCHAR2,&#10;    p_default_val VARCHAR2 DEFAULT NULL,&#10;    p_where       VARCHAR2 DEFAULT NULL,&#10;    p_order_by    VARCHAR2 DEFAULT NULL,&#10;    p_bind_var1   VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING, p_bind_var2 VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING, p_bind_var3 VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING,  p_bind_var4 VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING, p_bind_var5  VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING,&#10;    p_bind_var6   VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING, p_bind_var7 VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING, p_bind_var8 VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING,  p_bind_var9 VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING, p_bind_var10 VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING,&#10;    p_all_records VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_delim       VARCHAR2 DEFAULT CHR(10),&#10;    p_max_len     INTEGER  DEFAULT 4000)&#10;RETURN VARCHAR2&#10;    RESULT_CACHE&#10;IS&#10;BEGIN&#10;    RETURN&#10;        funcgetTabRecord(&#10;            p_table       &#61;&gt; p_table,&#10;            p_ref_col     &#61;&gt; p_ref_col,&#10;            p_ref_val     &#61;&gt; p_ref_val,&#10;            p_data_fld    &#61;&gt; p_data_fld,&#10;            p_default_val &#61;&gt; p_default_val,&#10;            p_where       &#61;&gt; p_where,&#10;            p_order_by    &#61;&gt; p_order_by,&#10;            p_bind_var1   &#61;&gt; p_bind_var1,&#10;            p_bind_var2   &#61;&gt; p_bind_var2,&#10;            p_bind_var3   &#61;&gt; p_bind_var3,&#10;            p_bind_var4   &#61;&gt; p_bind_var4,&#10;            p_bind_var5   &#61;&gt; p_bind_var5,&#10;            p_bind_var6   &#61;&gt; p_bind_var6,&#10;            p_bind_var7   &#61;&gt; p_bind_var7,&#10;            p_bind_var8   &#61;&gt; p_bind_var8,&#10;            p_bind_var9   &#61;&gt; p_bind_var9,&#10;            p_bind_var10  &#61;&gt; p_bind_var10,&#10;            p_all_records &#61;&gt; p_all_records,&#10;            p_delim       &#61;&gt; p_delim,&#10;            p_max_len     &#61;&gt; p_max_len);&#10;END funcgetTabRecord_CACHED;&#10;--&#10;--&#10;FUNCTION get_TAB_cache_cnt RETURN INTEGER IS&#10;BEGIN&#10;    RETURN NVL(g_cache_TAB.COUNT, 0);&#10;END get_TAB_cache_cnt;&#10;&#10;FUNCTION get_TAB_cache_elem(p_i INTEGER) RETURN VARCHAR2&#10;IS&#10;    l_i INTEGER;&#10;    l_key VARCHAR2(4000);&#10;BEGIN&#10;    IF NOT NVL(p_i, 0) BETWEEN 1 AND get_TAB_cache_cnt THEN&#10;        RETURN NULL;&#10;        --raise_application_error(-20001, &#39;ERROR in get_TAB_cache_elem: Index [&#39; || p_i || &#39;] is out of range&#39;);&#10;    END IF;&#10;    --&#10;    l_key :&#61; g_cache_TAB.FIRST;&#10;    l_i :&#61; 1;&#10;    LOOP&#10;        EXIT WHEN l_i &#61; p_i;&#10;        l_key :&#61; g_cache_TAB.NEXT(l_key);&#10;        l_i :&#61; l_i + 1;&#10;    END LOOP;&#10;    RETURN &#39;[&#39; || l_key || &#39;]: &#39; || g_cache_TAB(l_key);&#10;END get_TAB_cache_elem;&#10;--&#10;FUNCTION get_plsqlcache_rebuild_flag(p_sid NUMBER DEFAULT NULL) RETURN VARCHAR2&#10;IS&#10;    l_sid NUMBER;&#10;    l_key VARCHAR2(100);&#10;BEGIN&#10;    IF p_sid &gt; 0 THEN&#10;        l_sid :&#61; p_sid;&#10;    ELSE&#10;        l_sid :&#61; SYS_CONTEXT(&#39;USERENV&#39;, &#39;SID&#39;);&#10;    END IF;&#10;    --&#10;    l_key :&#61; gc_plsqlcache_rebuild_ctx || TO_CHAR(l_sid);&#10;    --&#10;--    procDebug(UPPER(&#39;get_plsqlcache_rebuild_flag&#39;) ||&#10;--        &#39;(sid&#61;&#39; || TO_CHAR(l_sid) || &#39;: &#39; ||&#10;--        &#39;getting the &#39; || l_key );&#10;    --&#10;    RETURN NVLSTR( SYS_CONTEXT(&#39;vpd_ctx&#39;, l_key), &#39;N&#39; );&#10;    --&#10;END get_plsqlcache_rebuild_flag;&#10;--&#10;PROCEDURE do_set_plsqlcache_rebuild_flag(p_flag BOOLEAN, p_sid NUMBER DEFAULT NULL)&#10;IS&#10;    l_sid  NUMBER;&#10;    l_flag VARCHAR2(1);&#10;    l_key VARCHAR2(100);&#10;BEGIN&#10;    IF p_sid &gt; 0 THEN&#10;        l_sid :&#61; p_sid;&#10;    ELSE&#10;        l_sid :&#61; SYS_CONTEXT(&#39;USERENV&#39;, &#39;SID&#39;);&#10;    END IF;&#10;    l_flag :&#61; CASE WHEN NVL(p_flag, FALSE) THEN &#39;Y&#39; ELSE &#39;N&#39; END;&#10;    --&#10;    IF l_flag &lt;&gt; get_plsqlcache_rebuild_flag(l_sid) THEN&#10;        --&#10;        l_key :&#61; gc_plsqlcache_rebuild_ctx || TO_CHAR(l_sid);&#10;        --&#10;        procDebug(UPPER(&#39;do_set_plsqlcache_rebuild_flag&#39;) ||&#10;            &#39;(sid&#61;&#39; || TO_CHAR(l_sid) || &#39;: &#39; ||&#10;            &#39;setting the &#39; || l_key || &#39; flag to &#39; || l_flag );&#10;        --&#10;        PKG_VPD_CTX.set_table_value(&#10;            l_key,&#10;            CASE WHEN NVL(p_flag, FALSE) &#61; TRUE THEN &#39;Y&#39; ELSE &#39;N&#39; END&#10;        );&#10;    END IF;&#10;    --&#10;END do_set_plsqlcache_rebuild_flag;&#10;--&#10;PROCEDURE do_set_cache_flush_signals&#10;IS&#10;    CURSOR cs IS&#10;      SELECT sid, serial#&#10;      FROM gv$session&#10;      WHERE username LIKE &#39;DELIUS%&#39;; --&#61; SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_USER&#39;);&#10;    l_rec cs%ROWTYPE;&#10;BEGIN&#10;    OPEN cs;&#10;    LOOP&#10;        FETCH cs INTO l_rec;&#10;        EXIT WHEN cs%NOTFOUND;&#10;        --&#10;        do_set_plsqlcache_rebuild_flag(TRUE, l_rec.sid);&#10;    END LOOP;&#10;    CLOSE cs;&#10;END do_set_cache_flush_signals;&#10;--&#10;PROCEDURE do_flush_TAB_cache(p_global_flag BOOLEAN DEFAULT FALSE)&#10;IS&#10;    --&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; UPPER(&#39;do_flush_TAB_cache&#39;);&#10;    --&#10;BEGIN&#10;    IF p_global_flag THEN&#10;        procDebug(l_proc || &#39;: p_global_flag is set to TRUE. Set&#39;);&#10;        do_set_cache_flush_signals;&#10;    END IF;&#10;    g_cache_TAB.DELETE;&#10;    --&#10;    do_set_plsqlcache_rebuild_flag(FALSE);&#10;    --&#10;    g_cache_miss_cnt  :&#61; 0;&#10;    g_cache_flush_cnt :&#61; g_cache_flush_cnt + 1;&#10;    --&#10;END do_flush_TAB_cache;&#10;--&#10;FUNCTION get_bind_var(p_var IN VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;    IF p_var &#61; GC_LUP_BIND_VAR_MISSING THEN&#10;        RETURN NULL;&#10;    ELSE&#10;        RETURN p_var || &#39;|&#39;;&#10;    END IF;&#10;END get_bind_var;&#10;--&#10;--&#10;FUNCTION get_parsed_tab_list(p_tables_lst VARCHAR2) RETURN VARCHAR2&#10;IS&#10;    lc_token_num   CONSTANT INTEGER :&#61; 1;&#10;    lc_token_delim VARCHAR2(1) :&#61; &#39; &#39;;&#10;BEGIN&#10;    RETURN&#10;        p_tables_lst;&#10;--        PKG_LstUtl.get_array_2_list(&#10;--            PKG_LstUtl.get_list_2_array(&#10;--                TRIM(REPLACE(REPLACE(REPLACE(p_tables_lst,&#10;--                    CHR(10), &#39; &#39;), CHR(13), &#39;&#39;), CHR(9), &#39; &#39;)),&#10;--                p_token_num   &#61;&gt; lc_token_num,&#10;--                p_token_delim &#61;&gt; lc_token_delim&#10;--            ),&#10;--            p_iterator_function_args_cnt&#61;&gt;4,&#10;--            p_iterator_function&#61;&gt;&#10;--               &#39;CASE WHEN INSTR(:p_table, &#39;&#39;@&#39;&#39;) &gt; 0 THEN&#10;--                    UPPER(SUBSTR(TRIM(PKG_LstUtl.list_num_elem(p_list&#61;&gt;TRIM(:p_table), p_delim&#61;&gt;&#39;&#39; &#39;&#39;, p_num&#61;&gt;1)), 1, 30))&#10;--                ELSE&#10;--                    funcgetTabRecord(&#10;--                        p_table       &#61;&gt; &#39;&#39;pg_class C LEFT OUTER JOIN pg_class T ON C.reltoastrelid &#61; T.oid&#39;&#39;,&#10;--                        p_ref_col     &#61;&gt; &#39;&#39;1&#39;&#39;,&#10;--                        p_ref_val     &#61;&gt; &#39;&#39;1&#39;&#39;,&#10;--                        p_data_fld    &#61;&gt; &#39;&#39;SUBSTR(UPPER(C.oid::regclass::varchar2), 1, 30 - 1 - LENGTH(TO_CHAR(GREATEST(AGE(C.relfrozenxid), AGE(T.relfrozenxid))))) || &#39;&#39;&#39;&#39;_&#39;&#39;&#39;&#39; || GREATEST(AGE(C.relfrozenxid), AGE(T.relfrozenxid))&#39;&#39;,&#10;--                        p_default_val &#61;&gt; UPPER(TRIM(PKG_LstUtl.list_num_elem(p_list&#61;&gt;:p_elem, p_delim&#61;&gt;&#39;&#39; &#39;&#39;, p_num&#61;&gt;1))),&#10;--                        p_where       &#61;&gt; &#39;&#39;c.relkind &#61; :p_rel_kind AND C./*oid::regclass::varchar2*/relname &#61; LOWER(TRIM(:p_table_name))&#39;&#39;,&#10;--                        p_bind_var1   &#61;&gt; &#39;&#39;r&#39;&#39;,&#10;--                        p_bind_var2   &#61;&gt; PKG_LstUtl.list_num_elem(p_list&#61;&gt;:p_elem, p_delim&#61;&gt;&#39;&#39; &#39;&#39;, p_num&#61;&gt;1) )&#10;--                END&#39;&#10;--        );&#10;EXCEPTION WHEN OTHERS THEN&#10;    do_flush_TAB_cache;&#10;    RAISE;&#10;END get_parsed_tab_list;&#10;--&#10;FUNCTION funcgetTabRecord_CACHED_1(&#10;    p_table       VARCHAR2,&#10;    p_ref_col     VARCHAR2,&#10;    p_ref_val     VARCHAR2,&#10;    p_data_fld    VARCHAR2,&#10;    p_default_val VARCHAR2 DEFAULT NULL,&#10;    p_where       VARCHAR2 DEFAULT NULL,&#10;    p_order_by    VARCHAR2 DEFAULT NULL,&#10;    p_bind_var1   VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING, p_bind_var2 VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING, p_bind_var3 VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING,  p_bind_var4 VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING, p_bind_var5  VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING,&#10;    p_bind_var6   VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING, p_bind_var7 VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING, p_bind_var8 VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING,  p_bind_var9 VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING, p_bind_var10 VARCHAR2 DEFAULT GC_LUP_BIND_VAR_MISSING,&#10;    p_all_records VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_delim       VARCHAR2 DEFAULT CHR(10),&#10;    p_max_len     INTEGER  DEFAULT 4000,&#10;    p_cache_key   VARCHAR2 DEFAULT NULL)&#10;RETURN VARCHAR2 /*RESULT_CACHE*/&#10;IS&#10;    --&#10;    l_key               VARCHAR2(4001);&#10;    l_key_max_size      INTEGER :&#61; 4000;&#10;    l_ret               VARCHAR2(4000);&#10;    l_cache_mode_flag   BOOLEAN;&#10;    l_entry_cached_flag BOOLEAN;&#10;    --&#10;    l_current_SCN       NUMBER;&#10;    --&#10;BEGIN&#10;    l_key :&#61;&#10;        NVLSTR(p_cache_key,&#10;            SUBSTR(&#10;                get_parsed_tab_list(p_table) || &#39;|&#39; ||&#10;                p_ref_col     || &#39;|&#39; ||&#10;                p_ref_val     || &#39;|&#39; ||&#10;                p_data_fld    || &#39;|&#39; ||&#10;                p_default_val || &#39;|&#39; ||&#10;                p_where       || &#39;|&#39; ||&#10;                p_order_by    || &#39;|&#39; ||&#10;                get_bind_var(p_bind_var1) ||&#10;                get_bind_var(p_bind_var2) ||&#10;                get_bind_var(p_bind_var3) ||&#10;                get_bind_var(p_bind_var4) ||&#10;                get_bind_var(p_bind_var5) ||&#10;                get_bind_var(p_bind_var6) ||&#10;                get_bind_var(p_bind_var7) ||&#10;                get_bind_var(p_bind_var8) ||&#10;                get_bind_var(p_bind_var9) ||&#10;                get_bind_var(p_bind_var10) ||&#10;                p_all_records || &#39;|&#39; ||&#10;                p_delim       || &#39;|&#39; ||&#10;                p_max_len,&#10;                1, l_key_max_size + 1)&#10;        );&#10;    --&#10;    l_cache_mode_flag :&#61; (LENGTH(l_key) &lt;&#61; l_key_max_size);&#10;    l_entry_cached_flag :&#61; FALSE;&#10;    --&#10;    IF l_cache_mode_flag THEN&#10;        -- Flush the PLSQL cache when global SCN number has changed&#10;        l_current_SCN :&#61; PKG_VpdSupport.get_current_scn_number;&#10;        IF NVL(g_current_SCN, -1) &lt;&gt; NVL(l_current_SCN, -2) OR get_plsqlcache_rebuild_flag &#61; &#39;Y&#39; THEN&#10;            do_flush_tab_cache;&#10;            g_current_SCN :&#61; l_current_SCN;&#10;        END IF;&#10;        --&#10;        IF g_cache_TAB.EXISTS(l_key) THEN&#10;            l_ret :&#61; g_cache_TAB(l_key);&#10;            l_entry_cached_flag :&#61; TRUE;&#10;        END IF;&#10;    END IF;&#10;    --&#10;    IF NOT l_entry_cached_flag THEN&#10;        l_ret :&#61; funcgetTabRecord(&#10;                     p_table       &#61;&gt; p_table,&#10;                     p_ref_col     &#61;&gt; p_ref_col,&#10;                     p_ref_val     &#61;&gt; p_ref_val,&#10;                     p_data_fld    &#61;&gt; p_data_fld,&#10;                     p_default_val &#61;&gt; p_default_val,&#10;                     p_where       &#61;&gt; p_where,&#10;                     p_order_by    &#61;&gt; p_order_by,&#10;                     p_bind_var1   &#61;&gt; p_bind_var1, p_bind_var2 &#61;&gt; p_bind_var2, p_bind_var3 &#61;&gt; p_bind_var3, p_bind_var4 &#61;&gt; p_bind_var4, p_bind_var5 &#61;&gt; p_bind_var5,&#10;                     p_bind_var6   &#61;&gt; p_bind_var6, p_bind_var7 &#61;&gt; p_bind_var7, p_bind_var8 &#61;&gt; p_bind_var8, p_bind_var9 &#61;&gt; p_bind_var9, p_bind_var10 &#61;&gt; p_bind_var10,&#10;                     p_all_records &#61;&gt; p_all_records,&#10;                     p_delim       &#61;&gt; p_delim,&#10;                     p_max_len     &#61;&gt; p_max_len);&#10;        IF l_cache_mode_flag THEN&#10;            IF g_cache_TAB.COUNT &gt; g_cache_max_size THEN&#10;                do_flush_TAB_cache;&#10;            END IF;&#10;            g_cache_TAB(l_key) :&#61; l_ret;&#10;            l_entry_cached_flag :&#61; TRUE;&#10;        END IF;&#10;        --&#10;        g_cache_miss_cnt :&#61; g_cache_miss_cnt + 1;&#10;        --&#10;    END IF;&#10;    --&#10;    RETURN l_ret;&#10;END funcgetTabRecord_CACHED_1;&#10;--&#10;--&#10;FUNCTION funcgetStdRefListID(p_code_set VARCHAR2, p_code VARCHAR2) RETURN NUMBER&#10;IS&#10;BEGIN&#10;    RETURN&#10;        funcgetTabRecord_CACHED(&#10;            p_table &#61;&gt; &#39;r_standard_reference_list R, r_reference_data_master M&#39;,&#10;            p_data_fld &#61;&gt; &#39;STANDARD_REFERENCE_LIST_ID&#39;,&#10;            p_ref_col &#61;&gt; &#39;code_value&#39;,&#10;            p_ref_val &#61;&gt; p_code,&#10;            p_where &#61;&gt; &#39;M.reference_data_master_id &#61; R.reference_data_master_id AND M.code_set_name &#61; :p_code_set&#39;,&#10;            p_bind_var1 &#61;&gt; p_code_set);&#10;END funcgetStdRefListID;&#10;--&#10;FUNCTION funcgetStdRefListCodeDesc(p_ID NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN&#10;        funcgetTabRecord_CACHED(&#10;            p_table &#61;&gt; &#39;r_standard_reference_list&#39;,&#10;            p_data_fld &#61;&gt; &#39;CODE_DESCRIPTION&#39;,&#10;            p_ref_col &#61;&gt; &#39;STANDARD_REFERENCE_LIST_ID&#39;,&#10;            p_ref_val &#61;&gt; TO_CHAR(p_ID) );&#10;END funcgetStdRefListCodeDesc;&#10;--&#10;FUNCTION funcgetStdRefListCodeDesc(p_code_set VARCHAR2, p_ID NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN&#10;        funcgetTabRecord_CACHED(&#10;            p_table &#61;&gt; &#39;r_standard_reference_list R, r_reference_data_master M&#39;,&#10;            p_data_fld &#61;&gt; &#39;CODE_DESCRIPTION&#39;,&#10;            p_ref_col &#61;&gt; &#39;STANDARD_REFERENCE_LIST_ID&#39;,&#10;            p_ref_val &#61;&gt; TO_CHAR(p_ID),&#10;            p_where &#61;&gt; &#39;M.reference_data_master_id &#61; R.reference_data_master_id AND M.code_set_name &#61; :p_code_set&#39;,&#10;            p_bind_var1 &#61;&gt; p_code_set);&#10;END funcgetStdRefListCodeDesc;&#10;--&#10;FUNCTION funcgetStdRefListCodeAndDesc(p_ID NUMBER, p_delim VARCHAR2 DEFAULT &#39;,&#39;) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN&#10;        funcgetTabRecord_CACHED(&#10;            p_table    &#61;&gt; &#39;r_standard_reference_list&#39;,&#10;            p_data_fld &#61;&gt; &#39;CODE_VALUE || &#39;&#39;&#39; || p_delim || &#39;&#39;&#39; || CODE_DESCRIPTION&#39;,&#10;            p_ref_col &#61;&gt; &#39;STANDARD_REFERENCE_LIST_ID&#39;,&#10;            p_ref_val &#61;&gt; TO_CHAR(p_ID) );&#10;END funcgetStdRefListCodeAndDesc;&#10;--&#10;PROCEDURE procAddStdRefList(p_domain VARCHAR2, p_code_value VARCHAR2, p_code_desc VARCHAR2, p_selectable VARCHAR2 DEFAULT &#39;Y&#39;)&#10;IS&#10;    --&#10;    LC_USER_ID    NUMBER :&#61; PKG_LOOKUPS.GetUserID(p_distinguished_name &#61;&gt; PKG_Common.NVLSTR(SYS_CONTEXT(&#39;USERENV&#39;, &#39;CLIENT_IDENTIFIER&#39;), &#39;[Data Maintenance]&#39;));&#10;    LC_DATE_TIME  DATE   :&#61; SYSDATE;&#10;    --&#10;BEGIN&#10;    INSERT INTO r_standard_reference_list(&#10;      standard_reference_list_id,&#10;      code_value, code_description,&#10;      selectable,&#10;      created_by_user_id,&#10;      created_datetime,&#10;      last_updated_user_id,&#10;      last_updated_datetime,&#10;      reference_data_master_id,&#10;      row_version,&#10;      spg_interest,&#10;      spg_override )&#10;    SELECT&#10;      STANDARD_REFERENCE_LIST_ID_SEQ.NEXTVAL,&#10;      p_code_value,&#10;      p_code_desc,&#10;      &#39;N&#39;,&#10;      LC_USER_ID,&#10;      LC_DATE_TIME,&#10;      LC_USER_ID,&#10;      LC_DATE_TIME,&#10;      ( SELECT reference_data_master_id FROM r_reference_data_master WHERE code_set_name &#61; p_domain ),&#10;      0,&#10;      1,&#10;      0&#10;    FROM dual&#10;    WHERE 1&#61;1&#10;      AND NOT EXISTS (&#10;          SELECT 1 FROM r_standard_reference_list&#10;          WHERE code_value &#61; p_code_value&#10;          AND reference_data_master_id &#61; ( SELECT reference_data_master_id FROM r_reference_data_master WHERE code_set_name &#61; p_domain ) );&#10;    --&#10;    --IF SQL%ROWCOUNT &gt; 0 THEN&#10;    --    message(&#39;new Std REF Data record has been created: [&#39; || p_domain || &#39;][&#39; || p_code_value || &#39;][&#39; || p_code_desc || &#39;]&#39;);&#10;    --END IF;&#10;END procAddStdRefList;&#10;--&#10;-- Specific to OBJECT_TYPE_DOCUMENT_TEMPLATE Linked List&#10;--&#10;FUNCTION funcgetDTObjLinkageRecord(&#10;    p_obj_type VARCHAR2,&#10;    p_ref_val  VARCHAR2,&#10;    p_data_fld VARCHAR2 )&#10;RETURN VARCHAR2&#10;IS&#10;    --&#10;    l_obj_type      VARCHAR2(30) :&#61; TRIM(UPPER(p_obj_type));&#10;    l_data_fld      VARCHAR2(30) :&#61; TRIM(UPPER(p_data_fld));&#10;    --&#10;    l_table_name    VARCHAR2(1024);&#10;    l_ctx_desc      VARCHAR2(30);&#10;    l_stdref_domain VARCHAR2(30);&#10;    l_static_id     INTEGER :&#61; -1;&#10;    --&#10;    l_lup_table         VARCHAR2(1024);&#10;    l_lup_ref_col       VARCHAR2(30);&#10;    l_lup_data_fld      VARCHAR2(30);&#10;    --&#10;    l_ret VARCHAR2(4000);&#10;    --&#10;    PROCEDURE do_init IS&#10;    BEGIN&#10;        --&#10;        IF l_obj_type &#61; &#39;R_APPROVED_PREMISES&#39; THEN&#10;            l_ctx_desc :&#61; &#39;AP Referral&#39;;&#10;            l_table_name :&#61; &#39;R_APPROVED_PREMISES&#39;;&#10;        ELSIF l_obj_type &#61; &#39;REFERRAL&#39; THEN&#10;            l_ctx_desc :&#61; &#39;Referral&#39;;&#10;            l_table_name :&#61; &#39;R_REFERRAL_TYPE&#39;;&#10;        ELSIF l_obj_type &#61; &#39;R_CONTACT_TYPE&#39; THEN&#10;            l_ctx_desc :&#61; &#39;Contact&#39;;&#10;            l_table_name :&#61; &#39;R_CONTACT_TYPE&#39;;&#10;        ELSIF l_obj_type &#61; &#39;R_COURT_REPORT_TYPE&#39; THEN&#10;            l_ctx_desc :&#61; &#39;Court Report&#39;;&#10;            l_table_name :&#61; &#39;R_COURT_REPORT_TYPE&#39;;&#10;        ELSIF l_obj_type &#61; &#39;INSTITUTIONAL_REPORT&#39; THEN&#10;            l_ctx_desc :&#61; &#39;Institutional Report&#39;;&#10;            l_table_name :&#61; &#39;STDREF&#39;;&#10;            l_stdref_domain :&#61; &#39;IREPORTTYPE&#39;;&#10;        ELSIF l_obj_type &#61; &#39;OFFENDER&#39; THEN&#10;            l_ctx_desc :&#61; &#39;Person&#39;;&#10;            l_static_id :&#61; 11;&#10;        ELSIF l_obj_type &#61; &#39;EVENT&#39; THEN&#10;            l_ctx_desc :&#61; &#39;Event&#39;;&#10;            l_static_id :&#61; 10;&#10;        ELSIF l_obj_type &#61; &#39;ADDRESS_ASSESSMENT&#39; THEN&#10;            l_ctx_desc :&#61; &#39;Address Assessment&#39;;&#10;            l_static_id :&#61; 9;&#10;        ELSIF l_obj_type &#61; &#39;PERSONAL_CONTACT&#39; THEN&#10;            l_ctx_desc :&#61; &#39;Personal Contact&#39;;&#10;            l_static_id :&#61; 12;&#10;        ELSIF l_obj_type &#61; &#39;ASSESSMENT&#39; THEN&#10;            l_ctx_desc :&#61; &#39;Generic Assessment&#39;;&#10;            l_table_name :&#61; &#39;R_ASSESSMENT_TYPE&#39;;&#10;        ELSIF l_obj_type &#61; &#39;NSI&#39; THEN&#10;            l_ctx_desc :&#61; &#39;Non Statutory Intervention&#39;;&#10;            l_table_name :&#61; &#39;R_NSI_TYPE&#39;;&#10;        ELSIF l_obj_type &#61; &#39;CASE_ALLOCATION&#39; THEN&#10;            l_ctx_desc :&#61; &#39;Case Allocation&#39;;&#10;            l_static_id :&#61; 14;&#10;        ELSIF l_obj_type &#61; &#39;PERSONAL_CIRCUMSTANCE&#39; THEN&#10;            l_ctx_desc :&#61; &#39;Personal Circumstances&#39;;&#10;            l_static_id :&#61; 15;&#10;        ELSIF l_obj_type &#61; &#39;UPW_APPOINTMENT&#39; THEN&#10;            l_ctx_desc :&#61; &#39;Unpaid Work Appointments&#39;;&#10;            l_static_id :&#61; 16;&#10;        ELSIF l_obj_type &#61; &#39;EQUALITY&#39; THEN&#10;            l_ctx_desc :&#61; &#39;Equalities&#39;;&#10;            l_static_id :&#61; 17;&#10;        ELSIF l_obj_type &#61; &#39;DRUGS_TEST&#39; THEN&#10;            l_ctx_desc :&#61; &#39;Drug Test&#39;;&#10;            l_static_id :&#61; 18;&#10;        ELSIF l_obj_type &#61; &#39;OFFENDER_ADDRESS&#39; THEN&#10;            l_ctx_desc :&#61; &#39;Address&#39;;&#10;            l_static_id :&#61; 19;&#10;        ELSIF l_obj_type &#61; &#39;R_REFERRAL_TYPE&#39; THEN&#10;            l_ctx_desc :&#61; &#39;Referral Type&#39;;&#10;            l_table_name :&#61; &#39;R_REFERRAL_TYPE&#39;;&#10;        ELSIF l_obj_type &#61; &#39;REGISTRATION&#39; THEN&#10;            l_ctx_desc :&#61; &#39;Register&#39;;&#10;            l_table_name :&#61; &#39;R_REGISTER_TYPE&#39;;&#10;        END IF;&#10;        --&#10;    END do_init;&#10;    --&#10;    PROCEDURE do_set_static_obj IS&#10;    BEGIN&#10;        --&#10;        IF l_data_fld &#61; &#39;ID&#39; THEN&#10;            l_ret :&#61; l_static_id;&#10;        ELSIF l_data_fld &#61; &#39;CODE&#39; THEN&#10;            l_ret :&#61; l_obj_type;&#10;        ELSE&#10;            l_ret :&#61; l_ctx_desc;&#10;        END IF;&#10;    END do_set_static_obj;&#10;    --&#10;    PROCEDURE do_set_stdref_obj IS&#10;    BEGIN&#10;        --&#10;        IF l_data_fld &#61; &#39;ID&#39; THEN&#10;            l_ret :&#61; funcgetStdRefListID(l_stdref_domain, p_ref_val);&#10;        ELSIF l_data_fld &#61; &#39;CODE&#39; THEN&#10;            l_ret :&#61;&#10;                funcgetTabRecord_CACHED(&#10;                    p_table &#61;&gt; &#39;r_standard_reference_list&#39;,&#10;                    p_data_fld &#61;&gt; &#39;CODE_VALUE&#39;,&#10;                    p_ref_col &#61;&gt; &#39;STANDARD_REFERENCE_LIST_ID&#39;,&#10;                    p_ref_val &#61;&gt; p_ref_val );&#10;        ELSE&#10;            l_ret :&#61; funcgetStdRefListCodeDesc(l_stdref_domain, p_ref_val);&#10;        END IF;&#10;        --&#10;    END do_set_stdref_obj;&#10;    --&#10;    PROCEDURE do_set_nonstdref_obj IS&#10;    BEGIN&#10;        --&#10;        IF l_table_name &#61; &#39;R_APPROVED_PREMISES&#39; THEN&#10;            --&#10;            l_lup_table :&#61;&#10;                &#39;( SELECT&#10;                     AP.approved_premises_id,&#10;                     S.code_value AS national_hostel_code,&#10;                     AP.description&#10;                   FROM&#10;                     r_approved_premises AP&#10;                       INNER JOIN r_standard_reference_list S ON S.standard_reference_list_id &#61; AP.national_hostel_code&#10;                         INNER JOIN r_reference_data_master M ON S.reference_data_master_id &#61; M.reference_data_master_id&#10;                   WHERE M.code_set_name &#61; &#39;&#39;HOSTEL CODE&#39;&#39; ) R_APPROVED_PREMISES_V&#39;;&#10;            --&#10;            IF l_data_fld &#61; &#39;ID&#39; THEN&#10;                l_lup_data_fld :&#61; &#39;approved_premises_id&#39;;&#10;                l_lup_ref_col :&#61; &#39;national_hostel_code&#39;;&#10;            ELSIF l_data_fld &#61; &#39;CODE&#39; THEN&#10;                l_lup_data_fld :&#61; &#39;national_hostel_code&#39;;&#10;                l_lup_ref_col :&#61; &#39;approved_premises_id&#39;;&#10;            ELSE&#10;                l_lup_data_fld :&#61; &#39;description&#39;;&#10;                l_lup_ref_col :&#61; &#39;approved_premises_id&#39;;&#10;            END IF;&#10;            --&#10;        ELSE&#10;            --&#10;            l_lup_table :&#61; l_table_name;&#10;            --&#10;            IF l_data_fld &#61; &#39;ID&#39; THEN&#10;                l_lup_data_fld :&#61; LOWER(SUBSTR(l_lup_table, 3)) || &#39;_id&#39;;&#10;                l_lup_ref_col :&#61; &#39;code&#39;;&#10;            ELSIF l_data_fld &#61; &#39;CODE&#39; THEN&#10;                l_lup_data_fld :&#61; &#39;code&#39;;&#10;                l_lup_ref_col :&#61; LOWER(SUBSTR(l_lup_table, 3)) || &#39;_id&#39;;&#10;            ELSE&#10;                l_lup_data_fld :&#61; &#39;description&#39;;&#10;                l_lup_ref_col :&#61; LOWER(SUBSTR(l_lup_table, 3)) || &#39;_id&#39;;&#10;            END IF;&#10;            --&#10;        END IF;&#10;        --&#10;        IF l_lup_table IS NULL THEN&#10;            raise_application_error( -20001,&#10;                &#39;ERROR in PKG_Lookup.funcgetDTObjLinkageRecord(&#39; || p_obj_type || &#39;, &#39; || p_ref_val || &#39;, &#39; || p_data_fld || &#39;)&#39; || CHR(10) ||&#10;                &#39;[ctx&#61;&#39;       || l_ctx_desc  || &#39;]&#39; ||&#10;                &#39;[static_id&#61;&#39; || l_static_id || &#39;]&#39; );&#10;        END IF;&#10;        --&#10;        l_ret :&#61;&#10;            funcgetTabRecord_CACHED(&#10;                p_table    &#61;&gt; l_lup_table,&#10;                p_data_fld &#61;&gt; l_lup_data_fld,&#10;                p_ref_col  &#61;&gt; l_lup_ref_col,&#10;                p_ref_val  &#61;&gt; p_ref_val );&#10;        --&#10;    END do_set_nonstdref_obj;&#10;    --&#10;BEGIN&#10;    --&#10;    do_init;&#10;    --&#10;    IF l_static_id &gt; 0 THEN&#10;        do_set_static_obj;&#10;    ELSIF l_table_name &#61; &#39;STDREF&#39; THEN&#10;        do_set_stdref_obj;&#10;    ELSE&#10;        do_set_nonstdref_obj;&#10;    END IF;&#10;    --&#10;    RETURN l_ret;&#10;    --&#10;END funcgetDTObjLinkageRecord;&#10;--&#10;--&#10;--&#10;FUNCTION funcgetNDParameterValue(p_par_name VARCHAR2, p_default_value NUMBER DEFAULT NULL) RETURN NUMBER&#10;IS&#10;BEGIN&#10;    RETURN&#10;        TO_NUMBER(&#10;            funcgetTabRecord_CACHED(&#10;                p_table       &#61;&gt; &#39;nd_parameter&#39;,&#10;                p_data_fld    &#61;&gt; &#39;TO_CHAR(nd_value)&#39;,&#10;                p_default_val &#61;&gt; TO_CHAR(p_default_value),&#10;                p_ref_col     &#61;&gt; &#39;nd_parameter&#39;,&#10;                p_ref_val     &#61;&gt; p_par_name ) );&#10;END funcgetNDParameterValue;&#10;--&#10;FUNCTION funcgetGenderCode(p_gender_id NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;r_standard_reference_list&#39;,&#10;            p_data_fld &#61;&gt; &#39;CODE_VALUE&#39;,&#10;            p_ref_col &#61;&gt; &#39;STANDARD_REFERENCE_LIST_ID&#39;,&#10;            p_ref_val &#61;&gt; TO_CHAR(p_gender_id) );&#10;END funcgetGenderCode;&#10;&#10;FUNCTION funcgetTierDescription(p_tier_id NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;r_standard_reference_list&#39;,&#10;            p_data_fld &#61;&gt; &#39;CODE_DESCRIPTION&#39;,&#10;            p_ref_col &#61;&gt; &#39;STANDARD_REFERENCE_LIST_ID&#39;,&#10;            p_ref_val &#61;&gt; TO_CHAR(p_tier_id) );&#10;END funcgetTierDescription;&#10;&#10;FUNCTION funcgetTeamDescription(p_trust_provider_flag NUMBER, p_trust_provider_team_id NUMBER) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN&#10;        CASE&#10;            WHEN p_trust_provider_flag &#61; 0 THEN&#10;                funcgetTabRecord_CACHED(&#10;                    p_table     &#61;&gt; &#39;team T&#39;,&#10;                    p_data_fld  &#61;&gt; &#39;DESCRIPTION&#39;,&#10;                    p_ref_col   &#61;&gt; &#39;team_id&#39;,&#10;                    p_ref_val   &#61;&gt; TO_CHAR(p_trust_provider_team_id) )&#10;            WHEN p_trust_provider_flag &#61; 1 THEN&#10;                funcgetTabRecord_CACHED(&#10;                    p_table     &#61;&gt; &#39;provider_team&#39;,&#10;                    p_data_fld  &#61;&gt; &#39;NAME&#39;,&#10;                    p_ref_col   &#61;&gt; &#39;external_provider_id&#39;,&#10;                    p_ref_val   &#61;&gt; TO_CHAR(p_trust_provider_team_id) )&#10;            ELSE&#10;                &#39;UNKNOWN_TEAM[&#39; || p_trust_provider_flag || &#39;][&#39; || p_trust_provider_team_id || &#39;]&#39;&#10;        END;&#10;END funcgetTeamDescription;&#10;--&#10;FUNCTION funcgetTeamProvider(p_trust_provider_flag NUMBER, p_trust_provider_team_id NUMBER) RETURN NUMBER IS&#10;BEGIN&#10;    RETURN&#10;        CASE&#10;            WHEN p_trust_provider_flag &#61; 0 THEN&#10;                funcgetTabRecord_CACHED(&#10;                    p_table     &#61;&gt; &#39;team T&#39;,&#10;                    p_data_fld  &#61;&gt; &#39;PROBATION_AREA_ID&#39;,&#10;                    p_ref_col   &#61;&gt; &#39;team_id&#39;,&#10;                    p_ref_val   &#61;&gt; TO_CHAR(p_trust_provider_team_id))&#10;            WHEN p_trust_provider_flag &#61; 1 THEN&#10;                funcgetTabRecord_CACHED(&#10;                    p_table     &#61;&gt; &#39;provider_team&#39;,&#10;                    p_data_fld  &#61;&gt; &#39;PROBATION_AREA_ID&#39;,&#10;                    p_ref_col   &#61;&gt; &#39;external_provider_id&#39;,&#10;                    p_ref_val   &#61;&gt; TO_CHAR(p_trust_provider_team_id))&#10;            ELSE&#10;                -1&#10;        END;&#10;END funcgetTeamProvider;&#10;--&#10;FUNCTION funcgetStaffDescription(p_trust_provider_flag NUMBER, p_staff_employee_id NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN&#10;        funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;OFFICER&#39;,&#10;                    p_data_fld   &#61;&gt; &#39;surname || DECODE(forename, NULL, NULL, &#39;&#39;, &#39;&#39; || forename) || DECODE(forename2, NULL, NULL, &#39;&#39;, &#39;&#39; || forename2)&#39;,&#10;                    p_ref_col   &#61;&gt; &#39;staff_employee_id&#39;,&#10;                    p_ref_val   &#61;&gt; TO_CHAR(p_staff_employee_id),&#10;                    p_where     &#61;&gt; &#39;trust_provider_flag &#61; :p_flag&#39;,&#10;                    p_bind_var1 &#61;&gt; TO_CHAR(p_trust_provider_flag));&#10;END funcgetStaffDescription;&#10;&#10;FUNCTION funcgetDisposalTypeDescription(p_disposal_type_id NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;r_disposal_type&#39;,&#10;            p_data_fld   &#61;&gt; &#39;DESCRIPTION&#39;,&#10;            p_ref_col   &#61;&gt; &#39;disposal_type_id&#39;,&#10;            p_ref_val   &#61;&gt; TO_CHAR(p_disposal_type_id));&#10;END funcgetDisposalTypeDescription;&#10;&#10;FUNCTION funcgetDisposalTypeUnits(p_disposal_type_id NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;r_disposal_type DT, r_standard_reference_list RDT&#39;,&#10;            p_data_fld &#61;&gt; &#39;RDT.CODE_DESCRIPTION&#39;,&#10;            p_ref_col  &#61;&gt; &#39;DT.disposal_type_id&#39;,&#10;            p_ref_val  &#61;&gt; TO_CHAR(p_disposal_type_id),&#10;            p_where    &#61;&gt; &#39;RDT.standard_reference_list_id &#61; DT.units_id&#39;);&#10;END funcgetDisposalTypeUnits;&#10;&#10;FUNCTION funcgetDisposalTypePreCJA2003(p_disposal_type_id NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;r_disposal_type&#39;,&#10;            p_data_fld &#61;&gt; &#39;pre_cja2003&#39;, p_default_val &#61;&gt; &#39;N&#39;,&#10;            p_ref_col  &#61;&gt; &#39;disposal_type_id&#39;,&#10;            p_ref_val  &#61;&gt; TO_CHAR(p_disposal_type_id));&#10;END funcgetDisposalTypePreCJA2003;&#10;&#10;FUNCTION funcgetDisposalTypeCJA2003(p_disposal_type_id NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;r_disposal_type&#39;,&#10;            p_data_fld &#61;&gt; &#39;cja2003&#39;, p_default_val &#61;&gt; &#39;N&#39;,&#10;            p_ref_col  &#61;&gt; &#39;disposal_type_id&#39;,&#10;            p_ref_val  &#61;&gt; TO_CHAR(p_disposal_type_id));&#10;END funcgetDisposalTypeCJA2003;&#10;&#10;FUNCTION funcgetLicCondTypeDescription(p_lic_cond_type_main_cat_id NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;r_lic_cond_type_main_cat&#39;,&#10;            p_data_fld &#61;&gt; &#39;DESCRIPTION&#39;,&#10;            p_ref_col  &#61;&gt; &#39;lic_cond_type_main_cat_id&#39;,&#10;            p_ref_val  &#61;&gt; TO_CHAR(p_lic_cond_type_main_cat_id));&#10;END funcgetLicCondTypeDescription;&#10;&#10;FUNCTION funcgetLicCondTypeUnits(p_lic_cond_type_main_cat_id NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;r_lic_cond_type_main_cat CAT, r_standard_reference_list RCATU&#39;,&#10;            p_data_fld &#61;&gt; &#39;RCATU.code_description&#39;,&#10;            p_ref_col  &#61;&gt; &#39;CAT.lic_cond_type_main_cat_id&#39;,&#10;            p_ref_val  &#61;&gt; TO_CHAR(p_lic_cond_type_main_cat_id),&#10;            p_where    &#61;&gt; &#39;RCATU.standard_reference_list_id &#61; CAT.units_id&#39;);&#10;END funcgetLicCondTypeUnits;&#10;--&#10;FUNCTION funcgetRqmntTypeID(p_code VARCHAR2) RETURN NUMBER&#10;IS&#10;BEGIN&#10;    RETURN funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;r_rqmnt_type_main_category&#39;,&#10;            p_data_fld &#61;&gt; &#39;rqmnt_type_main_category_id&#39;,&#10;            p_ref_col  &#61;&gt; &#39;code&#39;,&#10;            p_ref_val  &#61;&gt; p_code);&#10;END funcgetRqmntTypeID;&#10;--&#10;FUNCTION funcgetRqmntTypeDescription(p_rqmnt_type_main_cat_id NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;r_rqmnt_type_main_category&#39;,&#10;            p_data_fld &#61;&gt; &#39;DESCRIPTION&#39;,&#10;            p_ref_col  &#61;&gt; &#39;rqmnt_type_main_category_id&#39;,&#10;            p_ref_val  &#61;&gt; TO_CHAR(p_rqmnt_type_main_cat_id));&#10;END funcgetRqmntTypeDescription;&#10;&#10;FUNCTION funcgetRqmntTypeUnits(p_rqmnt_type_main_cat_id NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;r_rqmnt_type_main_category CAT, r_standard_reference_list RCATU&#39;,&#10;            p_data_fld &#61;&gt; &#39;RCATU.code_description&#39;,&#10;            p_ref_col  &#61;&gt; &#39;CAT.rqmnt_type_main_category_id&#39;,&#10;            p_ref_val  &#61;&gt; TO_CHAR(p_rqmnt_type_main_cat_id),&#10;            p_where    &#61;&gt; &#39;RCATU.standard_reference_list_id &#61; CAT.units_id&#39;);&#10;END funcgetRqmntTypeUnits;&#10;--&#10;FUNCTION funcgetADRqmntTypeDescription(p_ad_rqmnt_type_main_cat_id NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;r_ad_rqmnt_type_main_category&#39;,&#10;            p_data_fld &#61;&gt; &#39;DESCRIPTION&#39;,&#10;            p_ref_col  &#61;&gt; &#39;ad_rqmnt_type_main_category_id&#39;,&#10;            p_ref_val  &#61;&gt; TO_CHAR(p_ad_rqmnt_type_main_cat_id));&#10;END funcgetADRqmntTypeDescription;&#10;--&#10;FUNCTION funcgetADRqmntTypeUnits(p_ad_rqmnt_type_main_cat_id NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;r_ad_rqmnt_type_main_category CAT, r_standard_reference_list RCATU&#39;,&#10;            p_data_fld &#61;&gt; &#39;RCATU.code_description&#39;,&#10;            p_ref_col  &#61;&gt; &#39;CAT.ad_rqmnt_type_main_category_id&#39;,&#10;            p_ref_val  &#61;&gt; TO_CHAR(p_ad_rqmnt_type_main_cat_id),&#10;            p_where    &#61;&gt; &#39;RCATU.standard_reference_list_id &#61; CAT.units_id&#39;);&#10;END funcgetADRqmntTypeUnits;&#10;--&#10;FUNCTION funcgetPSSRqmntTypeID(p_code VARCHAR2) RETURN NUMBER&#10;IS&#10;BEGIN&#10;    RETURN funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;r_pss_rqmnt_type_main_category&#39;,&#10;            p_data_fld &#61;&gt; &#39;pss_rqmnt_type_main_cat_id&#39;,&#10;            p_ref_col  &#61;&gt; &#39;code&#39;,&#10;            p_ref_val  &#61;&gt; p_code);&#10;END funcgetPSSRqmntTypeID;&#10;--&#10;FUNCTION funcgetPSSRqmntTypeDescription(p_pss_rqmnt_type_main_cat_id NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;r_pss_rqmnt_type_main_category&#39;,&#10;            p_data_fld &#61;&gt; &#39;DESCRIPTION&#39;,&#10;            p_ref_col  &#61;&gt; &#39;pss_rqmnt_type_main_cat_id&#39;,&#10;            p_ref_val  &#61;&gt; TO_CHAR(p_pss_rqmnt_type_main_cat_id));&#10;END funcgetPSSRqmntTypeDescription;&#10;&#10;FUNCTION funcgetPSSRqmntTypeUnits(p_pss_rqmnt_type_main_cat_id NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;r_pss_rqmnt_type_main_category CAT, r_standard_reference_list RCATU&#39;,&#10;            p_data_fld &#61;&gt; &#39;RCATU.code_description&#39;,&#10;            p_ref_col  &#61;&gt; &#39;CAT.pss_rqmnt_type_main_cat_id&#39;,&#10;            p_ref_val  &#61;&gt; TO_CHAR(p_pss_rqmnt_type_main_cat_id),&#10;            p_where    &#61;&gt; &#39;RCATU.standard_reference_list_id &#61; CAT.units_id&#39;);&#10;END funcgetPSSRqmntTypeUnits;&#10;--&#10;FUNCTION funcgetStaffTeamLst(p_team_id NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;staff_team&#39;,&#10;               p_ref_col     &#61;&gt; &#39;team_id&#39;,&#10;               p_ref_val     &#61;&gt; TO_CHAR(p_team_id),&#10;               p_data_fld    &#61;&gt; &#39;staff_id&#39;,&#10;               p_where       &#61;&gt; &#39;staff_id IS NOT NULL&#39;,&#10;               p_all_records &#61;&gt; &#39;Y&#39;, p_delim &#61;&gt; &#39;,&#39;, p_max_len &#61;&gt; 30000 );&#10;END funcgetStaffTeamLst;&#10;--&#10;FUNCTION get_court_data(p_court_id NUMBER, p_data_fld VARCHAR2) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN funcgetTabRecord_CACHED(p_table&#61;&gt;&#39;COURT&#39;,&#10;               p_ref_col  &#61;&gt; &#39;COURT_ID&#39;,&#10;               p_ref_val  &#61;&gt; TO_CHAR(p_court_id),&#10;               p_data_fld &#61;&gt; p_data_fld);&#10;END get_court_data;&#10;--&#10;FUNCTION funcGetContactTypeRecord(p_contact_type_id NUMBER, p_data_fld VARCHAR2) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;R_CONTACT_TYPE&#39;,&#10;               p_ref_col  &#61;&gt; &#39;CONTACT_TYPE_ID&#39;,&#10;               p_ref_val  &#61;&gt; TO_CHAR(p_contact_type_id),&#10;               p_data_fld &#61;&gt; p_data_fld);&#10;END funcGetContactTyperecord;&#10;--&#10;FUNCTION funcGetBusinessInteractionID(p_business_interaction_code IN VARCHAR2) RETURN NUMBER&#10;IS&#10;BEGIN&#10;    RETURN&#10;        funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;BUSINESS_INTERACTION&#39;,&#10;            p_ref_col  &#61;&gt; &#39;business_interaction_code&#39;,&#10;            p_ref_val  &#61;&gt; p_business_interaction_code,&#10;            p_data_fld &#61;&gt; &#39;business_interaction_id&#39; );&#10;END funcGetBusinessInteractionID;&#10;--&#10;FUNCTION funcGetBusinessInteraction(p_business_interaction_id IN NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN&#10;        funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;BUSINESS_INTERACTION&#39;,&#10;            p_ref_col  &#61;&gt; &#39;business_interaction_id&#39;,&#10;            p_ref_val  &#61;&gt; TO_CHAR(p_business_interaction_id),&#10;            p_data_fld &#61;&gt; &#39;business_interaction_code&#39; );&#10;END funcGetBusinessInteraction;&#10;--&#10;FUNCTION isReferenceDataBI(p_business_interaction_code IN BUSINESS_INTERACTION.business_interaction_code%TYPE) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;  RETURN&#10;    funcgetTabRecord_CACHED(&#10;        p_table     &#61;&gt; &#39;business_interaction&#39;,&#10;        p_ref_col   &#61;&gt; &#39;business_interaction_code&#39;,&#10;        p_ref_val   &#61;&gt; p_business_interaction_code,&#10;        p_where     &#61;&gt; &#39;(business_interaction_code LIKE &#39;&#39;R__CONFIG&#39;&#39; OR business_interaction_code LIKE &#39;&#39;REF__&#39;&#39; OR business_interaction_code LIKE &#39;&#39;LLBI___&#39;&#39;) &#39;,&#10;        p_data_fld  &#61;&gt; &#39;DECODE(MAX(business_interaction_id),NULL,&#39;&#39;FALSE&#39;&#39;,&#39;&#39;TRUE&#39;&#39;)&#39;);&#10;END isReferenceDataBI;&#10;--&#10;FUNCTION isReferenceDataBI(p_business_interaction_id IN BUSINESS_INTERACTION.business_interaction_id%TYPE) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;  RETURN&#10;    funcgetTabRecord_CACHED(&#10;        p_table     &#61;&gt; &#39;business_interaction&#39;,&#10;        p_ref_col   &#61;&gt; &#39;business_interaction_id&#39;,&#10;        p_ref_val   &#61;&gt; TO_CHAR(p_business_interaction_id),&#10;        p_where     &#61;&gt; &#39;(business_interaction_code LIKE &#39;&#39;R__CONFIG&#39;&#39; OR business_interaction_code LIKE &#39;&#39;REF__&#39;&#39; OR business_interaction_code LIKE &#39;&#39;LLBI___&#39;&#39;) &#39;,&#10;        p_data_fld  &#61;&gt; &#39;DECODE(MAX(business_interaction_id),NULL,&#39;&#39;FALSE&#39;&#39;,&#39;&#39;TRUE&#39;&#39;)&#39;);&#10;END isReferenceDataBI;&#10;--&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;-- Helper Pipelined functions that are used within the PKG_Search&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;&#10;-- Officer Diary Enforcemens Search: Event Details sub-component&#10;FUNCTION funcCheckContactEnforcement(p_contact_id NUMBER, p_contact_date DATE) RETURN VARCHAR2 IS&#10;BEGIN&#10;    IF NOT g_contact_enf_tab.EXISTS(p_contact_id) THEN&#10;        IF p_contact_date &lt; TRUNC(SYSDATE) + (1 - 1/24/60/60) THEN&#10;            g_contact_enf_tab(p_contact_id) :&#61; &#39;Y&#39;;&#10;        ELSE&#10;            BEGIN&#10;                SELECT &#39;Y&#39; INTO g_contact_enf_tab(p_contact_id)&#10;                FROM dual&#10;                WHERE EXISTS(&#10;                  SELECT 1&#10;                  FROM enforcement, r_enforcement_action EA&#10;                  WHERE ENFORCEMENT.contact_id &#61; p_contact_id&#10;                    AND EA.enforcement_action_id &#61; ENFORCEMENT.enforcement_action_id&#10;                    AND EA.outstanding_contact_action &#61; &#39;Y&#39; /*i.e. NO_FURTHER_ACTION&#61;N*/ );&#10;            EXCEPTION WHEN NO_DATA_FOUND THEN&#10;                g_contact_enf_tab(p_contact_id) :&#61; &#39;N&#39;;&#10;            END;&#10;        END IF;&#10;    END IF;&#10;    --&#10;    RETURN g_contact_enf_tab(p_contact_id);&#10;    --&#10;END funcCheckContactEnforcement;&#10;--&#10;FUNCTION get_ST_clause(&#10;    p_table                 VARCHAR2,&#10;    p_team_id               NUMBER,&#10;    p_staff_id              NUMBER,&#10;    p_provider_team_id      NUMBER,&#10;    p_provider_employee_id  NUMBER )&#10;RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN&#10;        REPLACE(&#10;        --&#10;        CASE WHEN p_team_id IS NOT NULL OR p_staff_id IS NOT NULL THEN&#10;           CASE WHEN p_team_id  IS NOT NULL THEN &#39;AND @T.trust_provider_flag &#61; 0 AND @T.trust_provider_team_id &#61; :p_team_id&#39; ELSE &#39;AND :p_team_id IS NULL&#39;  END || CHR(10) ||&#10;           CASE WHEN p_staff_id IS NOT NULL THEN &#39;AND @T.trust_provider_flag &#61; 0 AND @T.staff_employee_id &#61; :p_staff_id&#39;     ELSE &#39;AND :p_staff_id IS NULL&#39; END || CHR(10) ||&#10;           &#39;AND :p_provider_team_id IS NULL AND :p_provider_employee_id IS NULL&#39;&#10;        WHEN p_provider_team_id IS NOT NULL OR p_provider_employee_id IS NOT NULL THEN&#10;           &#39;AND :p_team_id IS NULL AND :p_staff_id IS NULL&#39; || CHR(10) ||&#10;           CASE WHEN p_provider_team_id IS NOT NULL OR p_provider_employee_id IS NOT NULL THEN&#10;               CASE WHEN p_provider_team_id     IS NOT NULL THEN &#39;AND @T.trust_provider_flag &#61; 1 AND @T.trust_provider_team_id &#61; :p_provider_team_id&#39; ELSE &#39; AND :p_provider_team_id IS NULL&#39;     END || CHR(10) ||&#10;               CASE WHEN p_provider_employee_id IS NOT NULL THEN &#39;AND @T.trust_provider_flag &#61; 1 AND @T.staff_employee_id &#61; :p_provider_employee_id&#39;  ELSE &#39; AND :p_provider_employee_id IS NULL&#39; END&#10;            END&#10;        ELSE&#10;           &#39;AND :p_team_id IS NULL AND :p_staff_id IS NULL AND :p_provider_team_id IS NULL AND :p_provider_employee_id IS NULL&#39;&#10;        END,&#10;        --&#10;        &#39;@T&#39;, p_table);&#10;END get_ST_clause;&#10;--&#10;FUNCTION procFindEnforcementEventsTAB(&#10;    p_date                 DATE,&#10;    p_team_id              NUMBER,&#10;    p_provider_team_id     NUMBER,&#10;    p_staff_id             NUMBER,&#10;    p_provider_employee_id NUMBER,&#10;    p_filter               INTEGER,&#10;    p_max_rows             INTEGER DEFAULT 100000)&#10;RETURN ttabOfficerDiaryEvent PIPELINED&#10;IS&#10;    --&#10;    TYPE l_cur_TYP IS REF CURSOR;&#10;    l_cur l_cur_TYP;&#10;    --&#10;    l_SQL VARCHAR2(10000);&#10;    --&#10;    l_tab ttabOfficerDiaryEvent;&#10;    --&#10;    l_i   INTEGER;&#10;    l_row INTEGER :&#61; 0;&#10;    --&#10;    l_buffer_gets_1 NUMBER;&#10;    l_buffer_gets_2 NUMBER;&#10;    --&#10;    l_scn_current NUMBER;&#10;    l_same_schema BOOLEAN;&#10;    --&#10;BEGIN&#10;    IF NOT (p_team_id IS NOT NULL OR p_staff_id IS NOT NULL OR p_provider_team_id IS NOT NULL OR p_provider_employee_id IS NOT NULL) THEN&#10;        raise_application_error(-20001, &#39;Error in procFindEnforcementEventsTAB: insufficient number of parameters specified&#39;);&#10;    END IF;&#10;    --&#10;    l_SQL :&#61;&#10;&#39;WITH&#10;--&#10;OFFENDER_M AS (&#10;  --&#10;  SELECT&#10;    OM.offender_id,&#10;    S1.staff_id,&#10;    S1.officer_code AS staff_code,&#10;    --PKG_LstUtl.concat(S1.surname, PKG_LstUtl.concat(S1.forename, S1.forename2, p_delim &#61;&gt; &#39;&#39; &#39;&#39;), p_delim &#61;&gt; &#39;&#39;, &#39;&#39;) AS staff_desc&#10;    RTRIM(S1.surname || &#39;&#39;, &#39;&#39; || S1.forename || &#39;&#39;, &#39;&#39; || S1.forename2, &#39;&#39;, &#39;&#39;) AS staff_desc&#10;  FROM&#10;    offender_manager OM&#10;      INNER JOIN officer S ON S.staff_employee_id &#61; OM.staff_employee_id AND S.trust_provider_flag &#61; OM.trust_provider_flag&#10;        LEFT OUTER JOIN staff S1 ON S1.staff_id &#61; S.staff_employee_id AND S.trust_provider_flag &#61; 0&#10;  WHERE OM.active_flag &#61; 1&#10;    -- ST clause&#10;    &#39; || get_st_clause(&#39;OM&#39;, p_team_id, p_staff_id, p_provider_team_id, p_provider_employee_id ) || &#39;&#10;  ),&#10;  --&#10;SELECTED_EV AS (&#10;  SELECT&#10;    E.offender_id,&#10;    E.event_id,&#10;    NVL(E.breach_end, TO_DATE(&#39;&#39;19000101&#39;&#39;, &#39;&#39;YYYYMMDD&#39;&#39;)) AS breach_end,&#10;    --&#10;    OM.staff_id,&#10;    OM.staff_code,&#10;    OM.staff_desc&#10;  FROM&#10;    OFFENDER_M OM&#10;      INNER JOIN event E ON E.offender_id &#61; OM.offender_id&#10;  WHERE E.active_flag &#61; 1 )&#10;--&#10;-- Main SQL&#10;--&#10;SELECT&#10;  C.offender_id,&#10;  C.event_id,&#10;  --&#10;  /*01*/ O.crn,&#10;  /*02*/ O.first_name,&#10;  /*03*/ O.second_name,&#10;  /*04*/ O.third_name,&#10;  /*05*/ O.surname,&#10;  /*06*/ O.current_highest_risk_colour,&#10;  /*07*/ O.current_restriction,&#10;  /*08*/ O.current_exclusion,&#10;  /*09*/ O.restriction_message,&#10;  /*10*/ O.exclusion_message,&#10;  --&#10;  /*11*/ C.contact_id,&#10;  /*12*/ C.contact_date,&#10;  /*13*/ C.contact_start_time,&#10;  /*14*/ C.contact_type_id,&#10;  /*15*/ CT.code                                AS contact_type_code,&#10;  /*16*/ CT.description                         AS contact_type_desc,&#10;  /*17*/ C.contact_outcome_type_id,&#10;  --&#10;  /*20*/ O.current_tier,&#10;  /*21*/ TO_CHAR(c.latest_enforcement_action_id) ea_desc,&#10;  /*22*/ CT.editable                             user_editable,&#10;  /*23*/ O.date_of_birth_date                    date_of_birth,&#10;  --&#10;  /*24*/ T.staff_id,&#10;  /*25*/ T.staff_code,&#10;  /*26*/ T.staff_desc&#10;  --&#10;FROM&#10;  SELECTED_EV T&#10;    INNER JOIN contact C ON C.event_id &#61; T.event_id&#10;      INNER JOIN r_contact_type CT ON CT.contact_type_id &#61; C.contact_type_id&#10;    INNER JOIN offender O ON O.offender_id &#61; T.offender_id&#10;WHERE 1&#61;1&#10;  --&#10;  -- Adding Enforceable CONTACT records&#10;  --&#10;  AND C.soft_deleted &#61; 0&#10;  AND C.contact_date &gt; TRUNC(T.breach_end)&#10;  AND C.contact_date &lt;&#61; TRUNC(:p_date) + (1 - 1/24/60/60)&#10;  AND CT.NATIONAL_STANDARDS_CONTACT &#61; &#39;&#39;Y&#39;&#39;&#10;  -- YF: PDM v0.43 uplift&#10;  AND C.enforcement &#61; 1&#10;  -- YF: funcCheckContactEnforcement call has to be here,&#10;  --     until C.contact_date is eliminated from the Enforcement Check equasion&#10;  AND PKG_Lookups.funcCheckContactEnforcement(C.contact_id, C.contact_date) &#61; &#39;&#39;Y&#39;&#39;&#10;  -- END of PDMv0.43 uplift&#10;  --&#10;  -- Apply VPD predicate&#10;  AND ( &#39; || PKG_VpdSupport.funcOffenderPolicyPredicate(&#39;O&#39;) || &#39; )&#10;  --&#10;  ORDER BY&#10;    C.contact_date DESC,&#10;    C.contact_start_time,&#10;    C.contact_end_time&#10;-- End of Main SQL&#39;;&#10;    --&#10;    l_scn_current :&#61; PKG_VpdSupport.get_current_scn_number;&#10;    l_same_schema :&#61; ( SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_SCHEMA&#39;) &#61; SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_USER&#39;) );&#10;    --&#10;    g_contact_enf_tab.DELETE;&#10;    --&#10;    PKG_Debug.procrecordDbStats(l_buffer_gets_1);&#10;    --&#10;    OPEN l_cur FOR l_SQL USING&#10;      -- OFFENDER_M&#10;      p_team_id, p_staff_id, p_provider_team_id, p_provider_employee_id,&#10;      -- Main SQL block&#10;      p_date&#10;    ;&#10;    --&#10;    FETCH l_cur BULK COLLECT INTO l_tab LIMIT 10000;&#10;    CLOSE l_cur;&#10;    --&#10;    FOR l_i IN 1..l_tab.COUNT LOOP&#10;        --&#10;        IF ( CASE&#10;                 WHEN p_filter &#61; 1 THEN&#10;                     ( &#39;Y&#39; &#61; funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;r_enforcement_action&#39;,&#10;                                 p_ref_col &#61;&gt; &#39;ENFORCEMENT_ACTION_ID&#39;,&#10;                                p_ref_val &#61;&gt; l_tab(l_i).ea_desc,&#10;                                p_data_fld &#61;&gt; &#39;OUTSTANDING_CONTACT_ACTION&#39; )&#10;                     )&#10;                 WHEN p_filter &#61; 2 THEN&#10;                     ( l_tab(l_i).CONTACT_TYPE_CODE &#61; &#39;ARWS&#39; )&#10;                 WHEN p_filter &#61; 3 THEN&#10;                     ( l_tab(l_i).contact_outcome_type_id IS NULL AND&#10;                       l_tab(l_i).CONTACT_TYPE_CODE &lt;&gt; &#39;ARWS&#39;&#10;                     )&#10;                 ELSE 1&#61;1&#10;             END&#10;           )&#10;        THEN&#10;            l_tab(l_i).ea_desc :&#61;&#10;                funcgetTabRecord_CACHED(p_table &#61;&gt; &#39;r_enforcement_action&#39;,&#10;                    p_ref_col &#61;&gt; &#39;ENFORCEMENT_ACTION_ID&#39;,&#10;                    p_ref_val &#61;&gt; l_tab(l_i).ea_desc,&#10;                    p_data_fld &#61;&gt; &#39;DESCRIPTION&#39; );&#10;            l_row :&#61; l_row + 1;&#10;            --&#10;            EXIT WHEN l_row &gt; p_max_rows;&#10;            PIPE ROW ( l_tab(l_i) );&#10;            --&#10;        END IF;&#10;        --&#10;    END LOOP;&#10;    --&#10;    PKG_Debug.procrecordDbStats(l_buffer_gets_2);&#10;    --&#10;    procDebug(&#10;        &#39;procFindEnforcementEventsTAB (rows&#61;&#39; || l_row || &#39;)&#39; ||&#10;        &#39;(&#39; || PKG_Debug.funcgetDbStats(l_buffer_gets_2 - l_buffer_gets_1) || &#39;): &#39; ||&#10;        &#39;num_of_rows&#61;&#39; || l_row       || &#39;, &#39; ||&#10;        &#39;p_date&#61;&gt;&#39;     || p_date      || &#39;, &#39; ||&#10;        &#39;p_team_id&#61;&gt;&#39;  || p_team_id   || &#39;, &#39; ||&#10;        &#39;p_staff_id&#61;&gt;&#39; || p_staff_id  || &#39;, &#39; ||&#10;        &#39;p_provider_team_id&#61;&gt;&#39;     || p_provider_team_id || &#39;, &#39; ||&#10;        &#39;p_provider_employee_id&#61;&gt;&#39; || p_provider_employee_id ||&#10;        &#39;(contacts_cache_HITS&#61;&#39;    || PKG_VpdSupport.get_tab_cont_off_CNT_HITS || &#39;)&#39; ||&#10;        &#39;(contacts_cache_MISS&#61;&#39;    || PKG_VpdSupport.get_tab_cont_off_CNT_MISS || &#39;)&#39; || CHR(10) ||&#10;        &#39;(curr_schema&#61;&#39;            || SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_SCHEMA&#39;) || &#39;)&#39; || CHR(10) ||&#10;        &#39;(curr_user&#61;&#39;              || USER                                     || &#39;)&#39; || CHR(10) ||&#10;        l_SQL );&#10;    --&#10;--EXCEPTION WHEN OTHERS THEN&#10;--    procDebug(SQLERRM || CHR(10) ||&#10;--              &#39;procFindEnforcementEventsTAB (rows&#61;&#39; || l_row || &#39;)(&#39; || PKG_Debug.funcgetDbStats || &#39;): &#39; ||&#10;--              &#39;num_of_rows&#61;&#39; || l_row || &#39;, &#39; ||&#10;--              &#39;p_date&#61;&gt;&#39; || p_date || &#39;, &#39; ||&#10;--              &#39;p_team_id&#61;&gt;&#39; || p_team_id || &#39;, &#39; ||&#10;--              &#39;p_staff_id&#61;&gt;&#39; || p_staff_id  || &#39;, &#39; ||&#10;--              &#39;p_provider_team_id&#61;&gt;&#39; || p_provider_team_id || &#39;, &#39; ||&#10;--              &#39;p_provider_employee_id&#61;&gt;&#39; || p_provider_employee_id || CHR(10) ||&#10;--              l_SQL);&#10;--    RAISE;&#10;END procFindEnforcementEventsTAB;&#10;--&#10;--&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;-- Misc&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--&#10;FUNCTION funcGetTabPkFields(p_table_name VARCHAR2, p_col_prefix VARCHAR2 DEFAULT &#39;&#39;, p_delim VARCHAR2 DEFAULT &#39;:&#39;) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN&#10;        CASE&#10;            WHEN p_table_name NOT IN (&#39;ORGANISATION_OFFENDER&#39;, &#39;R_DISPOSAL_TYPE_TERMINATION&#39;, &#39;R_LINKED_LIST&#39;) THEN&#10;                funcgetTabRecord_CACHED(&#10;                     p_table &#61;&gt; &#39;user_constraints C, user_cons_columns CC, user_tab_columns TC&#39;,&#10;                     p_ref_col &#61;&gt; &#39;c.table_name&#39;,&#10;                     p_ref_val &#61;&gt; UPPER(p_table_name),&#10;                     p_data_fld   &#61;&gt; &#39;&#39;&#39;&#39; || p_col_prefix || &#39;&#39;&#39; || TC.column_name&#39;,&#10;                     p_where      &#61;&gt; &#39;C.constraint_type &#61; &#39;&#39;P&#39;&#39; AND cc.table_name &#61; c.table_name AND cc.constraint_name &#61; c.constraint_name AND tc.table_name &#61; cc.table_name AND tc.column_name &#61; cc.column_name&#39;,&#10;                     p_order_by   &#61;&gt; &#39;CC.position&#39;,&#10;                     p_all_records &#61;&gt; &#39;Y&#39;, p_delim &#61;&gt; p_delim )&#10;            WHEN p_table_name &#61; &#39;ORGANISATION_OFFENDER&#39; THEN&#10;                p_col_prefix || &#39;PROBATION_AREA_ID&#39; || p_delim || p_col_prefix || &#39;EXTERNAL_PROVIDER_ID&#39; || p_delim || p_col_prefix || &#39;OFFENDER_ID&#39;&#10;            WHEN p_table_name &#61; &#39;R_DISPOSAL_TYPE_TERMINATION&#39; THEN&#10;                p_col_prefix || &#39;DISPOSAL_TYPE_ID&#39; || p_delim || p_col_prefix || &#39;DISPOSAL_TERMINATION_REASON_ID&#39;&#10;            WHEN p_table_name &#61; &#39;R_LINKED_LIST&#39; THEN&#10;                p_col_prefix || &#39;STANDARD_REFERENCE_DATA1&#39; || p_delim || p_col_prefix || &#39;STANDARD_REFERENCE_DATA2&#39;&#10;          END;&#10;END funcGetTabPkFields;&#10;--&#10;FUNCTION object_exists (p_object_type IN VARCHAR2, p_object_name IN VARCHAR2, p_object_owner IN VARCHAR2 DEFAULT &#39;DELIUS_APP_SCHEMA&#39;) RETURN BOOLEAN&#10;IS&#10;    l_Count NUMBER;&#10;BEGIN&#10;    l_count :&#61;&#10;        funcgetTabRecord(&#10;            p_table &#61;&gt; &#39;all_objects&#39;,&#10;            p_ref_col &#61;&gt; &#39;object_name&#39;,&#10;            p_ref_val &#61;&gt; UPPER(p_object_name),&#10;            p_data_fld   &#61;&gt; &#39;COUNT(1)&#39;,&#10;            p_where      &#61;&gt; &#39;object_type &#61; :p_object_type AND owner &#61; :p_object_owner&#39;,&#10;            p_bind_var1 &#61;&gt; p_object_type,&#10;            p_bind_var2 &#61;&gt; p_object_owner );&#10;    RETURN ( l_count &gt;&#61; 1 );&#10;END object_exists;&#10;--&#10;FUNCTION tab_col_exists(p_tab_name IN VARCHAR2, p_col_name VARCHAR2, p_owner IN VARCHAR2 DEFAULT &#39;DELIUS_APP_SCHEMA&#39;) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;  RETURN&#10;      funcgetTabRecord_CACHED(&#10;          p_table   &#61;&gt; &#39;all_tab_columns&#39;,&#10;          p_ref_col &#61;&gt; &#39;table_name&#39;,&#10;          p_ref_val &#61;&gt; UPPER(p_tab_name),&#10;          --&#10;          p_data_fld   &#61;&gt; &#39;&#39;&#39;Y&#39;&#39;&#39;,&#10;          p_default_val&#61;&gt; &#39;N&#39;,&#10;          --&#10;          p_where      &#61;&gt; &#39;owner &#61; :p_owner AND column_name &#61; :p_col_name&#39;,&#10;          --&#10;          p_bind_var1 &#61;&gt; UPPER(p_owner),&#10;          p_bind_var2 &#61;&gt; UPPER(p_col_name) );&#10;END tab_col_exists;&#10;--&#10;FUNCTION get_sql_xplain_plan(p_SQL VARCHAR2) RETURN CLOB&#10;IS&#10;    PRAGMA AUTONOMOUS_TRANSACTION;&#10;    l_ret CLOB;&#10;BEGIN&#10;    EXECUTE IMMEDIATE &#39;EXPLAIN PLAN FOR &#39; || p_SQL;&#10;    l_ret :&#61; DBMS_XPLAN.DISPLAY_PLAN;&#10;    COMMIT;&#10;    RETURN l_ret;&#10;END get_sql_xplain_plan;&#10;--&#10;FUNCTION GetUserID(p_distinguished_name IN VARCHAR2) RETURN NUMBER&#10;IS&#10;BEGIN&#10;    RETURN&#10;        funcgetTabRecord_CACHED(&#10;            p_table &#61;&gt; &#39;USER_&#39;,&#10;            p_ref_col &#61;&gt; &#39;UPPER(distinguished_name)&#39;,&#10;            p_ref_val &#61;&gt; UPPER(p_distinguished_name),&#10;            p_data_fld   &#61;&gt; &#39;user_id&#39; );&#10;END GetUserID;&#10;--&#10;FUNCTION GetUserName(p_user_id IN NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN&#10;        funcgetTabRecord_CACHED(&#10;            p_table &#61;&gt; &#39;USER_&#39;,&#10;            p_ref_col &#61;&gt; &#39;user_id&#39;,&#10;            p_ref_val &#61;&gt; TO_CHAR(p_user_id),&#10;            p_data_fld   &#61;&gt; &#39;TRIM(surname) || &#39;&#39;,&#39;&#39; || TRIM(forename)&#39; );&#10;END GetUserName;&#10;--&#10;FUNCTION GetResponsibleTeam(p_team_id IN NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN&#10;        funcgetTabRecord_CACHED(&#10;            p_table       &#61;&gt; &#39;TEAM&#39;,&#10;            p_ref_col     &#61;&gt; &#39;team_id&#39;,&#10;            p_ref_val     &#61;&gt; TO_CHAR(p_team_id),&#10;            p_data_fld    &#61;&gt; &#39;code || &#39;&#39;/&#39;&#39; || description&#39;,&#10;            p_default_val &#61;&gt; &#39;XXXXXX/X&#39; );&#10;END ;&#10;--&#10;FUNCTION GetResponsibleOfficer(p_staff_id IN NUMBER) RETURN VARCHAR2&#10;IS&#10;BEGIN&#10;    RETURN&#10;        funcgetTabRecord_CACHED(&#10;            p_table       &#61;&gt; &#39;STAFF&#39;,&#10;            p_ref_col     &#61;&gt; &#39;staff_id&#39;,&#10;            p_ref_val     &#61;&gt; TO_CHAR(p_staff_id),&#10;            p_data_fld    &#61;&gt; &#39;officer_code || &#39;&#39;/&#39;&#39; || PKG_LSTUTL.concat(TRIM(surname), TRIM(forename), TRIM(forename2), p_delim &#61;&gt; &#39;&#39;,&#39;&#39;)&#39;,&#10;            p_default_val &#61;&gt; &#39;XXXXXX/X&#39; );&#10;END GetResponsibleOfficer;&#10;--&#10;FUNCTION GetLDUID(lducode_in  IN VARCHAR2, probationareaid_in IN NUMBER DEFAULT NULL) RETURN NUMBER&#10;IS&#10;BEGIN&#10;    RETURN&#10;        funcgetTabRecord_CACHED(&#10;            p_table       &#61;&gt; &#39;LOCAL_DELIVERY_UNIT&#39;,&#10;            p_ref_col     &#61;&gt; &#39;code&#39;,&#10;            p_ref_val     &#61;&gt; lducode_in,&#10;            p_data_fld    &#61;&gt; &#39;local_delivery_unit_id&#39;,&#10;            p_where       &#61;&gt; ( CASE WHEN probationareaid_in IS NOT NULL THEN &#39;probation_area_id &#61; :probation_area_id&#39; END ),&#10;            p_bind_var1   &#61;&gt; NVLSTR(TO_CHAR(probationareaid_in), GC_LUP_BIND_VAR_MISSING) );&#10;END GetLDUID;&#10;--&#10;FUNCTION GetDistrictID(districtcode_in  IN VARCHAR2, boroughid_in IN NUMBER DEFAULT NULL) RETURN NUMBER&#10;IS&#10;BEGIN&#10;    RETURN&#10;        funcgetTabRecord_CACHED(&#10;            p_table       &#61;&gt; &#39;DISTRICT&#39;,&#10;            p_ref_col     &#61;&gt; &#39;code&#39;,&#10;            p_ref_val     &#61;&gt; districtcode_in,&#10;            p_data_fld    &#61;&gt; &#39;district_id&#39;,&#10;            p_where       &#61;&gt; ( CASE WHEN boroughid_in IS NOT NULL THEN &#39;borough_id &#61; :borough_id&#39; END ),&#10;            p_bind_var1   &#61;&gt; NVLSTR(TO_CHAR(boroughid_in), GC_LUP_BIND_VAR_MISSING) );&#10;END GetDistrictID;&#10;--&#10;FUNCTION GetBoroughID(boroughcode_in  IN VARCHAR2, probationareaid_in IN NUMBER DEFAULT NULL) RETURN NUMBER&#10;IS&#10;BEGIN&#10;    RETURN&#10;        funcgetTabRecord_CACHED(&#10;            p_table       &#61;&gt; &#39;BOROUGH&#39;,&#10;            p_ref_col     &#61;&gt; &#39;code&#39;,&#10;            p_ref_val     &#61;&gt; boroughcode_in,&#10;            p_data_fld    &#61;&gt; &#39;borough_id&#39;,&#10;            p_where       &#61;&gt; ( CASE WHEN probationareaid_in IS NOT NULL THEN &#39;probation_area_id &#61; :probation_area_id&#39; END ),&#10;            p_bind_var1   &#61;&gt; NVLSTR(TO_CHAR(probationareaid_in), GC_LUP_BIND_VAR_MISSING) );&#10;END GetBoroughID;&#10;--&#10;PROCEDURE do_init_vars&#10;IS&#10;    ex_mutating_table EXCEPTION;&#10;    PRAGMA EXCEPTION_INIT (ex_mutating_table, -4091);&#10;    --&#10;    l_proc VARCHAR2(100) :&#61; &#39;PKG_Lookups.DO_INIT_VARS&#39;;&#10;    --&#10;BEGIN&#10;    --&#10;    -- 1. PLSQL Cache maximum size&#10;    BEGIN&#10;        g_cache_max_size :&#61; funcgetNDParameterValue(p_par_name &#61;&gt; &#39;CUSTOM_CACHE_MAX_SIZE&#39;, p_default_value &#61;&gt; 1000);&#10;    EXCEPTION&#10;        WHEN ex_mutating_table THEN&#10;            --procDebug(l_proc || &#39;: failed to initialise the [G_CACHE_MAX_SIZE] global variable {&#39; || SQLERRM || &#39;): settng to the default 1000 value&#39;);&#10;            g_cache_max_size :&#61; 1000;&#10;        WHEN OTHERS THEN&#10;            --procDebug(l_proc || &#39;: failed to initialise the [G_CACHE_MAX_SIZE] global variable {&#39; || SQLERRM || &#39;): settng to the default 1000 value&#39;);&#10;            g_cache_max_size :&#61; 1000;&#10;    END;&#10;    --&#10;END do_init_vars;&#10;--&#10;-- Test MTT_DEBUG pipelined functiuon&#10;--&#10;--TYPE trecMttDebug IS RECORD(&#10;--    /*01*/ record_id    NUMBER,&#10;--    /*02*/ dbg_context  VARCHAR2(4000),&#10;--    /*03*/ dbg_message  CLOB );&#10;--TYPE ttabMttDebug IS TABLE OF trecMttDebug;&#10;--&#10;FUNCTION procFindMttDebugTAB(&#10;    p_date                 DATE     DEFAULT NULL,&#10;    p_dbg_context          VARCHAR2 DEFAULT NULL,&#10;    p_dbg_search_mask      VARCHAR2 DEFAULT NULL,&#10;    p_max_rows             INTEGER DEFAULT 100000)&#10;RETURN ttabMttDebug PIPELINED&#10;IS&#10;    --&#10;    TYPE l_cur_TYP IS REF CURSOR;&#10;    l_cur l_cur_TYP;&#10;    --&#10;    l_SQL VARCHAR2(10000);&#10;    --&#10;    l_tab ttabMttDebug;&#10;    --&#10;    l_i   INTEGER;&#10;    l_row INTEGER :&#61; 0;&#10;    --&#10;    l_buffer_gets_1 NUMBER;&#10;    l_buffer_gets_2 NUMBER;&#10;    --&#10;    l_scn_current NUMBER;&#10;    l_same_schema BOOLEAN;&#10;BEGIN&#10;    --&#10;    --l_SQL :&#61; &#39;SELECT 1 AS record_id, &#39;&#39;DBG CTX&#39;&#39; AS dbg_context, &#39;&#39;DBG message 1&#39;&#39; AS dbg_message  FROM dual&#39;;&#10;    l_SQL :&#61;&#10;&#39;WITH DBG_T AS (&#10;  SELECT&#10;    id      AS record_id,&#10;    column1 AS dbg_context,&#10;    column2 AS dbg_message&#10;  FROM mtt_debug&#10;  WHERE 1&#61;1&#10;    AND &#39; || CASE WHEN p_date            IS NOT NULL THEN &#39;column1 LIKE TO_CHAR(TRUNC(:p_date), &#39;&#39;YYYYMMDD&#39;&#39;) || &#39;&#39;%&#39;&#39;&#39; ELSE &#39;:p_date IS NULL&#39;        END || &#39;&#10;    AND &#39; || CASE WHEN p_dbg_context     IS NOT NULL THEN &#39;UPPER(column2) LIKE &#39;&#39;%&#39;&#39; || UPPER(:p_dbg_context) || &#39;&#39;%&#39;&#39;&#39; ELSE &#39;:p_dbg_context IS NULL&#39; END || &#39;&#10;    AND &#39; || CASE WHEN p_dbg_search_mask IS NOT NULL THEN &#39;UPPER(column2) LIKE &#39;&#39;%&#39;&#39; || UPPER(:p_dbg_message) || &#39;&#39;%&#39;&#39;&#39; ELSE &#39;:p_dbg_message IS NULL&#39; END || &#39;&#10;  )&#10;--&#10;SELECT&#10;  /*01*/ record_id,&#10;  /*02*/ dbg_context,&#10;  /*03*/ dbg_message&#10;FROM DBG_T&#10;WHERE 1&#61;1&#10;ORDER BY 1 DESC&#39;;&#10;    --&#10;    l_scn_current :&#61; 1; --PKG_VpdSupport.get_current_scn_number;&#10;    l_same_schema :&#61; ( SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_SCHEMA&#39;) &#61; SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_USER&#39;) );&#10;    --&#10;    PKG_Debug.procrecordDbStats(l_buffer_gets_1);&#10;    --&#10;    OPEN l_cur FOR l_SQL USING p_date, p_dbg_context, p_dbg_search_mask&#10;    ;&#10;    FETCH l_cur BULK COLLECT INTO l_tab LIMIT NVL(p_max_rows, 10000);&#10;    CLOSE l_cur;&#10;    --&#10;    FOR l_i IN 1..l_tab.COUNT LOOP&#10;        --&#10;        l_row :&#61; l_row + 1;&#10;        --&#10;        EXIT WHEN l_row &gt; p_max_rows;&#10;        PIPE ROW ( l_tab(l_i) );&#10;        --&#10;    END LOOP;&#10;    --&#10;    PKG_Debug.procrecordDbStats(l_buffer_gets_2);&#10;    --&#10;    procDebug(&#39;procFindMttDebugTAB (rows&#61;&#39; || l_row || &#39;)(&#39; || PKG_Debug.funcgetDbStats(l_buffer_gets_2 - l_buffer_gets_1) || &#39;): &#39; ||&#10;              &#39;num_of_rows&#61;&#39;        || l_row              || &#39;, &#39; ||&#10;              &#39;p_date&#61;&gt;&#39;            || p_date             || &#39;, &#39; ||&#10;              &#39;p_dbg_context&#61;&gt;&#39;     || p_dbg_context      || &#39;, &#39; ||&#10;              &#39;p_dbg_search_mask&#61;&gt;&#39; || p_dbg_search_mask  || &#39;, &#39; ||&#10;              &#39;(curr_schema&#61;&#39; || SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_SCHEMA&#39;)|| &#39;)&#39; || CHR(10) ||&#10;              &#39;(curr_user&#61;&#39; || USER || &#39;)&#39; || CHR(10) ||&#10;              l_SQL);&#10;    --&#10;    RETURN /*l_tab*/;&#10;    --&#10;--EXCEPTION WHEN OTHERS THEN&#10;--    procDebug(&#39;ERROR in procFindMttDebugTAB (rows&#61;&#39; || l_row || &#39;): &#39; ||&#10;--              &#39;num_of_rows&#61;&#39;        || l_row              || &#39;, &#39; ||&#10;--              &#39;p_date&#61;&gt;&#39;            || p_date             || &#39;, &#39; ||&#10;--              &#39;p_dbg_context&#61;&gt;&#39;     || p_dbg_context      || &#39;, &#39; ||&#10;--              &#39;p_dbg_search_mask&#61;&gt;&#39; || p_dbg_search_mask  || &#39;, &#39; ||&#10;--              &#39;(curr_schema&#61;&#39; || SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_SCHEMA&#39;)|| &#39;)&#39; || CHR(10) ||&#10;--              &#39;(curr_user&#61;&#39; || USER || &#39;)&#39; || CHR(10) ||&#10;--              SQLERRM || CHR(10) ||&#10;--              l_SQL );&#10;--    RAISE;&#10;END procFindMttDebugTAB;&#10;--&#10;-- Package Body initialisation block&#10;--&#10;BEGIN&#10;    PKG_Global.do_init;&#10;    --&#10;    do_init_vars;&#10;    --&#10;    BEGIN&#10;        do_flush_TAB_cache;&#10;    EXCEPTION WHEN OTHERS THEN&#10;        g_cache_TAB.DELETE;&#10;    END;&#10;    --&#10;END pkg_Lookups;</textarea>
                        </div>
                    </div>
                </section>
            </div>
            <!-- /.content-wrapper -->
            <footer class="main-footer">
                <div>
                    <div class="pull-right hidden-xs">
                        <a href="https://github.com/schemaspy/schemaspy" title="GitHub for SchemaSpy"><i class="fa fa-github-square fa-2x"></i></a>
                        <a href="http://stackoverflow.com/questions/tagged/schemaspy" title="StackOverflow for SchemaSpy"><i class="fa fa-stack-overflow fa-2x"></i></a>
                    </div>
                    <strong>Generated by <a href="http://schemaspy.org/" class="logo-text"><i class="fa fa-database"></i> SchemaSpy 6.2.4</a></strong>
                </div>
                <!-- /.container -->
            </footer>
        </div>
        <!-- ./wrapper -->

        <!-- jQuery 2.2.3 -->
        <script src="../bower/admin-lte/plugins/jQuery/jquery-2.2.3.min.js"></script>
        <script src="../bower/admin-lte/plugins/jQueryUI/jquery-ui.min.js"></script>
        <!-- Bootstrap 3.3.5 -->
        <script src="../bower/admin-lte/bootstrap/js/bootstrap.min.js"></script>
        <!-- DataTables -->
        <script src="../bower/datatables.net/jquery.dataTables.min.js"></script>
        <script src="../bower/datatables.net-bs/js/dataTables.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/dataTables.buttons.min.js"></script>
        <script src="../bower/datatables.net-buttons-bs/js/buttons.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.html5.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.print.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.colVis.min.js"></script>
        <!-- SheetJS -->
        <script src="../bower/js-xlsx/xlsx.full.min.js"></script>
        <!-- pdfmake -->
        <script src="../bower/pdfmake/pdfmake.min.js"></script>
        <script src="../bower/pdfmake/vfs_fonts.js"></script>
        <!-- SlimScroll -->
        <script src="../bower/admin-lte/plugins/slimScroll/jquery.slimscroll.min.js"></script>
        <!-- FastClick -->
        <script src="../bower/admin-lte/plugins/fastclick/fastclick.js"></script>
        <!-- Salvattore -->
        <script src="../bower/salvattore/salvattore.min.js"></script>
        <!-- AnchorJS -->
        <script src="../bower/anchor-js/anchor.min.js"></script>
        <!-- CodeMirror -->
        <script src="../bower/codemirror/codemirror.js"></script>
        <script src="../bower/codemirror/sql.js"></script>
        <!-- AdminLTE App -->
        <script src="../bower/admin-lte/dist/js/app.min.js"></script>
        <script src="routine.js"></script>
        <script src="../schemaSpy.js"></script>
    </body>
</html>