<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>TSTNDA.DELIUS_APP_SCHEMA</title>
        <!-- Tell the browser to be responsive to screen width -->
        <meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport">
        <link rel="icon" type="image/png" sizes="16x16" href="../favicon.png">
        <!-- Bootstrap 3.3.5 -->
        <link rel="stylesheet" href="../bower/admin-lte/bootstrap/css/bootstrap.min.css">
        <!-- Font Awesome -->
        <link rel="stylesheet" href="../bower/font-awesome/css/font-awesome.min.css">
        <!-- Ionicons -->
        <link rel="stylesheet" href="../bower/ionicons/css/ionicons.min.css">
        <!-- DataTables -->
        <link rel="stylesheet" href="../bower/datatables.net-bs/css/dataTables.bootstrap.min.css">
        <link rel="stylesheet" href="../bower/datatables.net-buttons-bs/css/buttons.bootstrap.min.css">
        <!-- Code Mirror -->
        <link rel="stylesheet" href="../bower/codemirror/codemirror.css">
        <!-- Fonts -->
        <link href='../fonts/indieflower/indie-flower.css' rel='stylesheet' type='text/css'>
        <link href='../fonts/source-sans-pro/source-sans-pro.css' rel='stylesheet' type='text/css'>

        <!-- Theme style -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/AdminLTE.min.css">
        <!-- Salvattore -->
        <link rel="stylesheet" href="../bower/salvattore/salvattore.css">
        <!-- AdminLTE Skins. Choose a skin from the css/skins
           folder instead of downloading all of them to reduce the load. -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/skins/_all-skins.min.css">
        <!-- SchemaSpy -->
        <link rel="stylesheet" href="../schemaSpy.css">

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
        <script src="../bower/html5shiv/html5shiv.min.js"></script>
        <script src="../bower/respond/respond.min.js"></script>
        <![endif]-->
    </head>
    <!-- ADD THE CLASS layout-top-nav TO REMOVE THE SIDEBAR. -->
    <body class="hold-transition skin-blue layout-top-nav">
        <div class="wrapper">
            <header class="main-header">
                <nav class="navbar navbar-static-top">
                    <div class="container">
                        <div class="navbar-header">
                            <a href="../index.html" class="navbar-brand"><b>TSTNDA</b></a><span class="navbar-brand" style="padding-left: 0">.DELIUS_APP_SCHEMA</span>
                            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse"><i class="fa fa-bars"></i></button>
                        </div>

                        <!-- Collect the nav links, forms, and other content for toggling -->
                        <div class="collapse navbar-collapse pull-left" id="navbar-collapse">
                            <ul class="nav navbar-nav">
                                <li><a href="../index.html">Tables <span class="sr-only">(current)</span></a></li>
                                <li><a href="../columns.html" title="All of the columns in the schema">Columns</a></li>
                                <li><a href="../constraints.html" title="Useful for diagnosing error messages that just give constraint name or number">Constraints</a></li>
                                <li><a href="../relationships.html" title="Diagram of table relationships">Relationships</a></li>
                                <li><a href="../orphans.html" title="View of tables with neither parents nor children">Orphan&nbsp;Tables</a></li>
                                <li><a href="../anomalies.html" title="Things that might not be quite right">Anomalies</a></li>
                                <li><a href="../routines.html" title="Procedures and functions">Routines</a></li>
                            </ul>
                        </div>
                        <!-- /.navbar-collapse -->
                        <!-- Navbar Right Menu -->
                    </div>
                    <!-- /.container-fluid -->
                </nav>
            </header>
            <!-- Main content -->
            <!-- Full Width Column -->
            <div class="content-wrapper">
                <!-- Content Header (Page header) -->
                <section class="content-header">
                    <h1>DELIUS_APP_SCHEMA.PKG_SPG_EXPORT</h1><br />
                </section>
                <!-- Main content -->
                <section class="content">
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <span class="glyphicon glyphicon-list-alt" aria-hidden="true"></span>
                            <h3 id="Columns" class="box-title">Parameters</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <table id="standard_table" class="table table-bordered table-striped dataTable" role="grid">
                                <thead align='left'>
                                <tr>
                                    <th>Name</th>
                                    <th>Type</th>
                                    <th>Mode</th>
                                </tr>
                                </thead>
                                <tbody>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <i class="fa fa-file-code-o"></i>
                            <h3 id="RoutineDefinition" class="box-title">Definition</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <textarea id="sql-script-codemirror" name="sql-script-codemirror" rows="" style="display: none;">PACKAGE BODY PKG_SPG_EXPORT&#10;AS&#10;--&#10;--&#10;--&#10;--&#10;&#10;--&#10;-- Global variables&#10;--&#10;    --g_package_version CONSTANT VARCHAR2(30) :&#61; GC_VERSION;&#10;    g_component_code  CONSTANT VARCHAR2(3)  :&#61; &#39;SPG&#39;;&#10;    g_package_name    CONSTANT VARCHAR2(30) :&#61; &#39;PKG_SPG_EXPORT&#39;;&#10;    --&#10;    g_procedure_name  VARCHAR2(30)  :&#61; &#39;initial_value&#39;;&#10;    g_label           VARCHAR2(100) :&#61; &#39;000000&#39;;&#10;&#10;    --g_label VARCHAR2(100);&#10;&#10;    -- message type&#10;    mt_information    CONSTANT NUMBER :&#61; 1;&#10;    mt_warning        CONSTANT NUMBER :&#61; 2;&#10;    mt_error          CONSTANT NUMBER :&#61; 3;&#10;    mt_fatal_error    CONSTANT NUMBER :&#61; 4;&#10;&#10;    GC_BI_202_CODE       CONSTANT VARCHAR2(30) :&#61; &#39;SPGISN202&#39;;&#10;    GC_BI_410_CODE       CONSTANT VARCHAR2(30) :&#61; &#39;SPGISN410&#39;;&#10;    GC_BI_413_CODE       CONSTANT VARCHAR2(30) :&#61; &#39;SPGISN413&#39;;&#10;    GC_BI_OFFENDER       CONSTANT VARCHAR2(30) :&#61; &#39;SPOBI004&#39;;&#10;    GC_BI_ALLOC_OFFENDER CONSTANT VARCHAR2(30) :&#61; &#39;CABI020&#39;;&#10;    GC_BI_ALLOC_EVENT    CONSTANT VARCHAR2(30) :&#61; &#39;CABI041&#39;;&#10;&#10;    G_BI_202_ID NUMBER;&#10;    G_BI_410_ID NUMBER;&#10;    G_BI_413_ID NUMBER;&#10;&#10;    TYPE t_tab_deferred IS TABLE OF VARCHAR2(1) INDEX BY VARCHAR(100);&#10;    g_tab_deferred_SPG_202     t_tab_deferred;&#10;    g_tab_deferred_crc_export  t_tab_deferred;&#10;&#10;&#10;    g_deferred_SPG_202_FLAG    BOOLEAN :&#61; FALSE;&#10;    g_crc_export_deferred_FLAG BOOLEAN :&#61; FALSE;&#10;&#10;--&#10;--&#10;-- PKG_COMMON wrappers&#10;--&#10;PROCEDURE procDebug(p_msg CLOB) IS&#10;BEGIN&#10;    PKG_Debug.procDebug(p_msg);&#10;END procDebug;&#10;&#10;FUNCTION funcgetDebugMode RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Debug.funcgetDebugMode;&#10;END funcgetDebugMode;&#10;--&#10;PROCEDURE message(p_msg VARCHAR2, p_trace_level INTEGER DEFAULT 0) IS&#10;BEGIN&#10;    PKG_Common.print_message(&#10;        p_msg         &#61;&gt; p_msg,&#10;        p_trace_level &#61;&gt; NVL(p_trace_level, PKG_Common.GC_TRACE_LEVEL),&#10;        p_label       &#61;&gt; g_label );&#10;END message;&#10;--&#10;FUNCTION is_str_empty(p_str VARCHAR2, p_ignore_spaces_and_zeroes VARCHAR2 DEFAULT &#39;N&#39;) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.is_str_empty( p_str, p_ignore_spaces_and_zeroes );&#10;END is_str_empty;&#10;--&#10;FUNCTION empty2null(p_str VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.empty2null(p_str);&#10;END empty2null;&#10;&#10;FUNCTION nvlstr(p_str1 VARCHAR2, p_str2 VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.NVLSTR(p_str1, p_str2);&#10;END nvlstr;&#10;--&#10;PROCEDURE raise_error(p_err_msg VARCHAR2, p_proc VARCHAR2, p_label VARCHAR2 DEFAULT NULL) IS&#10;BEGIN&#10;    PKG_Common.raise_error( p_err_msg, p_proc, p_label );&#10;END raise_error;&#10;--&#10;--&#10;--&#10;-- Used to populate mtt_message_log with information type message&#10;PROCEDURE info (message_in VARCHAR2)&#10;IS&#10;BEGIN&#10;  IF SPGConfig.SPGInfoActive THEN&#10;    SPGConfig.insert_message_log( message_type_id_in  &#61;&gt; mt_information,&#10;                                  component_code_in   &#61;&gt; g_component_code,&#10;                                  package_name_in     &#61;&gt; g_package_name,&#10;                                  procedure_name_in   &#61;&gt; g_procedure_name,&#10;                                  label_in            &#61;&gt; g_label,&#10;                                  message_text_in     &#61;&gt; message_in);&#10;  END IF;&#10;END info;&#10;--&#10;-- Will populate mtt_message_log with warning message - will populate mtt_error_log if result of exception&#10;PROCEDURE warn (message_in VARCHAR2)&#10;IS&#10;BEGIN&#10;  IF SPGConfig.SPGWarnActive THEN&#10;    SPGConfig.record_error( message_type_id_in    &#61;&gt; mt_warning,&#10;                            component_code_in     &#61;&gt; g_component_code,&#10;                            package_name_in       &#61;&gt; g_package_name,&#10;                            procedure_name_in     &#61;&gt; g_procedure_name,&#10;                            label_in              &#61;&gt; g_label,&#10;                            message_text_in       &#61;&gt; message_in);&#10;  END IF;&#10;END warn;&#10;--&#10;-- Will populate mtt_message_log with error message and populate mtt_error_log with exception - used for log and continue&#10;PROCEDURE error (message_in VARCHAR2)&#10;IS&#10;BEGIN&#10;  SPGConfig.record_error( message_type_id_in    &#61;&gt; mt_error,&#10;                          component_code_in     &#61;&gt; g_component_code,&#10;                          package_name_in       &#61;&gt; g_package_name,&#10;                          procedure_name_in     &#61;&gt; g_procedure_name,&#10;                          label_in              &#61;&gt; g_label,&#10;                          message_text_in       &#61;&gt; message_in);&#10;END error;&#10;--&#10;-- Will populate mtt_message_log, mtt_error_log with error message and raise exception - used for log and halt&#10;PROCEDURE fatal (message_in VARCHAR2)&#10;IS&#10;BEGIN&#10;  SPGConfig.record_error( message_type_id_in    &#61;&gt; mt_fatal_error,&#10;                          component_code_in     &#61;&gt; g_component_code,&#10;                          package_name_in       &#61;&gt; g_package_name,&#10;                          procedure_name_in     &#61;&gt; g_procedure_name,&#10;                          label_in              &#61;&gt; g_label,&#10;                          message_text_in       &#61;&gt; message_in,&#10;                          raise_error_in        &#61;&gt; TRUE);&#10;END fatal;&#10;--&#10;&#10;--&#10;-- RBAC WRAPPERS&#10;--&#10;PROCEDURE do_set_rbac_levels(&#10;    p_offender_id        NUMBER,&#10;    p_L1          IN OUT NUMBER,&#10;    p_L2          IN OUT NUMBER,&#10;    p_L3          IN OUT NUMBER,&#10;    p_username    IN VARCHAR2 DEFAULT NULL )&#10;IS&#10;BEGIN&#10;    PKG_RBAC.do_set_rbac_levels( p_offender_id, p_L1, p_L2, p_L3, p_username );&#10;END do_set_rbac_levels;&#10;--&#10;FUNCTION procGetOwnersTAB(&#10;    p_user_id             NUMBER,&#10;    p_offender_id_LST     CLOB&#10;)&#10;RETURN PKG_RBAC.ttabOwners PIPELINED&#10;IS&#10;    l_tab PKG_RBAC.ttabOwners;&#10;BEGIN&#10;    --&#10;    SELECT * BULK COLLECT INTO l_tab&#10;    FROM TABLE( PKG_RBAC.procGetOwnersTAB(p_user_id, p_offender_id_LST) );&#10;    --&#10;    FOR l_idx IN 1..l_tab.COUNT LOOP&#10;        PIPE ROW ( l_tab(l_idx) );&#10;    END LOOP;&#10;END procGetOwnersTAB;&#10;--&#10;--&#10;--&#10;--&#10;-- Offender CRC Extract support subroutines&#10;--&#10;FUNCTION procGetOffCRCExtractSummaryTAB(&#10;    p_probation_area_id NUMBER,&#10;    p_team_id           NUMBER DEFAULT -1,&#10;    p_staff_id          NUMBER DEFAULT -1 )&#10;RETURN ttabOffCRCExtractSummary PIPELINED IS&#10;    --&#10;    lc_proc CONSTANT VARCHAR2(30) :&#61; &#39;procGetOffCRCExtractSummaryTAB&#39;;&#10;    --&#10;    TYPE l_cur_TYP IS REF CURSOR;&#10;    l_cur l_cur_TYP;&#10;    --&#10;    l_rec trecOffCRCExtractSummary;&#10;    l_tab ttabOffCRCExtractSummary;&#10;    --&#10;    l_bi_alloc_ID NUMBER :&#61; PKG_Lookups.funcGetBusinessInteractionID(GC_BI_ALLOC_OFFENDER);&#10;    --&#10;    l_SQL     CLOB;&#10;    l_cnt     INTEGER :&#61; 0;&#10;    --&#10;BEGIN&#10;    --&#10;    PKG_Debug.procrecordDbStats_START;&#10;    --&#10;    --TYPE trecOffCRCExtractSummary IS RECORD(&#10;    --  /*00*/ rbac_level  VARCHAR2(4),&#10;    --  /*01*/ num_of_rows NUMBER );&#10;    --&#10;    l_SQL :&#61;&#10;&#39;WITH&#10;  L AS (&#10;    SELECT &#39; || CASE WHEN NVL(p_probation_area_id, -1) &gt; 0 THEN &#39;/*+ LEADING( t cl ) USE_NL( cl ) INDEX(cl xif10caseload) */&#39; END || &#39;&#10;      CL.offender_id,&#10;      DECODE(CL.role_code, &#39;&#39;OM&#39;&#39;, &#39;&#39;L1&#39;&#39;, &#39;&#39;L3&#39;&#39;) AS rbac_level,&#10;      T.probation_area_id,&#10;      CL.trust_provider_flag,&#10;      CL.trust_provider_team_id&#10;    FROM&#10;      caseload CL&#10;        INNER JOIN all_team T ON T.trust_provider_team_id &#61; CL.trust_provider_team_id&#10;                             AND T.trust_provider_flag    &#61; CL.trust_provider_flag&#10;    WHERE 1&#61;1&#10;      AND CL.trust_provider_flag &#61; 0&#10;      AND CL.role_code NOT IN ( &#39;&#39;POM&#39;&#39; )&#10;      /*DST-4984: excluding the Court Report linked to Presentence event*/&#10;      AND ( CL.court_report_id IS NULL OR ( CL.court_report_id IS NOT NULL AND CL.disposal_id IS NOT NULL ) )&#10;      --&#10;      &#39; ||&#10;    --&#10;CASE WHEN NVL(p_staff_id, -1) &gt; 0 THEN&#10;    --&#10;     &#39;AND NVL(:p_probation_area_id, -1) IS NOT NULL&#10;      -- DST-2639: Restrict record set to Officer + Current Team&#10;      AND &#39; || CASE WHEN NVL(p_team_id, -1) &gt; 0 THEN &#39;CL.trust_provider_team_id &#61; :p_team_id&#39; ELSE &#39;NVL(:p_team_id, -1) IS NOT NULL&#39; END || &#39;&#10;      AND CL.staff_employee_id          &#61; :p_staff_id&#39;&#10;    --&#10;WHEN NVL(p_team_id, -1) &gt; 0 THEN&#10;    --&#10;     &#39;AND NVL(:p_probation_area_id, -1) IS NOT NULL&#10;      AND CL.trust_provider_team_id     &#61; :p_team_id&#10;      AND NVL(:p_staff_id, -1)          IS NOT NULL&#39;&#10;    --&#10;WHEN NVL(p_probation_area_id, -1) &gt; 0 THEN&#10;    --&#10;     &#39;AND T.trust_provider_flag &#61; 0&#10;      AND T.probation_area_id   &#61; :p_probation_area_id&#10;      AND NVL(:p_team_id, -1)   IS NOT NULL&#10;      AND NVL(:p_staff_id, -1)  IS NOT NULL&#39;&#10;     --&#10;END || &#39;&#10;  ),&#10;  L0 AS (&#10;    SELECT DISTINCT&#10;      L.rbac_level,&#10;      L.offender_id,&#10;      L.probation_area_id&#10;    FROM L&#10;  ),&#10;  L1 AS (&#10;    SELECT offender_id, probation_area_id&#10;    FROM L0&#10;    WHERE rbac_level &#61; &#39;&#39;L1&#39;&#39;&#10;  ),&#10;  L3 AS (&#10;    SELECT offender_id, probation_area_id&#10;    FROM L0&#10;    WHERE rbac_level &#61; &#39;&#39;L3&#39;&#39;&#10;      AND offender_id NOT IN ( SELECT offender_id FROM L WHERE rbac_level &#61; &#39;&#39;L1&#39;&#39; )&#10;  )&#10;--&#10;SELECT &#39;&#39;L1&#39;&#39; AS src , COUNT(DISTINCT offender_id) AS num_of_rows&#10;FROM L1&#10;--&#10;UNION ALL&#10;--&#10;SELECT &#39;&#39;L1_1&#39;&#39; AS src, COUNT(DISTINCT L1.offender_id) AS num_of_rows&#10;FROM&#10;  L1&#10;    INNER JOIN offender_crc_export E ON E.offender_id         &#61; L1.offender_id&#10;                                    AND E.crc_provider_id     &#61; L1.probation_area_id&#10;                                    AND E.current_record_flag &#61; &#39;&#39;Y&#39;&#39;&#10;                                    AND NVL(E.error_flag, 0)  &#61; 0&#10;                                    AND E.submitted_datetime IS NOT NULL&#10;--&#10;UNION ALL&#10;--&#10;SELECT &#39;&#39;L1_2&#39;&#39; AS src, COUNT(DISTINCT L1.offender_id) AS num_of_rows&#10;FROM&#10;  L1&#10;    INNER JOIN spg_notification SN ON SN.offender_id             &#61; L1.offender_id&#10;                                  AND SN.receiver_identity_id    &#61; L1.probation_area_id&#10;                                  AND SN.processed_flag          &#61; 0&#10;                                  AND SN.business_interaction_id &#61; :p_BI_ALLOC_id&#10;--&#10;UNION ALL&#10;--&#10;SELECT &#39;&#39;L3&#39;&#39; AS src, COUNT(DISTINCT offender_id) AS num_of_rows&#10;FROM L3&#10;--&#10;UNION ALL&#10;--&#10;SELECT &#39;&#39;L3_1&#39;&#39; AS src, COUNT(DISTINCT L3.offender_id) AS num_of_rows&#10;FROM&#10;  L3&#10;    INNER JOIN offender_crc_export E ON E.offender_id         &#61; L3.offender_id&#10;                                    AND E.crc_provider_id     &#61; L3.probation_area_id&#10;                                    AND E.current_record_flag &#61; &#39;&#39;Y&#39;&#39;&#10;                                    AND NVL(E.error_flag, 0)  &#61; 0&#10;                                    AND E.submitted_datetime IS NOT NULL&#10;--&#10;UNION ALL&#10;--&#10;SELECT &#39;&#39;L3_2&#39;&#39; AS src, COUNT(DISTINCT L3.offender_id) AS num_of_rows&#10;FROM&#10;  L3&#10;    INNER JOIN spg_notification SN ON SN.offender_id             &#61; L3.offender_id&#10;                                  AND SN.receiver_identity_id    &#61; L3.probation_area_id&#10;                                  AND SN.processed_flag          &#61; 0&#10;                                  AND SN.business_interaction_id &#61; :p_BI_ALLOC_id&#10;--&#10;&#39;;&#10;    --&#10;    OPEN l_cur FOR l_SQL&#10;    USING&#10;      p_probation_area_id,&#10;      p_team_id,&#10;      p_staff_id,&#10;      l_bi_alloc_ID,&#10;      l_bi_alloc_ID&#10;    ;&#10;    --&#10;    FETCH l_cur BULK COLLECT INTO l_tab;&#10;    CLOSE l_cur;&#10;    --&#10;    FOR l_i IN 1..l_tab.COUNT LOOP&#10;        l_cnt :&#61; l_cnt + 1;&#10;        PIPE ROW ( l_tab(l_i) );&#10;    END LOOP;&#10;    --&#10;    procDebug( lc_proc || &#39; (rows&#61;&#39; || l_tab.COUNT  || &#39;)&#39;   ||&#10;        &#39;(&#39; || PKG_Debug.funcgetDbStats       || &#39;): &#39; ||&#10;        &#39;(p_area_id&#61;&#39;  || p_probation_area_id || &#39;)&#39;   ||&#10;        &#39;(p_team_id&#61;&#39;  || p_team_id           || &#39;)&#39;   ||&#10;        &#39;(p_staff_id&#61;&#39; || p_staff_id          || &#39;)&#39;   ||&#10;        l_SQL );&#10;    --&#10;EXCEPTION&#10;    WHEN NO_DATA_NEEDED THEN&#10;        procDebug( lc_proc || &#39; (&#39; || l_cnt || &#39; of &#39; || l_tab.COUNT || &#39; rows called from the cursor)&#39; ||&#10;            &#39;(&#39; || PKG_Debug.funcgetDbStats       || &#39;): &#39; ||&#10;            &#39;(p_area_id&#61;&#39;  || p_probation_area_id || &#39;)&#39;   ||&#10;            &#39;(p_team_id&#61;&#39;  || p_team_id           || &#39;)&#39;   ||&#10;            &#39;(p_staff_id&#61;&#39; || p_staff_id          || &#39;)&#39;   ||&#10;            l_SQL );&#10;    WHEN OTHERS THEN&#10;        procDebug( lc_proc || &#39; ERROR: &#39; || SQLERRM || &#39; &#39; ||&#10;            &#39;(p_area_id&#61;&#39;  || p_probation_area_id || &#39;)&#39;   ||&#10;            &#39;(p_team_id&#61;&#39;  || p_team_id           || &#39;)&#39;   ||&#10;            &#39;(p_staff_id&#61;&#39; || p_staff_id          || &#39;)&#39;   ||&#10;            l_SQL );&#10;    RAISE;&#10;END procGetOffCRCExtractSummaryTAB;&#10;--&#10;FUNCTION procGetOffCRCExtractTAB(&#10;    p_probation_area_id           NUMBER,&#10;    p_team_id                     NUMBER   DEFAULT -1,&#10;    p_staff_id                    NUMBER   DEFAULT -1,&#10;    p_excl_already_extracted_flag VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_incl_already_extracted_flag VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_crc_export_date_from        DATE     DEFAULT NULL,&#10;    p_crc_export_date_to          DATE     DEFAULT NULL,&#10;    p_crn                         VARCHAR2  DEFAULT NULL,&#10;    p_status_export_flag          SMALLINT  DEFAULT 0,&#10;    p_debug_flag                  VARCHAR2 DEFAULT &#39;Y&#39;,&#10;    --&#10;    p_max_rows                    INTEGER  DEFAULT -1,&#10;    p_max_rows_L1                 INTEGER  DEFAULT -1,&#10;    p_max_rows_L3                 INTEGER  DEFAULT -1 )&#10;RETURN ttabOffCRCExtract PIPELINED&#10;IS&#10;    --&#10;    lc_proc CONSTANT VARCHAR2(30) :&#61; &#39;procGetOffCRCExtractTAB&#39;;&#10;    --&#10;    TYPE l_cur_TYP IS REF CURSOR;&#10;    l_cur l_cur_TYP;&#10;    --&#10;    l_rec trecOffCRCExtract;&#10;    l_tab ttabOffCRCExtract;&#10;    --&#10;    l_SQL     CLOB;&#10;    --&#10;    l_cnt         INTEGER :&#61; 0;&#10;    l_cnt_L1      INTEGER :&#61; 0;&#10;    l_cnt_L3      INTEGER :&#61; 0;&#10;    l_max_rows    INTEGER;&#10;    l_max_rows_L1 INTEGER;&#10;    l_max_rows_L3 INTEGER;&#10;    --&#10;    l_L1_L3_flag           BOOLEAN;&#10;    l_include_record_flag  BOOLEAN;&#10;    --&#10;    TYPE l_tab_off_TYP IS TABLE OF VARCHAR2(1) INDEX BY VARCHAR2(50);&#10;    l_tab_off l_tab_off_TYP;&#10;    l_key     VARCHAR2(50);&#10;    --&#10;BEGIN&#10;    --&#10;    IF p_debug_flag &#61; &#39;Y&#39; THEN&#10;        PKG_Debug.procrecordDbStats_START;&#10;    END IF;&#10;    --&#10;    --TYPE trecOffCRCExtract IS RECORD(&#10;    --  /*00*/ offender_id NUMBER,&#10;    --  /*01*/ rbac_level  VARCHAR2(4),&#10;    --  /*02*/ entity_code VARCHAR2(2),&#10;    --  /*03*/ entity_name VARCHAR2(30),&#10;    --  /*04*/ entity_id   NUMBER );&#10;    --&#10;    l_SQL :&#61;&#10;&#39;WITH&#10;  L AS (&#10;    SELECT&#10;      CL.offender_id,&#10;      CL.trust_provider_team_id,&#10;      CL.staff_employee_id,&#10;      --&#10;      DECODE(CL.role_code, &#39;&#39;OM&#39;&#39;, &#39;&#39;L1&#39;&#39;, &#39;&#39;L3&#39;&#39;)                                          AS rbac_level,&#10;      CL.role_code,&#10;      DECODE(CL.role_code,&#10;          &#39;&#39;OM&#39;&#39; , &#39;&#39;OFFENDER&#39;&#39;,&#10;          &#39;&#39;OS&#39;&#39; , &#39;&#39;EVENT&#39;&#39;,&#10;          &#39;&#39;LC&#39;&#39; , &#39;&#39;LIC_CONDITION&#39;&#39;,&#10;          &#39;&#39;RQ&#39;&#39; , &#39;&#39;RQMNT&#39;&#39;,&#10;          &#39;&#39;PQ&#39;&#39; , &#39;&#39;PSS_RQMNT&#39;&#39;,&#10;          &#39;&#39;NSI&#39;&#39;, &#39;&#39;NSI&#39;&#39;,&#10;          &#39;&#39;RM&#39;&#39; , (CASE WHEN CL.court_report_id IS NOT NULL THEN &#39;&#39;CR&#39;&#39; ELSE &#39;&#39;IR&#39;&#39; END)&#10;      )                                                                                     AS entity_name,&#10;      DECODE(CL.role_code,&#10;          &#39;&#39;OM&#39;&#39; , CL.offender_id,&#10;          &#39;&#39;OS&#39;&#39; , CL.event_id,&#10;          &#39;&#39;LC&#39;&#39; , CL.lic_condition_id,&#10;          &#39;&#39;RQ&#39;&#39; , CL.rqmnt_id,&#10;          &#39;&#39;PQ&#39;&#39; , CL.pss_rqmnt_id,&#10;          &#39;&#39;NSI&#39;&#39;, CL.nsi_id,&#10;          &#39;&#39;RM&#39;&#39; , NVL(CL.court_report_id, CL.institutional_report_id)&#10;      )                                                                                     AS entity_id&#10;    FROM&#10;      caseload CL&#10;        INNER JOIN offender O ON O.offender_id &#61; CL.offender_id&#10;        INNER JOIN all_team T ON T.trust_provider_flag &#61; CL.trust_provider_flag AND T.trust_provider_team_id &#61; CL.trust_provider_team_id&#10;        &#39; ||&#10;        CASE WHEN p_incl_already_extracted_flag &#61; &#39;Y&#39; THEN&#10;            &#39;INNER JOIN offender_crc_export OE ON OE.offender_id &#61; CL.offender_id AND OE.crc_provider_id &#61; T.probation_area_id AND OE.current_record_flag &#61; &#39;&#39;Y&#39;&#39;&#39; ||&#10;            &#39; AND ( &#39; || CASE WHEN p_crc_export_date_from IS NOT NULL THEN &#39;OE.export_date IS NULL OR OE.export_date &gt;&#61; TRUNC(:p_date_from)&#39; ELSE &#39;:p_date_from IS NULL&#39; END || &#39; )&#39; ||&#10;            &#39; AND ( &#39; || CASE WHEN p_crc_export_date_to   IS NOT NULL THEN &#39;OE.export_date IS NULL OR OE.export_date &lt;&#61; TRUNC(:p_date_to)&#39;   ELSE &#39;:p_date_to IS NULL&#39;   END || &#39; )&#39; ||&#10;            &#39; AND ( &#39; || CASE&#10;                             WHEN p_status_export_flag &#61; 0 /*All*/       THEN &#39;1&#61;1&#39;&#10;                             WHEN p_status_export_flag &#61; 1 /*Processed*/ THEN &#39;submitted_datetime IS NOT NULL AND NVL(error_flag, 0) &#61; 0&#39;&#10;                             WHEN p_status_export_flag &#61; 2 /*Errored*/   THEN &#39;error_flag &gt; 0&#39;&#10;                             WHEN p_status_export_flag &#61; 3 /*Completed*/ THEN &#39;submitted_datetime IS NOT NULL AND processed_datetime IS NOT NULL AND NVL(error_flag, 0) &#61; 0&#39;&#10;                             ELSE &#39;1&#61;1&#39;&#10;                         END || &#39; )&#39;&#10;        END || &#39;&#10;    WHERE 1&#61;1&#10;      AND CL.role_code NOT IN ( &#39;&#39;POM&#39;&#39; )&#10;      /*DST-4984: excluding the Court Report linked to Presentence event*/&#10;      AND ( CL.court_report_id IS NULL OR ( CL.court_report_id IS NOT NULL AND CL.disposal_id IS NOT NULL ) )&#10;      &#39; || CASE WHEN p_excl_already_extracted_flag &#61; &#39;Y&#39; THEN&#10;     &#39;AND NOT EXISTS(&#10;          SELECT 1&#10;          FROM offender_crc_export&#10;          WHERE offender_id         &#61; CL.offender_id&#10;            AND crc_provider_id     &#61; T.probation_area_id&#10;            AND current_record_flag &#61; &#39;&#39;Y&#39;&#39;&#10;            AND NVL(error_flag, 0)  &#61; 0&#10;            AND submitted_datetime IS NOT NULL&#10;            --SPG-12417: Exclude PROCESSED (not COMPLETED) records&#10;            --AND processed_datetime IS NOT NULL&#10;          )&#39;&#10;      END || &#39;&#10;      AND T.trust_provider_flag &#61; 0&#10;      AND T.probation_area_id &#61; :p_probation_area_id&#10;      AND &#39; || CASE WHEN EMPTY2NULL(TRIM(p_crn)) IS NOT NULL THEN &#39;O.crn &#61; :p_crn&#39; ELSE &#39;:p_crn IS NULL&#39; END || &#39;&#10;  ),&#10;  L1 AS (&#10;    SELECT DISTINCT&#10;      offender_id,&#10;      &#39;&#39;L1&#39;&#39; AS rbac_level&#10;    FROM L&#10;    WHERE rbac_level &#61; &#39;&#39;L1&#39;&#39;&#10;    ),&#10;  T AS (&#10;    SELECT DISTINCT&#10;      L.offender_id,&#10;      L.trust_provider_team_id,&#10;      L.staff_employee_id,&#10;      --&#10;      NVL(L1.rbac_level, L.rbac_level) AS rbac_level,&#10;      L.role_code,&#10;      L.entity_name,&#10;      L.entity_id,&#10;      L.entity_name || &#39;&#39;_&#39;&#39; || L.entity_id AS entity_unique_key&#10;    FROM L, L1&#10;    WHERE L1.offender_id(+) &#61; L.offender_id&#10;    )&#10;--&#10;SELECT DISTINCT offender_id, rbac_level, role_code, entity_name, entity_id&#10;FROM T T1&#10;WHERE 1&#61;1&#10;  AND &#39; || CASE WHEN NVL(p_team_id, -1)  &gt; 0 THEN &#39;trust_provider_team_id &#61; :p_team_id&#39; ELSE &#39;NVL(:p_team_id, -1) &lt; 0&#39;  END || &#39;&#10;  AND &#39; || CASE WHEN NVL(p_staff_id, -1) &gt; 0 THEN &#39;staff_employee_id &#61; :p_staff_id&#39;     ELSE &#39;NVL(:p_staff_id, -1) &lt; 0&#39; END || &#39;&#10;  -- Extra criteria that was implemented in version 1.198:&#10;  -- L1 records can only be at OM level + {offender_id, RBAC_LEVEL} must be unique (i.e. a random sample for Offender&quot;s L3 set)&#10;  AND (&#10;        ( rbac_level &#61; &#39;&#39;L1&#39;&#39; AND role_code &#61; &#39;&#39;OM&#39;&#39; )&#10;        OR&#10;        ( rbac_level &#61; &#39;&#39;L3&#39;&#39; )&#10;      )&#10;ORDER BY offender_id, rbac_level&#10;&#39;;&#10;    --&#10;    IF p_incl_already_extracted_flag &#61; &#39;Y&#39; THEN&#10;        OPEN l_cur FOR l_SQL&#10;        USING&#10;          p_crc_export_date_from,&#10;          p_crc_export_date_to,&#10;          p_probation_area_id,&#10;          EMPTY2NULL(TRIM(p_crn)),&#10;          p_team_id, p_staff_id&#10;        ;&#10;    ELSE&#10;        OPEN l_cur FOR l_SQL&#10;        USING&#10;          p_probation_area_id,&#10;          EMPTY2NULL(TRIM(p_crn)),&#10;          p_team_id, p_staff_id&#10;        ;&#10;    END IF;&#10;    --&#10;    FETCH l_cur BULK COLLECT INTO l_tab;&#10;    CLOSE l_cur;&#10;    --&#10;    IF NVL(p_max_rows, -1) &#61; -1 THEN&#10;        l_max_rows :&#61; l_tab.COUNT;&#10;    ELSE&#10;        l_max_rows :&#61; p_max_rows; --LEAST(NVL(l_tab.COUNT, 0), p_max_rows);&#10;    END IF;&#10;    --&#10;    SELECT&#10;      CASE WHEN NVL(p_max_rows_L1, -1) &gt;&#61; 0 THEN p_max_rows_L1 ELSE /*l_max_rows*/ -1 END AS max_rows_L1,&#10;      CASE WHEN NVL(p_max_rows_L3, -1) &gt;&#61; 0 THEN p_max_rows_L3 ELSE /*l_max_rows*/ -1 END AS max_rows_L3&#10;    INTO&#10;      l_max_rows_L1,&#10;      l_max_rows_L3&#10;    FROM dual;&#10;    --&#10;    IF l_max_rows_L1 &gt; 0 AND l_max_rows_L3 &#61; -1 THEN&#10;        l_max_rows_L3 :&#61; 0;&#10;    ELSIF l_max_rows_L3 &gt; 0 AND l_max_rows_L1 &#61; -1 THEN&#10;        l_max_rows_L1 :&#61; 0;&#10;    END IF;&#10;    --&#10;    l_L1_L3_flag :&#61; (l_max_rows_L1 &#61; -1 AND l_max_rows_L3 &#61; -1);&#10;    --&#10;    IF l_max_rows_L1 &gt; 0 AND l_max_rows_L3 &gt; 0 THEN&#10;        raise_error(&#39;ERROR: p_max_rows_L1&#61;&#39; || l_max_rows_L1 || &#39;, p_max_rows_L3&#61;&#39; || l_max_rows_L3 || &#39; parameters are mutually exclusive (only one can be set to &gt; than 0 value)&#39;, lc_proc);&#10;    END IF;&#10;    procDebug(lc_proc || &#39;: L1_L3_flag&#61;&#39; || CASE WHEN l_L1_L3_flag THEN &#39;TRUE&#39; ELSE &#39;FALSE&#39; END || &#39;, max_rows_L1&#61;&#39; || l_max_rows_L1 || &#39;, max_rows_L3&#61;&#39; || l_max_rows_L3 || &#39;, max_rows&#61;&#39; || l_max_rows);&#10;    --procDebug(&#39;l_max_rows_L3&#61;&#39; || l_max_rows_L3);&#10;    --&#10;    FOR l_i IN 1..l_tab.COUNT LOOP&#10;        --&#10;        l_rec :&#61; l_tab(l_i);&#10;        --&#10;        l_key :&#61; l_rec.rbac_level || &#39;|&#39; || l_rec.offender_id;&#10;        IF NOT l_tab_OFF.EXISTS(l_key) THEN&#10;            l_tab_OFF(l_key) :&#61; &#39;Y&#39;;&#10;            --&#10;            IF l_rec.rbac_level &#61; &#39;L1&#39; THEN&#10;                l_cnt_L1 :&#61; l_cnt_L1 + 1;&#10;                l_include_record_flag :&#61; ( (l_L1_L3_flag &#61; TRUE) OR (l_max_rows_L1 &#61; -1) OR (l_cnt_L1 &lt;&#61; l_max_rows_L1) );&#10;            ELSIF l_rec.rbac_level &#61; &#39;L3&#39; THEN&#10;                l_cnt_L3 :&#61; l_cnt_L3 + 1;&#10;                l_include_record_flag :&#61; ( (l_L1_L3_flag &#61; TRUE) OR (l_max_rows_L3 &#61; -1) OR (l_cnt_L3 &lt;&#61; l_max_rows_L3) );&#10;            ELSE&#10;                l_include_record_flag :&#61; FALSE;&#10;            END IF;&#10;        ELSE&#10;            l_include_record_flag :&#61; FALSE;&#10;        END IF;&#10;        --&#10;        IF l_include_record_flag THEN&#10;            l_cnt :&#61; l_cnt + 1;&#10;            PIPE ROW ( l_rec );&#10;        END IF;&#10;        --&#10;        EXIT WHEN l_cnt &gt;&#61; l_max_rows;&#10;        --&#10;    END LOOP;&#10;    --&#10;    procDebug( lc_proc || &#39; (rows&#61;&#39; || l_tab.COUNT  || &#39;)&#39;   ||&#10;        &#39;(&#39; || PKG_Debug.funcgetDbStats   || &#39;): &#39; ||&#10;        &#39;(p_area_id&#61;&#39;                     || p_probation_area_id           || &#39;)&#39; ||&#10;        &#39;(p_team_id&#61;&#39;                     || p_team_id                     || &#39;)&#39; ||&#10;        &#39;(p_staff_id&#61;&#39;                    || p_staff_id                    || &#39;)&#39; ||&#10;        &#39;(p_excl_already_extracted_flag&#61;&#39; || p_excl_already_extracted_flag || &#39;)&#39; ||&#10;        &#39;(p_incl_already_extracted_flag&#61;&#39; || p_incl_already_extracted_flag || &#39;)&#39; ||&#10;        &#39;(p_crc_export_date_from&#61;&#39;        || p_crc_export_date_from        || &#39;)&#39; ||&#10;        &#39;(p_crc_export_date_to&#61;&#39;          || p_crc_export_date_to          || &#39;)&#39; ||&#10;        &#39;(p_crn&#61;&#39;                         || p_crn                         || &#39;)&#39; ||&#10;        &#39;(p_status_export_flag&#61;&#39;          || p_status_export_flag          || &#39;)&#39; ||&#10;        &#39;(p_max_rows&#61;&#39;                    || p_max_rows                    || &#39;)&#39; ||&#10;        &#39;(p_max_rows_L1&#61;&#39;                 || p_max_rows_L1                 || &#39;)&#39; ||&#10;        &#39;(p_max_rows_L3&#61;&#39;                 || p_max_rows_L3                 || &#39;)&#39; ||&#10;        l_SQL );&#10;    --&#10;EXCEPTION&#10;    WHEN NO_DATA_NEEDED THEN&#10;        procDebug( lc_proc || &#39; (&#39; || l_cnt || &#39; of &#39; || l_tab.COUNT || &#39; rows called from the cursor)&#39; ||&#10;            &#39;(&#39; || PKG_Debug.funcgetDbStats   || &#39;): &#39; ||&#10;            &#39;(p_area_id&#61;&#39;                     || p_probation_area_id           || &#39;)&#39; ||&#10;            &#39;(p_team_id&#61;&#39;                     || p_team_id                     || &#39;)&#39; ||&#10;            &#39;(p_staff_id&#61;&#39;                    || p_staff_id                    || &#39;)&#39; ||&#10;            &#39;(p_excl_already_extracted_flag&#61;&#39; || p_excl_already_extracted_flag || &#39;)&#39; ||&#10;            &#39;(p_incl_already_extracted_flag&#61;&#39; || p_incl_already_extracted_flag || &#39;)&#39; ||&#10;            &#39;(p_crc_export_date_from&#61;&#39;        || p_crc_export_date_from        || &#39;)&#39; ||&#10;            &#39;(p_crc_export_date_to&#61;&#39;          || p_crc_export_date_to          || &#39;)&#39; ||&#10;            &#39;(p_crn&#61;&#39;                         || p_crn                         || &#39;)&#39; ||&#10;            &#39;(p_status_export_flag&#61;&#39;          || p_status_export_flag          || &#39;)&#39; ||&#10;            &#39;(p_max_rows&#61;&#39;                    || p_max_rows                    || &#39;)&#39; ||&#10;            &#39;(p_max_rows_L1&#61;&#39;                 || p_max_rows_L1                 || &#39;)&#39; ||&#10;            &#39;(p_max_rows_L3&#61;&#39;                 || p_max_rows_L3                 || &#39;)&#39; ||&#10;            l_SQL );&#10;    WHEN OTHERS THEN&#10;        procDebug( lc_proc || &#39; ERROR: &#39; || SQLERRM || &#39; &#39; ||&#10;            &#39;(p_area_id&#61;&#39;                     || p_probation_area_id           || &#39;)&#39; ||&#10;            &#39;(p_team_id&#61;&#39;                     || p_team_id                     || &#39;)&#39; ||&#10;            &#39;(p_staff_id&#61;&#39;                    || p_staff_id                    || &#39;)&#39; ||&#10;            &#39;(p_excl_already_extracted_flag&#61;&#39; || p_excl_already_extracted_flag || &#39;)&#39; ||&#10;            &#39;(p_incl_already_extracted_flag&#61;&#39; || p_incl_already_extracted_flag || &#39;)&#39; ||&#10;            &#39;(p_crc_export_date_from&#61;&#39;        || p_crc_export_date_from        || &#39;)&#39; ||&#10;            &#39;(p_crc_export_date_to&#61;&#39;          || p_crc_export_date_to          || &#39;)&#39; ||&#10;            &#39;(p_crn&#61;&#39;                         || p_crn                         || &#39;)&#39; ||&#10;            &#39;(p_status_export_flag&#61;&#39;          || p_status_export_flag          || &#39;)&#39; ||&#10;            &#39;(p_max_rows&#61;&#39;                    || p_max_rows                    || &#39;)&#39; ||&#10;            l_SQL );&#10;    RAISE;&#10;END procGetOffCRCExtractTAB;&#10;--&#10;FUNCTION procGetOffCRCExtractedOffTAB(&#10;    p_probation_area_id           NUMBER,&#10;    p_team_id                     NUMBER    DEFAULT -1,&#10;    p_staff_id                    NUMBER    DEFAULT -1,&#10;    p_crc_export_date_from        DATE      DEFAULT NULL,&#10;    p_crc_export_date_to          DATE      DEFAULT NULL,&#10;    p_crn                         VARCHAR2  DEFAULT NULL,&#10;    p_status_export_flag          SMALLINT  DEFAULT 0,&#10;    p_max_rows                    INTEGER   DEFAULT 10000 )&#10;RETURN ttabOffCRCExtractedOff PIPELINED&#10;IS&#10;--&#10;    lc_proc CONSTANT VARCHAR2(30) :&#61; &#39;procGetOffCRCExtractedOffTAB&#39;;&#10;    --&#10;    TYPE l_cur_TYP IS REF CURSOR;&#10;    l_cur l_cur_TYP;&#10;    --&#10;    l_rec trecOffCRCExtractedOff;&#10;    l_tab ttabOffCRCExtractedOff;&#10;    --&#10;    l_SQL     CLOB;&#10;    --&#10;    l_cnt         INTEGER :&#61; 0;&#10;    l_max_rows    INTEGER;&#10;    --&#10;BEGIN&#10;    --&#10;    PKG_Debug.procrecordDbStats_START;&#10;    --&#10;    l_SQL :&#61;&#10;&#39;WITH&#10;  E AS (&#10;    SELECT DISTINCT offender_id, rbac_level&#10;    FROM TABLE( PKG_SPG_EXPORT.procGetOffCRCExtractTAB(:p_probation_area_id, :p_team_id, :p_staff_id, &#39;&#39;N&#39;&#39;, &#39;&#39;Y&#39;&#39;, :p_extracted_date_from, :p_extracted_date_to, :p_crn, :p_status_export_flag, &#39;&#39;N&#39;&#39;, p_max_rows&#61;&gt;-1) )&#10;  ),&#10;  E1 AS (&#10;    SELECT offender_id, MIN(rbac_level) AS rbac_level FROM E GROUP BY offender_id&#10;  )&#10;--&#10;SELECT&#10;  /*00*/ E1.offender_id,&#10;  /*01*/ O.first_name,&#10;  /*02*/ O.second_name,&#10;  /*03*/ O.surname,&#10;  /*04*/ O.crn,&#10;  --&#10;  /*05*/ OM.probation_area_id,&#10;  /*06*/ PA.code        AS probation_area_code,&#10;  /*07*/ PA.description AS probation_area_desc,&#10;  --&#10;  /*08*/ OM.trust_provider_flag,&#10;  /*09*/ OM.trust_provider_team_id,&#10;  /*10*/ NVL(T1.code, T2.code)          AS team_code,&#10;  /*11*/ T.description                  AS team_desc,&#10;  /*12*/ OM.staff_employee_id,&#10;  /*13*/ NVL(S1.officer_code, S2.code)  AS staff_code,&#10;  /*14*/ S.forename                     AS staff_first_name,&#10;  /*15*/ S.forename2                    AS staff_second_name,&#10;  /*16*/ S.surname                      AS staff_surname,&#10;  --&#10;  /*17*/ OE.export_date,&#10;  /*18*/ E1.rbac_level,&#10;  /*19*/ OE.crc_provider_id,&#10;  --&#10;  /*20*/ OE.row_version,&#10;  /*21*/ OE.created_by_user_id,&#10;  /*22*/ OE.created_datetime,&#10;  /*23*/ OE.last_updated_user_id,&#10;  /*24*/ OE.last_updated_datetime,&#10;  /*25*/ OE.requested_export_level,&#10;  /*26*/ OE.error_flag,&#10;  /*27*/ OE.submitted_datetime,&#10;  /*28*/ OE.processed_datetime,&#10;  /*29*/ OE.error_message,&#10;  /*30*/ OE.spg_notification_id,&#10;  /*31*/ OE.offender_crc_export_id,&#10;  /*32*/ O.current_exclusion,&#10;  /*33*/ O.current_restriction,&#10;  /*34*/ OE.batch_flag&#10;  --&#10;FROM&#10;  E1&#10;    INNER JOIN offender_crc_export OE ON OE.offender_id &#61; E1.offender_id AND crc_provider_id &#61; :p_probation_area_id AND OE.current_record_flag &#61; &#39;&#39;Y&#39;&#39;&#10;    INNER JOIN offender O          ON O.offender_id &#61; E1.offender_id&#10;      INNER JOIN offender_manager OM ON OM.offender_id &#61; O.offender_id AND OM.active_flag &#61; 1&#10;        INNER JOIN all_team T ON T.trust_provider_flag &#61; OM.trust_provider_flag AND T.trust_provider_team_id &#61; OM.trust_provider_team_id&#10;          INNER JOIN probation_area PA ON PA.probation_area_id &#61; T.probation_area_id&#10;          LEFT OUTER JOIN team T1 ON T1.team_id &#61; T.trust_provider_team_id AND T.trust_provider_flag &#61; 0&#10;          LEFT OUTER JOIN provider_team T2 ON T2.provider_team_id &#61; T.trust_provider_team_id AND T.trust_provider_flag &#61; 1&#10;        INNER JOIN officer S ON S.trust_provider_flag &#61; OM.trust_provider_flag AND S.staff_employee_id &#61; OM.staff_employee_id&#10;          LEFT OUTER JOIN staff S1 ON S1.staff_id &#61; S.staff_employee_id AND S.trust_provider_flag &#61; 0&#10;          LEFT OUTER JOIN provider_employee S2 ON S2.provider_employee_id &#61; S.staff_employee_id AND S.trust_provider_flag &#61; 1&#10;WHERE 1&#61;1&#10;ORDER BY 1, 2&#39;;&#10;    --&#10;    OPEN l_cur FOR l_SQL&#10;    USING&#10;      p_probation_area_id, p_team_id, p_staff_id,&#10;      p_crc_export_date_from, p_crc_export_date_to,&#10;      p_crn, p_status_export_flag,&#10;      p_probation_area_id;&#10;    --&#10;    FETCH l_cur BULK COLLECT INTO l_tab;&#10;    CLOSE l_cur;&#10;    --&#10;    IF NVL(p_max_rows, 10000) &#61; -1 THEN&#10;        l_max_rows :&#61; l_tab.COUNT;&#10;    ELSE&#10;        l_max_rows :&#61; LEAST(NVL(l_tab.COUNT, 0), NVL(p_max_rows, 10000));&#10;    END IF;&#10;    --&#10;    FOR l_i IN 1..l_max_rows LOOP&#10;        l_cnt :&#61; l_cnt + 1;&#10;        l_rec :&#61; l_tab(l_i);&#10;        --&#10;        PIPE ROW ( l_rec );&#10;        --&#10;    END LOOP;&#10;    --&#10;    procDebug( lc_proc || &#39; (rows&#61;&#39; || l_tab.COUNT  || &#39;)&#39;   ||&#10;        &#39;(&#39; || PKG_Debug.funcgetDbStats   || &#39;): &#39; ||&#10;        &#39;(p_area_id&#61;&#39;                     || p_probation_area_id           || &#39;)&#39; ||&#10;        &#39;(p_team_id&#61;&#39;                     || p_team_id                     || &#39;)&#39; ||&#10;        &#39;(p_staff_id&#61;&#39;                    || p_staff_id                    || &#39;)&#39; ||&#10;        &#39;(p_crc_export_date_from&#61;&#39;        || p_crc_export_date_from        || &#39;)&#39; ||&#10;        &#39;(p_crc_export_date_to&#61;&#39;          || p_crc_export_date_to          || &#39;)&#39; ||&#10;        &#39;(p_crn&#61;&#39;                         || p_crn                         || &#39;)&#39; ||&#10;        &#39;(p_status_export_flag&#61;&#39;          || p_status_export_flag          || &#39;)&#39; ||&#10;        &#39;(p_max_rows&#61;&#39;                    || p_max_rows                    || &#39;)&#39; ||&#10;        l_SQL );&#10;    --&#10;EXCEPTION&#10;    WHEN NO_DATA_NEEDED THEN&#10;        procDebug( lc_proc || &#39; (&#39; || l_cnt || &#39; of &#39; || l_tab.COUNT || &#39; rows called from the cursor)&#39; ||&#10;            &#39;(&#39; || PKG_Debug.funcgetDbStats   || &#39;): &#39; ||&#10;            &#39;(p_area_id&#61;&#39;                     || p_probation_area_id           || &#39;)&#39; ||&#10;            &#39;(p_team_id&#61;&#39;                     || p_team_id                     || &#39;)&#39; ||&#10;            &#39;(p_staff_id&#61;&#39;                    || p_staff_id                    || &#39;)&#39; ||&#10;            &#39;(p_crc_export_date_from&#61;&#39;        || p_crc_export_date_from        || &#39;)&#39; ||&#10;            &#39;(p_crc_export_date_to&#61;&#39;          || p_crc_export_date_to          || &#39;)&#39; ||&#10;            &#39;(p_crn&#61;&#39;                         || p_crn                         || &#39;)&#39; ||&#10;            &#39;(p_status_export_flag&#61;&#39;          || p_status_export_flag          || &#39;)&#39; ||&#10;            &#39;(p_max_rows&#61;&#39;                    || p_max_rows                    || &#39;)&#39; ||&#10;            l_SQL );&#10;    WHEN OTHERS THEN&#10;        procDebug( lc_proc || &#39; ERROR: &#39; || SQLERRM || &#39; &#39; ||&#10;            &#39;(p_area_id&#61;&#39;                     || p_probation_area_id           || &#39;)&#39; ||&#10;            &#39;(p_team_id&#61;&#39;                     || p_team_id                     || &#39;)&#39; ||&#10;            &#39;(p_staff_id&#61;&#39;                    || p_staff_id                    || &#39;)&#39; ||&#10;            &#39;(p_crc_export_date_from&#61;&#39;        || p_crc_export_date_from        || &#39;)&#39; ||&#10;            &#39;(p_crc_export_date_to&#61;&#39;          || p_crc_export_date_to          || &#39;)&#39; ||&#10;            &#39;(p_crn&#61;&#39;                         || p_crn                         || &#39;)&#39; ||&#10;            &#39;(p_status_export_flag&#61;&#39;          || p_status_export_flag          || &#39;)&#39; ||&#10;            &#39;(p_max_rows&#61;&#39;                    || p_max_rows                    || &#39;)&#39; ||&#10;            l_SQL );&#10;        RAISE;&#10;END procGetOffCRCExtractedOffTAB;&#10;&#10;--&#10;-- CRC Extract DB trigger support subroutines&#10;--&#10;FUNCTION get_override_bi(&#10;    p_business_interaction_id NUMBER,&#10;    p_action                  VARCHAR2,&#10;    p_fld                     VARCHAR2 DEFAULT &#39;ID&#39;)&#10;RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN&#10;        PKG_Lookups.funcgetTabRecord_CACHED(&#10;            p_data_fld&#61;&gt; &#39;BI.&#39; || CASE WHEN UPPER(p_fld) &#61; &#39;CODE&#39; THEN &#39;business_interaction_code&#39; ELSE &#39;business_interaction_id&#39; END,&#10;            p_table   &#61;&gt; &#39;business_int_xml_map BIM1, business_interaction BI1, business_int_xml_map BIM, business_interaction BI&#39;,&#10;            p_ref_col &#61;&gt; &#39;BIM1.business_interaction_id&#39;,&#10;            p_ref_val &#61;&gt; p_business_interaction_id,&#10;            p_where   &#61;&gt; &#39;BIM1.xsd_number &#61; :p_xsd_number&#10;                      AND BI1.business_interaction_id &#61; BIM1.business_interaction_id&#10;                      AND BIM.root_xml_message_id &#61; BIM1.root_xml_message_id&#10;                      AND BIM.xsd_number &#61; BIM1.xsd_number&#10;                      AND BIM.include_xml_message_list &#61; BIM1.include_xml_message_list&#10;                      AND BIM.data_update_mode &#61; :p_action&#10;                      AND BI.business_interaction_id &#61; BIM.business_interaction_id&#10;                      AND BI.business_interaction_code LIKE RTRIM(BI1.business_interaction_code, SUBSTR(BI1.business_interaction_code, -3)) || &#39;&#39;%&#39;&#39;&#39;,&#10;            p_bind_var1 &#61;&gt; TO_CHAR(NVL(SPGMESSAGE.GC_SCHEMA_NUMBER, 1)),&#10;            p_bind_var2 &#61;&gt; UPPER(p_action) );&#10;END get_override_bi;&#10;&#10;PROCEDURE do_dedup_messages(p_offender_id NUMBER, p_crc_probation_area_id NUMBER, x_max_spg_notification_id OUT NUMBER)&#10;IS&#10;    --&#10;    lc_proc CONSTANT VARCHAR2(30) :&#61; &#39;DO_DEDUP_MESSAGES&#39;;&#10;    --&#10;    l_not_processed_flag NUMBER :&#61; 0;&#10;    l_deferred_flag      NUMBER :&#61; 2;&#10;    l_deduplicated_flag  NUMBER :&#61; 3;&#10;    --&#10;    CURSOR cs IS&#10;      WITH&#10;        T_DUPL AS (&#10;          SELECT&#10;            S.offender_id,&#10;            S.unique_id,&#10;            S.receiver_identity_id,&#10;            BIM.root_xml_message_id,&#10;            BIM.include_xml_message_list,&#10;            COUNT(1) qty,&#10;            MIN(spg_notification_id) min_spg_notification_id,&#10;            MAX(spg_notification_id) max_spg_notification_id&#10;          FROM&#10;            spg_notification S,&#10;            business_int_xml_map BIM&#10;          WHERE BIM.business_interaction_id &#61; S.business_interaction_id&#10;            AND S.processed_flag &#61; l_deferred_flag&#10;            AND S.offender_id &#61; p_offender_id&#10;            AND S.receiver_identity_id &#61; p_crc_probation_area_id&#10;            AND BIM.xsd_number &#61; NVL(SPGMESSAGE.GC_SCHEMA_NUMBER, 1)&#10;          GROUP BY&#10;            S.offender_id,&#10;            S.unique_id,&#10;            S.receiver_identity_id,&#10;            BIM.root_xml_message_id,&#10;            BIM.include_xml_message_list&#10;          HAVING COUNT(1) &gt; 1 ),&#10;        T AS (&#10;          SELECT&#10;            BI.business_interaction_code,&#10;            BIM.root_xml_message_id       AS xml_msg_id,&#10;            BIM.include_xml_message_list  AS xml_msg_lst,&#10;            BIM.data_update_mode          AS action,&#10;            &#39;DELETE&#39;                      AS status,&#10;            T_DEL.ROWID                   AS row_id,&#10;            T_DEL.*&#10;          FROM&#10;            T_DUPL,&#10;            spg_notification     T_DEL,&#10;            business_interaction BI,&#10;            business_int_xml_map BIM&#10;          WHERE BI.business_interaction_id &#61; T_DEL.business_interaction_id&#10;            AND BIM.business_interaction_id &#61; T_DEL.business_interaction_id&#10;            AND T_DEL.processed_flag &#61; l_deferred_flag&#10;            AND T_DEL.offender_id &#61; T_DUPL.offender_id&#10;            AND T_DEL.unique_id   &#61; T_DUPL.unique_id&#10;            AND BIM.root_xml_message_id &#61; T_DUPL.root_xml_message_id&#10;            AND BIM.xsd_number &#61; NVL(SPGMESSAGE.GC_SCHEMA_NUMBER, 1)&#10;            AND BIM.include_xml_message_list &#61; T_DUPL.include_xml_message_list&#10;            AND T_DEL.spg_notification_id &lt; T_DUPL.max_spg_notification_id&#10;          UNION ALL&#10;          SELECT&#10;            BI.business_interaction_code,&#10;            BIM.root_xml_message_id       AS xml_msg_id,&#10;            BIM.include_xml_message_list  AS xml_msg_lst,&#10;            BIM.data_update_mode          AS action,&#10;            &#39;RETAIN&#39;                      AS status,&#10;            T_RETAIN.ROWID                AS row_id,&#10;            T_RETAIN.*&#10;          FROM&#10;            T_DUPL,&#10;            spg_notification     T_RETAIN,&#10;            business_interaction BI,&#10;            business_int_xml_map BIM&#10;          WHERE BI.business_interaction_id &#61; T_RETAIN.business_interaction_id&#10;            AND BIM.business_interaction_id &#61; T_RETAIN.business_interaction_id&#10;            AND T_RETAIN.processed_flag &#61; l_deferred_flag&#10;            AND T_RETAIN.offender_id &#61; T_DUPL.offender_id&#10;            AND T_RETAIN.unique_id   &#61; T_DUPL.unique_id&#10;            AND BIM.root_xml_message_id &#61; T_DUPL.root_xml_message_id&#10;            AND BIM.xsd_number &#61; NVL(SPGMESSAGE.GC_SCHEMA_NUMBER, 1)&#10;            AND BIM.include_xml_message_list &#61; T_DUPL.include_xml_message_list&#10;            AND T_RETAIN.spg_notification_id &#61; T_DUPL.max_spg_notification_id )&#10;      --&#10;      SELECT&#10;--        T.business_interaction_id      AS bi_id,&#10;--        T.business_interaction_code    AS bi_code,&#10;--        --&#10;--        BIM_I.business_interaction_id  AS bi_id_INS,&#10;--        BI_I.business_interaction_code AS bi_code_INS,&#10;--        --&#10;--        BIM_U.business_interaction_id  AS bi_id_UPD,&#10;--        BI_U.business_interaction_code AS bi_code_UPD,&#10;--        --&#10;--        BIM_D.business_interaction_id  AS bi_id_DEL,&#10;--        BI_D.business_interaction_code AS bi_code_DEL,&#10;--        --&#10;        T.*&#10;      FROM&#10;        T&#10;--          LEFT OUTER JOIN business_int_xml_map BIM_I ON BIM_I.root_xml_message_id &#61; T.xml_msg_id AND BIM_I.include_xml_message_list &#61; T.xml_msg_lst AND BIM_I.data_update_mode &#61; &#39;I&#39; AND BIM_I.xsd_number &#61; NVL(SPGMESSAGE.GC_SCHEMA_NUMBER, 1)&#10;--            LEFT OUTER JOIN business_interaction BI_I ON BI_I.business_interaction_id &#61; BIM_I.business_interaction_id AND BI_I.business_interaction_code LIKE RTRIM(T.business_interaction_code, SUBSTR(T.business_interaction_code, -3)) || &#39;%&#39;&#10;--          LEFT OUTER JOIN business_int_xml_map BIM_U ON BIM_U.root_xml_message_id &#61; T.xml_msg_id AND BIM_U.include_xml_message_list &#61; T.xml_msg_lst AND BIM_U.data_update_mode &#61; &#39;U&#39; AND BIM_U.xsd_number &#61; NVL(SPGMESSAGE.GC_SCHEMA_NUMBER, 1)&#10;--            LEFT OUTER JOIN business_interaction BI_U ON BI_U.business_interaction_id &#61; BIM_U.business_interaction_id AND BI_U.business_interaction_code LIKE RTRIM(T.business_interaction_code, SUBSTR(T.business_interaction_code, -3)) || &#39;%&#39;&#10;--          LEFT OUTER JOIN business_int_xml_map BIM_D ON BIM_D.root_xml_message_id &#61; T.xml_msg_id AND BIM_D.include_xml_message_list &#61; T.xml_msg_lst AND BIM_D.data_update_mode &#61; &#39;U&#39; AND BIM_D.xsd_number &#61; NVL(SPGMESSAGE.GC_SCHEMA_NUMBER, 1)&#10;--            LEFT OUTER JOIN business_interaction BI_D ON BI_D.business_interaction_id &#61; BIM_D.business_interaction_id AND BI_D.business_interaction_code LIKE RTRIM(T.business_interaction_code, SUBSTR(T.business_interaction_code, -3)) || &#39;%&#39;&#10;      WHERE 1&#61;1&#10;      ORDER BY&#10;        T.xml_msg_id,&#10;        T.xml_msg_lst,&#10;        T.offender_id,&#10;        T.unique_id,&#10;        T.spg_notification_id;&#10;      --&#10;      l_last_xml_msg_lst        VARCHAR2(1024) :&#61; &#39;X&#39;;&#10;      l_last_xml_msg_id         NUMBER         :&#61; -1;&#10;      l_last_unique_id          NUMBER         :&#61; -1;&#10;      --&#10;      l_key_dedup_count         INTEGER        :&#61; 0;&#10;      l_max_spg_notification_id NUMBER         :&#61; 0;&#10;      --&#10;      l_has_inserts             BOOLEAN        :&#61; FALSE;&#10;      l_has_deletes             BOOLEAN        :&#61; FALSE;&#10;      l_has_updates             BOOLEAN        :&#61; FALSE;&#10;      --&#10;      l_REC_D_U_IN_DEDUP_BLOCK  BOOLEAN        :&#61; FALSE;&#10;      --&#10;      TYPE spg_message_tab_TYP IS TABLE OF cs%ROWTYPE INDEX BY PLS_INTEGER;&#10;      l_changes_tab  spg_message_tab_TYP;&#10;      --&#10;      TYPE l_action_tab_TYP IS TABLE OF ROWID INDEX BY PLS_INTEGER;&#10;      l_upd_2_ins_tab l_action_tab_TYP;&#10;      l_ins_2_upd_tab l_action_tab_TYP;&#10;      l_del_tab      l_action_tab_TYP;&#10;      --&#10;      l_upd_cnt  INTEGER :&#61; 1;&#10;      l_del_cnt  INTEGER :&#61; 1;&#10;      l_ins_cnt  INTEGER :&#61; 1;&#10;      l_prc_cnt  INTEGER :&#61; 1;&#10;      --&#10;      PROCEDURE do_reset_flags_for_next_record IS&#10;      BEGIN&#10;          l_key_dedup_count        :&#61; 0;&#10;          l_has_inserts            :&#61; FALSE;&#10;          l_has_deletes            :&#61; FALSE;&#10;          l_has_updates            :&#61; FALSE;&#10;          l_REC_D_U_IN_DEDUP_BLOCK :&#61; FALSE;&#10;      END do_reset_flags_for_next_record;&#10;      --&#10;BEGIN&#10;    --&#10;    g_procedure_name :&#61; lc_proc;&#10;    --&#10;    g_label :&#61; &#39;080000&#39;;&#10;    --&#10;    SELECT MAX(spg_notification_id) max_spg_notification_id&#10;    INTO l_max_spg_notification_id&#10;    FROM spg_notification S&#10;    WHERE S.processed_flag &#61; l_deferred_flag&#10;      AND S.offender_id &#61; p_offender_id&#10;      AND S.receiver_identity_id &#61; p_crc_probation_area_id;&#10;    --&#10;    OPEN cs;&#10;    LOOP&#10;        g_label :&#61; &#39;080010&#39;;&#10;        FETCH cs BULK COLLECT INTO l_changes_tab LIMIT 10000;&#10;        EXIT WHEN l_changes_tab.COUNT &#61; 0;&#10;        --&#10;        g_label :&#61; &#39;080020&#39;;&#10;        FOR l_idx IN 1 .. l_changes_tab.COUNT&#10;        LOOP&#10;            --info (l_changes_tab(l_idx).spg_notification_id || &#39; &#61;&gt; &#39; || l_max_spg_notification_id);&#10;            IF l_changes_tab(l_idx).spg_notification_id &gt; l_max_spg_notification_id THEN&#10;              l_max_spg_notification_id :&#61; l_changes_tab(l_idx).spg_notification_id;&#10;            END IF;&#10;            IF l_changes_tab(l_idx).status &#61; &#39;DELETE&#39; THEN&#10;                g_label :&#61; &#39;080030&#39;;&#10;                IF ( l_last_xml_msg_id &#61; l_changes_tab(l_idx).xml_msg_id AND l_last_xml_msg_lst &#61; l_changes_tab(l_idx).xml_msg_lst AND l_last_unique_id &#61; l_changes_tab(l_idx).unique_id ) OR ( l_last_xml_msg_id &#61; -1 )  THEN&#10;                    -- First time through loop set table and key variables&#10;                    IF l_last_xml_msg_id &#61; -1 THEN&#10;                        g_label :&#61; &#39;080040&#39;;&#10;                        l_last_xml_msg_id  :&#61; l_changes_tab(l_idx).xml_msg_id;&#10;                        l_last_xml_msg_lst :&#61; l_changes_tab(l_idx).xml_msg_lst;&#10;                        l_last_unique_id   :&#61; l_changes_tab(l_idx).unique_id;&#10;                    END IF;&#10;                    --&#10;                    l_key_dedup_count :&#61; l_key_dedup_count + 1;&#10;                    --&#10;                    IF l_changes_tab(l_idx).action &#61; &#39;I&#39; THEN&#10;                        g_label :&#61; &#39;080050&#39;;&#10;                        l_has_inserts :&#61; TRUE;&#10;                    ELSIF l_changes_tab(l_idx).action &#61; &#39;D&#39; THEN&#10;                        g_label :&#61; &#39;080051&#39;;&#10;                        l_has_deletes :&#61; TRUE;&#10;                    ELSIF l_changes_tab(l_idx).action &#61; &#39;U&#39; THEN&#10;                        g_label :&#61; &#39;080052&#39;;&#10;                        l_has_updates :&#61; TRUE;&#10;                    END IF;&#10;                    --&#10;                ELSE&#10;                    g_label :&#61; &#39;080060&#39;;&#10;                    l_last_xml_msg_id  :&#61; l_changes_tab(l_idx).xml_msg_id;&#10;                    l_last_xml_msg_lst :&#61; l_changes_tab(l_idx).xml_msg_lst;&#10;                    l_last_unique_id   :&#61; l_changes_tab(l_idx).unique_id;&#10;                    --&#10;                    l_key_dedup_count :&#61; 1;&#10;                    --&#10;                    l_has_inserts :&#61; (l_changes_tab(l_idx).action &#61; &#39;I&#39;);&#10;                    l_has_deletes :&#61; (l_changes_tab(l_idx).action &#61; &#39;D&#39;);&#10;                    l_has_updates :&#61; (l_changes_tab(l_idx).action &#61; &#39;U&#39;);&#10;                    --&#10;                END IF;&#10;                --&#10;                -- On first record for the DEDUP series of records,&#10;                IF l_key_dedup_count &#61; 1 THEN&#10;                    l_REC_D_U_IN_DEDUP_BLOCK :&#61; ( l_changes_tab(l_idx).action IN (&#39;D&#39;, &#39;U&#39;) );&#10;                END IF;&#10;                --&#10;                g_label :&#61; &#39;080070&#39;;&#10;                l_del_tab(l_del_cnt) :&#61; l_changes_tab(l_idx).row_id;&#10;                l_del_cnt :&#61; l_del_cnt + 1;&#10;                --&#10;            ELSIF l_changes_tab(l_idx).status &#61; &#39;RETAIN&#39; THEN&#10;                g_label :&#61; &#39;080080&#39;;&#10;                --&#10;                IF l_key_dedup_count &gt; 0 THEN&#10;                    --&#10;                    g_label :&#61; &#39;080081&#39;;&#10;                    --&#10;                    -- If there are De-duplicated rows for the current unique_id&#10;                    --   Then go through the U-&gt;I / I-&gt;U and D-&gt;x logic&#10;                    IF l_changes_tab(l_idx).action &#61; &#39;U&#39; AND (l_has_inserts AND NOT l_REC_D_U_IN_DEDUP_BLOCK) THEN&#10;                        --&#10;                        g_label :&#61; &#39;080090&#39;;&#10;                        info(&#39;WARNING: U-&gt;I action has been detected [&#39; || l_changes_tab(l_idx).offender_id || &#39;][&#39; || l_changes_tab(l_idx).unique_id || &#39;]&#39;);&#10;                        --&#10;                        l_upd_2_ins_tab(l_upd_cnt) :&#61; l_changes_tab(l_idx).row_id;&#10;                        l_upd_cnt :&#61; l_upd_cnt + 1;&#10;                        --&#10;                    ELSIF l_changes_tab(l_idx).action &#61; &#39;I&#39; AND l_REC_D_U_IN_DEDUP_BLOCK THEN&#10;                        -- turn_into_UPDATE&#10;                        g_label :&#61; &#39;080092&#39;;&#10;                        info(&#39;WARNING: I-&gt;U action has been detected [&#39; || l_changes_tab(l_idx).offender_id || &#39;][&#39; || l_changes_tab(l_idx).unique_id || &#39;]&#39;);&#10;                        --&#10;                        l_ins_2_upd_tab(l_ins_cnt) :&#61; l_changes_tab(l_idx).row_id;&#10;                        l_ins_cnt :&#61; l_ins_cnt + 1;&#10;                        --&#10;                    ELSIF l_changes_tab(l_idx).action &#61; &#39;D&#39; AND (NOT l_REC_D_U_IN_DEDUP_BLOCK) THEN&#10;                        --&#10;                        g_label :&#61; &#39;080094&#39;;&#10;                        info(&#39;WARNING: D action has been detected [&#39; || l_changes_tab(l_idx).offender_id || &#39;][&#39; || l_changes_tab(l_idx).unique_id || &#39;]&#39;);&#10;                        l_del_tab(l_del_cnt) :&#61; l_changes_tab(l_idx).row_id;&#10;                        l_del_cnt :&#61; l_del_cnt + 1;&#10;                        --&#10;                    END IF;&#10;                    --&#10;                END IF;&#10;                --&#10;                -- Reset all the flags as we move on to the next offender_id / UNIQUE_KEY_ID combination&#10;                DO_RESET_FLAGS_FOR_NEXT_RECORD;&#10;                --&#10;            END IF;&#10;            --&#10;        END LOOP;&#10;        g_label :&#61; &#39;080110&#39;;&#10;        --&#10;    END LOOP;&#10;    g_label :&#61; &#39;080120&#39;;&#10;    CLOSE cs;&#10;    --&#10;    g_label :&#61; &#39;080130&#39;;&#10;    FORALL i IN l_upd_2_ins_tab.FIRST .. l_upd_2_ins_tab.LAST&#10;        --UPDATE change_capture SET action &#61; &#39;I&#39; WHERE ROWID &#61; l_upd_2_ins_tab(i);&#10;        UPDATE spg_notification SET&#10;          --processed_flag &#61; l_not_processed_flag,&#10;          business_interaction_id &#61; NVL(PKG_SPG_EXPORT.get_override_bi(business_interaction_id, &#39;I&#39;), business_interaction_id)&#10;        WHERE ROWID &#61; l_upd_2_ins_tab(i);&#10;    l_upd_cnt :&#61; NVL(SQL%ROWCOUNT,0);&#10;    info(&#39;U-&gt;I: &#39; || l_upd_cnt || &#39; rows updated&#39;);&#10;    --&#10;    g_label :&#61; &#39;080135&#39;;&#10;    FORALL i IN l_ins_2_upd_tab.FIRST .. l_ins_2_upd_tab.LAST&#10;        --UPDATE change_capture SET action &#61; &#39;U&#39; WHERE ROWID &#61; l_ins_2_upd_tab(i);&#10;        UPDATE spg_notification SET&#10;          business_interaction_id &#61; NVL(PKG_SPG_EXPORT.get_override_bi(business_interaction_id, &#39;U&#39;), TO_CHAR(business_interaction_id))&#10;        WHERE ROWID &#61; l_ins_2_upd_tab(i);&#10;&#10;    l_ins_cnt :&#61; NVL(SQL%ROWCOUNT,0);&#10;    info(&#39;I-&gt;U: &#39; || l_ins_cnt || &#39; rows updated&#39;);&#10;    --&#10;    g_label :&#61; &#39;080140&#39;;&#10;    FORALL i IN l_del_tab.FIRST .. l_del_tab.LAST&#10;        --UPDATE change_capture SET processed_flag &#61; &#39;D&#39; WHERE ROWID &#61; l_del_tab(i);&#10;        UPDATE spg_notification SET&#10;          processed_flag &#61; l_deduplicated_flag&#10;        WHERE ROWID &#61; l_del_tab(i);&#10;&#10;    l_del_cnt :&#61; NVL(SQL%ROWCOUNT,0);&#10;    info(l_del_cnt || &#39; rows marked as deleted&#39;);&#10;    --&#10;    FORALL i IN l_changes_tab.FIRST .. l_changes_tab.LAST&#10;        UPDATE spg_notification SET&#10;          processed_flag &#61; l_not_processed_flag&#10;        WHERE ROWID &#61; l_changes_tab(i).row_id&#10;          AND processed_flag &#61; l_deferred_flag;&#10;    l_prc_cnt :&#61; NVL(SQL%ROWCOUNT,0);&#10;    info(l_prc_cnt || &#39; rows re-submitted for SPG processing&#39;);&#10;    --&#10;    info(&#39;MAX spg_notification_id &#61;&gt; &#39; || l_max_spg_notification_id);&#10;    x_max_spg_notification_id :&#61; l_max_spg_notification_id;&#10;    --&#10;EXCEPTION&#10;  WHEN OTHERS THEN&#10;    warn(&#39;Exception (RAISING): &#39; || SQLERRM);&#10;    RAISE;&#10;END do_dedup_messages;&#10;--&#10;PROCEDURE do_resume_pending_messages(p_offender_id NUMBER, p_crc_probation_area_id NUMBER)&#10;IS&#10;    CURSOR cs IS&#10;      SELECT spg_notification_id&#10;      FROM spg_notification&#10;      WHERE processed_flag &#61; 2&#10;        AND offender_id &#61; p_offender_id&#10;        AND receiver_identity_id &#61; p_crc_probation_area_id;&#10;    l_rec cs%ROWTYPE;&#10;BEGIN&#10;    -- TODO: do_dedup_messages&#10;    OPEN cs;&#10;    LOOP&#10;        FETCH cs INTO l_rec;&#10;        EXIT WHEN cs%NOTFOUND;&#10;        --&#10;        UPDATE spg_notification SET&#10;          processed_flag &#61; 0&#10;        WHERE spg_notification_id &#61; l_rec.spg_notification_id;&#10;    END LOOP;&#10;    CLOSE cs;&#10;END do_resume_pending_messages;&#10;--&#10;PROCEDURE do_mark_crc_export_processed(&#10;    p_spg_notification_id NUMBER,&#10;    p_trigger_name        VARCHAR2 DEFAULT NULL )&#10;IS&#10;    --&#10;    CURSOR cs IS&#10;      SELECT&#10;        S1.business_interaction_id,&#10;        OE.offender_crc_export_id,&#10;        S.spg_notification_id,&#10;        S.receiver_identity_id AS crc_probation_area_id,&#10;        OE.offender_id&#10;        --&#10;      FROM&#10;        spg_notification S1&#10;          INNER JOIN spg_notification S ON S.control_reference &#61; S1.receiver_control_reference&#10;            INNER JOIN offender_crc_export OE ON OE.spg_notification_id &#61; S.spg_notification_id&#10;      WHERE S1.spg_notification_id &#61; p_spg_notification_id&#10;        AND S1.business_interaction_id IN (G_BI_202_ID, G_BI_410_ID, G_BI_413_ID)&#10;        AND OE.processed_datetime IS NULL&#10;      ORDER BY&#10;        DECODE(S1.business_interaction_id,&#10;            G_BI_202_ID, 1,&#10;            G_BI_410_ID, 2,&#10;            G_BI_413_ID, 3,&#10;            4 );&#10;    --&#10;    l_rec        cs%ROWTYPE;&#10;    l_found_flag BOOLEAN;&#10;    --&#10;BEGIN&#10;    --&#10;    OPEN cs;&#10;    FETCH cs INTO l_rec;&#10;    l_found_flag :&#61; cs%FOUND;&#10;    CLOSE cs;&#10;    --&#10;    IF l_found_flag THEN&#10;        UPDATE offender_crc_export SET&#10;          row_version &#61; row_version + 1,&#10;          last_updated_user_id &#61; NVL(PKG_Lookups.GetUserID( SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_USER&#39;) ), last_updated_user_id),&#10;          last_updated_datetime &#61; SYSDATE,&#10;          processed_datetime &#61; SYSDATE&#10;          --error_flag &#61; ,&#10;          --error_message &#61; ,&#10;        WHERE offender_crc_export_id &#61; l_rec.offender_crc_export_id;&#10;    END IF;&#10;    --&#10;    -- YF: resume all (if any) deferred SPG notification entries for the current offender/target area combination&#10;    do_resume_pending_messages(l_rec.offender_id, l_rec.crc_probation_area_id);&#10;    --&#10;END do_mark_crc_export_processed;&#10;&#10;FUNCTION get_deferred_SPG_202_FLAG RETURN BOOLEAN IS&#10;BEGIN&#10;    RETURN g_deferred_SPG_202_FLAG;&#10;END get_deferred_SPG_202_FLAG;&#10;&#10;FUNCTION get_spg_202_deferred_CNT RETURN NUMBER IS&#10;BEGIN&#10;    RETURN NVL(g_tab_deferred_SPG_202.COUNT, 0);&#10;END get_spg_202_deferred_CNT;&#10;&#10;PROCEDURE add_spg_202_DEFERRED_LST(&#10;    p_spg_notification_id         NUMBER,&#10;    p_business_interaction_id     NUMBER,&#10;    p_receiver_control_reference  SPG_NOTIFICATION.receiver_control_reference%TYPE,&#10;    p_trigger_name                VARCHAR2 DEFAULT NULL )&#10;IS&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;add_spg_202_DEFERRED_LST&#39;;&#10;    --&#10;    l_key VARCHAR2(100);&#10;BEGIN&#10;    IF NVL(p_business_interaction_id, -1) NOT IN ( G_BI_202_ID, G_BI_410_ID, G_BI_413_ID ) THEN&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    l_key :&#61; TO_CHAR(p_spg_notification_id);&#10;    IF NOT g_tab_deferred_SPG_202.EXISTS(l_key) THEN&#10;        procDebug(l_proc || &#39;[&#39; || p_trigger_name || &#39;]: add new 202 spg_notification_id&#61;&#39; || p_spg_notification_id);&#10;        g_tab_deferred_SPG_202(l_key) :&#61; &#39;Y&#39;;&#10;    END IF;&#10;END add_spg_202_DEFERRED_LST;&#10;&#10;PROCEDURE process_spg_202_DEFERRED(p_trigger_name VARCHAR2 DEFAULT NULL)&#10;IS&#10;    --&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;process_spg_202_DEFERRED&#39;;&#10;    --&#10;    l_key                 VARCHAR2(100);&#10;    l_spg_notification_id NUMBER;&#10;    --&#10;    ex_mutating_table EXCEPTION;&#10;    PRAGMA EXCEPTION_INIT (ex_mutating_table, -4091);&#10;    --&#10;BEGIN&#10;    IF g_tab_deferred_SPG_202.COUNT &gt; 0 THEN&#10;        --&#10;        g_deferred_SPG_202_FLAG :&#61; TRUE;&#10;        --&#10;        l_key :&#61; g_tab_deferred_SPG_202.FIRST;&#10;        LOOP&#10;            EXIT WHEN empty2null(l_key) IS NULL;&#10;            --&#10;            procDebug(l_proc || &#39;: processing the [&#39; || l_key || &#39;] queue element&#39;);&#10;            --&#10;            BEGIN&#10;                l_spg_notification_id :&#61; TO_NUMBER(l_key);&#10;            EXCEPTION WHEN OTHERS THEN&#10;                l_spg_notification_id :&#61; -1;&#10;            END;&#10;            --&#10;            IF l_spg_notification_id &lt;&#61; 0  THEN&#10;                raise_application_error(-20001, &#39;ERROR in &#39; || l_proc || &#39; [&#39; || l_key || &#39;]: invalid deferred queue element detected&#39;);&#10;            END IF;&#10;            --&#10;            --BEGIN&#10;                do_mark_crc_export_processed(p_spg_notification_id&#61;&gt;l_spg_notification_id, p_trigger_name &#61;&gt; p_trigger_name);&#10;            --EXCEPTION WHEN ex_mutating_table THEN&#10;            --    procDebug(l_proc || &#39;: failed to process the [&#39; || l_key || &#39;] queue element {&#39; || SQLERRM || &#39;): keeping in the queue&#39;);&#10;            --    IF NOT l_tab_deferred_upd_CURRENT_D.EXISTS(l_key) THEN&#10;            --        l_tab_deferred_upd_CURRENT_D(l_key) :&#61; &#39;Y&#39;;&#10;            --    END IF;&#10;            --END;&#10;            --&#10;            l_key :&#61; g_tab_deferred_SPG_202.NEXT(l_key);&#10;        END LOOP;&#10;        --&#10;        g_tab_deferred_SPG_202.DELETE;&#10;        --&#10;        g_deferred_SPG_202_FLAG :&#61; FALSE;&#10;        --&#10;        --IF l_tab_deferred_SPG_202.COUNT &gt; 0 THEN&#10;        --    g_tab_deferred_SPG_202 :&#61; l_tab_deferred_SPG_202;&#10;        --END IF;&#10;        --&#10;    END IF;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    --&#10;    g_deferred_SPG_202_FLAG :&#61; FALSE;&#10;    --&#10;    RAISE;&#10;    --&#10;END process_spg_202_DEFERRED;&#10;&#10;FUNCTION get_crc_export_deferred_CNT RETURN NUMBER IS&#10;BEGIN&#10;    RETURN NVL(g_tab_deferred_crc_export.COUNT, 0);&#10;END get_crc_export_deferred_CNT;&#10;&#10;FUNCTION get_crc_export_deferred_FLAG RETURN BOOLEAN IS&#10;BEGIN&#10;    RETURN g_crc_export_deferred_FLAG;&#10;END get_crc_export_deferred_FLAG;&#10;&#10;PROCEDURE add_crc_export_DEFERRED_LST(&#10;    p_offender_crc_export_id      NUMBER,&#10;    p_trigger_name                VARCHAR2 DEFAULT NULL )&#10;IS&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;add_crc_export_DEFERRED_LST&#39;;&#10;    --&#10;    l_key VARCHAR2(100);&#10;BEGIN&#10;    l_key :&#61; TO_CHAR(p_offender_crc_export_id);&#10;    IF NOT g_tab_deferred_crc_export.EXISTS(l_key) THEN&#10;        procDebug(l_proc || &#39;[&#39; || p_trigger_name || &#39;]: add new offender_crc_export_id&#61;&#39; || p_offender_crc_export_id);&#10;        g_tab_deferred_crc_export(l_key) :&#61; &#39;Y&#39;;&#10;    END IF;&#10;END add_crc_export_DEFERRED_LST;&#10;&#10;PROCEDURE process_crc_export_DEFERRED(p_trigger_name VARCHAR2 DEFAULT NULL)&#10;IS&#10;    --&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;process_crc_export_DEFERRED&#39;;&#10;    --&#10;    l_key                    VARCHAR2(100);&#10;    l_key1                   VARCHAR2(100);&#10;    l_offender_crc_export_id NUMBER;&#10;    l_offender_id            NUMBER;&#10;    l_crc_provider_id        NUMBER;&#10;    --&#10;    ex_mutating_table EXCEPTION;&#10;    PRAGMA EXCEPTION_INIT (ex_mutating_table, -4091);&#10;    --&#10;    l_tab_off t_tab_deferred;&#10;    --&#10;BEGIN&#10;    IF g_tab_deferred_crc_export.COUNT &gt; 0 THEN&#10;        --&#10;        g_crc_export_deferred_FLAG :&#61; TRUE;&#10;        --&#10;        l_key :&#61; g_tab_deferred_crc_export.FIRST;&#10;        LOOP&#10;            EXIT WHEN empty2null(l_key) IS NULL;&#10;            --&#10;            procDebug(l_proc || &#39;: processing the [&#39; || l_key || &#39;] queue element&#39;);&#10;            --&#10;            BEGIN&#10;                l_offender_crc_export_id :&#61; TO_NUMBER(l_key);&#10;            EXCEPTION WHEN OTHERS THEN&#10;                l_offender_crc_export_id :&#61; -1;&#10;            END;&#10;            --&#10;            IF l_offender_crc_export_id &lt;&#61; 0  THEN&#10;                raise_application_error(-20001, &#39;ERROR in &#39; || l_proc || &#39; [&#39; || l_key || &#39;]: invalid deferred queue element detected&#39;);&#10;            END IF;&#10;            --&#10;            --BEGIN&#10;                --&#10;                SELECT offender_id, crc_provider_id INTO l_offender_id, l_crc_provider_id&#10;                FROM offender_crc_export&#10;                WHERE offender_crc_export_id &#61; l_offender_crc_export_id;&#10;                --&#10;                l_key1 :&#61; l_offender_id || &#39;|&#39; || l_crc_provider_id;&#10;                IF l_tab_off.EXISTS(l_key1) THEN&#10;                    raise_application_error(-20001, &#39;ERROR in &#39; || l_proc || &#39; [&#39; || l_key1 || &#39;]: a duplicate deferred queue element detected&#39;);&#10;                    NULL;&#10;                ELSE&#10;                    l_tab_off(l_key1) :&#61; &#39;Y&#39;;&#10;                END IF;&#10;                --&#10;                UPDATE offender_crc_export OE SET&#10;                  current_record_flag &#61; CASE&#10;                                            WHEN offender_crc_export_id &lt; l_offender_crc_export_id THEN NULL&#10;                                            WHEN offender_crc_export_id &#61; l_offender_crc_export_id THEN &#39;Y&#39;&#10;                                            ELSE &#39;X&#39;&#10;                                        END&#10;                WHERE offender_id &#61; l_offender_id&#10;                  AND crc_provider_id &#61; l_crc_provider_id;&#10;                --&#10;                PKG_SPG_EXPORT.submit_crc_export(p_offender_crc_export_id&#61;&gt;l_offender_crc_export_id);&#10;            --EXCEPTION WHEN ex_mutating_table THEN&#10;            --    procDebug(l_proc || &#39;: failed to process the [&#39; || l_key || &#39;] queue element {&#39; || SQLERRM || &#39;): keeping in the queue&#39;);&#10;            --    IF NOT l_tab_deferred_crc_export.EXISTS(l_key) THEN&#10;            --        l_tab_deferred_crc_export(l_key) :&#61; &#39;Y&#39;;&#10;            --    END IF;&#10;            --END;&#10;            --&#10;            l_key :&#61; g_tab_deferred_crc_export.NEXT(l_key);&#10;        END LOOP;&#10;        --&#10;        g_tab_deferred_crc_export.DELETE;&#10;        --&#10;        g_crc_export_deferred_FLAG :&#61; FALSE;&#10;        --&#10;        --IF l_tab_deferred_crc_export.COUNT &gt; 0 THEN&#10;        --    g_tab_deferred_crc_export :&#61; l_tab_deferred_crc_export;&#10;        --END IF;&#10;        --&#10;    END IF;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    --&#10;    g_crc_export_deferred_FLAG :&#61; FALSE;&#10;    --&#10;    RAISE;&#10;    --&#10;END process_crc_export_DEFERRED;&#10;&#10;&#10;--&#10;-- CRC Export submit outbound messages&#10;--&#10;PROCEDURE submit_crc_export(&#10;    p_crc_provider_id        NUMBER DEFAULT NULL,&#10;    p_export_date_from       DATE   DEFAULT NULL,&#10;    p_export_date_to         DATE   DEFAULT NULL,&#10;    p_offender_crc_export_id NUMBER DEFAULT NULL )&#10;IS&#10;    --&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;SUBMIT_CRC_EXPORT&#39;;&#10;    --&#10;    l_rbac_check_flag     BOOLEAN;&#10;    l_spg_notification_id NUMBER;&#10;    --&#10;    CURSOR cs IS&#10;      SELECT&#10;        T1.offender_crc_export_id, T1.offender_id, T1.crc_provider_id, T1.export_date,&#10;        T1.row_version, T1.created_by_user_id, T1.created_datetime, T1.last_updated_user_id, T1.last_updated_datetime,&#10;        T1.requested_export_level,&#10;        T1.error_flag, T1.submitted_datetime, T1.processed_datetime, T1.error_message, T1.spg_notification_id&#10;        --OT.offender_transfer_id&#10;      FROM&#10;        offender_crc_export T1&#10;--          INNER JOIN offender_transfer OT ON OT.offender_id &#61; T1.offender_id&#10;--            INNER JOIN team T ON T.team_id &#61; OT.receiving_team_id&#10;--              INNER JOIN probation_area PA ON PA.probation_area_id &#61; T.probation_area_id&#10;      WHERE 1&#61;1&#10;        --AND PA.probation_area_id &#61; T1.crc_provider_id&#10;        AND T1.submitted_datetime IS NULL&#10;        AND ( p_crc_provider_id  IS NULL OR T1.crc_provider_id &#61; p_crc_provider_id )&#10;        AND ( p_export_date_from IS NULL OR T1.export_date &gt;&#61; p_export_date_from )&#10;        AND ( p_export_date_to   IS NULL OR T1.export_date &lt;&#61; p_export_date_to   )&#10;        AND ( p_offender_crc_export_id IS NULL OR T1.offender_crc_export_id &#61; p_offender_crc_export_id )&#10;      --FOR UPDATE OF error_flag, submitted_datetime, error_message, spg_notification_id&#10;    ;&#10;    --&#10;    l_rec cs%ROWTYPE;&#10;    --&#10;    CURSOR csE IS&#10;      WITH E AS (&#10;        SELECT&#10;          E.event_id,&#10;          E.event_number,&#10;          D.disposal_id,&#10;          D.termination_date&#10;        FROM&#10;          event    E,&#10;          disposal D&#10;        WHERE E.offender_id     &#61; l_rec.offender_id&#10;          AND E.soft_deleted    &#61; 0&#10;          AND D.event_id(+)     &#61; E.event_id&#10;          AND D.soft_deleted(+) &#61; 0 )&#10;      SELECT *&#10;      FROM E&#10;      WHERE l_rec.requested_export_level &#61; 1 OR termination_date IS NULL;&#10;    --&#10;    l_rec_event csE%ROWTYPE;&#10;    --&#10;    PROCEDURE do_submit_alloc(p_bi_code VARCHAR2, p_offender_id NUMBER, p_unique_id NUMBER DEFAULT NULL, p_area_id NUMBER, x_spg_notification_id IN OUT NUMBER)&#10;    IS&#10;    BEGIN&#10;        INSERT INTO spg_notification (&#10;          spg_notification_id, business_interaction_id, offender_id, unique_id, date_created, message_direction,&#10;          sender_identity_id, receiver_identity_id,&#10;          control_reference&#10;          --receiver_control_reference&#10;        ) VALUES (&#10;          spg_notification_id_seq.NEXTVAL,&#10;          PKG_LOOKUPS.funcGetBusinessInteractionID(p_bi_code),&#10;          p_offender_id,&#10;          NVL(p_unique_id, p_offender_id),&#10;          SYSDATE,&#10;          &#39;O&#39;,&#10;          PKG_Lookups.funcgetTabRecord_CACHED(p_table&#61;&gt;&#39;PROBATION_AREA&#39;, p_ref_col&#61;&gt;&#39;code&#39;, p_ref_val&#61;&gt;&#39;N00&#39;, p_data_fld&#61;&gt;&#39;probation_area_ID&#39;),&#10;          p_area_id,&#10;          SPGConfig.getnextcontrolreference(&#39;N00&#39;)&#10;        )&#10;        RETURNING spg_notification_id&#10;        INTO x_spg_notification_id;&#10;    END do_submit_alloc;&#10;    --&#10;    PROCEDURE do_submit_offender&#10;    IS&#10;        l_id NUMBER;&#10;    BEGIN&#10;        do_submit_alloc(GC_BI_OFFENDER, l_rec.offender_id, l_rec.offender_id /*offender_transfer_id*/, l_rec.crc_provider_id, l_id);&#10;    END do_submit_offender;&#10;    --&#10;    PROCEDURE do_submit_alloc_offender IS&#10;    BEGIN&#10;        do_submit_alloc(GC_BI_ALLOC_OFFENDER, l_rec.offender_id, l_rec.offender_id /*offender_transfer_id*/, l_rec.crc_provider_id, l_spg_notification_id);&#10;    END do_submit_alloc_offender;&#10;    --&#10;    PROCEDURE do_submit_alloc_event&#10;    IS&#10;        l_id NUMBER;&#10;    BEGIN&#10;        do_submit_alloc(GC_BI_ALLOC_EVENT, l_rec.offender_id, l_rec_event.event_id, l_rec.crc_provider_id, l_id);&#10;    END do_submit_alloc_event;&#10;    --&#10;    PROCEDURE do_upd_submit_details(p_off_crc_export_id NUMBER) IS&#10;    BEGIN&#10;        UPDATE offender_crc_export SET&#10;          row_version &#61; row_version + 1,&#10;          last_updated_user_id &#61; 3,&#10;          last_updated_datetime &#61; SYSDATE,&#10;          submitted_datetime &#61; SYSDATE,&#10;          --processed_datetime &#61; SYSDATE,&#10;          --error_flag &#61; ,&#10;          --error_message &#61; ,&#10;          spg_notification_id &#61; l_spg_notification_id&#10;        --WHERE CURRENT OF cs;&#10;        WHERE offender_crc_export_id &#61; p_off_crc_export_id;&#10;    END do_upd_submit_details;&#10;    --&#10;    PROCEDURE do_upd_error_details(p_off_crc_export_id NUMBER, p_err_msg VARCHAR2) IS&#10;    BEGIN&#10;        UPDATE offender_crc_export SET&#10;          row_version &#61; row_version + 1,&#10;          last_updated_user_id &#61; NVL(PKG_Lookups.GetUserID( SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_USER&#39;) ), last_updated_user_id),&#10;          last_updated_datetime &#61; SYSDATE,&#10;          error_flag &#61; 1,&#10;          error_message &#61; p_err_msg&#10;        --WHERE CURRENT OF cs;&#10;        WHERE offender_crc_export_id &#61; p_off_crc_export_id;&#10;    END do_upd_error_details;&#10;    --&#10;    PROCEDURE do_check_rbac(p_off_crc_export_id NUMBER, p_expected_rbac_level NUMBER, x_checked_flag IN OUT BOOLEAN)&#10;    IS&#10;        CURSOR csRB IS&#10;          WITH&#10;            L AS (&#10;              SELECT&#10;                SUM( CASE WHEN role_code &#61;  &#39;OM&#39; AND T1.probation_area_id &#61; OE.crc_provider_id THEN 1 END) AS rbac_L1,&#10;                SUM( CASE WHEN role_code &lt;&gt; &#39;OM&#39; AND t1.probation_area_id &#61; OE.crc_provider_id THEN 1 END) AS rbac_L3&#10;              FROM&#10;                offender_crc_export OE&#10;                  INNER JOIN caseload CL ON CL.offender_id &#61; OE.offender_id&#10;                    INNER JOIN all_team T1 ON T1.trust_provider_flag &#61; CL.trust_provider_flag AND T1.trust_provider_team_id &#61; CL.trust_provider_team_id&#10;              WHERE OE.offender_crc_export_id &#61; p_off_crc_export_id )&#10;          --&#10;          SELECT&#10;            CASE WHEN rbac_L1 &gt; 0 THEN 1&#10;                 WHEN rbac_L3 &gt; 0 THEN 3&#10;                 ELSE 0&#10;            END AS rbac_level&#10;          FROM L;&#10;        --&#10;        l_rbac_level NUMBER;&#10;        --&#10;    BEGIN&#10;        OPEN csRB;&#10;        FETCH csRB INTO l_rbac_level;&#10;        IF csRB%NOTFOUND THEN&#10;            l_rbac_level :&#61; 0;&#10;        END IF;&#10;        CLOSE csRB;&#10;        --&#10;        IF NVL(l_rbac_level, -1) &#61; NVL(p_expected_rbac_level, -2) THEN&#10;            x_checked_flag :&#61; TRUE;&#10;        ELSE&#10;            do_upd_error_details(p_off_crc_export_id, &#39;RBAC check has been failed: expected_rbac&#61;&#39; || p_expected_rbac_level || &#39; &lt;&gt; current_rbac&#61;&#39; || l_rbac_level);&#10;            x_checked_flag :&#61; FALSE;&#10;        END IF;&#10;        --&#10;    END do_check_rbac;&#10;    --&#10;BEGIN&#10;    --&#10;    IF p_crc_provider_id IS NULL AND p_offender_crc_export_id IS NULL THEN&#10;        raise_application_error(-20001, &#39;ERROR in &#39; || l_proc || &#39;: either P_CRC_PROVIDER_ID or P_OFFENDER_CRC_EXPORT_ID must be specified&#39;);&#10;    END IF;&#10;    --&#10;--    info(&#39;PKG_SPG_EXPORT.submit_crc_export &#39; ||&#10;--        &#39;[CRC Provider ID&#61;&#39;       || p_crc_provider_id          || &#39;]&#39; ||&#10;--        &#39;[Export Date From&#61;&#39;       || p_export_date_from        || &#39;]&#39; ||&#10;--        &#39;[Export Date To&#61;&#39;         || p_export_date_to          || &#39;]&#39; ||&#10;--        &#39;[Offender CRC Export ID&#61;&#39; || p_offender_crc_export_id  || &#39;]&#39; ||&#10;--        &#39;: START&#39; );&#10;    --&#10;    OPEN cs;&#10;    LOOP&#10;        FETCH cs INTO l_rec;&#10;        EXIT WHEN cs%NOTFOUND;&#10;        --&#10;        do_check_rbac(l_rec.offender_crc_export_id, l_rec.requested_export_level, l_rbac_check_flag);&#10;--        info(&#39;PKG_SPG_EXPORT.submit_crc_export.do_check_rbac &#39; ||&#10;--            &#39;[CRC Provider ID&#61;&#39; || p_crc_provider_id            || &#39;]&#39; ||&#10;--            &#39;[RBAC Requested&#61;&#39;  || l_rec.requested_export_level || &#39;]&#39; ||&#10;--            &#39;[RBAC Check Passed&#61;&#39; || PKG_Common.bool_2_char(l_rbac_check_flag) || &#39;]&#39; );&#10;        --&#10;        IF l_rbac_check_flag THEN&#10;            do_submit_offender;&#10;            do_submit_alloc_offender;&#10;            do_upd_submit_details(l_rec.offender_crc_export_id);&#10;            --&#10;            OPEN csE;&#10;            LOOP&#10;                FETCH csE INTO l_rec_event;&#10;                EXIT WHEN csE%NOTFOUND;&#10;                --&#10;                do_submit_alloc_event;&#10;            END LOOP;&#10;            CLOSE csE;&#10;        END IF;&#10;    END LOOP;&#10;    CLOSE cs;&#10;END submit_crc_export;&#10;--&#10;PROCEDURE create_crc_export_batch(&#10;    p_probation_area_id           NUMBER,&#10;    p_team_id                     NUMBER    DEFAULT -1,&#10;    p_staff_id                    NUMBER    DEFAULT -1,&#10;    p_excl_already_extracted_flag VARCHAR2  DEFAULT &#39;N&#39;,&#10;    p_incl_already_extracted_flag VARCHAR2  DEFAULT &#39;N&#39;,&#10;    p_crc_export_date_from        DATE      DEFAULT NULL,&#10;    p_crc_export_date_to          DATE      DEFAULT NULL,&#10;    p_crn                         VARCHAR2  DEFAULT NULL,&#10;    p_status_export_flag          SMALLINT  DEFAULT 0,&#10;    p_debug_flag                  VARCHAR2  DEFAULT &#39;Y&#39;,&#10;    --&#10;    p_max_rows                    INTEGER   DEFAULT -1,&#10;    p_max_rows_L1                 INTEGER   DEFAULT -1,&#10;    p_max_rows_L3                 INTEGER   DEFAULT -1,&#10;    --&#10;    p_async_flag                  VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_spg_notification_id         NUMBER   DEFAULT NULL,&#10;    p_offender_id                 NUMBER   DEFAULT NULL,&#10;    p_db_trigger_mode             VARCHAR2 DEFAULT &#39;N&#39; )&#10;IS&#10;    --&#10;    lc_proc CONSTANT VARCHAR2(30) :&#61; &#39;CREATE_CRC_EXPORT_BATCH&#39;;&#10;    --&#10;    TYPE l_rec_TYP IS RECORD(&#10;      offender_crc_export_id    NUMBER,&#10;      offender_id               NUMBER,&#10;      crc_provider_id           NUMBER,&#10;      export_date               DATE,&#10;      requested_export_level    NUMBER,&#10;      submitted_datetime        DATE,&#10;      processed_datetime        DATE,&#10;      spg_notification_id       NUMBER );&#10;    TYPE l_tab_TYP IS TABLE OF l_rec_TYP;&#10;    --&#10;    l_idx INTEGER;&#10;    l_rec l_rec_TYP;&#10;    l_TAB l_tab_TYP;&#10;    --&#10;    l_lock_name   VARCHAR2(30) :&#61; &#39;ND_CRC_EXPORT_LOCK&#39;;&#10;    l_lock_handle VARCHAR2(128);&#10;    l_dummy       PLS_INTEGER;&#10;    --&#10;    l_user_id     NUMBER :&#61; PKG_LOOKUPS.GetUserID(p_distinguished_name &#61;&gt; NVLSTR(SYS_CONTEXT(&#39;USERENV&#39;, &#39;CLIENT_IDENTIFIER&#39;), &#39;DELIUS_SYSTEM_USER&#39;));&#10;    l_batch_flag  SMALLINT;&#10;    l_async_flag  VARCHAR2(1);&#10;    --&#10;    PROCEDURE do_allocate_soft_lock IS&#10;    BEGIN&#10;        IF NVL(p_db_trigger_mode, &#39;N&#39;) &lt;&gt; &#39;Y&#39; THEN&#10;            DBMS_LOCK.allocate_unique(l_lock_name, l_lock_handle);&#10;            l_dummy :&#61; DBMS_LOCK.request(l_lock_handle, DBMS_LOCK.x_mode, DBMS_LOCK.maxwait, FALSE);&#10;        END IF;&#10;    END do_allocate_soft_lock;&#10;    --&#10;    PROCEDURE do_release_soft_lock IS&#10;    BEGIN&#10;        IF NVL(p_db_trigger_mode, &#39;N&#39;) &lt;&gt; &#39;Y&#39; THEN&#10;            l_dummy :&#61; DBMS_LOCK.release(l_lock_handle);&#10;        END IF;&#10;    END do_release_soft_lock;&#10;    --&#10;    PROCEDURE create_bg_process&#10;    IS&#10;        --&#10;        l_status INTEGER;&#10;        --&#10;        l_proc CONSTANT VARCHAR2(30) :&#61; &#39;CREATE_BG_PROCESS&#39;;&#10;        l_prog_name VARCHAR2(100)    :&#61; &#39;SPG_EXPORT_OFFENDER_PROG&#39;;&#10;        l_job_name  VARCHAR2(100);&#10;        --&#10;    BEGIN&#10;        -- Create DBMS_SCHEDULE job&#10;        l_job_name  :&#61; &#39;SPG_CRC_EXP&#39; || PKG_VpdSupport.get_current_scn_number;&#10;        --&#10;        DBMS_SCHEDULER.create_job(&#10;            job_name      &#61;&gt; l_job_name,&#10;            program_name  &#61;&gt; l_prog_name,&#10;            start_date    &#61;&gt; SYSDATE,&#10;            enabled       &#61;&gt; FALSE,&#10;            comments      &#61;&gt; &#39;SPG_EXPORT_OFFENDER_JOB&#39;);&#10;        --&#10;        DBMS_SCHEDULER.set_job_argument_value(job_name &#61;&gt; l_job_name, argument_name &#61;&gt; &#39;p_probation_area_id&#39;            , argument_value &#61;&gt; p_probation_area_id);&#10;        DBMS_SCHEDULER.set_job_argument_value(job_name &#61;&gt; l_job_name, argument_name &#61;&gt; &#39;p_team_id&#39;                      , argument_value &#61;&gt; p_team_id);&#10;        DBMS_SCHEDULER.set_job_argument_value(job_name &#61;&gt; l_job_name, argument_name &#61;&gt; &#39;p_staff_id&#39;                     , argument_value &#61;&gt; p_staff_id);&#10;        DBMS_SCHEDULER.set_job_argument_value(job_name &#61;&gt; l_job_name, argument_name &#61;&gt; &#39;p_excl_already_extracted_flag&#39;  , argument_value &#61;&gt; p_excl_already_extracted_flag);&#10;        DBMS_SCHEDULER.set_job_argument_value(job_name &#61;&gt; l_job_name, argument_name &#61;&gt; &#39;p_incl_already_extracted_flag&#39;  , argument_value &#61;&gt; p_incl_already_extracted_flag);&#10;        DBMS_SCHEDULER.set_job_argument_value(job_name &#61;&gt; l_job_name, argument_name &#61;&gt; &#39;p_crc_export_date_from&#39;         , argument_value &#61;&gt; p_crc_export_date_from);&#10;        DBMS_SCHEDULER.set_job_argument_value(job_name &#61;&gt; l_job_name, argument_name &#61;&gt; &#39;p_crc_export_date_to&#39;           , argument_value &#61;&gt; p_crc_export_date_to);&#10;        DBMS_SCHEDULER.set_job_argument_value(job_name &#61;&gt; l_job_name, argument_name &#61;&gt; &#39;p_crn&#39;                          , argument_value &#61;&gt; p_crn);&#10;        DBMS_SCHEDULER.set_job_argument_value(job_name &#61;&gt; l_job_name, argument_name &#61;&gt; &#39;p_status_export_flag&#39;           , argument_value &#61;&gt; p_status_export_flag);&#10;        DBMS_SCHEDULER.set_job_argument_value(job_name &#61;&gt; l_job_name, argument_name &#61;&gt; &#39;p_debug_flag&#39;                   , argument_value &#61;&gt; p_debug_flag);&#10;        DBMS_SCHEDULER.set_job_argument_value(job_name &#61;&gt; l_job_name, argument_name &#61;&gt; &#39;p_max_rows&#39;                     , argument_value &#61;&gt; p_max_rows);&#10;        DBMS_SCHEDULER.set_job_argument_value(job_name &#61;&gt; l_job_name, argument_name &#61;&gt; &#39;p_max_rows_L1&#39;                  , argument_value &#61;&gt; p_max_rows_L1);&#10;        DBMS_SCHEDULER.set_job_argument_value(job_name &#61;&gt; l_job_name, argument_name &#61;&gt; &#39;p_max_rows_L3&#39;                  , argument_value &#61;&gt; p_max_rows_L3);&#10;        DBMS_SCHEDULER.set_job_argument_value(job_name &#61;&gt; l_job_name, argument_name &#61;&gt; &#39;p_async_flag&#39;                   , argument_value &#61;&gt; &#39;N&#39;);&#10;        --&#10;        DBMS_SCHEDULER.enable(l_job_name);&#10;        --&#10;    END create_bg_process;&#10;    --&#10;BEGIN&#10;    --&#10;    g_procedure_name :&#61; lc_proc;&#10;    g_label :&#61; CASE WHEN p_async_flag &#61; &#39;N&#39; THEN &#39;00010&#39; ELSE &#39;00020&#39; END;&#10;    --&#10;    l_async_flag :&#61; CASE&#10;                        WHEN p_spg_notification_id &gt; 0&#10;                            THEN &#39;N&#39;&#10;                            ELSE NVLSTR(p_async_flag, &#39;N&#39;)&#10;                    END;&#10;    --&#10;    info(&#10;        &#39;PKG_SPG_EXPORT.create_crc_export_batch: Create Offender Export Batch &#39; ||&#10;        &#39;(CRC&#61;&#39;   || PKG_LOOKUPS.funcgetTabRecord_CACHED(p_table&#61;&gt;&#39;probation_area&#39;, p_ref_col&#61;&gt;&#39;probation_area_id&#39;, p_ref_val&#61;&gt;TO_CHAR(p_probation_area_id), p_data_fld&#61;&gt;&#39;code&#39;) || &#39;)&#39; ||&#10;        &#39;(team&#61;&#39;  || PKG_LOOKUPS.funcgetTabRecord_CACHED(p_table&#61;&gt;&#39;team&#39;, p_ref_col&#61;&gt;&#39;team_id&#39;, p_ref_val&#61;&gt;TO_CHAR(p_team_id), p_data_fld&#61;&gt;&#39;code&#39;)                               || &#39;)&#39; ||&#10;        &#39;(staff&#61;&#39; || PKG_LOOKUPS.funcgetTabRecord_CACHED(p_table&#61;&gt;&#39;staff&#39;, p_ref_col&#61;&gt;&#39;staff_id&#39;, p_ref_val&#61;&gt;TO_CHAR(p_staff_id), p_data_fld&#61;&gt;&#39;officer_code&#39;)                    || &#39;)&#39; ||&#10;        &#39;(exclude extracted&#61;&#39; || p_excl_already_extracted_flag  || &#39;)&#39; ||&#10;        &#39;(include extracted&#61;&#39; || p_incl_already_extracted_flag  || &#39;)&#39; ||&#10;        &#39;(date from&#61;&#39;         || p_crc_export_date_from         || &#39;)&#39; ||&#10;        &#39;(date to&#61;&#39;           || p_crc_export_date_to           || &#39;)&#39; ||&#10;        &#39;(crn&#61;&#39;               || p_crn                          || &#39;)&#39; ||&#10;        &#39;(spg_not_id&#61;&#39;        || p_spg_notification_id          || &#39;)&#39; ||&#10;        &#39;(off_id&#61;&#39;            || p_offender_id                  || &#39;)&#39; ||&#10;        &#39;(trig_mode&#61;&#39;         || p_db_trigger_mode              || &#39;)&#39; ||&#10;        &#39;(export status&#61;&#39;     || p_status_export_flag           || &#39;)&#39; ||&#10;        &#39;(debug&#61;&#39;             || p_debug_flag                   || &#39;)&#39; ||&#10;        --&#10;        &#39;(max rows&#61;&#39;    || p_max_rows    || &#39;)&#39; ||&#10;        &#39;(max rows L1&#61;&#39; || p_max_rows_L1 || &#39;)&#39; ||&#10;        &#39;(max rows L3&#61;&#39; || p_max_rows_L3 || &#39;)&#39; ||&#10;        --&#10;        &#39;(bg flag&#61;&#39;     || l_async_flag  || &#39;)&#39; );&#10;    --&#10;    g_label :&#61; &#39;00050&#39;;&#10;    --&#10;    IF l_async_flag &#61; &#39;Y&#39; THEN&#10;        create_bg_process;&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    g_label :&#61; &#39;00060&#39;;&#10;    --&#10;    do_allocate_soft_lock;&#10;    --&#10;    g_label :&#61; &#39;00070&#39;;&#10;    --&#10;    IF p_spg_notification_id IS NULL THEN&#10;        --&#10;        l_batch_flag :&#61; 1;&#10;        --&#10;        WITH T AS (&#10;          SELECT DISTINCT&#10;            offender_id,&#10;            rbac_level&#10;          FROM TABLE( PKG_SPG_EXPORT.procGetOffCRCExtractTAB(&#10;                          p_probation_area_id           &#61;&gt; p_probation_area_id,&#10;                          p_team_id                     &#61;&gt; p_team_id,&#10;                          p_staff_id                    &#61;&gt; p_staff_id,&#10;                          p_excl_already_extracted_flag &#61;&gt; p_excl_already_extracted_flag,&#10;                          p_incl_already_extracted_flag &#61;&gt; p_incl_already_extracted_flag,&#10;                          p_crc_export_date_from        &#61;&gt; p_crc_export_date_from,&#10;                          p_crc_export_date_to          &#61;&gt; p_crc_export_date_to,&#10;                          p_crn                         &#61;&gt; p_crn,&#10;                          p_status_export_flag          &#61;&gt; p_status_export_flag,&#10;                          p_debug_flag                  &#61;&gt; p_debug_flag,&#10;                          --&#10;                          p_max_rows                    &#61;&gt; p_max_rows,&#10;                          p_max_rows_L1                 &#61;&gt; p_max_rows_L1,&#10;                          p_max_rows_L3                 &#61;&gt; p_max_rows_L3 ) )&#10;        )&#10;        --&#10;        SELECT&#10;          offender_crc_export_id_SEQ.NEXTVAL    AS offender_crc_export_id,&#10;          offender_id,&#10;          p_probation_area_id                   AS crc_provider_id,&#10;          SYSDATE                               AS export_date,&#10;          DECODE(rbac_level, &#39;L1&#39;, 1, &#39;L3&#39;, 3)  AS requested_export_level,&#10;          NULL                                  AS submitted_datetime,&#10;          NULL                                  AS processed_datetime,&#10;          NULL                                  AS spg_notification_id&#10;        BULK COLLECT INTO l_TAB&#10;        FROM T;&#10;    ELSIF p_spg_notification_id IS NOT NULL AND p_offender_id IS NULL AND NVL(p_db_trigger_mode, &#39;N&#39;) &lt;&gt; &#39;Y&#39; THEN&#10;        --&#10;        l_batch_flag :&#61; 0;&#10;        --&#10;        SELECT&#10;          offender_crc_export_id_SEQ.nextval        AS offender_crc_export_id,&#10;          S.offender_id,&#10;          p_probation_area_id                       AS crc_provider_id,&#10;          SYSDATE                                   AS export_date,&#10;          NULL                                      AS requested_export_level,&#10;          NVL(S.date_created, SYSDATE)              AS submitted_datetime,&#10;          ( SELECT NVL(MIN(date_created), SYSDATE)&#10;            FROM spg_notification S1&#10;            WHERE S1.receiver_control_reference &#61; S.control_reference&#10;              AND S1.business_interaction_id IN ( G_BI_202_ID, G_BI_410_ID, G_BI_413_ID )&#10;          )                                         AS processed_datetime,&#10;          S.spg_notification_id&#10;        BULK COLLECT INTO l_TAB&#10;        FROM&#10;          spg_notification S&#10;            INNER JOIN business_interaction BI ON BI.business_interaction_id &#61; S.business_interaction_id&#10;        WHERE S.spg_notification_id &#61; p_spg_notification_id&#10;          AND BI.business_interaction_code &#61; GC_BI_ALLOC_OFFENDER&#10;          AND S.receiver_identity_id &#61; p_probation_area_id;&#10;        --&#10;    ELSIF  p_spg_notification_id IS NOT NULL AND p_offender_id IS NOT NULL AND p_db_trigger_mode &#61; &#39;Y&#39; AND get_crc_export_deferred_FLAG &#61; FALSE THEN&#10;        --&#10;        l_batch_flag :&#61; 0;&#10;        --&#10;        SELECT&#10;          offender_crc_export_id_SEQ.nextval        AS offender_crc_export_id,&#10;          p_offender_id                             AS offender_id,&#10;          p_probation_area_id                       AS crc_provider_id,&#10;          SYSDATE                                   AS export_date,&#10;          NULL                                      AS requested_export_level,&#10;          SYSDATE                                   AS submitted_datetime,&#10;          NULL                                      AS processed_datetime,&#10;          p_spg_notification_id                     AS spg_notification_id&#10;        BULK COLLECT INTO l_TAB&#10;        FROM dual;&#10;        --&#10;    ELSE&#10;        raise_application_error(-20001, &#39;FATAL ERROR in PKG_SPG_EXPORT: an invalid combination of parameters&#39;);&#10;    END IF;&#10;    --&#10;    g_label :&#61; &#39;00080&#39;;&#10;    --&#10;    --raise_application_error(-20001, &#39;PKG_SPG_EXPORT: l_TAB.COUNT&#61;&#39; || l_TAB.COUNT);&#10;    --&#10;    FOR l_idx IN 1 .. l_TAB.COUNT LOOP&#10;        --&#10;        UPDATE offender_crc_export SET&#10;          current_record_flag &#61; NULL&#10;        WHERE offender_id &#61; l_tab(l_idx).offender_id&#10;          AND crc_provider_id &#61; l_tab(l_idx).crc_provider_id;&#10;        --&#10;        MERGE INTO offender_crc_export t0&#10;        USING (&#10;          SELECT&#10;            --l_tab(l_idx).offender_crc_export_id,&#10;            &#39;Y&#39;                                 AS current_record_flag,&#10;            l_tab(l_idx).offender_id            AS offender_id,&#10;            l_tab(l_idx).crc_provider_id        AS crc_provider_id,&#10;            l_tab(l_idx).export_date            AS export_date,&#10;            l_tab(l_idx).requested_export_level AS requested_export_level,&#10;            l_tab(l_idx).submitted_datetime     AS submitted_datetime,&#10;            l_tab(l_idx).processed_datetime     AS processed_datetime,&#10;            l_tab(l_idx).spg_notification_id    AS spg_notification_id,&#10;            l_batch_flag                        AS batch_flag,&#10;            l_user_id                           AS created_by_user_id,&#10;            SYSDATE                             AS created_datetime,&#10;            l_user_id                           AS last_updated_user_id,&#10;            SYSDATE                             AS last_updated_datetime&#10;          FROM dual&#10;        ) T1&#10;        ON ( t0.spg_notification_id &#61; t1.spg_notification_id )&#10;        WHEN MATCHED THEN UPDATE SET&#10;          t0.current_record_flag    &#61; &#39;Y&#39;,&#10;          t0.offender_id            &#61; t1.offender_id,&#10;          t0.crc_provider_id        &#61; t1.crc_provider_id,&#10;          t0.export_date            &#61; t1.export_date,&#10;          t0.requested_export_level &#61; t1.requested_export_level,&#10;          t0.submitted_datetime     &#61; t1.submitted_datetime,&#10;          t0.processed_datetime     &#61; t1.processed_datetime,&#10;          t0.batch_flag             &#61; t1.batch_flag,&#10;          t0.last_updated_user_id   &#61; t1.last_updated_user_id,&#10;          t0.last_updated_datetime  &#61; t1.last_updated_datetime,&#10;          t0.row_version            &#61; t0.row_version + 1&#10;        WHEN NOT MATCHED THEN&#10;          INSERT (&#10;            offender_crc_export_id,&#10;            current_record_flag,&#10;            offender_id,&#10;            crc_provider_id,&#10;            export_date,&#10;            requested_export_level,&#10;            submitted_datetime,&#10;            processed_datetime,&#10;            spg_notification_id,&#10;            batch_flag,&#10;            created_by_user_id,&#10;            created_datetime,&#10;            last_updated_user_id,&#10;            last_updated_datetime&#10;          ) VALUES (&#10;            offender_crc_export_id_SEQ.nextval,&#10;            t1.current_record_flag,&#10;            t1.offender_id,&#10;            t1.crc_provider_id,&#10;            t1.export_date,&#10;            t1.requested_export_level,&#10;            t1.submitted_datetime,&#10;            t1.processed_datetime,&#10;            t1.spg_notification_id,&#10;            t1.batch_flag,&#10;            t1.created_by_user_id,&#10;            t1.created_datetime,&#10;            t1.last_updated_user_id,&#10;            t1.last_updated_datetime&#10;          );&#10;    END LOOP;&#10;    --&#10;    g_label :&#61; &#39;00090&#39;;&#10;    --&#10;    info(&#39;PKG_SPG_EXPORT.create_crc_export_batch: Offender Export Batch has been created succussfully: &#39; || l_TAB.COUNT || &#39; records have been processed.&#39;);&#10;    --&#10;    do_release_soft_lock;&#10;    --&#10;    g_label :&#61; &#39;00100&#39;;&#10;    --&#10;--EXCEPTION WHEN OTHERS THEN&#10;--    do_release_soft_lock;&#10;--    fatal(&#39;PKG_SPG_EXPORT.create_crc_export_batch ERROR: &#39; || SQLERRM);&#10;END create_crc_export_batch;&#10;&#10;--&#10;-- Generate 202 (Response) messages&#10;--&#10;PROCEDURE generate_spg_response_202(&#10;    p_crc_provider_id     NUMBER DEFAULT NULL,&#10;    p_export_date_from    DATE   DEFAULT NULL,&#10;    p_export_date_to      DATE   DEFAULT NULL,&#10;    p_spg_notification_id NUMBER DEFAULT NULL )&#10;IS&#10;    --&#10;    CURSOR cs IS&#10;      SELECT&#10;        T1.offender_crc_export_id, T1.offender_id, T1.crc_provider_id, T1.export_date,&#10;        T1.row_version, T1.created_by_user_id, T1.created_datetime, T1.last_updated_user_id, T1.last_updated_datetime,&#10;        T1.requested_export_level,&#10;        T1.error_flag, T1.submitted_datetime, T1.processed_datetime, T1.error_message, T1.spg_notification_id&#10;        --OT.offender_transfer_id&#10;      FROM&#10;        offender_crc_export T1&#10;          --INNER JOIN offender_transfer OT ON OT.offender_id &#61; T1.offender_id&#10;            --INNER JOIN team T ON T.team_id &#61; OT.receiving_team_id&#10;              --INNER JOIN probation_area PA ON PA.probation_area_id &#61; T.probation_area_id&#10;      WHERE 1&#61;1&#10;        --AND PA.probation_area_id &#61; T1.crc_provider_id&#10;        AND T1.crc_provider_id &#61; NVL(p_crc_provider_id, T1.crc_provider_id)&#10;        AND T1.processed_datetime IS NULL&#10;        AND ( p_export_date_from IS NULL OR T1.export_date &gt;&#61; p_export_date_from )&#10;        AND ( p_export_date_to   IS NULL OR T1.export_date &lt;&#61; p_export_date_to   )&#10;        AND ( p_spg_notification_id IS NULL OR T1.spg_notification_id &#61; p_spg_notification_id );&#10;    --&#10;    l_rec cs%ROWTYPE;&#10;    --&#10;    PROCEDURE do_submit_202(p_spg_notification_id NUMBER)&#10;    IS&#10;    BEGIN&#10;        INSERT INTO spg_notification (&#10;          spg_notification_id,&#10;          business_interaction_id,&#10;          offender_id,&#10;          unique_id,&#10;          date_created,&#10;          message_direction,&#10;          sender_identity_id,&#10;          receiver_identity_id,&#10;          control_reference,&#10;          receiver_control_reference )&#10;        SELECT&#10;          spg_notification_id_seq.NEXTVAL,&#10;          G_BI_202_ID,&#10;          NULL AS offender_id,&#10;          NULL AS unique_id,&#10;          SYSDATE,&#10;          &#39;I&#39;,&#10;          receiver_identity_id AS sender_identity_id,&#10;          sender_identity_id   AS receiver_identity_id,&#10;          --&#10;          SPGConfig.getNextControlReference(PKG_Lookups.funcgetTabRecord_CACHED(p_table&#61;&gt;&#39;PROBATION_AREA&#39;, p_ref_col&#61;&gt;&#39;PROBATION_AREA_ID&#39;, p_ref_val&#61;&gt;sender_identity_id, p_data_fld&#61;&gt;&#39;CODE&#39;)),&#10;          control_reference&#10;        FROM spg_notification&#10;        WHERE spg_notification_id &#61; p_spg_notification_id;&#10;    END do_submit_202;&#10;    --&#10;BEGIN&#10;    OPEN cs;&#10;    LOOP&#10;        FETCH cs INTO l_rec;&#10;        EXIT WHEN cs%NOTFOUND;&#10;        --&#10;        do_submit_202(l_rec.spg_notification_id);&#10;    END LOOP;&#10;    CLOSE cs;&#10;END generate_spg_response_202;&#10;&#10;--&#10;-- CRC Inactive (ANY prev engagement) Offenders&#10;--&#10;FUNCTION procGetInactiveOffCRCTAB(&#10;    p_probation_area_id           NUMBER,&#10;    p_team_id                     NUMBER   DEFAULT NULL,&#10;    p_staff_id                    NUMBER   DEFAULT NULL,&#10;    --&#10;    p_exclude_extracted_flag      VARCHAR2 DEFAULT &#39;N&#39;,&#10;    --&#10;    p_debug_flag                  VARCHAR2 DEFAULT &#39;Y&#39;,&#10;    --&#10;    p_max_rows                    INTEGER  DEFAULT -1 )&#10;RETURN ttabInactiveOffCRC PIPELINED&#10;IS&#10;    --&#10;    lc_proc CONSTANT VARCHAR2(30) :&#61; &#39;procGetInactiveOffCRCTAB&#39;;&#10;    --&#10;    TYPE l_cur_TYP IS REF CURSOR;&#10;    l_cur l_cur_TYP;&#10;    --&#10;    l_rec trecInactiveOffCRC;&#10;    l_tab ttabInactiveOffCRC;&#10;    --&#10;    l_SQL     CLOB;&#10;    --&#10;    l_cnt         INTEGER :&#61; 0;&#10;    l_max_rows    INTEGER;&#10;    --&#10;    --&#10;    TYPE l_tab_off_TYP IS TABLE OF VARCHAR2(1) INDEX BY VARCHAR2(50);&#10;    l_tab_off l_tab_off_TYP;&#10;    l_key     VARCHAR2(50);&#10;    --&#10;BEGIN&#10;    --&#10;    IF p_debug_flag &#61; &#39;Y&#39; THEN&#10;        PKG_Debug.procrecordDbStats_START;&#10;    END IF;&#10;    --&#10;    --TYPE trecInactiveOffCRC IS RECORD(&#10;    --  /*00*/ crc_inactive_offender_id NUMBER,&#10;    --  /*01*/ offender_id              NUMBER,&#10;    --  /*02*/ crc_provider_id          NUMBER,&#10;    --  /*03*/ processed_flag           SMALLINT,&#10;    --  /*04*/ processed_datetime       DATE,&#10;    --  /*05*/ created_by_user_id       NUMBER,&#10;&#9;--  /*06*/ created_datetime         DATE,&#10;&#9;--  /*07*/ last_updated_user_id     NUMBER,&#10;&#9;--  /*08*/ last_updated_datetime    DATE&#10;    --);&#10;    --&#10;    l_SQL :&#61;&#10;&#39;WITH&#10;  --&#10;  PA AS (&#10;    SELECT probation_area_id&#10;    FROM probation_area&#10;    WHERE probation_area_id &#61; :p_probation_area_id ),&#10;  TEAM1 AS (&#10;    SELECT team_id&#10;    FROM team&#10;    WHERE &#39; || CASE WHEN p_team_id IS NOT NULL THEN &#39;team_id &#61; :p_team_id&#39; ELSE &#39;:p_team_id IS NULL AND 1&lt;&gt;1&#39; END || &#39; ),&#10;  STAFF1 AS (&#10;    SELECT staff_id&#10;    FROM staff&#10;    WHERE &#39; || CASE WHEN p_staff_id IS NOT NULL THEN &#39;staff_id &#61; :p_staff_id&#39; ELSE &#39;:p_staff_id IS NULL AND 1&lt;&gt;1&#39; END || &#39; ),&#10;  --&#10;  T AS (&#10;    -- 01. OFFENDER_MANAGER, OFFENDER_TRANSFER tables&#10;    SELECT OM.offender_id, T.probation_area_id, OM.trust_provider_flag, OM.trust_provider_team_id, OM.provider_employee_id&#10;    FROM&#10;      offender_manager OM&#10;        &#39; || CASE WHEN p_team_id  IS NOT NULL THEN &#39;INNER JOIN TEAM1 ON TEAM1.team_id &#61; OM.team_id&#39;                ELSE &#39;--&#39; END || &#39;&#10;        &#39; || CASE WHEN p_staff_id IS NOT NULL THEN &#39;INNER JOIN STAFF1 ON STAFF1.staff_id &#61; OM.allocation_staff_id&#39; ELSE &#39;--&#39; END || &#39;&#10;        INNER JOIN all_team T ON T.trust_provider_flag &#61; OM.trust_provider_flag AND T.trust_provider_team_id &#61; OM.trust_provider_team_id&#10;          INNER JOIN PA ON PA.probation_area_id &#61; T.probation_area_id&#10;    WHERE OM.active_flag &#61; 0&#10;      -- Soft Deleted Flag check&#10;      AND OM.soft_deleted &#61; 0&#10;    UNION&#10;    -- 02. ORDER_MANAGER, EVENT and ORDER_TRANSFER tables&#10;    SELECT E.offender_id, T.probation_area_id, OM.trust_provider_flag, OM.trust_provider_team_id, OM.provider_employee_id&#10;    FROM&#10;      event E&#10;        INNER JOIN order_manager OM ON OM.event_id &#61; E.event_id&#10;          &#39; || CASE WHEN p_team_id  IS NOT NULL THEN &#39;INNER JOIN TEAM1 ON TEAM1.team_id &#61; OM.allocation_team_id&#39;     ELSE &#39;--&#39; END || &#39;&#10;          &#39; || CASE WHEN p_staff_id IS NOT NULL THEN &#39;INNER JOIN STAFF1 ON STAFF1.staff_id &#61; OM.allocation_staff_id&#39; ELSE &#39;--&#39; END || &#39;&#10;          INNER JOIN all_team T ON T.trust_provider_flag &#61; OM.trust_provider_flag AND T.trust_provider_team_id &#61; OM.trust_provider_team_id&#10;            INNER JOIN PA ON PA.probation_area_id &#61; T.probation_area_id&#10;    WHERE OM.active_flag &#61; 0&#10;      -- Soft Deleted Flag check&#10;      AND E.soft_deleted &#61; 0&#10;      AND OM.soft_deleted &#61; 0&#10;    UNION&#10;    -- 03. LIC_CONDITION_MANAGER, LIC_CONDITION and LIC_CONDITION_TRANSFER tables&#10;    SELECT E.offender_id, T.probation_area_id, LCM.trust_provider_flag, LCM.trust_provider_team_id, LCM.provider_employee_id&#10;    FROM&#10;      event E&#10;        INNER JOIN disposal D ON D.event_id &#61; E.event_id&#10;          INNER JOIN lic_condition LC ON LC.disposal_id &#61; D.disposal_id&#10;            INNER JOIN lic_condition_manager LCM ON LCM.lic_condition_id &#61; LC.lic_condition_id&#10;              &#39; || CASE WHEN p_team_id  IS NOT NULL THEN &#39;INNER JOIN TEAM1 ON TEAM1.team_id &#61; LCM.team_id&#39;     ELSE &#39;--&#39; END || &#39;&#10;              &#39; || CASE WHEN p_staff_id IS NOT NULL THEN &#39;INNER JOIN STAFF1 ON STAFF1.staff_id &#61; LCM.staff_id&#39; ELSE &#39;--&#39; END || &#39;&#10;              INNER JOIN all_team T ON T.trust_provider_flag &#61; LCM.trust_provider_flag AND T.trust_provider_team_id &#61; LCM.trust_provider_team_id&#10;                INNER JOIN PA ON PA.probation_area_id &#61; T.probation_area_id&#10;    WHERE LCM.active_flag &#61; 0&#10;      --AND LC.termination_date IS NULL&#10;      -- Soft Deleted Flag check&#10;      AND E.soft_deleted &#61; 0&#10;      AND D.soft_deleted &#61; 0&#10;      AND LC.soft_deleted &#61; 0&#10;      AND LCM.soft_deleted &#61; 0&#10;    UNION&#10;    -- 04. RQMNT_MANAGER, RQMNT and RQMNT_TRANSFER&#10;    SELECT E.offender_id, T.probation_area_id, RQM.trust_provider_flag, RQM.trust_provider_team_id, RQM.provider_employee_id&#10;    FROM&#10;      event E&#10;        INNER JOIN disposal D ON D.event_id &#61; E.event_id&#10;          INNER JOIN rqmnt R ON R.disposal_id &#61; D.disposal_id&#10;            INNER JOIN rqmnt_manager RQM ON RQM.rqmnt_id &#61; R.rqmnt_id&#10;              &#39; || CASE WHEN p_team_id  IS NOT NULL THEN &#39;INNER JOIN TEAM1 ON TEAM1.team_id &#61; RQM.allocated_team_id&#39;     ELSE &#39;--&#39; END || &#39;&#10;              &#39; || CASE WHEN p_staff_id IS NOT NULL THEN &#39;INNER JOIN STAFF1 ON STAFF1.staff_id &#61; RQM.allocated_staff_id&#39; ELSE &#39;--&#39; END || &#39;&#10;              INNER JOIN all_team T ON T.trust_provider_flag &#61; RQM.trust_provider_flag AND T.trust_provider_team_id &#61; RQM.trust_provider_team_id&#10;                INNER JOIN PA ON PA.probation_area_id &#61; T.probation_area_id&#10;    WHERE RQM.active_flag &#61; 0&#10;      --AND R.termination_date IS NULL&#10;      -- Soft Deleted Flag check&#10;      AND E.soft_deleted &#61; 0&#10;      AND D.soft_deleted &#61; 0&#10;      AND R.soft_deleted &#61; 0&#10;      AND RQM.soft_deleted &#61; 0&#10;    UNION&#10;    -- 05. REPORT_MANAGER, COURT_REPORT, INSTITUTIONAL_REPORT_TRANSFER and COURT_REPORT_TRANSFER&#10;    SELECT E.offender_id, T.probation_area_id, RM.trust_provider_flag, RM.trust_provider_team_id, RM.provider_employee_id&#10;    FROM&#10;      event E&#10;        INNER JOIN report_manager RM ON RM.event_id &#61; E.event_id&#10;          &#39; || CASE WHEN p_team_id  IS NOT NULL THEN &#39;INNER JOIN TEAM1 ON TEAM1.team_id &#61; RM.team_id&#39;     ELSE &#39;--&#39; END || &#39;&#10;          &#39; || CASE WHEN p_staff_id IS NOT NULL THEN &#39;INNER JOIN STAFF1 ON STAFF1.staff_id &#61; RM.staff_id&#39; ELSE &#39;--&#39; END || &#39;&#10;          INNER JOIN all_team T ON T.trust_provider_flag &#61; RM.trust_provider_flag AND T.trust_provider_team_id &#61; RM.trust_provider_team_id&#10;            INNER JOIN PA ON PA.probation_area_id &#61; T.probation_area_id&#10;    WHERE RM.active_flag &#61; 0&#10;      -- Soft Deleted Flag check&#10;      AND E.soft_deleted &#61; 0&#10;      AND RM.soft_deleted &#61; 0&#10;    UNION&#10;    -- 06. NSI_MANAGER, NSI and NSI_TRANSFER&#10;    SELECT N.offender_id, T.probation_area_id, 0 AS trust_provider_flag, NM.team_id AS trust_provider_team_id, NM.staff_id AS provider_employee_id&#10;    FROM&#10;      nsi N&#10;        INNER JOIN nsi_manager NM ON NM.nsi_id &#61; N.nsi_id&#10;          &#39; || CASE WHEN p_team_id  IS NOT NULL THEN &#39;INNER JOIN TEAM1 ON TEAM1.team_id &#61; NM.team_id&#39; ELSE &#39;--&#39; END || &#39;&#10;          &#39; || CASE WHEN p_staff_id IS NOT NULL THEN &#39;INNER JOIN STAFF1 ON STAFF1.staff_id &#61; NM.staff_id&#39; ELSE &#39;--&#39; END || &#39;&#10;          INNER JOIN team T ON T.team_id &#61; NM.team_id&#10;            INNER JOIN PA ON PA.probation_area_id &#61; T.probation_area_id&#10;    WHERE NM.active_flag &#61; 0&#10;      --AND N.active_flag &#61; 1&#10;      -- Soft Deleted Flag check&#10;      AND N.soft_deleted &#61; 0&#10;      AND NM.soft_deleted &#61; 0&#10;    UNION&#10;    -- 07. PSS_RQMNT, PSS_RQMNT_MANAGER and PSS_RQMNT_TRANSFER&#10;    SELECT PR.offender_id, T.probation_area_id, 0 AS trust_provider_flag, PRM.team_id AS trust_provider_team_id, PRM.staff_id AS provider_employee_id&#10;    FROM&#10;      pss_rqmnt PR&#10;        INNER JOIN pss_rqmnt_manager PRM ON PRM.pss_rqmnt_id &#61; PR.pss_rqmnt_id&#10;          &#39; || CASE WHEN p_team_id  IS NOT NULL THEN &#39;INNER JOIN TEAM1 ON TEAM1.team_id &#61; PRM.team_id&#39;     ELSE &#39;--&#39; END || &#39;&#10;          &#39; || CASE WHEN p_staff_id IS NOT NULL THEN &#39;INNER JOIN STAFF1 ON STAFF1.staff_id &#61; PRM.staff_id&#39; ELSE &#39;--&#39; END || &#39;&#10;          INNER JOIN team T ON T.team_id &#61; PRM.team_id&#10;            INNER JOIN PA ON PA.probation_area_id &#61; T.probation_area_id&#10;    WHERE PRM.active_flag &#61; 0&#10;      --AND PR.termination_date IS NULL&#10;      -- Soft Deleted Flag check&#10;      AND PR.soft_deleted &#61; 0&#10;      AND PRM.soft_deleted &#61; 0&#10;    UNION&#10;    -- 08. APPROVED_PREMISES_REFERRAL&#10;    SELECT APR.offender_id, RAP.probation_area_id, 0 AS trust_provider_flag, NULL AS trust_provider_team_id, NULL AS provider_employee_id&#10;    FROM&#10;      approved_premises_referral APR&#10;        INNER JOIN r_approved_premises RAP ON RAP.approved_premises_id &#61; APR.approved_premises_id&#10;          INNER JOIN PA ON PA.probation_area_id &#61; RAP.probation_area_id&#10;    WHERE 1&#61;1&#10;      &#39; || CASE WHEN p_team_id  IS NOT NULL THEN &#39;AND 1&lt;&gt;1&#39; ELSE &#39;--&#39; END || &#39;&#10;      &#39; || CASE WHEN p_staff_id IS NOT NULL THEN &#39;AND 1&lt;&gt;1&#39; ELSE &#39;--&#39; END || &#39;&#10;      -- Soft Deleted Flag check&#10;      AND APR.soft_deleted &#61; 0&#10;    UNION&#10;    SELECT APR.offender_id, RAP.probation_area_id, 0 AS trust_provider_flag, NULL AS trust_provider_team_id, NULL AS provider_employee_id&#10;    FROM&#10;      approved_premises_referral APR&#10;      INNER JOIN r_ap_referral_group RAPRG ON RAPRG.standard_reference_list_id &#61; APR.referral_group_id&#10;        INNER JOIN r_approved_premises RAP ON RAP.approved_premises_id &#61; RAPRG.approved_premises_id&#10;          INNER JOIN PA ON PA.probation_area_id &#61; RAP.probation_area_id&#10;    WHERE 1&#61;1&#10;      &#39; || CASE WHEN p_team_id  IS NOT NULL THEN &#39;AND 1&lt;&gt;1&#39; ELSE &#39;--&#39; END || &#39;&#10;      &#39; || CASE WHEN p_staff_id IS NOT NULL THEN &#39;AND 1&lt;&gt;1&#39; ELSE &#39;--&#39; END || &#39;&#10;      AND APR.approved_premises_id IS NULL&#10;      -- Soft Deleted Flag check&#10;      AND APR.soft_deleted &#61; 0&#10;    --&#10;    UNION&#10;    -- 09. PRISON_OFFENDER_MANAGER, (YF TODO: PRISON_OFFENDER_TRANSFER)&#10;    SELECT POM.offender_id, T.probation_area_id, 0 AS trust_provider_flag, POM.allocation_team_id AS provider_team_id, POM.allocation_staff_id AS provider_employee_id&#10;    FROM&#10;      prison_offender_manager POM&#10;        &#39; || CASE WHEN p_team_id  IS NOT NULL THEN &#39;INNER JOIN TEAM1 ON TEAM1.team_id &#61; POM.allocation_team_id&#39;     ELSE &#39;--&#39; END || &#39;&#10;        &#39; || CASE WHEN p_staff_id IS NOT NULL THEN &#39;INNER JOIN STAFF1 ON STAFF1.staff_id &#61; POM.allocation_staff_id&#39; ELSE &#39;--&#39; END || &#39;&#10;        INNER JOIN team T ON T.team_id &#61; POM.allocation_team_id&#10;          INNER JOIN PA ON PA.probation_area_id &#61; T.probation_area_id&#10;    WHERE POM.active_flag &#61; 0&#10;      -- Soft Deleted Flag check&#10;      AND POM.soft_deleted &#61; 0 ),&#10;  --&#10;  T1 AS (&#10;    SELECT T.*&#10;    FROM T&#10;    WHERE 1&#61;1&#10;      AND NOT EXISTS(&#10;          SELECT 1&#10;          FROM caseload CL INNER JOIN all_team T2 ON T2.trust_provider_flag &#61; CL.trust_provider_flag AND T2.trust_provider_team_id &#61; CL.trust_provider_team_id&#10;          WHERE CL.offender_id &#61; T.offender_id&#10;            AND T2.probation_area_id &#61; T.probation_area_id&#10;          UNION ALL&#10;          SELECT 1&#10;          FROM&#10;            event E&#10;              INNER JOIN report_manager RM ON RM.event_id &#61; E.event_id AND RM.active_flag &#61; 1&#10;                INNER JOIN all_team T2 ON T2.trust_provider_flag &#61; RM.trust_provider_flag AND T2.trust_provider_team_id &#61; RM.trust_provider_team_id&#10;          WHERE E.offender_id &#61; T.offender_id&#10;            AND T2.probation_area_id &#61; T.probation_area_id&#10;            -- Soft Deleted Flag check&#10;            AND E.soft_deleted &#61; 0&#10;            AND RM.soft_deleted &#61; 0&#10;          )&#10;      AND NOT EXISTS(&#10;          SELECT 1&#10;          FROM offender_crc_export&#10;          WHERE offender_id &#61; T.offender_id&#10;            AND crc_provider_id &#61; T.probation_area_id&#10;            AND current_record_flag &#61; &#39;&#39;Y&#39;&#39; )&#10;      &#39; || CASE WHEN p_exclude_extracted_flag &#61; &#39;Y&#39; THEN &#39;AND NOT EXISTS( SELECT 1 FROM crc_inactive_offender WHERE offender_id &#61; T.offender_id AND crc_provider_id &#61; T.probation_area_id )&#39; ELSE &#39;--&#39; END || &#39;&#10;     )&#10;  --&#10;SELECT&#10;  /*00*/ CIO.crc_inactive_offender_id,&#10;  /*01*/ T1.offender_id,&#10;  /*02*/ T1.probation_area_id AS crc_provider_id,&#10;  /*03*/ CIO.processed_flag,&#10;  /*04*/ CIO.processed_datetime,&#10;  /*05*/ CIO.created_by_user_id,&#10;  /*06*/ CIO.created_datetime,&#10;  /*07*/ CIO.last_updated_user_id,&#10;  /*08*/ CIO.last_updated_datetime&#10;FROM&#10;  T1&#10;    LEFT OUTER JOIN crc_inactive_offender CIO ON CIO.offender_id &#61; T1.offender_id AND CIO.crc_provider_id &#61; T1.probation_area_id&#39;;&#10;    --&#10;    OPEN l_cur FOR l_SQL&#10;    USING&#10;      p_probation_area_id,&#10;      p_team_id,&#10;      p_staff_id;&#10;    --&#10;    IF NVL(p_max_rows, -1) &gt; 0 THEN&#10;        FETCH l_cur BULK COLLECT INTO l_tab LIMIT p_max_rows;&#10;    ELSE&#10;      FETCH l_cur BULK COLLECT INTO l_tab;&#10;    END IF;&#10;    --&#10;    CLOSE l_cur;&#10;    --&#10;    FOR l_i IN 1..l_tab.COUNT LOOP&#10;        --&#10;        l_rec :&#61; l_tab(l_i);&#10;        --&#10;        l_cnt :&#61; l_cnt + 1;&#10;        PIPE ROW ( l_rec );&#10;        --&#10;    END LOOP;&#10;    --&#10;    procDebug( lc_proc || &#39; (rows&#61;&#39; || l_tab.COUNT  || &#39;)&#39;   ||&#10;        &#39;(&#39; || PKG_Debug.funcgetDbStats   || &#39;): &#39; ||&#10;        &#39;(p_area_id&#61;&#39;                     || p_probation_area_id           || &#39;)&#39; ||&#10;        &#39;(p_team_id&#61;&#39;                     || p_team_id                     || &#39;)&#39; ||&#10;        &#39;(p_staff_id&#61;&#39;                    || p_staff_id                    || &#39;)&#39; ||&#10;        &#39;(p_max_rows&#61;&#39;                    || p_max_rows                    || &#39;)&#39; ||&#10;        CHR(10) || l_SQL );&#10;    --&#10;EXCEPTION&#10;    WHEN NO_DATA_NEEDED THEN&#10;        procDebug( lc_proc || &#39; (&#39; || l_cnt || &#39; of &#39; || l_tab.COUNT || &#39; rows called from the cursor)&#39; ||&#10;            &#39;(&#39; || PKG_Debug.funcgetDbStats   || &#39;): &#39; ||&#10;            &#39;(p_area_id&#61;&#39;                     || p_probation_area_id           || &#39;)&#39; ||&#10;            &#39;(p_team_id&#61;&#39;                     || p_team_id                     || &#39;)&#39; ||&#10;            &#39;(p_staff_id&#61;&#39;                    || p_staff_id                    || &#39;)&#39; ||&#10;            &#39;(p_max_rows&#61;&#39;                    || p_max_rows                    || &#39;)&#39; ||&#10;            CHR(10) || l_SQL );&#10;    WHEN OTHERS THEN&#10;        procDebug( lc_proc || &#39; ERROR: &#39; || SQLERRM || &#39; &#39; ||&#10;            &#39;(p_area_id&#61;&#39;                     || p_probation_area_id           || &#39;)&#39; ||&#10;            &#39;(p_team_id&#61;&#39;                     || p_team_id                     || &#39;)&#39; ||&#10;            &#39;(p_staff_id&#61;&#39;                    || p_staff_id                    || &#39;)&#39; ||&#10;            &#39;(p_max_rows&#61;&#39;                    || p_max_rows                    || &#39;)&#39; ||&#10;            CHR(10) || l_SQL );&#10;    RAISE;&#10;END procGetInactiveOffCRCTAB;&#10;&#10;PROCEDURE populate_inactive_offenders(&#10;    p_probation_area_id           NUMBER,&#10;    p_team_id                     NUMBER   DEFAULT NULL,&#10;    p_staff_id                    NUMBER   DEFAULT NULL,&#10;    --&#10;    p_max_rows                    INTEGER  DEFAULT -1 )&#10;IS&#10;    --&#10;    TYPE l_rec_TYP IS RECORD(&#10;      offender_id     NUMBER,&#10;      crc_provider_id NUMBER );&#10;    TYPE l_tab_TYP IS TABLE OF l_rec_TYP;&#10;    --&#10;    l_rec l_rec_TYP;&#10;    l_tab l_tab_TYP;&#10;    --&#10;    l_rows INTEGER :&#61; 0;&#10;    --&#10;BEGIN&#10;    --&#10;    SELECT&#10;      /*01*/ offender_id,&#10;      /*02*/ crc_provider_id&#10;    BULK COLLECT INTO l_TAB&#10;    FROM&#10;      TABLE(&#10;          PKG_SPG_EXPORT.procGetInactiveOffCRCTAB(&#10;               p_probation_area_id      &#61;&gt; p_probation_area_id,&#10;               p_team_id                &#61;&gt; p_team_id,&#10;               p_staff_id               &#61;&gt; p_staff_id,&#10;               p_exclude_extracted_flag &#61;&gt; &#39;Y&#39;,&#10;               p_max_rows               &#61;&gt; p_max_rows ) );&#10;    --&#10;    FOR l_i IN 1 .. l_TAB.COUNT LOOP&#10;        --&#10;        MERGE INTO crc_inactive_offender t0&#10;        USING (&#10;          SELECT&#10;            l_TAB(l_i).offender_id      AS offender_id,&#10;            l_TAB(l_i).crc_provider_id  AS crc_provider_id,&#10;            0                           AS processed_flag,&#10;            NULL                        AS processed_datetime,&#10;            0                           AS row_version,&#10;            3                           AS created_by_user_id,&#10;            SYSDATE                     AS created_datetime,&#10;            3                           AS last_updated_user_id,&#10;            SYSDATE                     AS last_updated_datetime&#10;          FROM dual&#10;        ) t1&#10;        ON ( t0.offender_id &#61; t1.offender_id AND t0.crc_provider_id &#61; t1.crc_provider_id )&#10;        WHEN MATCHED THEN UPDATE SET&#10;          t0.processed_flag        &#61; t1.processed_flag,&#10;          t0.processed_datetime    &#61; t1.processed_datetime,&#10;          t0.row_version           &#61; t0.row_version + 1,&#10;          t0.last_updated_user_id  &#61; t1.last_updated_user_id,&#10;          t0.last_updated_datetime &#61; t1.last_updated_datetime&#10;        WHEN NOT MATCHED THEN INSERT (&#10;          crc_inactive_offender_id,&#10;          offender_id,&#10;          crc_provider_id,&#10;          processed_flag,&#10;          processed_datetime,&#10;          row_version,&#10;          created_by_user_id,&#10;          created_datetime,&#10;          last_updated_user_id,&#10;          last_updated_datetime&#10;        ) VALUES (&#10;          crc_inactive_offender_id_SEQ.nextval,&#10;          t1.offender_id,&#10;          t1.crc_provider_id,&#10;          t1.processed_flag,&#10;          t1.processed_datetime,&#10;          t1.row_version,&#10;          t1.created_by_user_id,&#10;          t1.created_datetime,&#10;          t1.last_updated_user_id,&#10;          t1.last_updated_datetime );&#10;        --&#10;        l_rows :&#61; l_rows + SQL%ROWCOUNT;&#10;        --&#10;    END LOOP;&#10;    --&#10;END populate_inactive_offenders;&#10;--&#10;-- CRC Historical Caseload - Export AllocateOffender/Event XML messages&#10;--&#10;PROCEDURE export_inactive_offenders(&#10;    p_probation_area_id        NUMBER   DEFAULT NULL,&#10;    p_crc_inactive_offender_id NUMBER   DEFAULT NULL,&#10;    p_resubmit_failed_exports  VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_max_rows                 INTEGER  DEFAULT -1 )&#10;IS&#10;    --&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;EXPORT_INACTIVE_OFFENDERS&#39;;&#10;    --&#10;    l_max_rows            INTEGER :&#61; ( CASE&#10;                                           WHEN NVL(p_max_rows, -1) &gt; 0 THEN&#10;                                               p_MAX_ROWS&#10;                                           ELSE&#10;                                               PKG_Lookups.funcgetNDParameterValue(&#10;                                                   p_par_name      &#61;&gt; &#39;HISTORIC_CASELOAD_EXPORT_LIMIT&#39;,&#10;                                                   p_default_value &#61;&gt; 99999 )&#10;                                       END );&#10;    l_crc_provider_id     NUMBER;&#10;    l_spg_notification_id NUMBER;&#10;    --&#10;    CURSOR cs IS&#10;      SELECT PA.code AS area_code, O.crn, CIO.*&#10;      FROM&#10;        crc_inactive_offender CIO&#10;          INNER JOIN offender O ON O.offender_id &#61; CIO.offender_id&#10;          INNER JOIN probation_area PA ON PA.probation_area_id &#61; CIO.crc_provider_id&#10;      WHERE 1&#61;1&#10;        --AND CIO.processed_datetime IS NULL&#10;        AND CIO.processed_flag &#61; 0&#10;        AND CIO.crc_provider_id &#61; l_crc_provider_id&#10;        AND CIO.crc_inactive_offender_id &#61; NVL(p_crc_inactive_offender_id, CIO.crc_inactive_offender_id)&#10;      ORDER BY 1,2,3;&#10;    --&#10;    l_rec cs%ROWTYPE;&#10;    TYPE l_tab_TYP IS TABLE OF cs%ROWTYPE;&#10;    l_TAB l_tab_TYP;&#10;    --&#10;    CURSOR csE IS&#10;      WITH E AS (&#10;        SELECT&#10;          E.event_id,&#10;          E.event_number,&#10;          D.disposal_id,&#10;          D.termination_date&#10;        FROM&#10;          event    E,&#10;          disposal D&#10;        WHERE E.offender_id     &#61; l_rec.offender_id&#10;          AND E.soft_deleted    &#61; 0&#10;          AND D.event_id(+)     &#61; E.event_id&#10;          AND D.soft_deleted(+) &#61; 0 )&#10;      SELECT *&#10;      FROM E&#10;      WHERE 1&#61;1&#10;        --AND termination_date IS NULL&#10;      ;&#10;    --&#10;    l_rec_event csE%ROWTYPE;&#10;    --&#10;    PROCEDURE do_submit_alloc(p_bi_code VARCHAR2, p_offender_id NUMBER, p_unique_id NUMBER DEFAULT NULL, p_area_id NUMBER, x_spg_notification_id IN OUT NUMBER)&#10;    IS&#10;    BEGIN&#10;        INSERT INTO spg_notification (&#10;          spg_notification_id,&#10;          business_interaction_id,&#10;          offender_id,&#10;          unique_id,&#10;          date_created,&#10;          message_direction,&#10;          sender_identity_id,&#10;          receiver_identity_id,&#10;          control_reference,&#10;          export_to_file_flag&#10;        ) VALUES (&#10;          spg_notification_id_seq.NEXTVAL,&#10;          PKG_LOOKUPS.funcGetBusinessInteractionID(p_bi_code),&#10;          p_offender_id,&#10;          NVL(p_unique_id, p_offender_id),&#10;          SYSDATE,&#10;          &#39;O&#39;,&#10;          PKG_Lookups.funcgetTabRecord_CACHED(p_table&#61;&gt;&#39;PROBATION_AREA&#39;, p_ref_col&#61;&gt;&#39;code&#39;, p_ref_val&#61;&gt;&#39;N00&#39;, p_data_fld&#61;&gt;&#39;probation_area_ID&#39;),&#10;          p_area_id,&#10;          SPGConfig.getnextcontrolreference(&#39;N00&#39;),&#10;          1&#10;        )&#10;        RETURNING spg_notification_id&#10;        INTO x_spg_notification_id;&#10;    END do_submit_alloc;&#10;    --&#10;    PROCEDURE do_submit_offender&#10;    IS&#10;        l_id NUMBER;&#10;    BEGIN&#10;        do_submit_alloc(GC_BI_OFFENDER, l_rec.offender_id, l_rec.offender_id /*offender_transfer_id*/, l_rec.crc_provider_id, l_id);&#10;    END do_submit_offender;&#10;    --&#10;    PROCEDURE do_submit_alloc_offender IS&#10;    BEGIN&#10;        do_submit_alloc(GC_BI_ALLOC_OFFENDER, l_rec.offender_id, l_rec.offender_id /*offender_transfer_id*/, l_rec.crc_provider_id, l_spg_notification_id);&#10;    END do_submit_alloc_offender;&#10;    --&#10;    PROCEDURE do_submit_alloc_event&#10;    IS&#10;        l_id NUMBER;&#10;    BEGIN&#10;        do_submit_alloc(GC_BI_ALLOC_EVENT, l_rec.offender_id, l_rec_event.event_id, l_rec.crc_provider_id, l_id);&#10;    END do_submit_alloc_event;&#10;    --&#10;    PROCEDURE do_upd_submit_details(p_crc_inactive_offender_id NUMBER) IS&#10;    BEGIN&#10;        UPDATE crc_inactive_offender SET&#10;          row_version           &#61; row_version + 1,&#10;          last_updated_user_id  &#61; 3,&#10;          last_updated_datetime &#61; SYSDATE,&#10;          --&#10;          processed_datetime    &#61; SYSDATE,&#10;          processed_flag        &#61; 1&#10;        WHERE crc_inactive_offender_id &#61; p_crc_inactive_offender_id;&#10;    END do_upd_submit_details;&#10;    --&#10;--    PROCEDURE do_upd_error_details(p_crc_inactive_offender_id NUMBER, p_err_msg VARCHAR2) IS&#10;--    BEGIN&#10;--        UPDATE crc_inactive_offender SET&#10;--          row_version           &#61; row_version + 1,&#10;--          last_updated_user_id  &#61; 3,&#10;--          last_updated_datetime &#61; SYSDATE,&#10;--          --&#10;--          error_flag            &#61; 1,&#10;--          error_message         &#61; p_err_msg&#10;--        --WHERE CURRENT OF cs;&#10;--        WHERE crc_inactive_offender_id &#61; p_crc_inactive_offender_id;&#10;--    END do_upd_error_details;&#10;    --&#10;    PROCEDURE do_resubmit_failed_exports&#10;    IS&#10;        --&#10;        l_age_min NUMBER :&#61; 5;&#10;        --&#10;        CURSOR cs IS&#10;        SELECT&#10;          S.spg_notification_id,&#10;          BI.business_interaction_code  AS bi_code,&#10;          BI.description                AS BI_desc,&#10;          PA2.code                      AS receiver_area,&#10;          S.offender_id,&#10;          S.unique_id,&#10;          S.processed_flag,&#10;          S.error_flag,&#10;          S.error_message&#10;        FROM&#10;          spg_notification S&#10;            INNER JOIN business_interaction BI ON BI.business_interaction_id &#61; S.business_interaction_id&#10;              INNER JOIN probation_area PA2 ON PA2.probation_area_id &#61; S.receiver_identity_id&#10;          WHERE 1&#61;1&#10;            AND S.message_direction &#61; &#39;O&#39;&#10;            AND S.export_to_file_flag &#61; 1&#10;            AND S.error_flag &#61; 1&#10;            AND ( S.processed_flag IN (0, 4) OR S.error_flag &#61; 1)&#10;            AND SYSDATE - date_created &gt;&#61; l_age_min * 1/24/60&#10;            AND receiver_identity_id &#61; l_crc_provider_id&#10;            AND offender_id &#61; NVL(p_crc_inactive_offender_id, offender_id)&#10;          ORDER BY 1 ASC;&#10;        --&#10;        l_rec1 cs%ROWTYPE;&#10;        --&#10;        l_rows INTEGER :&#61; 0;&#10;        --&#10;    BEGIN&#10;        --&#10;        OPEN cs;&#10;        LOOP&#10;            FETCH cs INTO l_rec1;&#10;            EXIT WHEN cs%NOTFOUND;&#10;            l_rows :&#61; l_rows + 1;&#10;            --&#10;            SPGMessage.retry_msg(&#10;                x_spg_notification_id &#61;&gt; l_rec1.spg_notification_id,&#10;                p_new_record_flag     &#61;&gt; &#39;N&#39;,&#10;                p_force_flag          &#61;&gt; &#39;Y&#39; );&#10;        END LOOP;&#10;        CLOSE cs;&#10;        --&#10;        warn(&#39;Total of &#39; || l_rows || &#39; XML messages in SPG_NOTIFICATION (EXPORT_TO_FILE&#61;1) have been re-submitted for processing&#39;);&#10;        --&#10;    END do_resubmit_failed_exports;&#10;    --&#10;BEGIN&#10;    --&#10;    IF p_probation_area_id IS NULL AND p_crc_inactive_offender_id IS NULL THEN&#10;        raise_application_error(-20001, &#39;ERROR in &#39; || l_proc || &#39;: either P_CRC_INACTIVE_OFFENDER_ID or P_PROBATION_AREA_ID must be specified&#39;);&#10;    END IF;&#10;    --&#10;    IF p_probation_area_id IS NULL AND p_crc_inactive_offender_id IS NOT NULL THEN&#10;        SELECT crc_provider_id INTO l_crc_provider_id&#10;        FROM crc_inactive_offender&#10;        WHERE crc_inactive_offender_id &#61; p_crc_inactive_offender_id&#10;          AND processed_flag &#61; 0;&#10;    ELSE&#10;        l_crc_provider_id :&#61; p_probation_area_id;&#10;    END IF;&#10;    --&#10;    IF UPPER(p_resubmit_failed_exports) &#61; &#39;Y&#39; THEN&#10;        --&#10;        do_resubmit_failed_exports;&#10;        --&#10;        RETURN;&#10;        --&#10;    END IF;&#10;    --&#10;    OPEN cs;&#10;    FETCH cs BULK COLLECT INTO l_tab LIMIT l_max_rows;&#10;    CLOSE cs;&#10;    --&#10;    FOR l_i IN 1 .. l_TAB.COUNT LOOP&#10;        --&#10;        l_rec :&#61; l_TAB(l_i);&#10;        --&#10;        do_submit_offender;&#10;        do_submit_alloc_offender;&#10;        do_upd_submit_details(l_rec.crc_inactive_offender_id);&#10;        --&#10;        OPEN csE;&#10;        LOOP&#10;            FETCH csE INTO l_rec_event;&#10;            EXIT WHEN csE%NOTFOUND;&#10;            --&#10;            do_submit_alloc_event;&#10;        END LOOP;&#10;        CLOSE csE;&#10;    END LOOP;&#10;    --&#10;END export_inactive_offenders;&#10;--&#10;&#10;&#10;--&#10;--&#10;-- Initialise package variables block&#10;--&#10;PROCEDURE do_init&#10;IS&#10;BEGIN&#10;    G_BI_202_ID :&#61; PKG_Lookups.funcGetBusinessInteractionID(GC_BI_202_CODE);&#10;    G_BI_410_ID :&#61; PKG_Lookups.funcGetBusinessInteractionID(GC_BI_410_CODE);&#10;    G_BI_413_ID :&#61; PKG_Lookups.funcGetBusinessInteractionID(GC_BI_413_CODE);&#10;END do_init;&#10;&#10;--&#10;--&#10;--&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--&#10;-- Package Body initialisation block&#10;--&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--&#10;BEGIN&#10;    --&#10;    PKG_Global.do_init;&#10;    --&#10;    do_init;&#10;    --&#10;    -----------------------------------------------------------------&#10;    -- Cache reference values to be used within package procedures --&#10;    -----------------------------------------------------------------&#10;    --g_limit               :&#61; PKG_Lookups.funcgetNDParameterValue(p_par_name &#61;&gt; &#39;OFFENDER_SEARCH_MAX_RESULTS&#39;, p_default_value &#61;&gt; 10);&#10;    --g_transfer_pending_id :&#61; PKG_Lookups.funcgetStdRefListID(p_code_set &#61;&gt; &#39;TRANSFER STATUS&#39;, p_code &#61;&gt; &#39;PN&#39;);&#10;    --&#10;    --&#10;END PKG_SPG_EXPORT;</textarea>
                        </div>
                    </div>
                </section>
            </div>
            <!-- /.content-wrapper -->
            <footer class="main-footer">
                <div>
                    <div class="pull-right hidden-xs">
                        <a href="https://github.com/schemaspy/schemaspy" title="GitHub for SchemaSpy"><i class="fa fa-github-square fa-2x"></i></a>
                        <a href="http://stackoverflow.com/questions/tagged/schemaspy" title="StackOverflow for SchemaSpy"><i class="fa fa-stack-overflow fa-2x"></i></a>
                    </div>
                    <strong>Generated by <a href="http://schemaspy.org/" class="logo-text"><i class="fa fa-database"></i> SchemaSpy 6.2.4</a></strong>
                </div>
                <!-- /.container -->
            </footer>
        </div>
        <!-- ./wrapper -->

        <!-- jQuery 2.2.3 -->
        <script src="../bower/admin-lte/plugins/jQuery/jquery-2.2.3.min.js"></script>
        <script src="../bower/admin-lte/plugins/jQueryUI/jquery-ui.min.js"></script>
        <!-- Bootstrap 3.3.5 -->
        <script src="../bower/admin-lte/bootstrap/js/bootstrap.min.js"></script>
        <!-- DataTables -->
        <script src="../bower/datatables.net/jquery.dataTables.min.js"></script>
        <script src="../bower/datatables.net-bs/js/dataTables.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/dataTables.buttons.min.js"></script>
        <script src="../bower/datatables.net-buttons-bs/js/buttons.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.html5.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.print.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.colVis.min.js"></script>
        <!-- SheetJS -->
        <script src="../bower/js-xlsx/xlsx.full.min.js"></script>
        <!-- pdfmake -->
        <script src="../bower/pdfmake/pdfmake.min.js"></script>
        <script src="../bower/pdfmake/vfs_fonts.js"></script>
        <!-- SlimScroll -->
        <script src="../bower/admin-lte/plugins/slimScroll/jquery.slimscroll.min.js"></script>
        <!-- FastClick -->
        <script src="../bower/admin-lte/plugins/fastclick/fastclick.js"></script>
        <!-- Salvattore -->
        <script src="../bower/salvattore/salvattore.min.js"></script>
        <!-- AnchorJS -->
        <script src="../bower/anchor-js/anchor.min.js"></script>
        <!-- CodeMirror -->
        <script src="../bower/codemirror/codemirror.js"></script>
        <script src="../bower/codemirror/sql.js"></script>
        <!-- AdminLTE App -->
        <script src="../bower/admin-lte/dist/js/app.min.js"></script>
        <script src="routine.js"></script>
        <script src="../schemaSpy.js"></script>
    </body>
</html>