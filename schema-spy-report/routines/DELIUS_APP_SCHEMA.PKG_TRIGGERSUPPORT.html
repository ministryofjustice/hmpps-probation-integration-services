<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>TSTNDA.DELIUS_APP_SCHEMA</title>
        <!-- Tell the browser to be responsive to screen width -->
        <meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport">
        <link rel="icon" type="image/png" sizes="16x16" href="../favicon.png">
        <!-- Bootstrap 3.3.5 -->
        <link rel="stylesheet" href="../bower/admin-lte/bootstrap/css/bootstrap.min.css">
        <!-- Font Awesome -->
        <link rel="stylesheet" href="../bower/font-awesome/css/font-awesome.min.css">
        <!-- Ionicons -->
        <link rel="stylesheet" href="../bower/ionicons/css/ionicons.min.css">
        <!-- DataTables -->
        <link rel="stylesheet" href="../bower/datatables.net-bs/css/dataTables.bootstrap.min.css">
        <link rel="stylesheet" href="../bower/datatables.net-buttons-bs/css/buttons.bootstrap.min.css">
        <!-- Code Mirror -->
        <link rel="stylesheet" href="../bower/codemirror/codemirror.css">
        <!-- Fonts -->
        <link href='../fonts/indieflower/indie-flower.css' rel='stylesheet' type='text/css'>
        <link href='../fonts/source-sans-pro/source-sans-pro.css' rel='stylesheet' type='text/css'>

        <!-- Theme style -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/AdminLTE.min.css">
        <!-- Salvattore -->
        <link rel="stylesheet" href="../bower/salvattore/salvattore.css">
        <!-- AdminLTE Skins. Choose a skin from the css/skins
           folder instead of downloading all of them to reduce the load. -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/skins/_all-skins.min.css">
        <!-- SchemaSpy -->
        <link rel="stylesheet" href="../schemaSpy.css">

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
        <script src="../bower/html5shiv/html5shiv.min.js"></script>
        <script src="../bower/respond/respond.min.js"></script>
        <![endif]-->
    </head>
    <!-- ADD THE CLASS layout-top-nav TO REMOVE THE SIDEBAR. -->
    <body class="hold-transition skin-blue layout-top-nav">
        <div class="wrapper">
            <header class="main-header">
                <nav class="navbar navbar-static-top">
                    <div class="container">
                        <div class="navbar-header">
                            <a href="../index.html" class="navbar-brand"><b>TSTNDA</b></a><span class="navbar-brand" style="padding-left: 0">.DELIUS_APP_SCHEMA</span>
                            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse"><i class="fa fa-bars"></i></button>
                        </div>

                        <!-- Collect the nav links, forms, and other content for toggling -->
                        <div class="collapse navbar-collapse pull-left" id="navbar-collapse">
                            <ul class="nav navbar-nav">
                                <li><a href="../index.html">Tables <span class="sr-only">(current)</span></a></li>
                                <li><a href="../columns.html" title="All of the columns in the schema">Columns</a></li>
                                <li><a href="../constraints.html" title="Useful for diagnosing error messages that just give constraint name or number">Constraints</a></li>
                                <li><a href="../relationships.html" title="Diagram of table relationships">Relationships</a></li>
                                <li><a href="../orphans.html" title="View of tables with neither parents nor children">Orphan&nbsp;Tables</a></li>
                                <li><a href="../anomalies.html" title="Things that might not be quite right">Anomalies</a></li>
                                <li><a href="../routines.html" title="Procedures and functions">Routines</a></li>
                            </ul>
                        </div>
                        <!-- /.navbar-collapse -->
                        <!-- Navbar Right Menu -->
                    </div>
                    <!-- /.container-fluid -->
                </nav>
            </header>
            <!-- Main content -->
            <!-- Full Width Column -->
            <div class="content-wrapper">
                <!-- Content Header (Page header) -->
                <section class="content-header">
                    <h1>DELIUS_APP_SCHEMA.PKG_TRIGGERSUPPORT</h1><br />
                </section>
                <!-- Main content -->
                <section class="content">
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <span class="glyphicon glyphicon-list-alt" aria-hidden="true"></span>
                            <h3 id="Columns" class="box-title">Parameters</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <table id="standard_table" class="table table-bordered table-striped dataTable" role="grid">
                                <thead align='left'>
                                <tr>
                                    <th>Name</th>
                                    <th>Type</th>
                                    <th>Mode</th>
                                </tr>
                                </thead>
                                <tbody>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <i class="fa fa-file-code-o"></i>
                            <h3 id="RoutineDefinition" class="box-title">Definition</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <textarea id="sql-script-codemirror" name="sql-script-codemirror" rows="" style="display: none;">PACKAGE BODY PKG_TriggerSupport&#10;AS&#10;--&#10;--&#10;&#10;g_label VARCHAR2(100) :&#61; &#39;000000&#39;;&#10;&#10;G_DEBUG_FLAG BOOLEAN :&#61; FALSE;&#10;&#10;g_VPD_rebuild_flag           BOOLEAN :&#61; TRUE;&#10;g_VPD_rebuild_flag_INIT      BOOLEAN :&#61; FALSE;&#10;&#10;g_VPD_deferred_rebuild_flag  BOOLEAN :&#61; FALSE;&#10;&#10;g_CDC_flag        BOOLEAN :&#61; TRUE;&#10;g_CDC_flag_INIT   BOOLEAN :&#61; FALSE;&#10;&#10;g_off_area_counter        NUMBER :&#61; 0;&#10;&#10;g_tab_offenders_list      t_tab_ORGANISATIONS :&#61; t_tab_ORGANISATIONS();&#10;gc_tab_Offenders_max_size NUMBER :&#61; 5;&#10;&#10;--&#10;TYPE t_tab_vpd_tables IS TABLE OF VARCHAR2(30) INDEX BY BINARY_INTEGER;&#10;g_tab_vpd_tables t_tab_vpd_tables;&#10;&#10;TYPE t_tab_deferred_upd IS TABLE OF VARCHAR2(1) INDEX BY VARCHAR(100);&#10;g_tab_deferred_upd_VPD       t_tab_deferred_upd;&#10;g_tab_deferred_upd_CURRENT_D t_tab_deferred_upd;&#10;g_tab_deferred_upd_CURRENT_T t_tab_deferred_upd;&#10;g_tab_deferred_upd_CAS       t_tab_deferred_upd;&#10;&#10;TYPE t_tab_offenders IS TABLE OF VARCHAR2(1) INDEX BY VARCHAR(100);&#10;--&#10;g_tab_caseload_offender_list t_tab_offenders;&#10;g_tab_cohort_offender_list   t_tab_offenders;&#10;&#10;TYPE t_rec_row_id_map_TYP IS RECORD(&#10;  table_name    VARCHAR2(30),&#10;  table_id      NUMBER,&#10;  offender_id   NUMBER,&#10;  old_row_id    ROWID,&#10;  new_row_id    ROWID );&#10;TYPE t_tab_row_id_map_TYP  IS TABLE OF t_rec_row_id_map_TYP INDEX BY VARCHAR2(255);&#10;--&#10;g_tab_row_id_map      t_tab_row_id_map_TYP;&#10;g_tab_row_id_map_FLAG VARCHAR2(1) :&#61; &#39;N&#39;;&#10;&#10;&#10;&#10;g_debug_cnt NUMBER :&#61; 0;&#10;&#10;-- CDC CTX state variable&#10;G_CDC_CTX NUMBER :&#61; GC_CDC_CTX_NONE;&#10;&#10;&#10;--&#10;g_component_code  CONSTANT VARCHAR2(3)  :&#61; &#39;TRG&#39;;&#10;g_package_name    CONSTANT VARCHAR2(30) :&#61; &#39;PKG_TRIGGER_SUPPORT&#39;;&#10;g_procedure_name  VARCHAR2(30)          :&#61; &#39;initial_value&#39;;&#10;&#10;--&#10;-- message type&#10;mt_information    CONSTANT NUMBER :&#61; 1;&#10;mt_warning        CONSTANT NUMBER :&#61; 2;&#10;mt_error          CONSTANT NUMBER :&#61; 3;&#10;mt_fatal_error    CONSTANT NUMBER :&#61; 4;&#10;--&#10;&#10;&#10;&#10;&#10;&#10;--&#10;--&#10;--&#10;PROCEDURE procDebug(p_msg VARCHAR2, p_print_flag VARCHAR2 DEFAULT &#39;N&#39;) IS&#10;BEGIN&#10;    IF PKG_Debug.funcgetDebugMode IN (&#39;1&#39;, &#39;2&#39;) THEN&#10;        g_debug_cnt :&#61; g_debug_cnt + 1;&#10;        PKG_Debug.procDebug(SUBSTR(&#39;PKG_TriggerSupport[&#39; || LPAD(g_debug_cnt, 10) || &#39;].&#39; || REPLACE(p_msg, &#39;@CNT&#39;, LPAD(g_debug_cnt, 10)), 1, 32000), p_print_flag&#61;&gt;p_print_flag);&#10;    END IF;&#10;END procDebug;&#10;&#10;--&#10;-- PKG_COMMON wrappers&#10;--&#10;PROCEDURE message(p_msg VARCHAR2, p_trace_level NUMBER DEFAULT 0) IS&#10;BEGIN&#10;    PKG_Common.print_message(&#10;        p_msg         &#61;&gt; p_msg,&#10;        p_trace_level &#61;&gt; NVL(p_trace_level, PKG_Common.GC_TRACE_LEVEL),&#10;        p_label       &#61;&gt; g_label );&#10;END message;&#10;--&#10;FUNCTION empty2null(p_str VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.empty2null(p_str);&#10;END empty2null;&#10;--&#10;FUNCTION is_str_empty(p_str VARCHAR2, p_ignore_spaces_and_zeroes VARCHAR2 DEFAULT &#39;N&#39;) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.is_str_empty( p_str, p_ignore_spaces_and_zeroes );&#10;END is_str_empty;&#10;--&#10;FUNCTION nvlstr(p_str1 VARCHAR2, p_str2 VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Common.NVLSTR(p_str1, p_str2);&#10;END nvlstr;&#10;--&#10;PROCEDURE raise_error(p_err_msg VARCHAR2, p_proc VARCHAR2, p_label VARCHAR2 DEFAULT NULL) IS&#10;BEGIN&#10;    PKG_Common.raise_error( p_err_msg, p_proc, p_label );&#10;END raise_error;&#10;--&#10;--***************************************************&#10;-- Helpers                                          *&#10;--***************************************************&#10;--&#10;PROCEDURE set_debug_flag(p_debug_flag VARCHAR2) IS&#10;BEGIN&#10;    G_DEBUG_FLAG :&#61; (UPPER(p_debug_flag) &#61; &#39;Y&#39;);&#10;END set_debug_flag;&#10;--&#10;FUNCTION get_debug_flag RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN CASE WHEN G_DEBUG_FLAG THEN &#39;Y&#39; ELSE &#39;N&#39; END;&#10;END get_debug_flag;&#10;--&#10;-- Used to populate mtt_message_log with information type message&#10;PROCEDURE info(message_in VARCHAR2, p_trace_level INTEGER DEFAULT 15, p_proc VARCHAR2 DEFAULT NULL, p_label VARCHAR2 DEFAULT NULL) IS&#10;BEGIN&#10;    --&#10;    IF G_DEBUG_FLAG THEN&#10;        message(NVL(p_proc, g_procedure_name) || &#39;: &#39; || message_in, p_trace_level);&#10;    END IF;&#10;    --&#10;    IF SPGConfig.SPGInfoActive THEN&#10;        SPGConfig.insert_message_log(&#10;            message_type_id_in &#61;&gt; mt_information,&#10;            component_code_in  &#61;&gt; g_component_code,&#10;            package_name_in    &#61;&gt; g_package_name,&#10;            procedure_name_in  &#61;&gt; NVL(p_proc, g_procedure_name),&#10;            label_in           &#61;&gt; NVL(p_label, g_label),&#10;            message_text_in    &#61;&gt; message_in );&#10;    END IF;&#10;    --&#10;END info;&#10;--&#10;-- Will populate mtt_message_log with warning message - will populate mtt_error_log if result of exception&#10;PROCEDURE warn(message_in VARCHAR2, p_proc VARCHAR2 DEFAULT NULL, p_label VARCHAR2 DEFAULT NULL) IS&#10;BEGIN&#10;    --&#10;    IF G_DEBUG_FLAG THEN&#10;        message(&#39;WARNING in &#39; || NVL(p_proc, g_procedure_name) || &#39;: &#39; || message_in, 0);&#10;    END IF;&#10;    --&#10;    IF SPGConfig.SPGWarnActive THEN&#10;        SPGConfig.record_error(&#10;            message_type_id_in &#61;&gt; mt_warning,&#10;            component_code_in  &#61;&gt; g_component_code,&#10;            package_name_in    &#61;&gt; g_package_name,&#10;            procedure_name_in  &#61;&gt; NVL(p_proc, g_procedure_name),&#10;            label_in           &#61;&gt; NVL(p_label, g_label),&#10;            message_text_in    &#61;&gt; message_in );&#10;    END IF;&#10;END warn;&#10;--&#10;-- Will populate mtt_message_log with error message and populate mtt_error_log with exception - used for log and continue&#10;PROCEDURE error(message_in VARCHAR2, p_proc VARCHAR2 DEFAULT NULL, p_label VARCHAR2 DEFAULT NULL) IS&#10;BEGIN&#10;    --&#10;    IF G_DEBUG_FLAG THEN&#10;        message(&#39;ERROR in &#39; || NVL(p_proc, g_procedure_name) || &#39;: &#39; || message_in, 5);&#10;    END IF;&#10;    --&#10;    SPGConfig.record_error(&#10;        message_type_id_in &#61;&gt; mt_error,&#10;        component_code_in  &#61;&gt; g_component_code,&#10;        package_name_in    &#61;&gt; g_package_name,&#10;        procedure_name_in  &#61;&gt; NVL(p_proc, g_procedure_name),&#10;        label_in           &#61;&gt; NVL(p_label, g_label),&#10;        message_text_in    &#61;&gt; message_in);&#10;END error;&#10;--&#10;-- Will populate mtt_message_log, mtt_error_log with error message and raise exception - used for log and halt&#10;PROCEDURE fatal(message_in VARCHAR2, p_proc VARCHAR2 DEFAULT NULL, p_label VARCHAR2 DEFAULT NULL) IS&#10;BEGIN&#10;    --&#10;    IF G_DEBUG_FLAG THEN&#10;        message(&#39;FATAL ERROR in &#39; || NVL(p_proc, g_procedure_name) || &#39;: &#39; || message_in, 0);&#10;    END IF;&#10;    --&#10;    SPGConfig.record_error(&#10;        message_type_id_in &#61;&gt; mt_fatal_error,&#10;        component_code_in  &#61;&gt; g_component_code,&#10;        package_name_in    &#61;&gt; g_package_name,&#10;        procedure_name_in  &#61;&gt; NVL(p_proc, g_procedure_name),&#10;        label_in           &#61;&gt; NVL(p_label, g_label),&#10;        message_text_in    &#61;&gt; message_in,&#10;        raise_error_in     &#61;&gt; TRUE );&#10;END fatal;&#10;--&#10;&#10;&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;-- VPD Optimisation Table support&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;&#10;-- Description: A procedure to rebuild the optimisation tables&#10;-- Input Paramaters : There are no input parameters required, Oracle will&#10;--                  : not allow the declarion of a procedure with no values&#10;-- Output Parameters : None&#10;-- Author : Gordon Stutchbury&#10;--&#10;-- ----------------------------------------------------------------------------------&#10;PROCEDURE do_rebuild_vpd(p_offender_id NUMBER)&#10;IS&#10;    --&#10;    CURSOR cs IS&#10;      WITH T AS (&#10;        -- 01. OFFENDER_MANAGER, OFFENDER_TRANSFER tables&#10;        SELECT &#39;OM_1&#39; AS vpd_level, om.offender_id, om.team_id AS team_id, om.provider_team_id AS provider_team_id , T.probation_area_id AS probation_area_id, NULL AS external_provider, om.training_session_id&#10;        FROM&#10;          offender_manager OM,&#10;          team             T&#10;        WHERE OM.offender_id &#61; p_offender_id&#10;          AND T.team_id &#61; OM.team_id&#10;          -- Soft Deleted Flag check&#10;          AND OM.soft_deleted &#61; 0&#10;        UNION&#10;        SELECT &#39;OM_2&#39; AS vpd_level, om.offender_id, om.team_id AS team_id, om.provider_team_id AS provider_team_id , T.probation_area_id AS probation_area_id, T.external_provider_id AS external_provider, om.training_session_id&#10;        FROM&#10;          offender_manager OM,&#10;          provider_team    T&#10;        WHERE om.offender_id &#61; p_offender_id&#10;          AND T.provider_team_id &#61; OM.provider_team_id&#10;          -- Soft Deleted Flag check&#10;          AND OM.soft_deleted &#61; 0&#10;        UNION&#10;        -- OFFENDER_TRANSFER&#10;        SELECT &#39;OMT_1&#39; AS vpd_level, offender_id, receiving_team_id  AS team_id, receiving_provider_team_id AS provider_team_id , T.probation_area_id AS probation_area_id, NULL AS external_provider, ot.training_session_id&#10;        FROM&#10;          offender_transfer         OT,&#10;          team                      T,&#10;          r_standard_reference_list TS&#10;        WHERE OT.offender_id &#61; p_offender_id&#10;          AND T.team_id &#61; OT.receiving_team_id&#10;          AND TS.standard_reference_list_id &#61; OT.transfer_status_id AND TS.code_value &#61; &#39;PN&#39;&#10;          -- Soft Deleted Flag check&#10;          AND OT.soft_deleted &#61; 0&#10;        UNION&#10;        SELECT &#39;OMT_2&#39; AS vpd_level, offender_id, receiving_team_id  AS team_id, receiving_provider_team_id AS provider_team_id , T.probation_area_id AS probation_area_id, T.external_provider_id AS external_provider, ot.training_session_id&#10;        FROM&#10;          offender_transfer         OT,&#10;          provider_team             T,&#10;          r_standard_reference_list TS&#10;        WHERE OT.offender_id &#61; p_offender_id&#10;          AND T.provider_team_id &#61; OT.receiving_provider_team_id&#10;          AND TS.standard_reference_list_id &#61; OT.transfer_status_id AND ts.code_value &#61; &#39;PN&#39;&#10;          -- Soft Deleted Flag check&#10;          AND OT.soft_deleted &#61; 0&#10;        UNION&#10;        -- 02. ORDER_MANAGER, EVENT and ORDER_TRANSFER tables&#10;        SELECT &#39;OS_1&#39; AS vpd_level, E.offender_id, om.allocation_team_id  AS team_id, om.provider_team_id AS provider_team_id , T.probation_area_id AS probation_area_id, NULL AS external_provider, om.training_session_id&#10;        FROM&#10;          event         E,&#10;          order_manager OM,&#10;          team          T&#10;        WHERE E.offender_id &#61; p_offender_id&#10;          AND E.active_flag &#61; 1&#10;          AND OM.event_id &#61; E.event_id&#10;          AND OM.active_flag &#61; 1&#10;          AND T.team_id &#61; OM.allocation_team_id&#10;          -- Soft Deleted Flag check&#10;          AND E.soft_deleted &#61; 0&#10;          AND OM.soft_deleted &#61; 0&#10;        UNION&#10;        SELECT &#39;OS_2&#39; AS vpd_level, E.offender_id, om.allocation_team_id  AS team_id, om.provider_team_id AS provider_team_id , T.probation_area_id AS probation_area_id, T.EXTERNAL_PROVIDER_ID AS external_provider, om.training_session_id&#10;        FROM&#10;          event         E,&#10;          order_manager OM,&#10;          provider_team T&#10;        WHERE E.offender_id &#61; p_offender_id&#10;          AND E.active_flag &#61; 1&#10;          AND OM.event_id &#61; E.event_id&#10;          AND T.provider_team_id &#61; OM.provider_team_id&#10;          AND OM.active_flag &#61; 1&#10;          -- Soft Deleted Flag check&#10;          AND E.soft_deleted &#61; 0&#10;          AND OM.soft_deleted &#61; 0&#10;        UNION&#10;        -- ORDER_TRANSFER&#10;        SELECT &#39;OST_1&#39; AS vpd_level, E.offender_id, receiving_team_id AS team_id, receiving_provider_team_id AS provider_team_id , T.probation_area_id AS probation_area_id, NULL AS external_provider, ot.training_session_id&#10;        FROM&#10;          event                     E,&#10;          order_transfer            OT,&#10;          team                      T,&#10;          r_standard_reference_list TS&#10;        WHERE E.offender_id &#61; p_offender_id&#10;          AND OT.event_id &#61; E.event_id&#10;          AND T.team_id &#61; OT.receiving_team_id&#10;          AND TS.standard_reference_list_id &#61; OT.transfer_status_id AND TS.code_value &#61; &#39;PN&#39;&#10;          -- Soft Deleted Flag check&#10;          AND E.soft_deleted &#61; 0&#10;          AND OT.soft_deleted &#61; 0&#10;        UNION&#10;        SELECT &#39;OST_2&#39; AS vpd_level, E.offender_id, receiving_team_id  AS team_id, receiving_provider_team_id AS provider_team_id , T.probation_area_id AS probation_area_id, T.EXTERNAL_PROVIDER_ID AS external_provider, ot.training_session_id&#10;        FROM&#10;          event                     E,&#10;          order_transfer            OT,&#10;          provider_team             T,&#10;          r_standard_reference_list TS&#10;        WHERE E.offender_id &#61; p_offender_id&#10;          AND OT.event_id &#61; E.event_id&#10;          AND T.provider_team_id &#61; OT.receiving_provider_team_id&#10;          AND TS.standard_reference_list_id &#61; OT.transfer_status_id AND TS.code_value &#61; &#39;PN&#39;&#10;          -- Soft Deleted Flag check&#10;          AND E.soft_deleted &#61; 0&#10;          AND OT.soft_deleted &#61; 0&#10;        UNION&#10;        -- 03. LIC_CONDITION_MANAGER, LIC_CONDITION and LIC_CONDITION_TRANSFER tables&#10;        SELECT &#39;LC_1&#39; AS vpd_level, E.offender_id, lcm.team_id  AS team_id, lcm.provider_team_id AS provider_team_id , T.probation_area_id AS probation_area_id, NULL AS external_provider, lcm.training_session_id&#10;        FROM&#10;          event                 E,&#10;          disposal              D,&#10;          lic_condition         LC,&#10;          lic_condition_manager LCM,&#10;          team                  T&#10;        WHERE E.offender_id &#61; p_offender_id&#10;          AND D.event_id &#61; E.event_id&#10;          AND LC.disposal_id &#61; D.disposal_id&#10;          AND LC.termination_date IS NULL&#10;          AND LCM.lic_condition_id &#61; LC.lic_condition_id&#10;          AND LCM.active_flag &#61; 1&#10;          AND T.team_id &#61; LCM.team_id&#10;          -- Soft Deleted Flag check&#10;          AND E.soft_deleted &#61; 0&#10;          AND D.soft_deleted &#61; 0&#10;          AND LC.soft_deleted &#61; 0&#10;          AND LCM.soft_deleted &#61; 0&#10;        UNION&#10;        SELECT &#39;LC_2&#39; AS vpd_level, E.offender_id, lcm.team_id  AS team_id, lcm.provider_team_id AS provider_team_id , T.probation_area_id AS probation_area_id, T.EXTERNAL_PROVIDER_ID AS external_provider, lcm.training_session_id&#10;        FROM&#10;          event                 E,&#10;          disposal              D,&#10;          lic_condition         LC,&#10;          lic_condition_manager LCM,&#10;          provider_team         T&#10;        WHERE E.offender_id &#61; p_offender_id&#10;          AND D.event_id &#61; E.event_id&#10;          AND LC.disposal_id &#61; D.disposal_id&#10;          AND LC.termination_date IS NULL&#10;          AND LCM.lic_condition_id &#61; LC.lic_condition_id&#10;          AND LCM.active_flag &#61; 1&#10;          AND T.provider_team_id &#61; LCM.provider_team_id&#10;          -- Soft Deleted Flag check&#10;          AND E.soft_deleted &#61; 0&#10;          AND D.soft_deleted &#61; 0&#10;          AND LC.soft_deleted &#61; 0&#10;          AND LCM.soft_deleted &#61; 0&#10;        UNION&#10;        -- LIC_CONDITION_TRANSFER&#10;        SELECT &#39;LCT_1&#39; AS vpd_level, E.offender_id, receiving_team_id  AS team_id, receiving_provider_team_id AS provider_team_id , T.probation_area_id AS probation_area_id, NULL AS external_provider, lct.training_session_id&#10;        FROM&#10;          event                     E,&#10;          disposal                  D,&#10;          lic_condition             LC,&#10;          lic_condition_transfer    LCT,&#10;          team                      T,&#10;          r_standard_reference_list TS&#10;        WHERE E.offender_id &#61; p_offender_id&#10;          AND D.event_id &#61; E.event_id&#10;          AND LC.disposal_id &#61; D.disposal_id&#10;          AND LCT.lic_condition_id &#61; LC.lic_condition_id&#10;          AND T.team_id &#61; LCT.receiving_team_id&#10;          AND TS.standard_reference_list_id &#61; LCT.transfer_status_id AND ts.code_value &#61; &#39;PN&#39;&#10;          -- Soft Deleted Flag check&#10;          AND E.soft_deleted &#61; 0&#10;          AND D.soft_deleted &#61; 0&#10;          AND LC.soft_deleted &#61; 0&#10;          AND LCT.soft_deleted &#61; 0&#10;        UNION&#10;        SELECT &#39;LCT_2&#39; AS vpd_level, E.offender_id, receiving_team_id  AS team_id, receiving_provider_team_id AS provider_team_id , T.probation_area_id AS probation_area_id, T.external_provider_id AS external_provider, lct.training_session_id&#10;        FROM&#10;          event                     E,&#10;          disposal                  D,&#10;          lic_condition             LC,&#10;          lic_condition_transfer    LCT,&#10;          provider_team             T,&#10;          r_standard_reference_list TS&#10;        WHERE E.offender_id &#61; p_offender_id&#10;          AND D.event_id &#61; E.event_id&#10;          AND LC.disposal_id &#61; D.disposal_id&#10;          AND LCT.lic_condition_id &#61; LC.lic_condition_id&#10;          AND T.provider_team_id &#61; LCT.receiving_provider_team_id&#10;          AND TS.standard_reference_list_id  &#61; LCT.transfer_status_id AND ts.code_value &#61; &#39;PN&#39;&#10;          -- Soft Deleted Flag check&#10;          AND E.soft_deleted &#61; 0&#10;          AND D.soft_deleted &#61; 0&#10;          AND LC.soft_deleted &#61; 0&#10;          AND LCT.soft_deleted &#61; 0&#10;        UNION&#10;        -- 04. RQMNT_MANAGER, RQMNT and RQMNT_TRANSFER&#10;        SELECT &#39;RQ_1&#39; AS vpd_level, E.offender_id, rqm.allocated_team_id  AS team_id, rqm.provider_team_id AS provider_team_id , T.probation_area_id AS probation_area_id, NULL AS external_provider, rqm.training_session_id&#10;        FROM&#10;          event         E,&#10;          disposal      D,&#10;          rqmnt         R,&#10;          rqmnt_manager RQM,&#10;          team          T&#10;        WHERE E.offender_id &#61; p_offender_id&#10;          AND D.event_id &#61; E.event_id&#10;          AND R.disposal_id &#61; D.disposal_id&#10;          AND R.termination_date IS NULL&#10;          AND RQM.rqmnt_id &#61; R.rqmnt_id&#10;          AND RQM.active_flag &#61; 1&#10;          AND T.team_id &#61; RQM.allocated_team_id&#10;          -- Soft Deleted Flag check&#10;          AND E.soft_deleted &#61; 0&#10;          AND D.soft_deleted &#61; 0&#10;          AND R.soft_deleted &#61; 0&#10;          AND RQM.soft_deleted &#61; 0&#10;        UNION&#10;        SELECT &#39;RQ_2&#39; AS vpd_level, E.offender_id, rqm.allocated_team_id  AS team_id, rqm.provider_team_id AS provider_team_id, T.probation_area_id AS probation_area_id, T.EXTERNAL_PROVIDER_ID AS external_provider, rqm.training_session_id&#10;        FROM&#10;          event         E,&#10;          disposal      D,&#10;          rqmnt         R,&#10;          rqmnt_manager RQM,&#10;          provider_team T&#10;        WHERE E.offender_id &#61; p_offender_id&#10;          AND D.event_id &#61; E.event_id&#10;          AND R.disposal_id &#61; D.disposal_id&#10;          AND R.termination_date IS NULL&#10;          AND RQM.rqmnt_id &#61; R.rqmnt_id&#10;          AND RQM.active_flag &#61; 1&#10;          AND T.provider_team_id &#61; RQM.provider_team_id&#10;          -- Soft Deleted Flag check&#10;          AND E.soft_deleted &#61; 0&#10;          AND D.soft_deleted &#61; 0&#10;          AND R.soft_deleted &#61; 0&#10;          AND RQM.soft_deleted &#61; 0&#10;        UNION&#10;        -- RQMNT_TRANSFER&#10;        SELECT &#39;RQT_1&#39; AS vpd_level, E.offender_id, receiving_team_id  AS team_id, receiving_provider_team_id AS provider_team_id , T.probation_area_id AS probation_area_id, NULL AS external_provider, rqt.training_session_id&#10;        FROM&#10;          event                     E,&#10;          disposal                  D,&#10;          rqmnt                     RQ,&#10;          rqmnt_transfer            RQT,&#10;          team                      T,&#10;          r_standard_reference_list TS&#10;        WHERE E.offender_id &#61; p_offender_id&#10;          AND D.event_id &#61; E.event_id&#10;          AND RQ.disposal_id &#61; D.disposal_id&#10;          AND RQT.rqmnt_id &#61; RQ.rqmnt_id&#10;          AND T.team_id &#61; RQT.receiving_team_id&#10;          AND TS.standard_reference_list_id &#61; RQT.transfer_status_id AND ts.code_value &#61; &#39;PN&#39;&#10;          -- Soft Deleted Flag check&#10;          AND E.soft_deleted &#61; 0&#10;          AND D.soft_deleted &#61; 0&#10;          AND RQ.soft_deleted &#61; 0&#10;          AND RQT.soft_deleted &#61; 0&#10;        UNION&#10;        SELECT &#39;RQT_2&#39; AS vpd_level, E.offender_id, receiving_team_id  AS team_id, receiving_provider_team_id AS provider_team_id , T.probation_area_id AS probation_area_id, T.external_provider_id AS external_provider, rqt.training_session_id&#10;        FROM&#10;          event E,&#10;          disposal D,&#10;          rqmnt RQ,&#10;          rqmnt_transfer rqt, provider_team T, r_standard_reference_list ts&#10;        WHERE E.offender_id &#61; p_offender_id&#10;          AND D.event_id &#61; E.event_id&#10;          AND RQ.disposal_id &#61; D.disposal_id&#10;          AND RQT.rqmnt_id &#61; RQ.rqmnt_id&#10;          AND T.provider_team_id &#61; RQT.receiving_provider_team_id&#10;          AND TS.standard_reference_list_id &#61; RQT.transfer_status_id AND ts.code_value &#61; &#39;PN&#39;&#10;          -- Soft Deleted Flag check&#10;          AND E.soft_deleted &#61; 0&#10;          AND D.soft_deleted &#61; 0&#10;          AND RQ.soft_deleted &#61; 0&#10;          AND RQT.soft_deleted &#61; 0&#10;        UNION&#10;        -- 05. REPORT_MANAGER, COURT_REPORT, INSTITUTIONAL_REPORT_TRANSFER and COURT_REPORT_TRANSFER&#10;        SELECT &#39;RM_1&#39; AS vpd_level, E.offender_id, rm.team_id  AS team_id, rm.provider_team_id AS provider_team_id , T.probation_area_id AS probation_area_id, NULL AS external_provider, rm.training_session_id&#10;        FROM&#10;          event E,&#10;          report_manager RM,&#10;          team T&#10;        WHERE E.offender_id &#61; p_offender_id&#10;          AND RM.event_id &#61; E.event_id&#10;          AND RM.active_flag &#61; 1&#10;          AND T.team_id &#61; RM.team_id&#10;          -- Soft Deleted Flag check&#10;          AND E.soft_deleted &#61; 0&#10;          AND RM.soft_deleted &#61; 0&#10;        UNION&#10;        SELECT &#39;RM_2&#39; AS vpd_level, E.offender_id, rm.team_id  AS team_id, rm.provider_team_id AS provider_team_id, T.probation_area_id AS probation_area_id, T.EXTERNAL_PROVIDER_ID AS external_provider, rm.training_session_id&#10;        FROM&#10;          event E,&#10;          report_manager RM,&#10;          provider_team T&#10;        WHERE E.offender_id &#61; p_offender_id&#10;          AND RM.event_id &#61; E.event_id&#10;          AND RM.active_flag &#61; 1&#10;          AND T.provider_team_id &#61; RM.provider_team_id&#10;          -- Soft Deleted Flag check&#10;          AND E.soft_deleted &#61; 0&#10;          AND RM.soft_deleted &#61; 0&#10;        UNION&#10;        -- COURT_REPORT_TRANSFER&#10;        SELECT &#39;CRT_1&#39; AS vpd_level, E.offender_id, rt.receiving_team_id  AS team_id, NULL AS provider_team_id , T.probation_area_id AS probation_area_id, NULL AS external_provider, NULL AS training_session_id&#10;        FROM&#10;          event E,&#10;          court_appearance CA,&#10;          court_report R,&#10;          court_report_transfer RT,&#10;          team T,&#10;          r_standard_reference_list TS&#10;        WHERE E.offender_id &#61; p_offender_id&#10;          AND CA.event_id &#61; E.event_id&#10;          AND R.court_appearance_id &#61; CA.court_appearance_id&#10;          AND RT.court_report_id &#61; R.court_report_id&#10;          AND T.team_id &#61; RT.receiving_team_id&#10;          AND TS.standard_reference_list_id &#61; RT.transfer_status_id AND ts.code_value &#61; &#39;PN&#39;&#10;          -- Soft Deleted Flag check&#10;          AND E.soft_deleted &#61; 0&#10;          AND CA.soft_deleted &#61; 0&#10;          AND R.soft_deleted &#61; 0&#10;          AND RT.soft_deleted &#61; 0&#10;        UNION&#10;        -- INSTITUTIONAL_REPORT_TRANSFER&#10;        SELECT &#39;IRT_1&#39; AS vpd_level, E.offender_id, rt.receiving_team_id  AS team_id, NULL AS provider_team_id , T.probation_area_id AS probation_area_id, NULL AS external_provider, NULL AS training_session_id&#10;        FROM&#10;          event E,&#10;          disposal D,&#10;          custody C,&#10;          institutional_report R,&#10;          institutional_report_transfer RT,&#10;          team T,&#10;          r_standard_reference_list TS&#10;        WHERE E.offender_id &#61; p_offender_id&#10;          AND D.event_id &#61; E.event_id&#10;          AND C.disposal_id &#61; D.disposal_id&#10;          AND R.custody_id &#61; c.custody_id&#10;          AND RT.institutional_report_id &#61; R.institutional_report_id&#10;          AND T.team_id &#61; RT.receiving_team_id&#10;          AND TS.standard_reference_list_id &#61; RT.transfer_status_id AND ts.code_value &#61; &#39;PN&#39;&#10;          -- Soft Deleted Flag check&#10;          AND E.soft_deleted &#61; 0&#10;          AND D.soft_deleted &#61; 0&#10;          AND C.soft_deleted &#61; 0&#10;          AND R.soft_deleted &#61; 0&#10;          AND RT.soft_deleted &#61; 0&#10;        UNION&#10;        -- 06. NSI_MANAGER, NSI and NSI_TRANSFER&#10;        SELECT &#39;NSI_1&#39; AS vpd_level, offender_id, nm.team_id  AS team_id, NULL AS provider_team_id , T.probation_area_id AS probation_area_id, NULL AS external_provider, nm.training_session_id&#10;        FROM&#10;          nsi N,&#10;          nsi_manager NM,&#10;          team T&#10;        WHERE N.offender_id &#61; p_offender_id&#10;          AND N.active_flag &#61; 1&#10;          AND NM.nsi_id &#61; N.nsi_id&#10;          AND NM.active_flag &#61; 1&#10;          AND T.team_id &#61; NM.team_id&#10;          -- Soft Deleted Flag check&#10;          AND N.soft_deleted &#61; 0&#10;          AND NM.soft_deleted &#61; 0&#10;        UNION&#10;        -- NSI_TRANSFER&#10;        SELECT &#39;NSIT_1&#39; AS vpd_level, n.offender_id, target_team_id  AS team_id, NULL AS provider_team_id , T.probation_area_id AS probation_area_id, NULL AS external_provider, nt.training_session_id&#10;        FROM&#10;          nsi N,&#10;          nsi_transfer NT,&#10;          team T,&#10;          r_standard_reference_list TS&#10;        WHERE N.offender_id &#61; p_offender_id&#10;          AND NT.nsi_id &#61; N.nsi_id&#10;          AND T.team_id &#61; NT.target_team_id&#10;          AND TS.standard_reference_list_id &#61; NT.transfer_status_id AND TS.code_value &#61; &#39;PN&#39;&#10;          -- Soft Deleted Flag check&#10;          AND N.soft_deleted &#61; 0&#10;          AND NT.soft_deleted &#61; 0&#10;        --TS2 start&#10;        UNION&#10;        --- 07. PSS_RQMNT, PSS_RQMNT_MANAGER and PSS_RQMNT_TRANSFER&#10;        SELECT &#39;PRQ_1&#39; AS vpd_level, pr.offender_id, prm.team_id AS team_id, NULL AS provider_team_id, t.probation_area_id AS probation_area_id, NULL AS external_provider, null&#10;        FROM&#10;          pss_rqmnt PR,&#10;          pss_rqmnt_manager PRM,&#10;          team T&#10;        WHERE PR.offender_id &#61; p_offender_id&#10;          AND PR.termination_date IS NULL&#10;          AND PRM.pss_rqmnt_id &#61; PR.pss_rqmnt_id&#10;          AND PRM.active_flag &#61; 1&#10;          AND T.team_id &#61; PRM.team_id&#10;          -- Soft Deleted Flag check&#10;          AND PR.soft_deleted &#61; 0&#10;          AND PRM.soft_deleted &#61; 0&#10;        UNION&#10;        -- PSS_RQMNT_TRANSFER&#10;        SELECT &#39;PRQT_1&#39; AS vpd_level, pr.offender_id, prt.receiving_team_id AS team_id, NULL AS provider_team_id, t.probation_area_id AS probation_area_id, NULL AS external_provider, null&#10;        FROM&#10;          pss_rqmnt_transfer PRT,&#10;          pss_rqmnt PR,&#10;          team T,&#10;          r_standard_reference_list RSRL&#10;        WHERE PR.offender_id &#61; p_offender_id&#10;          AND PRT.pss_rqmnt_id &#61; PR.pss_rqmnt_id&#10;          AND T.team_id &#61; PRT.receiving_team_id&#10;          AND RSRL.standard_reference_list_id &#61; PRT.transfer_status_id AND RSRL.code_value &#61; &#39;PN&#39;&#10;          -- Soft Deleted Flag check&#10;          AND PRT.soft_deleted &#61; 0&#10;          AND PR.soft_deleted &#61; 0&#10;        -- TS2 end&#10;        UNION&#10;        -- 08. APPROVED_PREMISES_REFERRAL&#10;        SELECT &#39;APR_1&#39; AS vpd_level, apr.offender_id, 1 AS team_id, NULL AS provider_team_id, rap.probation_area_id AS probation_area_id, NULL AS external_provider, apr.training_session_id&#10;        FROM&#10;          approved_premises_referral APR,&#10;          r_approved_premises RAP&#10;        WHERE APR.offender_id &#61; p_offender_id&#10;          AND RAP.approved_premises_id &#61; APR.approved_premises_id&#10;          -- Soft Deleted Flag check&#10;          AND APR.soft_deleted &#61; 0&#10;        UNION&#10;        SELECT DISTINCT &#39;APRG_1&#39; AS vpd_level, apr.offender_id, 1 AS team_id, NULL AS provider_team_id, rap.probation_area_id AS probation_area_id, NULL AS external_provider, apr.training_session_id&#10;        FROM&#10;          approved_premises_referral APR,&#10;          r_ap_referral_group RAPRG,&#10;          r_approved_premises RAP&#10;        WHERE APR.offender_id &#61; p_offender_id&#10;          AND RAPRG.standard_reference_list_id &#61; APR.referral_group_id&#10;          AND RAP.approved_premises_id &#61; RAPRG.approved_premises_id&#10;          AND APR.approved_premises_id IS NULL&#10;          -- Soft Deleted Flag check&#10;          AND APR.soft_deleted &#61; 0&#10;        --&#10;        UNION&#10;        -- 09. PRISON_OFFENDER_MANAGER, (YF TODO: PRISON_OFFENDER_TRANSFER)&#10;        SELECT &#39;PRM_1&#39; AS vpd_level, offender_id, POM.allocation_team_id  AS team_id, NULL AS provider_team_id , T.probation_area_id AS probation_area_id, NULL AS external_provider, NULL AS training_session_id&#10;        FROM&#10;          prison_offender_manager POM,&#10;          team T&#10;        WHERE POM.offender_id &#61; p_offender_id&#10;          AND POM.active_flag &#61; 1&#10;          AND T.team_id &#61; POM.allocation_team_id&#10;          -- Soft Deleted Flag check&#10;          AND POM.soft_deleted &#61; 0&#10;      )&#10;      --&#10;      SELECT DISTINCT&#10;        --T.vpd_level,&#10;        T.offender_id,&#10;        T.team_id,&#10;        T.provider_team_id,&#10;        T.probation_area_id,&#10;        --PA.code AS area_code,&#10;        T.external_provider,&#10;        T.training_session_id&#10;      FROM T --INNER JOIN probation_area PA ON PA.probation_area_id &#61; T.probation_area_id&#10;      ;&#10;    --&#10;    TYPE l_rec_TYP IS RECORD(&#10;      offender_id         NUMBER,&#10;      team_id             NUMBER,&#10;      provider_team_id    NUMBER,&#10;      probation_area_id   NUMBER,&#10;      external_provider   NUMBER,&#10;      training_session_id NUMBER );&#10;    TYPE l_tab_TYP IS TABLE OF l_rec_TYP;&#10;    --&#10;    l_tab l_tab_TYP;&#10;    --&#10;BEGIN&#10;    IF NVLSTR(SYS_CONTEXT(&#39;vpd_ctx&#39;, &#39;REBUILD_REQUIRED&#39;), &#39;N&#39;) &lt;&gt; &#39;Y&#39; THEN&#10;        procDebug(&#39;procRebuildOptTables.DO_REBUILD_VPD: REBUILD_REQUIRED is set to N&#39;);&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    DELETE FROM organisation_offender WHERE offender_ID &#61; p_offender_ID;&#10;    --&#10;    IF SQL%ROWCOUNT &gt; 0 THEN&#10;        procDebug(&#39;PKG_TriggerSupport.DO_REBUILD_VPD(&#39; || p_offender_id || &#39;): &#39; || TO_CHAR(SQL%ROWCOUNT) || &#39; records deleted from ORGANISATION_OFFENDER table&#39;);&#10;    END IF;&#10;    --&#10;    OPEN cs;&#10;    FETCH cs BULK COLLECT INTO l_tab;&#10;    CLOSE cs;&#10;    BEGIN&#10;        --&#10;        -- YF: suppress the AFTER STATEMENT level TR00_IU_AS_ORGSANISATION_OFF trigger&#10;        set_VPD_deferred_flag( TRUE );&#10;        --&#10;        FOR l_idx IN 1..l_tab.COUNT LOOP&#10;            --&#10;            procInsertOrgOffenderRecord(&#10;                p_offender_id          &#61;&gt; l_tab(l_idx).offender_id,&#10;                p_probation_area_id    &#61;&gt; l_tab(l_idx).probation_area_id,&#10;                p_external_provider_id &#61;&gt; l_tab(l_idx).external_provider,&#10;                p_training_session_id  &#61;&gt; l_tab(l_idx).training_session_id );&#10;        END LOOP;&#10;        --&#10;        set_VPD_deferred_flag( FALSE );&#10;        --&#10;        -- YF: replay the AFTER INSERT level TR00_I_ORGANISATION_OFFENDER trigger logic (cascade update the ORGANISATIONS columns)&#10;        procDebug(&#39;VPD [ORGANISATION_OFFENDER][DO_REBUILD_VPD]&#39; || &#39;[offender_id: &#39; || p_offender_id || &#39;]&#39;);&#10;        procAddOffenderToRebuildList(p_offender_id&#61;&gt;p_offender_id);&#10;        -- YF: replay the AFTER STATEMENT level TR00_IU_AS_ORGSANISATION_OFF trigger logic (cascade update the ORGANISATIONS columns)&#10;        procDebug(&#39;VPD [ORGANISATION_OFFENDER][DO_REBUILD_VPD]&#39;);&#10;        procUpdateProbationAreas;&#10;        --&#10;    EXCEPTION WHEN OTHERS THEN&#10;        set_VPD_deferred_flag( FALSE );&#10;        RAISE;&#10;    END;&#10;    --&#10;    IF l_tab.COUNT &gt; 0 THEN&#10;        procDebug(&#39;PKG_TriggerSupport.DO_REBUILD_VPD(&#39; || p_offender_id || &#39;): &#39; || TO_CHAR(l_tab.COUNT) || &#39; records inserted into ORGANISATION_OFFENDER table&#39;);&#10;    END IF;&#10;    --&#10;    PKG_VPD_CTX.set_table_value(&#39;REBUILD_REQUIRED&#39;, &#39;N&#39;);&#10;    --&#10;    -- Instead of checking for duplicate rows, we silently throw away duplicates&#10;--EXCEPTION WHEN DUP_VAL_ON_INDEX THEN&#10;--    NULL;&#10;END do_rebuild_vpd;&#10;&#10;PROCEDURE do_rebuild_caseload(p_offender_id NUMBER)&#10;IS&#10;    l_count NUMBER :&#61; 0;&#10;BEGIN&#10;    IF NVLSTR(SYS_CONTEXT(&#39;vpd_ctx&#39;, &#39;CASELOAD_REBUILD_REQUIRED&#39;), &#39;N&#39;) &lt;&gt; &#39;Y&#39; THEN&#10;        procDebug(&#39;PKG_TriggerSupport.DO_REBUILD_CASELOAD: CASELOAD_REBUILD_REQUIRED is set to N&#39;);&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    DELETE FROM caseload WHERE offender_ID &#61; p_offender_ID;&#10;    --&#10;    IF SQL%ROWCOUNT &gt; 0 THEN&#10;        procDebug(&#39;PKG_TriggerSupport.DO_REBUILD_CASELOAD(&#39; || p_offender_id || &#39;): &#39; || TO_CHAR(SQL%ROWCOUNT) || &#39; records deleted from CASELOAD table&#39;);&#10;    END IF;&#10;    --&#10;    INSERT INTO caseload (&#10;      -- PK Value&#10;      caseload_id,&#10;      -- FK ID values&#10;      offender_id,&#10;      offender_manager_id,&#10;      event_id,&#10;      order_manager_id,&#10;      disposal_id,&#10;      lic_condition_id,&#10;      lic_condition_manager_id,&#10;      rqmnt_id,&#10;      rqmnt_manager_id,&#10;      -- TS2&#10;      pss_rqmnt_id,&#10;      pss_rqmnt_manager_id,&#10;      -- TS2 end&#10;      nsi_id,&#10;      nsi_manager_id,&#10;      -- PDM 9.05&#10;      prison_offender_manager_id,&#10;      -- PDM 14.08&#10;      report_manager_id,&#10;      court_report_id,&#10;      institutional_report_id,&#10;      -- Staff/Team fields&#10;      trust_provider_flag,&#10;      trust_provider_team_id,&#10;      staff_employee_id,&#10;      -- Additional FK columns&#10;      disposal_type_id,&#10;      lic_cond_type_main_cat_id,&#10;      rqmnt_type_main_category_id,&#10;      ad_rqmnt_type_main_category_id,&#10;      pss_rqmnt_type_main_cat_id,&#10;      -- Values from OFFENDER table&#10;      crn,&#10;      gender_id,&#10;      first_name,&#10;      second_name,&#10;      third_name,&#10;      surname,&#10;      date_of_birth,&#10;      current_highest_risk_colour,&#10;      current_restriction,&#10;      current_exclusion,&#10;      --restriction_message,&#10;      --exclusion_message,&#10;      current_tier,&#10;      -- ORDER_MANAGER/RQMNT/LIC_COND level values&#10;      length_value,&#10;      role_code,&#10;      start_date,&#10;      -- NDelius common system columns&#10;      partition_area_id,&#10;      row_version,&#10;      training_session_id,&#10;      -- VPD column&#10;      ORGANISATIONS,&#10;      allocation_date,&#10;      notional_end_date,&#10;      entry_length,&#10;      length_in_days,&#10;      entry_length_units_id)&#10;    --&#10;    SELECT&#10;      -- PK Value&#10;      caseload_id_SEQ.NEXTVAL,&#10;      -- FK ID values&#10;      offender_id,&#10;      offender_manager_id,&#10;      event_id,&#10;      order_manager_id,&#10;      disposal_id,&#10;      lic_condition_id,&#10;      lic_condition_manager_id,&#10;      rqmnt_id,&#10;      rqmnt_manager_id,&#10;      -- TS2&#10;      pss_rqmnt_id,&#10;      pss_rqmnt_manager_id,&#10;      -- TS2 end&#10;      nsi_id,&#10;      nsi_manager_id,&#10;      -- PDM 9.05&#10;      prison_offender_manager_id,&#10;      -- PDM 14.08&#10;      report_manager_id,&#10;      court_report_id,&#10;      institutional_report_id,&#10;      -- Staff/Team fields&#10;      trust_provider_flag,&#10;      trust_provider_team_id,&#10;      staff_employee_id,&#10;      -- Additional FK columns&#10;      disposal_type_id,&#10;      lic_cond_type_main_cat_id,&#10;      rqmnt_type_main_category_id,&#10;      ad_rqmnt_type_main_category_id,&#10;      pss_rqmnt_type_main_cat_id,&#10;      -- Values from OFFENDER table&#10;      crn,&#10;      gender_id,&#10;      first_name,&#10;      second_name,&#10;      third_name,&#10;      surname,&#10;      date_of_birth,&#10;      current_highest_risk_colour,&#10;      current_restriction,&#10;      current_exclusion,&#10;      --restriction_message,&#10;      --exclusion_message,&#10;      current_tier,&#10;      -- ORDER_MANAGER/RQMNT/LIC_COND level values&#10;      length_value,&#10;      role_code,&#10;      start_date,&#10;      -- NDelius common system columns&#10;      0 partition_area_id,&#10;      0 row_version,&#10;      NULL training_session_id,&#10;      -- VPD column&#10;      NULL ORGANISATIONS,&#10;      allocation_date,&#10;      notional_end_date,&#10;      entry_length,&#10;      length_in_days,&#10;      entry_length_units_id&#10;    FROM TABLE( PKG_CASELOAD.procFindCaseLoadTAB(p_offender_id&#61;&gt;p_offender_ID) );&#10;    --&#10;    IF SQL%ROWCOUNT &gt; 0 THEN&#10;        procDebug(&#39;PKG_TriggerSupport.DO_REBUILD_CASELOAD(&#39; || p_offender_id || &#39;): &#39; || TO_CHAR(SQL%ROWCOUNT) || &#39; records inserted into CASELOAD table&#39;);&#10;    END IF;&#10;    --&#10;    PKG_VPD_CTX.set_table_value(&#39;CASELOAD_REBUILD_REQUIRED&#39;, &#39;N&#39;);&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    raise_application_error(-20001, &#39;ERROR in PKG_TriggerSupport.DO_REBUILD_CASELOAD(p_offender_id&#61;&gt;&#39; || p_offender_ID || &#39;):&#39; || CHR(10) || SQLERRM);&#10;END do_rebuild_caseload;&#10;--&#10;PROCEDURE do_rebuild_cohort_diary(p_offender_id NUMBER)&#10;IS&#10;BEGIN&#10;--    IF G_PDM_VERSION &lt; 601 THEN&#10;--        RETURN;&#10;--    END IF;&#10;    IF NVLSTR(SYS_CONTEXT(&#39;vpd_ctx&#39;, &#39;COHORT_REBUILD_REQUIRED&#39;), &#39;N&#39;) &lt;&gt; &#39;Y&#39; THEN&#10;        procDebug(&#39;DO_REBUILD_COHORT_DIARY: COHORT_REBUILD_REQUIRED is set to N&#39;);&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    DELETE FROM COHORT_DIARY WHERE offender_ID &#61; p_offender_ID;&#10;    --&#10;    IF SQL%ROWCOUNT &gt; 0 THEN&#10;        procDebug(&#39;PKG_TriggerSupport.DO_REBUILD_COHORT_DIARY(&#39; || p_offender_id || &#39;): &#39; || TO_CHAR(SQL%ROWCOUNT) || &#39; records deleted from COHORT_DIARY table&#39;);&#10;    END IF;&#10;    --&#10;    INSERT INTO cohort_diary (&#10;      -- PK Value&#10;      cohort_diary_id,&#10;      --&#10;      offender_id,&#10;      offender_manager_id,&#10;      event_id,&#10;      main_offence_id,&#10;      disposal_id,&#10;      disposal_type_id,&#10;      trust_provider_flag,&#10;      trust_provider_team_id,&#10;      staff_employee_id,&#10;      cohort,&#10;      probation_area_id,&#10;      first_release_date,&#10;      disposal_date,&#10;      upw,&#10;      offence_date,&#10;      row_version )&#10;    SELECT&#10;      -- PK Value&#10;      cohort_diary_id_SEQ.NEXTVAL,&#10;      --&#10;      offender_id,&#10;      offender_manager_id,&#10;      event_id,&#10;      main_offence_id,&#10;      disposal_id,&#10;      disposal_type_id,&#10;      trust_provider_flag,&#10;      trust_provider_team_id,&#10;      staff_employee_id,&#10;      cohort,&#10;      probation_area_id,&#10;      first_release_date,&#10;      disposal_date,&#10;      upw,&#10;      offence_date,&#10;      --&#10;      0 AS row_version&#10;      --&#10;    FROM TABLE( PKG_CASELOAD.procFindCohortDiaryTAB(p_offender_id&#61;&gt;p_offender_ID) );&#10;    --&#10;    IF SQL%ROWCOUNT &gt; 0 THEN&#10;        procDebug(&#39;PKG_TriggerSupport.DO_REBUILD_COHORT_DIARY(&#39; || p_offender_id || &#39;): &#39; || TO_CHAR(SQL%ROWCOUNT) || &#39; records inserted into COHORT_DIARY table&#39;);&#10;    END IF;&#10;    --&#10;    PKG_VPD_CTX.set_table_value(&#39;COHORT_REBUILD_REQUIRED&#39;, &#39;N&#39;);&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    raise_application_error(-20001, &#39;ERROR in PKG_TriggerSupport.DO_REBUILD_DIARY(p_offenderID&#61;&gt;&#39; || p_offender_ID || &#39;):&#39; || CHR(10) || SQLERRM);&#10;END do_rebuild_cohort_diary;&#10;--&#10;PROCEDURE do_rebuild_rej_transfers_diary(p_offender_id NUMBER)&#10;IS&#10;BEGIN&#10;    IF G_PDM_VERSION &lt; 808 THEN&#10;        RETURN;&#10;    END IF;&#10;    IF NVLSTR(SYS_CONTEXT(&#39;vpd_ctx&#39;, &#39;REJ_TRANSFERS_REBUILD_REQUIRED&#39;), &#39;N&#39;) &lt;&gt; &#39;Y&#39; THEN&#10;        procDebug(&#39;DO_REBUILD_REJ_TRANSFERS_DIARY: REJ_TRANSFERS_REBUILD_REQUIRED is set to N&#39;);&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    DELETE FROM rejected_transfer_diary WHERE offender_ID &#61; p_offender_ID;&#10;    --&#10;    IF SQL%ROWCOUNT &gt; 0 THEN&#10;        procDebug(&#39;PKG_TriggerSupport.DO_REBUILD_REJ_TRANSFERS_DIARY(&#39; || p_offender_id || &#39;): &#39; || TO_CHAR(SQL%ROWCOUNT) || &#39; records deleted from REJECTED_TRANSFER_DIARY table&#39;);&#10;    END IF;&#10;    --&#10;    INSERT INTO REJECTED_TRANSFER_DIARY(&#10;      rejected_transfer_diary_id,&#10;      transfer_request_date,&#10;      transfer_status_date,&#10;      target_provider_id,&#10;      target_team_id,&#10;      target_staff_id,&#10;      origin_provider_id,&#10;      origin_team_id,&#10;      origin_staff_id,&#10;      rejection_reason_id,&#10;      offender_id,&#10;      master_transfer_id,&#10;      offender_transfer_id,&#10;      nsi_transfer_id,&#10;      nsi_id,&#10;      order_transfer_id,&#10;      event_id ,&#10;      rqmnt_transfer_id,&#10;      rqmnt_id,&#10;      lic_condition_transfer_id,&#10;      lic_condition_id,&#10;      pss_rqmnt_transfer_id,&#10;      pss_rqmnt_id,&#10;      institutional_rep_transfer_id,&#10;      institutional_report_id,&#10;      court_report_transfer_id,&#10;      court_report_id )&#10;    SELECT&#10;      rejected_transfer_diary_id_SEQ.nextval,&#10;      RTD.request_date AS tranfer_request_date,&#10;      RTD.transfer_status_date,&#10;      RTD.tgt_provider_id,&#10;      RTD.tgt_team_id,&#10;      RTD.tgt_staff_id,&#10;      RTD.orig_provider_id,&#10;      RTD.orig_team_id,&#10;      RTD.orig_staff_id,&#10;      RTD.rejection_reason_id,&#10;      RTD.offender_id,&#10;      PKG_Common.NVL2(&#10;          OT.master_transfer_id,&#10;          NT.master_transfer_id,&#10;          OT1.master_transfer_id,&#10;          RT.master_transfer_id,&#10;          LT.master_transfer_id,&#10;          PT.master_transfer_id,&#10;          IRT.master_transfer_id,&#10;          CRT.master_transfer_id&#10;      ) AS master_transfer_id,&#10;      RTD.offender_transfer_id,&#10;      RTD.nsi_transfer_id,&#10;      RTD.nsi_id,&#10;      RTD.event_transfer_id AS order_transfer_id,&#10;      RTD.event_id ,&#10;      RTD.rqmnt_transfer_id,&#10;      RTD.rqmnt_id,&#10;      RTD.lic_condition_transfer_id,&#10;      RTD.lic_condition_id,&#10;      RTD.pss_rqmnt_transfer_id,&#10;      RTD.pss_rqmnt_id,&#10;      RTD.inst_rpt_transfer_id AS institutional_rep_transfer_id,&#10;      RTD.institutional_report_id,&#10;      RTD.court_report_transfer_id,&#10;      RTD.court_report_id&#10;    FROM&#10;      TABLE( PKG_Search.procOffTransferRejectsTAB(&#10;                p_start_date          &#61;&gt; TO_DATE(&#39;10010101&#39;, &#39;YYYYMMDD&#39;),&#10;                p_end_date            &#61;&gt; TO_DATE(&#39;40001231&#39;, &#39;YYYYMMDD&#39;),&#10;                p_offender_id         &#61;&gt; p_offender_id,&#10;                p_use_live_query_flag &#61;&gt; &#39;Y&#39; )&#10;            ) RTD&#10;        LEFT OUTER JOIN offender_transfer OT ON RTD.offender_transfer_id &#61; OT.offender_transfer_id&#10;        LEFT OUTER JOIN nsi_transfer NT ON NT.nsi_transfer_id &#61; RTD.nsi_transfer_id&#10;        LEFT OUTER JOIN order_transfer OT1 ON OT1.order_transfer_id &#61; RTD.event_transfer_id /*order_transfer_id*/&#10;        LEFT OUTER JOIN rqmnt_transfer RT ON RT.rqmnt_transfer_id &#61; RTD.rqmnt_transfer_id&#10;        LEFT OUTER JOIN lic_condition_transfer LT ON LT.lic_condition_transfer_id &#61; RTD.lic_condition_transfer_id&#10;        LEFT OUTER JOIN pss_rqmnt_transfer PT ON PT.pss_rqmnt_transfer_id &#61; RTD.pss_rqmnt_transfer_id&#10;        LEFT OUTER JOIN institutional_report_transfer IRT ON IRT.institutional_rep_transfer_id &#61; RTD.inst_rpt_transfer_id /*institutional_rep_transfer_id*/&#10;        LEFT OUTER JOIN court_report_transfer CRT ON CRT.court_report_transfer_id &#61; RTD.court_report_transfer_id;&#10;    --&#10;    IF SQL%ROWCOUNT &gt; 0 THEN&#10;        procDebug(&#39;PKG_TriggerSupport.DO_REBUILD_REJ_TRANSFERS_DIARY(&#39; || p_offender_id || &#39;): &#39; || TO_CHAR(SQL%ROWCOUNT) || &#39; records inserted into REJECTED_TRANSFER_DIARY table&#39;);&#10;    END IF;&#10;    --&#10;    PKG_VPD_CTX.set_table_value(&#39;REJ_TRANSFERS_REBUILD_REQUIRED&#39;, &#39;N&#39;);&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    raise_application_error(-20001, &#39;ERROR in PKG_TriggerSupport.DO_REBUILD_REJ_TRANSFERS_DIARY(p_offenderID&#61;&gt;&#39; || p_offender_ID || &#39;):&#39; || CHR(10) || SQLERRM);&#10;END do_rebuild_rej_transfers_diary;&#10;--&#10;PROCEDURE procRebuildOptTables( p_offenderID NUMBER, p_process_alfresco_flag VARCHAR2 DEFAULT &#39;Y&#39; )&#10;IS&#10;    --&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;procRebuildOptTables&#39;;&#10;    --&#10;    l_offender_id_CHAR  VARCHAR2(100);&#10;    l_cnt               NUMBER;&#10;    --&#10;    l_debug_flag BOOLEAN;&#10;    --&#10;    PROCEDURE do_init IS&#10;    BEGIN&#10;        l_debug_flag :&#61; (PKG_Lookups.funcgetNDParameterValue(&#39;VPD_REBUILD_DEBUG_FLAG&#39;, &#39;0&#39;) &#61; &#39;1&#39;);&#10;    END do_init;&#10;    --&#10;    PROCEDURE do_debug(p_msg VARCHAR2, p_label VARCHAR2) IS&#10;    BEGIN&#10;        IF l_debug_flag THEN&#10;            warn( p_msg, l_proc, p_label );&#10;        END IF;&#10;    END do_debug;&#10;    --&#10;    FUNCTION get_dbg_line(p_prefix VARCHAR2, p_msg VARCHAR2, p_postfix VARCHAR2) RETURN VARCHAR2 IS&#10;    BEGIN&#10;        RETURN PKG_LstUtl.add_postfix(PKG_LstUtl.add_prefix(p_prefix, p_msg), p_postfix);&#10;    END get_dbg_line;&#10;    --&#10;BEGIN&#10;    --&#10;    do_init;&#10;    --&#10;    IF l_debug_flag THEN&#10;        do_debug(&#10;            PKG_LstUtl.concat(&#10;                get_dbg_line(&#39;[CLIENT_IDENTIFIER&#61;&#39; , SYS_CONTEXT(&#39;USERENV&#39;, &#39;CLIENT_IDENTIFIER&#39;)                     ,  &#39;]&#39;),&#10;                get_dbg_line(&#39;[off_caseload_cnt&#61;&#39;  , g_tab_caseload_offender_list.COUNT                              ,  &#39;]&#39;),&#10;                get_dbg_line(&#39;[off_id&#61;&#39;            , p_offenderID                                                    ,  &#39;]&#39;),&#10;                get_dbg_line(&#39;[alf_process_flag&#61;&#39;  , p_process_alfresco_flag                                         ,  &#39;]&#39;),&#10;                --get_dbg_line(&#39;[upd_off_id_flag&#61;&#39;   , p_update_offender_id_flag                                       ,  &#39;]&#39;),&#10;                --get_dbg_line(&#39;[force_rebuild_flag&#61;&#39;, p_force_flag                                                    ,  &#39;]&#39;),&#10;                --get_dbg_line(&#39;[vpd_rebuild&#61;&#39;       , CASE WHEN p_force_flag &#61; &#39;Y&#39; THEN &#39;Y&#39; ELSE NVLSTR(SYS_CONTEXT(&#39;vpd_ctx&#39;, &#39;REBUILD_REQUIRED&#39;), &#39;N&#39;)          END, &#39;]&#39;),&#10;                --get_dbg_line(&#39;[caseload_rebuild&#61;&#39;  , CASE WHEN p_force_flag &#61; &#39;Y&#39; THEN &#39;Y&#39; ELSE NVLSTR(SYS_CONTEXT(&#39;vpd_ctx&#39;, &#39;CASELOAD_REBUILD_REQUIRED&#39;), &#39;N&#39;) END, &#39;]&#39;),&#10;                --get_dbg_line(&#39;[cohort_rebuild&#61;&#39;    , CASE WHEN p_force_flag &#61; &#39;Y&#39; THEN &#39;Y&#39; ELSE NVLSTR(SYS_CONTEXT(&#39;vpd_ctx&#39;, &#39;COHORT_REBUILD_REQUIRED&#39;), &#39;N&#39;)   END, &#39;]&#39;),&#10;                get_dbg_line(&#39;[vpd_rebuild&#61;&#39;       , NVLSTR(SYS_CONTEXT(&#39;vpd_ctx&#39;, &#39;REBUILD_REQUIRED&#39;), &#39;N&#39;)          , &#39;]&#39;),&#10;                get_dbg_line(&#39;[caseload_rebuild&#61;&#39;  , NVLSTR(SYS_CONTEXT(&#39;vpd_ctx&#39;, &#39;CASELOAD_REBUILD_REQUIRED&#39;), &#39;N&#39;) , &#39;]&#39;),&#10;                get_dbg_line(&#39;[cohort_rebuild&#61;&#39;    , NVLSTR(SYS_CONTEXT(&#39;vpd_ctx&#39;, &#39;COHORT_REBUILD_REQUIRED&#39;), &#39;N&#39;)   , &#39;]&#39;),&#10;                get_dbg_line(&#39;[alf_rebuild_id_LST&#61;&#39;, PKG_LstUtl.get_array_2_list(AlfrescoSupport.getOffendersQueue)  ,  &#39;]&#39;),&#10;                --&#10;                p_delim&#61;&gt;CHR(10) ),&#10;            --&#10;            &#39;100100&#39; );&#10;    END IF;&#10;    --&#10;    IF NVL(p_offenderID, -1) &gt; 0 THEN&#10;        do_rebuild_vpd(p_offenderID);&#10;    END IF;&#10;    --&#10;    l_offender_id_CHAR :&#61; TO_CHAR(p_offenderID);&#10;    --&#10;    IF NVL(p_offenderID, -1) &gt; 0 THEN&#10;        do_rebuild_caseload(l_offender_ID_CHAR);&#10;        IF g_tab_caseload_offender_list.EXISTS(l_offender_id_CHAR) /*AND SYS_CONTEXT(&#39;vpd_ctx&#39;, &#39;CASELOAD_REBUILD_REQUIRED&#39;) &#61; &#39;Y&#39;*/ THEN&#10;            g_tab_caseload_offender_list.DELETE(l_offender_id_CHAR);&#10;        END IF;&#10;    END IF;&#10;    l_cnt :&#61; g_tab_caseload_offender_list.COUNT;&#10;    IF l_cnt &gt; 0 THEN&#10;        procDebug(&#39;INFO - procRebuildOptTables(&#39; || l_offender_id_CHAR || &#39;): &#39; ||&#10;            &#39;g_tab_caseload_offender_list.COUNT&#61;&#39; || TO_CHAR(l_cnt) || &#39;. &#39; ||&#10;            &#39;Calling procRebuildCaseloadTable_OFF to process the remaining list of offenders&#39;);&#10;        procRebuildCaseloadTable_OFF;&#10;    END IF;&#10;    --&#10;    IF NVL(p_offenderID, -1) &gt; 0 THEN&#10;        do_rebuild_cohort_diary(p_offenderID);&#10;        IF g_tab_cohort_offender_list.EXISTS(l_offender_id_CHAR) THEN&#10;            g_tab_cohort_offender_list.DELETE(l_offender_id_CHAR);&#10;        END IF;&#10;    END IF;&#10;    l_cnt :&#61; g_tab_cohort_offender_list.COUNT;&#10;    IF l_cnt &gt; 0 THEN&#10;        procDebug(&#39;INFO - procRebuildOptTables(&#39; || l_offender_id_CHAR || &#39;): &#39; ||&#10;            &#39;g_tab_cohort_offender_list.COUNT&#61;&#39; || TO_CHAR(l_cnt) || &#39;. &#39; ||&#10;            &#39;Calling procRebuildCohortTable_OFF to process the remaining list of offenders&#39;);&#10;        procRebuildCohortTable_OFF;&#10;    END IF;&#10;    --&#10;    IF NVL(p_process_alfresco_flag, &#39;Y&#39;) &#61; &#39;Y&#39; THEN&#10;        IF PKG_Debug.funcgetDebugMode &lt;&gt; &#39;0&#39; THEN&#10;            procDebug(SUBSTR(&#39;PKG_TRIGGER_SUPPORT.procRebuildOptTables&#39; ||&#10;                &#39;(off_id&#61;&#39; || l_offender_id_CHAR || &#39;): performing the ALFRESCOSUPPORT.processQueue&#39; || CHR(10) ||&#10;                &#39;(plsql_call_stack&#61;&#39; || DBMS_UTILITY.format_call_stack || &#39;)&#39;,&#10;                1, 30000) );&#10;        END IF;&#10;        --&#10;        ALFRESCOSUPPORT.processQueue;&#10;        --&#10;--    ELSIF NVL(p_process_alfresco_flag, &#39;Y&#39;) &#61; &#39;N&#39; THEN&#10;--        IF PKG_Debug.funcgetDebugMode &lt;&gt; &#39;0&#39; THEN&#10;--            procDebug(SUBSTR(&#39;PKG_TRIGGER_SUPPORT.procRebuildOptTables&#39; ||&#10;--                &#39;(off_id&#61;&#39; || l_offender_id_CHAR || &#39;): performing the ALFRESCOSUPPORT.removeOffendersFromQueue&#39; || CHR(10) ||&#10;--                &#39;(plsql_call_stack&#61;&#39; || DBMS_UTILITY.format_call_stack || &#39;)&#39;,&#10;--                1, 30000) );&#10;--        END IF;&#10;--        --&#10;--        ALFRESCOSUPPORT.removeOffendersFromQueue(&#10;--            offenderid_TAB_in &#61;&gt; CASE&#10;--                                     WHEN p_offenderID &gt; 0 THEN&#10;--                                         T_TAB_ORGANISATIONS( l_offender_id_CHAR )&#10;--                                     ELSE&#10;--                                         ALFRESCOSUPPORT.getOffendersQueue&#10;--                                 END&#10;--        );&#10;--        --&#10;    END IF;&#10;    --&#10;END procRebuildOptTables;&#10;--&#10;PROCEDURE procChangeCapture_ClearContext IS&#10;BEGIN&#10;    G_CDC_CTX :&#61; GC_CDC_CTX_NONE;&#10;END procChangeCapture_ClearContext;&#10;--&#10;--&#10;&#10;--&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--    Partitioned ROWID Support subroutines&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--&#10;FUNCTION get_row_id_map(p_table_name VARCHAR2, p_row_id ROWID) RETURN ROWID&#10;IS&#10;    --&#10;    l_key VARCHAR2(255);&#10;    l_rec t_rec_row_id_map_TYP;&#10;    --&#10;    l_ret ROWID;&#10;    --&#10;BEGIN&#10;    --&#10;    l_key :&#61; UPPER(TRIM(p_table_name)) || &#39;|&#39; || TO_CHAR(p_row_id);&#10;    --&#10;    IF g_tab_row_id_map.EXISTS(l_key) THEN&#10;        --&#10;        l_rec :&#61; g_tab_row_id_map(l_key);&#10;        l_ret :&#61; l_rec.new_row_id;&#10;        --&#10;    ELSE&#10;        --&#10;        l_ret :&#61; p_row_id;&#10;        --&#10;    END IF;&#10;    --&#10;    RETURN l_ret;&#10;END get_row_id_map;&#10;--&#10;PROCEDURE add_row_id_map_rec(&#10;  p_table_name    VARCHAR2,&#10;  p_table_id      NUMBER,&#10;  p_offender_id   NUMBER,&#10;  p_old_row_id    ROWID,&#10;  p_new_row_id    ROWID )&#10;IS&#10;    --&#10;    l_key VARCHAR2(255);&#10;    l_rec t_rec_row_id_map_TYP;&#10;    --&#10;BEGIN&#10;    --&#10;    IF NVL(g_tab_row_id_map_FLAG, &#39;N&#39;) &#61; &#39;N&#39; THEN&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    l_key :&#61; UPPER(TRIM(p_table_name)) || &#39;|&#39; || TO_CHAR(p_old_row_id);&#10;    --&#10;    IF g_tab_row_id_map.EXISTS(l_key) THEN&#10;        --&#10;        l_rec :&#61; g_tab_row_id_map(l_key);&#10;        --&#10;        IF l_rec.table_name  &lt;&gt; p_table_name  OR&#10;           l_rec.table_id    &lt;&gt; p_table_id    OR&#10;           l_rec.offender_id &lt;&gt; p_offender_id OR&#10;           l_rec.old_row_id  &lt;&gt; p_old_row_id  OR&#10;           l_rec.new_row_id  &lt;&gt; p_new_row_id&#10;        THEN&#10;            raise_application_error(-20001,&#10;                &#39;ERROR in PKG_TriggerSupport.add_row_id_map_rec &#39; ||&#10;                &#39;[tab&#61;&#39;        || l_rec.table_name  || &#39; : &#39; || p_table_name  || &#39;]&#39; ||&#10;                &#39;[id&#61;&#39;         || l_rec.table_id    || &#39; : &#39; || p_table_id    || &#39;]&#39; ||&#10;                &#39;[off_id&#61;&#39;     || l_rec.offender_id || &#39; : &#39; || p_offender_id || &#39;]&#39; ||&#10;                &#39;[old_row_id&#61;&#39; || l_rec.old_row_id  || &#39; : &#39; || p_old_row_id  || &#39;]&#39; ||&#10;                &#39;[new_row_id&#61;&#39; || l_rec.new_row_id  || &#39; : &#39; || p_new_row_id  || &#39;]: &#39; ||&#10;                &#39;a duplicate entry in the table ROWID Map Table has been detected!&#39; );&#10;        END IF;&#10;        --&#10;    ELSE&#10;        --&#10;        l_rec.table_name  :&#61; p_table_name;&#10;        l_rec.table_id    :&#61; p_table_id;&#10;        l_rec.offender_id :&#61; p_offender_id;&#10;        l_rec.old_row_id  :&#61; p_old_row_id;&#10;        l_rec.new_row_id  :&#61; p_new_row_id;&#10;        --&#10;        g_tab_row_id_map(l_key) :&#61; l_rec;&#10;        --&#10;    END IF;&#10;    --&#10;END add_row_id_map_rec;&#10;--&#10;PROCEDURE del_row_id_map_tab IS&#10;BEGIN&#10;    --&#10;    IF NOT (g_tab_row_id_map_FLAG &#61; &#39;Y&#39;) THEN&#10;        raise_application_error(-20001, &#39;ERROR in PKG_TriggerSupport.del_row_id_map_tab: Cascade Update must be ON (g_tab_row_id_map_FLAG&#61;Y)&#39;);&#10;    END IF;&#10;    --&#10;    g_tab_row_id_map.DELETE;&#10;    --&#10;END del_row_id_map_tab;&#10;--&#10;--&#10;&#10;--&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--    Update Denormalised OFFENDER_ID Column subroutines&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--&#10;PROCEDURE update_offender_id(&#10;    p_parent_table    VARCHAR2,&#10;    p_table           VARCHAR2,&#10;    p_offender_id     NUMBER,&#10;    p_parent_row_id   ROWID,&#10;    p_row_id          ROWID,&#10;    p_recursive_level INTEGER )&#10;IS&#10;    --&#10;    l_offender_id_OLD NUMBER;&#10;    l_SQL             VARCHAR2(1024);&#10;    l_row_id          ROWID;&#10;    l_debug_flag      BOOLEAN :&#61; PKG_Debug.funcGetDebugActive;&#10;    --&#10;BEGIN&#10;    --&#10;    IF p_table IN (&#10;          &#39;OFFENDER&#39;,&#10;          &#39;MOST_RECENTLY_VIEWED_OFFENDERS&#39;,&#10;          &#39;ORGANISATION_OFFENDER&#39;,&#10;          &#39;CASELOAD&#39;,&#10;          &#39;COHORT_DIARY&#39;,&#10;          &#39;SPG_VERSION_ENTRY&#39;,&#10;          &#39;OFFENDER_CRC_EXPORT&#39;,&#10;          &#39;SPG_NOTIFICATION&#39; )&#10;    THEN&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    IF p_parent_table &#61; &#39;CONTACT&#39; AND&#10;       p_table IN (&#10;         &#39;DEREGISTRATION&#39;,&#10;         &#39;ENFORCEMENT&#39;,&#10;         --&#39;IAPS_CONTACT&#39;,&#10;         &#39;OASYS_ASSESSMENT&#39;,&#10;         &#39;REGISTRATION&#39;,&#10;         &#39;REGISTRATION_REVIEW&#39;,&#10;         &#39;SUBJECT_ACCESS_REPORT_CONTACT&#39;,&#10;         &#39;UPW_APPOINTMENT&#39;,&#10;         &#39;&#39; )&#10;    THEN&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    IF UPPER(TRIM(p_table)) &#61; &#39;CONTACT&#39; AND g_tab_row_id_map_FLAG &#61; &#39;Y&#39; THEN&#10;        --&#10;        l_row_id :&#61; get_row_id_map(&#39;CONTACT&#39;, p_row_id);&#10;        --&#10;        SELECT offender_id INTO l_offender_id_OLD&#10;        FROM contact&#10;        WHERE rowid &#61; l_row_id;&#10;        --&#10;    ELSE&#10;        EXECUTE IMMEDIATE &#39;SELECT offender_id FROM &#39; || p_table || &#39; WHERE rowid &#61; :p_rowid&#39;&#10;        INTO l_offender_id_OLD&#10;        USING p_row_id;&#10;    END IF;&#10;    --&#10;    IF l_offender_id_OLD &#61; p_offender_id THEN&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    IF p_table &#61; &#39;DOCUMENT&#39; AND p_parent_table &#61; &#39;OFFENDER&#39; THEN&#10;        l_SQL :&#61;&#10;           &#39;UPDATE document SET&#10;              offender_id &#61; :p_offender_id,&#10;              primary_key_id &#61; CASE WHEN table_name &#61; &#39;&#39;OFFENDER&#39;&#39; THEN :p_offender_id ELSE primary_key_id END,&#10;            WHERE rowid &#61; :p_rowid&#10;              AND NVL(offender_id, -1) &lt;&gt; :p_offender_id&#39;;&#10;        EXECUTE IMMEDIATE l_SQL&#10;        USING p_offender_id, p_offender_id, p_row_id, p_offender_id;&#10;    ELSE&#10;        l_SQL :&#61;&#10;           &#39;UPDATE &#39; || p_table || &#39; SET&#10;              offender_id &#61; :p_offender_id&#10;            WHERE rowid &#61; :p_rowid&#10;              AND NVL(offender_id, -1) &lt;&gt; :p_offender_id&#39;;&#10;        EXECUTE IMMEDIATE l_SQL&#10;        USING p_offender_id, p_row_id, p_offender_id;&#10;    END IF;&#10;    --&#10;    IF l_debug_flag THEN&#10;        IF SQL%ROWCOUNT &gt; 0 THEN&#10;            procDebug(&#10;                &#39;PKG_TriggerSupport.update_offender_id &#39;  ||&#10;                &#39;[parent_table&#61;&#39;    || p_parent_table    || &#39;]&#39;   ||&#10;                &#39;[table&#61;&#39;           || p_table           || &#39;]&#39;   ||&#10;                &#39;[offender_id&#61;&#39;     || p_offender_id     || &#39;]&#39;   ||&#10;                &#39;[offender_id_OLD&#61;&#39; || l_offender_id_OLD || &#39;]&#39;   ||&#10;                &#39;[parent_ROWID&#61;&#39;    || p_parent_row_id   || &#39;]&#39;   ||&#10;                &#39;[ROWID&#61;&#39;           || p_row_id          || &#39;]: &#39; ||&#10;                &#39;OFFENDER_ID value has been synchronised&#39; );&#10;        END IF;&#10;    END IF;&#10;    --&#10;END update_offender_id;&#10;--&#10;PROCEDURE procCascadeUpdateOffenderID(&#10;    p_offender_id       NUMBER,&#10;    p_table_name        VARCHAR2,&#10;    p_row_id            ROWID,&#10;    p_exclude_nodes_lst VARCHAR2 DEFAULT NULL )&#10;IS&#10;    --&#10;    PROCEDURE do_rpt_row_id_map&#10;    IS&#10;        --&#10;        l_key VARCHAR2(255);&#10;        l_rec t_rec_row_id_map_TYP;&#10;        --&#10;        CURSOR cs1 IS&#10;          SELECT&#10;            O1.crn AS old_crn,&#10;            O2.crn AS new_crn,&#10;            T.*&#10;          FROM&#10;            ( SELECT&#10;                l_rec.table_name  AS table_name,&#10;                l_rec.table_id    AS table_id,&#10;                l_rec.offender_id AS offender_id,&#10;                l_rec.old_row_id  AS old_row_id,&#10;                l_rec.new_row_id  AS new_row_id&#10;              FROM dual&#10;            ) T&#10;              INNER JOIN offender O1 ON O1.offender_id &#61; T.offender_id&#10;              LEFT OUTER JOIN contact C ON C.contact_id &#61; T.table_id AND T.table_name &#61; &#39;CONTACT&#39;&#10;                LEFT OUTER JOIN offender O2 ON O2.offender_id &#61; C.offender_id;&#10;        l_rec1 cs1%ROWTYPE;&#10;        --&#10;        l_init_FLAG BOOLEAN :&#61; TRUE;&#10;        --&#10;    BEGIN&#10;        --&#10;        l_key :&#61; g_tab_row_id_map.FIRST;&#10;        LOOP&#10;            EXIT WHEN empty2null(l_key) IS NULL;&#10;            --&#10;            l_rec :&#61; g_tab_row_id_map(l_key);&#10;            --&#10;            IF l_init_FLAG THEN&#10;                message(&#39;&#61;&#61;&#61; PKG_TriggerSupport.procCascadeUpdateOffenderID: CONTACT ROWID Mapping Summary &#61;&#61;&#61;&#39;);&#10;                l_init_FLAG :&#61; FALSE;&#10;            END IF;&#10;            --&#10;            OPEN cs1;&#10;            FETCH cs1 INTO l_rec1;&#10;            CLOSE cs1;&#10;            --&#10;            message(&#10;              &#39;[contact_id&#61;&#39; || l_rec.table_id   || &#39;]&#39; ||&#10;              &#39;[old_crn&#61;&#39;    || l_rec1.old_crn   || &#39;]&#39; ||&#10;              &#39;[new_crn&#61;&#39;    || l_rec1.new_crn   || &#39;]&#39; ||&#10;              &#39;[old_row_id&#61;&#39; || l_rec.old_row_id || &#39;]&#39; ||&#10;              &#39;[new_row_id&#61;&#39; || l_rec.new_row_id || &#39;]&#39; );&#10;            --&#10;            l_key :&#61; g_tab_row_id_map.NEXT(l_key);&#10;            --&#10;        END LOOP;&#10;        --&#10;        IF NOT l_init_FLAG THEN&#10;            message(&#39;&#61;-*-&#61;&#39;);&#10;            message(&#39;&#39;);&#10;        END IF;&#10;        --&#10;    END do_rpt_row_id_map;&#10;    --&#10;BEGIN&#10;    --&#10;    g_tab_row_id_map_FLAG :&#61; &#39;Y&#39;;&#10;    --&#10;    PKG_DynSQL.offender_records_iterator(&#10;        p_offender_id &#61;&gt; p_offender_id,&#10;        p_tab_name    &#61;&gt; p_table_name,&#10;        p_row_id      &#61;&gt; p_row_id,&#10;        --&#10;        p_check_offender_id_flag &#61;&gt; &#39;Y&#39;,&#10;        --&#10;        p_dyn_SQL     &#61;&gt;&#10;           &#39;DECLARE&#10;                --&#10;                l_parent_table    VARCHAR2(30) :&#61; :p_parent_table;&#10;                l_table           VARCHAR2(30) :&#61; :p_table;&#10;                l_offender_id     NUMBER       :&#61; :p_offender_id;&#10;                l_parent_row_id   ROWID        :&#61; :p_parent_row_id;&#10;                l_row_id          ROWID        :&#61; :p_row_id;&#10;                l_recursive_level INTEGER      :&#61; :p_recursive_level;&#10;                --&#10;            BEGIN&#10;                PKG_TriggerSupport.update_offender_id(&#10;                    p_parent_table    &#61;&gt; l_parent_table,&#10;                    p_table           &#61;&gt; l_table,&#10;                    p_offender_id     &#61;&gt; l_offender_id,&#10;                    p_parent_row_id   &#61;&gt; l_parent_row_id,&#10;                    p_row_id          &#61;&gt; l_row_id,&#10;                    p_recursive_level &#61;&gt; l_recursive_level );&#10;            END;&#39;,&#10;        --&#10;        p_skip_subtrees &#61;&gt;&#10;            PKG_LstUtl.concat(&#10;                p_exclude_nodes_lst,&#10;                --&#10;                &#39;OFFENDER_MANAGER/CONTACT_ALERT, &#39;                                                            ||&#10;                --&#10;                &#39;CONTACT/DEREGISTRATION, CONTACT/ENFORCEMENTxxx, CONTACT/OASYS_ASSESSMENT, &#39;                     ||&#10;                &#39;CONTACT/REGISTRATION, CONTACT/REGISTRATION_REVIEW, CONTACT/SUBJECT_ACCESS_REPORT_CONTACT, &#39;  ||&#10;                &#39;CONTACT/UPW_APPOINTMENT, &#39;                                                                   ||&#10;                --&#10;                &#39;CONTACT_ALERT/*, &#39;                                                                           ||&#10;                --&#10;                &#39;OFFENDER_TRANSFER/*, NSI_TRANSFER/*, RQMNT_TRANSFER/*, LIC_CONDITION_TRANSFER/*, &#39;           ||&#10;                &#39;PSS_RQMNT_TRANSFER/*, NSI_TRANSFER/*, &#39;                                                      ||&#10;                &#39;COURT_REPORT_TRANSFER/*, INSTITUTIONAL_REPORT_TRANSFER/*, &#39;                                  ||&#10;                --&#10;                &#39;*/ORGANISATION_OFFENDER, */CASELOAD, */COHORT_DIARY, &#39;                                       ||&#10;                &#39;*/SPG_NOTIFICATION, */SPG_VERSION_ENTRY, */OFFENDER_CRC_EXPORT, &#39;                            ||&#10;                &#39;*/MOST_RECENTLY_VIEWED_OFFENDERS, &#39;                                                          ||&#10;                &#39;*/MERGE_HISTORY, */MERGE_DUPLICATES, */MERGE_OFFENDER_VALUES&#39;,&#10;                --&#10;                p_delim &#61;&gt; &#39;, &#39; ) );&#10;    --&#10;    IF NVL(PKG_Common.GC_TRACE_LEVEL, 5) &gt;&#61; 15 AND g_tab_row_id_map_FLAG &#61; &#39;Y&#39; THEN&#10;--        raise_application_error(-20001,&#10;--            &#39;&#61;&#61;&#61; PKG_TriggerSupport.procCascadeUpdateOffenderID: &#39; ||&#10;--            &#39;[trace_level&#61;&#39; || PKG_Common.GC_TRACE_LEVEL || &#39;]&#39; ||&#10;--            &#39;[g_tab_row_id_map_FLAG&#61;&#39; || g_tab_row_id_map_FLAG || &#39;]&#39; ||&#10;--            &#39;[init_key&#61;&#39; || g_tab_row_id_map.FIRST || &#39;]&#39; );&#10;        do_rpt_row_id_map;&#10;    END IF;&#10;    --&#10;    del_row_id_map_tab;&#10;    g_tab_row_id_map_FLAG :&#61; &#39;N&#39;;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    --&#10;    --do_rpt_row_id_map;&#10;    del_row_id_map_tab;&#10;    g_tab_row_id_map_FLAG :&#61; &#39;N&#39;;&#10;    --&#10;    RAISE;&#10;    --&#10;END procCascadeUpdateOffenderID;&#10;--&#10;PROCEDURE procRebuildOptTables_ALL(&#10;    p_force_flag              VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_offender_id_LST         CLOB,&#10;    p_update_offender_id_flag VARCHAR2 DEFAULT &#39;Y&#39;,&#10;    p_process_alfresco_flag   VARCHAR2 DEFAULT &#39;Y&#39;,&#10;    p_exclude_nodes_lst       VARCHAR2 DEFAULT NULL )&#10;IS&#10;    --&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;procRebuildOptTables_ALL&#39;;&#10;    --&#10;    l_offender_id NUMBER;&#10;    --&#10;    l_tab T_TAB_ORGANISATIONS :&#61; T_TAB_ORGANISATIONS();&#10;    --&#10;    l_offender_id_LST CLOB;&#10;    --&#10;    l_row_id ROWID;&#10;    --&#10;BEGIN&#10;    --&#10;    l_offender_id_LST :&#61; REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(p_offender_id_LST, CHR(10), &#39;&#39;), CHR(13), &#39;&#39;), CHR(9), &#39; &#39;), &#39; &#39;, &#39;&#39;), &#39;;&#39;, &#39;,&#39;);&#10;    --&#10;    l_TAB :&#61; PKG_LstUtl.get_list_2_array(p_clob&#61;&gt;l_offender_id_LST, p_delim&#61;&gt;&#39;,&#39;, p_distinct_values_flag&#61;&gt;&#39;Y&#39;);&#10;    --&#10;    IF NVL(p_update_offender_id_flag, &#39;Y&#39;) &#61; &#39;Y&#39; THEN&#10;        -- DST-1773: Remove offenders from ALF queue (same offenders will be added one-by-one again within the LOOP)&#10;        ALFRESCOSUPPORT.removeOffendersFromQueue( offenderid_TAB_in&#61;&gt;l_TAB );&#10;    END IF;&#10;    --&#10;    FOR l_i IN 1 .. NVL(l_TAB.COUNT, 0) LOOP&#10;        --&#10;        IF NVL(p_update_offender_id_flag, &#39;Y&#39;) &#61; &#39;Y&#39; THEN&#10;            --&#10;            SELECT rowid INTO l_row_id&#10;            FROM offender&#10;            WHERE offender_id &#61; l_TAB(l_i);&#10;            --&#10;            procDebug(&#39;PKG_Trigger_Support.procRebuildOptTables_ALL: Invoking the PKG_DynSQL.offender_records_iterator(offender_id&#61;&#39; || l_TAB(l_i) || &#39;)&#39;);&#10;            --&#10;            procCascadeUpdateOffenderID(&#10;                p_offender_id       &#61;&gt; l_TAB(l_i),&#10;                p_table_name        &#61;&gt; &#39;OFFENDER&#39;,&#10;                p_row_id            &#61;&gt; l_row_id,&#10;                p_exclude_nodes_lst &#61;&gt; p_exclude_nodes_lst );&#10;            --&#10;            --ALFRESCOSUPPORT.addOffender2Queue(l_TAB(l_i));&#10;            --&#10;        END IF;&#10;        --&#10;        IF NVL(p_force_flag, &#39;N&#39;)              &#61; &#39;Y&#39; OR&#10;           NVL(p_update_offender_id_flag, &#39;Y&#39;) &#61; &#39;Y&#39;&#10;        THEN&#10;            PKG_VPD_CTX.set_table_value( &#39;REBUILD_REQUIRED&#39;         ,&#39;Y&#39; );&#10;            PKG_VPD_CTX.set_table_value( &#39;CASELOAD_REBUILD_REQUIRED&#39;,&#39;Y&#39; );&#10;            PKG_VPD_CTX.set_table_value( &#39;COHORT_REBUILD_REQUIRED&#39;  ,&#39;Y&#39; );&#10;        END IF;&#10;        --&#10;        IF NVL(p_update_offender_id_flag, &#39;Y&#39;) &#61; &#39;Y&#39; THEN&#10;            procRebuildOptTables( p_offenderID&#61;&gt;l_tab(l_i), p_process_alfresco_flag&#61;&gt;&#39;N&#39; );&#10;        ELSE&#10;            procRebuildOptTables( p_offenderID&#61;&gt;l_tab(l_i), p_process_alfresco_flag&#61;&gt;NVL(p_process_alfresco_flag, &#39;Y&#39;) );&#10;        END IF;&#10;        --&#10;        --COMMIT;&#10;    END LOOP;&#10;    --&#10;    IF NVL(p_update_offender_id_flag, &#39;Y&#39;) &#61; &#39;Y&#39; THEN&#10;        ALFRESCOSUPPORT.addOffenders2Queue( offenderid_TAB_in&#61;&gt;l_TAB );&#10;        IF NVL(p_process_alfresco_flag, &#39;Y&#39;) &#61; &#39;Y&#39; THEN&#10;            ALFRESCOSUPPORT.processQueue;&#10;        END IF;&#10;    END IF;&#10;    --&#10;END procRebuildOptTables_ALL;&#10;--&#10;PROCEDURE procValidate_VPD_Labels&#10;IS&#10;    l_scn NUMBER :&#61; PKG_VpdSupport.get_current_scn_number;&#10;    --&#10;    CURSOR cs IS&#10;      SELECT offender_id&#10;      FROM offender&#10;      WHERE NVL( CAST(ORGANISATIONS AS t_tab_ORGANISATIONS), t_tab_ORGANISATIONS() ) &lt;&gt;&#10;            PKG_VpdSupport.funcGetOffProbAreas(offender_id, l_scn)&#10;      ORDER BY 1;&#10;    --&#10;    l_offender_id NUMBER;&#10;    --&#10;    TYPE l_tab_TYP IS TABLE OF NUMBER;&#10;    l_tab l_tab_TYP;&#10;    --&#10;BEGIN&#10;    --&#10;    PKG_VPD_CTX.set_client_identifier(userID &#61;&gt; 1);&#10;    --&#10;    OPEN cs;&#10;    FETCH cs BULK COLLECT INTO l_tab;&#10;    CLOSE cs;&#10;    --&#10;    FOR l_i IN 1 .. NVL(l_tab.COUNT, 0) LOOP&#10;        --&#10;        PKG_VPD_CTX.set_table_value(&#39;REBUILD_REQUIRED&#39;,&#39;Y&#39;);&#10;        PKG_TriggerSupport.procRebuildOptTables(p_offenderID &#61;&gt; l_tab(l_i));&#10;        COMMIT;&#10;    END LOOP;&#10;    --&#10;END procValidate_VPD_Labels;&#10;--&#10;--&#10;PROCEDURE do_cr_user(p_user_id NUMBER, p_forename VARCHAR2, p_surname VARCHAR2, p_distinguished_name VARCHAR2)&#10;IS&#10;    l_user_id NUMBER;&#10;BEGIN&#10;    SELECT user_id INTO l_user_id&#10;    FROM user_&#10;    WHERE user_id &#61; p_user_id;&#10;    --&#10;    UPDATE user_ SET&#10;      forename &#61; p_forename,&#10;      surname &#61; p_surname,&#10;      distinguished_name &#61; p_distinguished_name&#10;    WHERE user_id &#61; l_user_id;&#10;    --&#10;EXCEPTION WHEN NO_DATA_FOUND THEN&#10;        IF NVL(p_user_id, -1) &lt;&#61; 0 THEN&#10;            l_user_id :&#61; USER_ID_SEQ.nextval;&#10;        ELSE&#10;            l_user_id :&#61; p_user_id;&#10;        END IF;&#10;    INSERT INTO user_ (&#10;      user_id, surname, forename, distinguished_name, private, organisation_id, row_version) VALUES (&#10;      l_user_id, p_surname, p_forename, PKG_Common.nvl2(p_distinguished_name, p_forename || p_surname), 0, 0, 0);&#10;END do_cr_user;&#10;--&#10;PROCEDURE do_grant_areas(p_user_id NUMBER, p_area_code VARCHAR2) IS&#10;BEGIN&#10;    DELETE FROM probation_area_user&#10;    WHERE user_id &#61; p_user_id;&#10;    INSERT INTO probation_area_user(user_id, probation_area_id, row_version, created_by_user_id, last_updated_user_id, created_datetime, last_updated_datetime)&#10;      SELECT p_user_id, probation_area_id, 0, 3, 3, SYSDATE, SYSDATE&#10;      FROM probation_area&#10;      WHERE ( UPPER(TRIM(p_area_code)) &#61; &#39;ALL&#39; OR code &#61; PKG_Common.nvl2(p_area_code, code) );&#10;END do_grant_areas;&#10;--&#10;PROCEDURE procAddSuperUser(p_user_id NUMBER, p_forename VARCHAR2 DEFAULT NULL, p_surname VARCHAR2 DEFAULT NULL, p_distinguished_name VARCHAR2 DEFAULT NULL, p_area_code VARCHAR2 DEFAULT NULL)&#10;IS&#10;BEGIN&#10;    do_cr_user(p_user_id, p_forename, p_surname, p_distinguished_name);&#10;    do_grant_areas(p_user_id, p_area_code);&#10;END procAddSuperUser;&#10;--&#10;FUNCTION funcOrganisationOffenderExists(&#10;    p_offender_ID          NUMBER,&#10;    p_probation_area_id    NUMBER,&#10;    p_external_provider_id NUMBER DEFAULT NULL,&#10;    p_training_session_id  NUMBER DEFAULT NULL)&#10;RETURN BOOLEAN IS&#10;    l_dummy VARCHAR2(1);&#10;BEGIN&#10;    SELECT &#39;Y&#39; INTO l_dummy&#10;    FROM organisation_offender&#10;    WHERE offender_id &#61; p_offender_ID&#10;      AND probation_area_id &#61; p_probation_area_id&#10;      AND NVL(external_provider_id, 0) &#61; NVL(p_external_provider_id, 0)&#10;      AND NVL(training_session_id, 0) &#61; NVL(training_session_id, 0)&#10;      AND ROWNUM &#61; 1;&#10;    --&#10;    RETURN TRUE;&#10;EXCEPTION WHEN NO_DATA_FOUND THEN&#10;    RETURN FALSE;&#10;END funcOrganisationOffenderExists;&#10;&#10;PROCEDURE procInsertOffenderRecord(p_offender_ID NUMBER, p_probation_area_id NUMBER, p_training_session_id NUMBER DEFAULT NULL) IS&#10;BEGIN&#10;    IF funcOrganisationOffenderExists(&#10;          p_offender_ID          &#61;&gt; p_offender_ID,&#10;          p_probation_area_id    &#61;&gt; p_probation_area_id,&#10;          p_external_provider_id &#61;&gt; NULL,&#10;          p_training_session_id  &#61;&gt; p_training_session_id )&#10;    THEN&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    INSERT INTO organisation_offender(&#10;      offender_id, probation_area_id, partition_area_id, training_session_id&#10;    ) VALUES (&#10;      p_offender_ID, p_probation_area_id, 0, p_training_session_id);&#10;    --&#10;    -- Instead of checking for duplicate rows, we silently throw away duplicates&#10;EXCEPTION WHEN DUP_VAL_ON_INDEX THEN&#10;    NULL;&#10;END procInsertOffenderRecord;&#10;&#10;PROCEDURE procInsertProviderRecord(p_offender_ID NUMBER, p_probation_area_id NUMBER, p_external_provider_id NUMBER, p_training_session_id NUMBER DEFAULT NULL)&#10;AS&#10;BEGIN&#10;    IF funcOrganisationOffenderExists(&#10;          p_offender_ID          &#61;&gt; p_offender_ID,&#10;          p_probation_area_id    &#61;&gt; p_probation_area_id,&#10;          p_external_provider_id &#61;&gt; NULL,&#10;          p_training_session_id  &#61;&gt; p_training_session_id )&#10;    THEN&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    INSERT INTO organisation_offender(&#10;      offender_id, probation_area_id, external_provider_id, partition_area_id, training_session_id&#10;    ) VALUES (&#10;      p_offender_ID, p_probation_area_id, p_external_provider_id, 0, p_training_session_id);&#10;    --&#10;    -- Instead of checking for duplicate rows, we silently throw away duplicates&#10;EXCEPTION WHEN DUP_VAL_ON_INDEX THEN&#10;    NULL;&#10;END procInsertProviderRecord;&#10;--&#10;FUNCTION funcPDTSession(&#10;    p_sid          IN OUT NUMBER,&#10;    p_job_name     IN OUT VARCHAR2,&#10;    p_owner_name   IN OUT VARCHAR2,&#10;    p_session_type IN OUT VARCHAR2 )&#10;RETURN BOOLEAN&#10;IS&#10;    l_ret           BOOLEAN :&#61; FALSE;&#10;BEGIN&#10;    SELECT s.sid, d.job_name, d.owner_name, d.session_type&#10;    INTO p_sid, p_job_name, p_owner_name, p_session_type&#10;    FROM dba_datapump_sessions d, v$session s&#10;    WHERE s.sid &#61; SYS_CONTEXT(&#39;USERENV&#39;, &#39;SID&#39;)&#10;    AND user &#61; SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_SCHEMA&#39;)&#10;    AND d.saddr &#61; s.saddr;&#10;    --&#10;    IF p_job_name LIKE &#39;PDT_TIER_%&#39; THEN&#10;        l_ret :&#61; TRUE;&#10;    END IF;&#10;    --&#10;    RETURN l_ret;&#10;    --&#10;EXCEPTION&#10;    WHEN NO_DATA_FOUND THEN&#10;        RETURN FALSE;&#10;    WHEN OTHERS THEN&#10;        RAISE;&#10;END funcPDTSession;&#10;--&#10;FUNCTION funcPDTActive RETURN BOOLEAN&#10;IS&#10;    l_ret BOOLEAN :&#61; FALSE;&#10;BEGIN&#10;    BEGIN&#10;        IF GLOBAL_CACHE_MGR.pdt_get_status &#61; &#39;ACTIVE&#39; THEN&#10;            l_ret :&#61; TRUE;&#10;        END IF;&#10;    EXCEPTION WHEN OTHERS THEN&#10;        NULL;&#10;    END;&#10;    --&#10;    RETURN l_ret;&#10;END funcPDTActive;&#10;--&#10;PROCEDURE do_pdt_debug_message(p_msg VARCHAR2) IS&#10;BEGIN&#10;    NULL;&#10;--    BEGIN&#10;--        EXECUTE IMMEDIATE &#39;BEGIN C08001_pdt_support.debugMessage(p_msg&#61;&gt;:p_msg); END;&#39; USING p_msg;&#10;--    EXCEPTION WHEN OTHERS THEN&#10;--        NULL;&#10;--    END;&#10;    --&#10;END do_pdt_debug_message;&#10;--&#10;PROCEDURE procOffender_PERF (p_offender_id NUMBER, p_institution_id NUMBER, p_establishment VARCHAR)&#10;IS&#10;    l_job_name      DBA_DATAPUMP_SESSIONS.job_name%TYPE;&#10;    l_owner_name    DBA_DATAPUMP_SESSIONS.owner_name%TYPE;&#10;    l_session_type  DBA_DATAPUMP_SESSIONS.session_type%TYPE;&#10;    l_sid           NUMBER;&#10;    l_sql           VARCHAR2(1024);&#10;    --&#10;BEGIN&#10;    IF funcPDTActive AND funcPDTSession(l_sid, l_job_name, l_owner_name, l_session_type) THEN&#10;        do_pdt_debug_message(&#39;procOffender_PERF: PDT Import Session Detected (SID&#61;&#39; || l_sid || &#39;, job_name&#61;&#39; || l_job_name || &#39;, owner_name&#61;&#39; || l_owner_name || &#39;, session_type&#61;&#39; || l_session_type || &#39;) - not updating&#39;);&#10;    ELSE&#10;        do_pdt_debug_message(&#39;procOffender_PERF: No PDT Import Sessions Detected - updating OFFENDER&#39;);&#10;        l_sql :&#61; &#39;UPDATE offender SET institution_id &#61; :institution_id, establishment &#61; :establishment&#10;                  WHERE offender_id &#61; :offender_id&#39;;&#10;        EXECUTE IMMEDIATE l_sql&#10;        USING p_institution_id, p_establishment, p_offender_id;&#10;    END IF;&#10;END procOffender_PERF;&#10;--&#10;PROCEDURE procSetVPDRebuildFlag&#10;IS&#10;    l_job_name      DBA_DATAPUMP_SESSIONS.job_name%TYPE;&#10;    l_owner_name    DBA_DATAPUMP_SESSIONS.owner_name%TYPE;&#10;    l_session_type  DBA_DATAPUMP_SESSIONS.session_type%TYPE;&#10;    l_sid           NUMBER;&#10;    --&#10;BEGIN&#10;    IF funcPDTSession(l_sid, l_job_name, l_owner_name, l_session_type) THEN&#10;        do_pdt_debug_message(&#39;procSetVPDRebuildFlag: PDT Import Session detected (sid&#61;&#39; || l_sid || &#39;, job_name&#61;&#39; || l_job_name || &#39;, owner_name&#61;&#39; || l_owner_name || &#39;, session_type&#61;&#39; || l_session_type || &#39;) - setting g_VPD_rebuild_flag to FALSE&#39;);&#10;        g_VPD_rebuild_flag :&#61; FALSE;&#10;    ELSE&#10;        do_pdt_debug_message(&#39;procSetVPDRebuildFlag: Non - PDT Import Session detected (sid&#61;&#39; || l_sid || &#39;, job_name&#61;&#39; || l_job_name || &#39;, owner_name&#61;&#39; || l_owner_name || &#39;, session_type&#61;&#39; || l_session_type || &#39;) - setting g_VPD_rebuild_flag to TRUE&#39;);&#10;        g_VPD_rebuild_flag :&#61; TRUE;&#10;    END IF;&#10;    --&#10;EXCEPTION&#10;    WHEN OTHERS THEN&#10;        do_pdt_debug_message(&#39;ERROR in procSetVPDRebuildFlag: &#39; || SQLERRM);&#10;        RAISE;&#10;END procSetVPDRebuildFlag;&#10;--&#10;PROCEDURE set_VPD_deferred_flag(p_flag BOOLEAN) IS&#10;BEGIN&#10;    g_VPD_deferred_rebuild_flag :&#61; NVL(p_flag, FALSE);&#10;END set_VPD_deferred_flag;&#10;--&#10;FUNCTION get_VPD_deferred_flag RETURN BOOLEAN IS&#10;BEGIN&#10;    RETURN NVL(g_VPD_deferred_rebuild_flag, FALSE);&#10;END get_VPD_deferred_flag;&#10;&#10;--&#10;-- YF 14/02/2014: added an overload procedure&#10;--&#10;PROCEDURE procSetVPDRebuildFlag(p_vpd_rebuild_flag BOOLEAN) IS&#10;BEGIN&#10;    g_VPD_rebuild_flag      :&#61; p_vpd_rebuild_flag;&#10;    g_VPD_rebuild_flag_INIT :&#61; TRUE;&#10;END procSetVPDRebuildFlag;&#10;&#10;PROCEDURE procInsertOrgOffenderRecord(&#10;    p_offender_id          NUMBER,&#10;    p_probation_area_id    NUMBER DEFAULT NULL,&#10;    p_external_provider_id NUMBER DEFAULT NULL,&#10;    p_team_id              NUMBER DEFAULT NULL,&#10;    p_provider_team_id     NUMBER DEFAULT NULL,&#10;    p_training_session_id  NUMBER DEFAULT NULL)&#10;IS&#10;    l_probation_area_id_1  NUMBER;&#10;    l_probation_area_id_2  NUMBER;&#10;    l_external_provider_id NUMBER;&#10;BEGIN&#10;    /*PKG_Debug.*/procDebug(&#39;procInsertOrgOffenderRecord: &#39; || CHR(10) ||&#10;                            &#39;p_offender_id &#61;&gt; &#39; || p_offender_id || CHR(10) ||&#10;                            &#39;p_probation_area_id &#61;&gt; &#39; || p_probation_area_id || CHR(10) ||&#10;                            &#39;p_external_provider_id &#61;&gt; &#39; || p_external_provider_id || CHR(10) ||&#10;                            &#39;p_team_id &#61;&gt; &#39; || p_team_id || CHR(10) ||&#10;                            &#39;p_provider_team_id &#61;&gt; &#39; || p_provider_team_id || CHR(10) ||&#10;                            &#39;p_training_session_id &#61;&gt; &#39; || p_training_session_id || CHR(10)&#10;                            || &#39;&#39;);&#10;    --&#10;    IF NOT g_VPD_rebuild_flag_INIT THEN&#10;        procSetVPDRebuildFlag;&#10;        g_VPD_rebuild_flag_INIT :&#61; TRUE;&#10;    END IF;&#10;    --&#10;    IF NOT g_VPD_rebuild_flag THEN&#10;        /*PKG_Debug.*/procDebug(&#39;procInsertOrgOffenderRecord WARNING: g_VPD_rebuild_flag&#61;FALSE&#39;);&#10;        --RETURN;&#10;    END IF;&#10;    --&#10;    IF p_team_id IS NOT NULL OR p_probation_area_id IS NOT NULL THEN&#10;        -- Staff Team&#10;        IF p_probation_area_id IS NULL THEN&#10;            l_probation_area_id_1 :&#61; funcGetTeamProbAreaID(p_team_id);&#10;        ELSE&#10;            l_probation_area_id_1 :&#61; p_probation_area_id;&#10;        END IF;&#10;        --&#10;        PKG_Lookups.do_flush_TAB_cache(TRUE);&#10;        --&#10;        /*PKG_Debug.*/procDebug(&#39;procInsertOrgOffenderRecord: CALL&#39; || CHR(10) ||&#10;                                &#39;p_offender_id &#61;&gt; &#39; || p_offender_id || CHR(10) ||&#10;                                &#39;p_probation_area_id &#61;&gt; &#39; || l_probation_area_id_1 || CHR(10) ||&#10;                                &#39;p_training_session_id &#61;&gt; &#39; || p_training_session_id || CHR(10)&#10;                                || &#39;&#39;);&#10;        --&#10;        procInsertOffenderRecord(&#10;            p_offender_ID         &#61;&gt; p_offender_id,&#10;            p_probation_area_id   &#61;&gt; l_probation_area_id_1,&#10;            p_training_session_id &#61;&gt; p_training_session_id);&#10;        --&#10;    END IF;&#10;    --&#10;    IF p_provider_team_id IS NOT NULL OR p_external_provider_id IS NOT NULL THEN&#10;        -- Provider  team&#10;        IF p_probation_area_id IS NULL THEN&#10;            l_probation_area_id_2 :&#61; funcGetProvTeamProbAreaID(p_provider_team_id);&#10;        ELSE&#10;            l_probation_area_id_2 :&#61; p_probation_area_id;&#10;        END IF;&#10;        --&#10;        IF p_external_provider_id IS NULL THEN&#10;            l_external_provider_id :&#61; funcGetProvTeamExtProviderID(p_provider_team_id);&#10;        ELSE&#10;            l_external_provider_id :&#61; p_external_provider_id;&#10;        END IF;&#10;        --&#10;        PKG_Lookups.do_flush_TAB_cache(TRUE);&#10;        --&#10;        procInsertProviderRecord(&#10;            p_offender_ID         &#61;&gt; p_offender_id,&#10;            p_external_provider_id&#61;&gt; l_external_provider_id,&#10;            p_probation_area_id   &#61;&gt; l_probation_area_id_2,&#10;            p_training_session_id &#61;&gt; p_training_session_id);&#10;        --&#10;        IF l_probation_area_id_2 &lt;&gt; NVL(l_probation_area_id_1, -99) THEN&#10;            procInsertOffenderRecord(&#10;                p_offender_ID         &#61;&gt; p_offender_id,&#10;                p_probation_area_id   &#61;&gt; l_probation_area_id_2,&#10;                p_training_session_id &#61;&gt; p_training_session_id);&#10;        END IF;&#10;        --&#10;    END IF;&#10;    --&#10;    IF NOT get_VPD_deferred_flag THEN&#10;        ALFRESCOSUPPORT.addOffender2Queue(offenderid_in &#61;&gt; p_offender_id);&#10;    END IF;&#10;    --&#10;END procInsertOrgOffenderRecord;&#10;&#10;FUNCTION funcIsOffenderExists(p_offender_id NUMBER) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_Lookups.funcgetTabRecord(&#10;               p_table      &#61;&gt; &#39;OFFENDER&#39;,&#10;               p_ref_col    &#61;&gt; &#39;offender_id&#39;,&#10;               p_ref_val    &#61;&gt; TO_CHAR(p_offender_id),&#10;               p_data_fld   &#61;&gt; &#39;&#39;&#39;Y&#39;&#39;&#39;,&#10;               p_default_val&#61;&gt; &#39;N&#39;);&#10;END funcIsOffenderExists;&#10;&#10;FUNCTION get_tab_offenders_list RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN PKG_LstUtl.get_array_2_list(g_tab_offenders_list);&#10;END get_tab_offenders_list;&#10;--&#10;FUNCTION get_tab_offenders_list_1 RETURN t_tab_ORGANISATIONS IS&#10;BEGIN&#10;    RETURN g_tab_offenders_list;&#10;END get_tab_offenders_list_1;&#10;--&#10;FUNCTION get_tab_offenders_list_cnt RETURN NUMBER IS&#10;BEGIN&#10;    RETURN g_tab_offenders_list.COUNT;&#10;END get_tab_offenders_list_cnt;&#10;&#10;PROCEDURE reset_tab_offenders_list IS&#10;BEGIN&#10;    g_tab_offenders_list.DELETE;&#10;END reset_tab_offenders_list;&#10;&#10;PROCEDURE procRebuildOffProbAreas(p_offenders_list VARCHAR2 DEFAULT NULL, p_validate_flag VARCHAR2 DEFAULT &#39;N&#39;)&#10;IS&#10;    --&#10;    l_offenders_arr  t_tab_ORGANISATIONS :&#61; t_tab_ORGANISATIONS();&#10;    l_offenders_list VARCHAR2(30000);&#10;    --l_scn            NUMBER;&#10;    --&#10;    l_off_prob_areas_NEW t_tab_ORGANISATIONS :&#61; t_tab_ORGANISATIONS();&#10;    l_off_prob_areas_OLD t_tab_ORGANISATIONS :&#61; t_tab_ORGANISATIONS();&#10;    --&#10;BEGIN&#10;    --&#10;    IF empty2null(TRIM(p_offenders_list)) IS NOT NULL THEN&#10;        l_offenders_list :&#61; p_offenders_list;&#10;        l_offenders_arr  :&#61; PKG_LstUtl.get_list_2_array(l_offenders_list);&#10;    ELSE&#10;        l_offenders_list :&#61; PKG_LstUtl.get_array_2_list(g_tab_offenders_list);&#10;        l_offenders_arr  :&#61; g_tab_offenders_list;&#10;    END IF;&#10;    --&#10;    IF empty2null(TRIM(l_offenders_list)) IS NULL THEN&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    --&#10;    procDebug(SUBSTR(&#39;procRebuildOffProbAreas[&#39; || l_offenders_list || &#39;]&#39;, 1, 30000));&#10;    --&#10;    --l_scn :&#61; PKG_VpdSupport.get_current_scn_number;&#10;    --&#10;    FOR l_i IN 1 .. l_offenders_arr.COUNT LOOP&#10;        --l_off_prob_areas_NEW :&#61; PKG_VpdSupport.funcGetOffProbAreas(l_offenders_arr(l_i), l_scn)&#10;        BEGIN&#10;--            SELECT&#10;--              CAST(ORGANISATIONS AS t_tab_ORGANISATIONS),&#10;--              PKG_VpdSupport.funcGetOffProbAreas_NOCACHE(l_offenders_arr(l_i))&#10;--            INTO&#10;--              l_off_prob_areas_OLD,&#10;--              l_off_prob_areas_NEW&#10;--            FROM offender&#10;--            WHERE offender_id &#61; l_offenders_arr(l_i);&#10;            --&#10;            l_off_prob_areas_NEW :&#61; PKG_VpdSupport.funcGetOffProbAreas_NOCACHE(l_offenders_arr(l_i));&#10;            --&#10;            g_VPD_validation_mode :&#61; ( NVLSTR(p_validate_flag, &#39;N&#39;) &#61; &#39;Y&#39; );&#10;            --&#10;            IF PKG_Debug.funcgetDebugMode &lt;&gt; &#39;0&#39; THEN&#10;                procDebug(SUBSTR(&#39;procRebuildOffProbAreas[&#39; || l_offenders_arr(l_i) || &#39;]&#39; ||&#10;                    --&#39;[l_i&#61;&#39; || l_i || &#39;]&#39; ||&#10;                    --&#39;[scn&#61;&#39; || l_scn || &#39;]&#39; ||&#10;                    &#39;[g_VPD_validation_mode&#61;&#39; || NVLSTR(p_validate_flag, &#39;N&#39;) || &#39;]&#39; ||&#10;                    --&#39;[orgs_OLD&#61;&#39; || PKG_LstUtl.get_array_2_list(l_off_prob_areas_OLD, p_iterator_function&#61;&gt;&#39;PKG_Lookups.funcgetTabRecord_CACHED(p_table&#61;&gt;&#39;&#39;PROBATION_AREA&#39;&#39;, p_ref_col&#61;&gt;&#39;&#39;probation_area_id&#39;&#39;, p_ref_val&#61;&gt;:p_probation_area_id, p_data_fld&#61;&gt;&#39;&#39;CODE&#39;&#39;)&#39;) || &#39;]&#39; ||&#10;                    &#39;[orgs_NEW&#61;&#39; || PKG_LstUtl.get_array_2_list(l_off_prob_areas_NEW, p_iterator_function&#61;&gt;&#39;PKG_Lookups.funcgetTabRecord_CACHED(p_table&#61;&gt;&#39;&#39;PROBATION_AREA&#39;&#39;, p_ref_col&#61;&gt;&#39;&#39;probation_area_id&#39;&#39;, p_ref_val&#61;&gt;:p_probation_area_id, p_data_fld&#61;&gt;&#39;&#39;CODE&#39;&#39;)&#39;) || &#39;]&#39;,&#10;                    1, 30000) );&#10;            END IF;&#10;            --&#10;            -- YF DST-1728: Top level OFFENDER.organisations may already be set to a correct value, while other tables still need VPD update&#10;--            IF g_VPD_validation_mode OR&#10;--               NVL(l_off_prob_areas_OLD, t_tab_ORGANISATIONS()) &lt;&gt; NVL(l_off_prob_areas_NEW, t_tab_ORGANISATIONS())&#10;--            THEN&#10;                IF PKG_Debug.funcgetDebugMode &lt;&gt; &#39;0&#39; THEN&#10;                    procDebug(&#39;procRebuildOffProbAreas: ORGS field has been changed - calling PKG_TriggerSupport.procUpdateProbationAreas_ALL(&#39; || l_offenders_arr(l_i) || &#39;)&#39;);&#10;                END IF;&#10;                -- YF: Cascade update of the ORGANISATIONS field for all Offender based tables that are VPD registered&#10;                procUpdateProbationAreas_ALL(&#10;                    p_offender_id   &#61;&gt; l_offenders_arr(l_i),&#10;                    p_ORGANISATIONS &#61;&gt; l_off_prob_areas_NEW );&#10;            --ELSE&#10;            --    procDebug(&#39;procRebuildOffProbAreas_JOB: OFFENDER [&#39; || l_offenders_arr(l_i) || &#39;]&#39; ||&#10;            --        &#39; already has up to date ORGANISATIONS [&#39; || PKG_LstUtl.get_array_2_list(l_off_prob_areas_OLD) || &#39;]&#61;[&#39; || PKG_LstUtl.get_array_2_list(l_off_prob_areas_NEW) || &#39;]&#39;);&#10;--            END IF;&#10;            --&#10;            g_VPD_validation_mode :&#61; FALSE;&#10;            --&#10;        EXCEPTION WHEN NO_DATA_FOUND THEN&#10;            --&#10;            g_VPD_validation_mode :&#61; FALSE;&#10;            --&#10;            procDebug(&#39;procRebuildOffProbAreas_JOB WARNING: OFFENDER [&#39; || l_offenders_arr(l_i) || &#39;] has not been found&#39;);&#10;            raise_application_error(-20001, &#39;procRebuildOffProbAreas_JOB WARNING: OFFENDER [&#39; || l_offenders_arr(l_i) || &#39;] has not been found&#39;);&#10;        WHEN OTHERS THEN&#10;            --&#10;            g_VPD_validation_mode :&#61; FALSE;&#10;            RAISE;&#10;            --&#10;        END;&#10;    END LOOP;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    procDebug(&#39;procRebuildOffProbAreas ERROR: &#39; || SQLERRM);&#10;    RAISE;&#10;END procRebuildOffProbAreas;&#10;&#10;PROCEDURE procFindAPFromGroup(&#10;    p_offender_ID                 NUMBER,&#10;    p_approvedPremisesReferral_ID NUMBER,&#10;    p_referralGroup_ID            NUMBER)&#10;AS&#10;    CURSOR cs IS&#10;      SELECT DISTINCT rap.probation_area_id, rap.training_session_id&#10;      FROM r_approved_premises rap, r_ap_referral_group raprg&#10;      WHERE RAPRG.standard_reference_list_id &#61; p_referralGroup_ID&#10;        AND RAP.approved_premises_id &#61; RAPRG.approved_premises_id;&#10;    --&#10;    l_prob_area_id NUMBER;&#10;    l_training_session_id NUMBER;&#10;    --&#10;BEGIN&#10;    OPEN cs;&#10;    LOOP&#10;        FETCH cs INTO l_prob_area_id, l_training_session_id;&#10;        EXIT WHEN cs%NOTFOUND;&#10;        --&#10;        procInsertOffenderRecord(&#10;          p_offender_id         &#61;&gt; p_offender_ID,&#10;          p_probation_area_id   &#61;&gt; l_prob_area_id,&#10;          p_training_session_id &#61;&gt; l_training_session_id);&#10;    END LOOP;&#10;    CLOSE cs;&#10;    --&#10;END procFindAPFromGroup;&#10;--&#10;&#10;&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;-- CASELOAD Rebuild suport subroutines&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;&#10;-- -----------------------------------------------------------------------------&#10;--&#10;-- Description: A procedure to rebuild the Officer Caseload optimisation table&#10;--&#10;-- -----------------------------------------------------------------------------&#10;PROCEDURE procRebuildCaseloadTable(p_offender_ID NUMBER)&#10;IS&#10;BEGIN&#10;    do_rebuild_caseload(p_offender_id);&#10;END procRebuildCaseloadTable;&#10;&#10;PROCEDURE procFetchCaseloadRecords(p_offender_id IN NUMBER, p_tab OUT t_tab_ORGANISATIONS) IS&#10;BEGIN&#10;    SELECT CASELOAD_ID BULK COLLECT INTO p_tab&#10;    FROM caseload&#10;    WHERE offender_id &#61; p_offender_id;&#10;END procFetchCaseloadRecords;&#10;&#10;PROCEDURE procCaseloadAddOffender(p_offender_id NUMBER)&#10;IS&#10;    l_offender_id  VARCHAR2(100);&#10;BEGIN&#10;    l_offender_id :&#61; TO_CHAR(p_offender_id);&#10;    IF NOT g_tab_caseload_offender_list.EXISTS(l_offender_id) THEN&#10;        procDebug(&#39;procCaseloadAddOffender: Add new caseload offender ID&#61;&#39; || l_offender_id);&#10;        g_tab_caseload_offender_list(l_offender_id) :&#61; &#39;Y&#39;;&#10;    END IF;&#10;    PKG_VPD_CTX.set_table_value(&#39;CASELOAD_REBUILD_REQUIRED&#39;,&#39;Y&#39;);&#10;END procCaseloadAddOffender;&#10;&#10;FUNCTION funcGetRebuildCaseload_OFF_lst RETURN VARCHAR2&#10;IS&#10;    l_offender_id NUMBER;&#10;    l_ret         VARCHAR2(4000);&#10;BEGIN&#10;    l_offender_id :&#61; g_tab_caseload_offender_list.FIRST;&#10;    LOOP&#10;        EXIT WHEN l_offender_id IS NULL;&#10;        --&#10;        l_ret :&#61; SUBSTR(l_ret || CASE WHEN empty2null(l_ret) IS NOT NULL THEN &#39;, &#39; END || l_offender_id, 1, 4000);&#10;        --&#10;        l_offender_id :&#61; g_tab_caseload_offender_list.NEXT(l_offender_id);&#10;    END LOOP;&#10;    RETURN l_ret;&#10;END funcGetRebuildCaseload_OFF_lst;&#10;--&#10;FUNCTION get_offender_id_max_val RETURN NUMBER RESULT_CACHE&#10;IS&#10;    l_res NUMBER;&#10;BEGIN&#10;    SELECT MAX_VALUE INTO l_res&#10;    FROM user_sequences WHERE sequence_name &#61; &#39;OFFENDER_ID_SEQ&#39;;&#10;    RETURN l_res;&#10;END get_offender_id_max_val;&#10;--&#10;FUNCTION getOffTAB(p_tab_type VARCHAR2) RETURN t_tab_ORGANISATIONS&#10;IS&#10;    l_offender_id VARCHAR2(100);&#10;    l_TAB_OFF     t_tab_OFFENDERS;&#10;    l_TAB         t_tab_ORGANISATIONS :&#61; t_tab_ORGANISATIONS();&#10;BEGIN&#10;    --&#10;    IF    p_tab_type &#61; &#39;CASELOAD&#39; THEN&#10;        l_TAB_OFF :&#61; g_tab_caseload_offender_list;&#10;    ELSIF p_tab_type &#61; &#39;COHORT&#39; THEN&#10;        l_TAB_OFF :&#61; g_tab_cohort_offender_list;&#10;    ELSE&#10;        raise_application_error(-20001, &#39;ERROR in PKG_TriggerSupport.getOffTAB: invalid value for the P_TAB_TYPE argument&#39;);&#10;    END IF;&#10;    --&#10;    l_offender_id :&#61; l_TAB_OFF.FIRST;&#10;    LOOP&#10;        EXIT WHEN l_offender_id IS NULL;&#10;        --&#10;        SELECT l_TAB MULTISET UNION DISTINCT t_tab_ORGANISATIONS(l_offender_id)&#10;        INTO l_TAB&#10;        FROM dual;&#10;        --&#10;        l_offender_id :&#61; l_TAB_OFF.NEXT(l_offender_id);&#10;        --&#10;    END LOOP;&#10;    --&#10;    RETURN l_TAB;&#10;    --&#10;END getOffTAB;&#10;--&#10;PROCEDURE procRebuildCaseloadTable_OFF&#10;IS&#10;    l_offender_id VARCHAR2(100);&#10;    l_TAB         t_tab_ORGANISATIONS;&#10;BEGIN&#10;    --&#10;    l_TAB :&#61; getOffTAB(&#39;CASELOAD&#39;);&#10;    --&#10;    FOR l_idx IN 1..l_TAB.COUNT LOOP&#10;        l_offender_id :&#61; l_TAB(l_idx);&#10;        --&#10;        PKG_VPD_CTX.set_table_value(&#39;CASELOAD_REBUILD_REQUIRED&#39;,&#39;Y&#39;);&#10;        procDebug(&#39;procRebuildCaseloadTable_OFF: Rebuilding CASELOAD for offender_id&#61;&#39; || l_offender_id);&#10;        --&#10;        procRebuildCaseloadTable(p_offender_ID &#61;&gt; TO_NUMBER(l_offender_id));&#10;        --&#10;    END LOOP;&#10;    --&#10;    g_tab_caseload_offender_list.DELETE;&#10;    --&#10;END procRebuildCaseloadTable_OFF;&#10;--&#10;PROCEDURE procRebuildCaseloadTable_ALL(p_offender_ID_from NUMBER DEFAULT NULL, p_offender_ID_to NUMBER DEFAULT NULL)&#10;IS&#10;--&#10;    l_offender_id      NUMBER;&#10;    l_offender_id_from NUMBER;&#10;    l_offender_id_to   NUMBER;&#10;    --&#10;    CURSOR cs IS&#10;      SELECT T.offender_id&#10;      FROM (SELECT offender_id&#10;            FROM offender&#10;            WHERE current_disposal &#61; 1&#10;            MINUS&#10;            SELECT offender_id&#10;            FROM caseload) T&#10;      WHERE T.offender_id BETWEEN l_offender_id_from AND l_offender_id_to;&#10;    --&#10;BEGIN&#10;    --&#10;    l_offender_id_from :&#61; NVL(p_offender_ID_from, 0);&#10;    l_offender_id_to   :&#61; NVL(p_offender_ID_to, get_offender_id_max_val);&#10;    --&#10;    OPEN cs;&#10;    LOOP&#10;        FETCH cs INTO l_offender_id;&#10;        EXIT WHEN cs%NOTFOUND;&#10;        --&#10;        PKG_VPD_CTX.set_table_value(&#39;CASELOAD_REBUILD_REQUIRED&#39;,&#39;Y&#39;);&#10;        procRebuildCaseloadTable(p_offender_ID &#61;&gt; l_offender_id);&#10;        --COMMIT;&#10;    END LOOP;&#10;    CLOSE cs;&#10;END procRebuildCaseloadTable_ALL;&#10;--&#10;--&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;-- COHORT_DIARY Rebuild suport subroutines&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;PROCEDURE procCohortAddOffender(p_offender_id NUMBER)&#10;IS&#10;    l_offender_id  VARCHAR2(100);&#10;BEGIN&#10;    l_offender_id :&#61; TO_CHAR(p_offender_id);&#10;    IF NOT g_tab_cohort_offender_list.EXISTS(l_offender_id) THEN&#10;        procDebug(&#39;procCohortAddOffender: Add new COHORT_DIARY offender ID&#61;&#39; || l_offender_id);&#10;        g_tab_cohort_offender_list(l_offender_id) :&#61; &#39;Y&#39;;&#10;        --&#10;    END IF;&#10;    PKG_VPD_CTX.set_table_value(&#39;COHORT_REBUILD_REQUIRED&#39;,&#39;Y&#39;);&#10;END procCohortAddOffender;&#10;--&#10;PROCEDURE procRebuildCohortTable(p_offender_id NUMBER)&#10;IS&#10;BEGIN&#10;    do_rebuild_cohort_diary(p_offender_id);&#10;END procRebuildCohortTable;&#10;--&#10;PROCEDURE procRebuildCohortTable_OFF&#10;IS&#10;    l_offender_id VARCHAR2(100);&#10;    l_TAB         t_tab_ORGANISATIONS;&#10;BEGIN&#10;    --&#10;    l_TAB :&#61; getOffTAB(&#39;COHORT&#39;);&#10;    --&#10;    FOR l_idx IN 1..l_TAB.COUNT LOOP&#10;        l_offender_id :&#61; l_TAB(l_idx);&#10;        --&#10;        PKG_VPD_CTX.set_table_value(&#39;COHORT_REBUILD_REQUIRED&#39;,&#39;Y&#39;);&#10;        procDebug(&#39;procRebuildCohortTable_OFF: Rebuilding COHORT_DIARY for offender_id&#61;&#39; || l_offender_id);&#10;        --&#10;        procRebuildCohortTable(p_offender_ID &#61;&gt; TO_NUMBER(l_offender_id));&#10;        --&#10;    END LOOP;&#10;    --&#10;    g_tab_cohort_offender_list.DELETE;&#10;    --&#10;END procRebuildCohortTable_OFF;&#10;--&#10;FUNCTION funcGetRebuildCohort_OFF_lst RETURN VARCHAR2&#10;IS&#10;    l_offender_id NUMBER;&#10;    l_ret         VARCHAR2(4000);&#10;BEGIN&#10;    l_offender_id :&#61; g_tab_cohort_offender_list.FIRST;&#10;    LOOP&#10;        EXIT WHEN l_offender_id IS NULL;&#10;        --&#10;        l_ret :&#61; SUBSTR(l_ret || CASE WHEN l_ret IS NOT NULL THEN &#39;, &#39; END || l_offender_id, 1, 4000);&#10;        --&#10;        l_offender_id :&#61; g_tab_cohort_offender_list.NEXT(l_offender_id);&#10;    END LOOP;&#10;    RETURN l_ret;&#10;END funcGetRebuildCohort_OFF_lst;&#10;--&#10;PROCEDURE procRebuildCohortTable_ALL(p_offender_ID_from NUMBER DEFAULT NULL, p_offender_ID_to NUMBER DEFAULT NULL)&#10;IS&#10;    --&#10;    l_offender_id      NUMBER;&#10;    l_offender_id_from NUMBER;&#10;    l_offender_id_to   NUMBER;&#10;    --&#10;    TYPE l_cur_TYP IS REF CURSOR;&#10;    l_cur l_cur_TYP;&#10;    --&#10;    l_SQL VARCHAR2(10000);&#10;    --&#10;BEGIN&#10;    --&#10;    l_offender_id_from :&#61; NVL(p_offender_ID_from, 0);&#10;    l_offender_id_to   :&#61; NVL(p_offender_ID_to, get_offender_id_max_val);&#10;    --&#10;    l_SQL :&#61;&#10;    --&#10;&#39;WITH T AS (&#10;  SELECT offender_id&#10;  FROM offender&#10;  WHERE 1&#61;1&#10;  MINUS&#10;  SELECT offender_id&#10;  FROM cohort_diary )&#10;SELECT offender_id&#10;FROM T&#10;WHERE T.offender_id BETWEEN :p_offender_id_from AND :p_offender_id_to&#10;  AND EXISTS(&#10;  --&#10;    &#39; || REPLACE(PKG_Caseload.get_cohort_diary_SQL(p_offender_id_only_flag&#61;&gt;&#39;Y&#39;), &#39;:p_offender_id&#39;, &#39;T.offender_id&#39;) || &#39;&#10;  --&#10;  )&#39;;&#10;    --&#10;    IF G_DEBUG_FLAG THEN&#10;        info(&#39;SQL: &#39; || l_SQL, p_proc&#61;&gt;&#39;procRebuildCohortTable_ALL&#39;, p_trace_level&#61;&gt;1);&#10;    END IF;&#10;    --&#10;    OPEN l_cur FOR l_SQL USING l_offender_id_from, l_offender_id_to;&#10;    LOOP&#10;        FETCH l_cur INTO l_offender_id;&#10;        EXIT WHEN l_cur%NOTFOUND;&#10;        --&#10;        PKG_VPD_CTX.set_table_value(&#39;COHORT_REBUILD_REQUIRED&#39;,&#39;Y&#39;);&#10;        procRebuildCohortTable(p_offender_ID &#61;&gt; l_offender_id);&#10;        --COMMIT;&#10;    END LOOP;&#10;    CLOSE l_cur;&#10;    --&#10;END procRebuildCohortTable_ALL;&#10;--&#10;PROCEDURE procRebuildRejTransfersDiary(p_offender_id NUMBER)&#10;IS&#10;BEGIN&#10;    do_rebuild_rej_transfers_diary(p_offender_id);&#10;END procRebuildRejTransfersDiary;&#10;&#10;--&#10;--&#10;--&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--    TRUST_PROVIDER_FLAG / TRUST_PROVIDER_TEAM_ID / STAFF_EMPLOYEE_ID /&#10;--    PROBATION_AREA_ID maintenance subroutines&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;&#10;FUNCTION funcGetTeamProbAreaID(p_team_id NUMBER)&#10;RETURN NUMBER&#10;IS&#10;BEGIN&#10;    RETURN&#10;        PKG_Lookups.funcgetTabRecord_CACHED(&#10;            p_table       &#61;&gt; &#39;team&#39;,&#10;            p_ref_col     &#61;&gt; &#39;team_id&#39;,&#10;            p_ref_val     &#61;&gt; TO_CHAR(p_team_id),&#10;            p_data_fld    &#61;&gt; &#39;probation_area_id&#39;,&#10;            p_default_val &#61;&gt; &#39;-1&#39; );&#10;EXCEPTION WHEN NO_DATA_FOUND THEN&#10;    raise_application_error(-20001, &#39;FATAL ERROR in PKG_TriggerSupport.funcGetTeamProbAreaID: NO_DATA_FOUND for TEAM_ID&#61;&#39; || p_team_id);&#10;END funcGetTeamProbAreaID;&#10;&#10;FUNCTION funcGetProvTeamProbAreaID(p_provider_team_id NUMBER)&#10;RETURN NUMBER&#10;IS&#10;BEGIN&#10;    RETURN&#10;        PKG_Lookups.funcgetTabRecord_CACHED(&#10;            p_table       &#61;&gt; &#39;provider_team&#39;,&#10;            p_ref_col     &#61;&gt; &#39;provider_team_id&#39;,&#10;            p_ref_val     &#61;&gt; TO_CHAR(p_provider_team_id),&#10;            p_data_fld    &#61;&gt; &#39;probation_area_id&#39;,&#10;            p_default_val &#61;&gt; &#39;-1&#39; );&#10;EXCEPTION WHEN NO_DATA_FOUND THEN&#10;    raise_application_error(-20001, &#39;FATAL ERROR in PKG_TriggerSupport.funcGetProvTeamProbAreaID: NO_DATA_FOUND for PROVIDER_TEAM_ID&#61;&#39; || p_provider_team_id);&#10;END funcGetProvTeamProbAreaID;&#10;&#10;FUNCTION funcGetProvTeamExtProviderID(p_provider_team_id NUMBER)&#10;RETURN NUMBER&#10;IS&#10;BEGIN&#10;    RETURN&#10;        PKG_Lookups.funcgetTabRecord_CACHED(&#10;            p_table       &#61;&gt; &#39;provider_team&#39;,&#10;            p_ref_col     &#61;&gt; &#39;provider_team_id&#39;,&#10;            p_ref_val     &#61;&gt; TO_CHAR(p_provider_team_id),&#10;            p_data_fld    &#61;&gt; &#39;external_provider_id&#39;,&#10;            p_default_val &#61;&gt; &#39;-1&#39; );&#10;    --&#10;EXCEPTION WHEN NO_DATA_FOUND THEN&#10;    raise_application_error(-20001, &#39;FATAL ERROR in PKG_TriggerSupport.funcGetProvTeamExtProviderID: NO_DATA_FOUND for PROVIDER_TEAM_ID&#61;&#39; || p_provider_team_id);&#10;END funcGetProvTeamExtProviderID;&#10;&#10;PROCEDURE procSetTrustStaffTeamArea(&#10;    p_staff_id               IN     NUMBER,&#10;    p_provider_employee_id   IN     NUMBER,&#10;    p_team_id                IN     NUMBER,&#10;    p_provider_team_id       IN     NUMBER,&#10;    p_TRUST_PROVIDER_FLAG    IN OUT NUMBER,&#10;    p_TRUST_PROVIDER_TEAM_ID IN OUT NUMBER,&#10;    p_STAFF_EMPLOYEE_ID      IN OUT NUMBER,&#10;    p_PROBATION_AREA_ID      IN OUT NUMBER)&#10;IS&#10;    l_provider_staff_id      NUMBER;&#10;    l_provider_staff_team_id NUMBER;&#10;    l_probation_area_if      NUMBER;&#10;BEGIN&#10;    IF p_provider_employee_id IS NULL THEN&#10;        --EMPLOYEE&#10;        p_TRUST_PROVIDER_FLAG    :&#61; 0;&#10;        p_STAFF_EMPLOYEE_ID      :&#61; p_staff_id;&#10;        p_TRUST_PROVIDER_TEAM_ID :&#61; p_team_id;&#10;        p_PROBATION_AREA_ID      :&#61; funcGetTeamProbAreaID(p_team_id);&#10;    ELSE&#10;        --PROVIDER&#10;        p_TRUST_PROVIDER_FLAG    :&#61; 1;&#10;        p_STAFF_EMPLOYEE_ID      :&#61; p_provider_employee_id;&#10;        p_TRUST_PROVIDER_TEAM_ID :&#61; p_provider_team_id;&#10;        p_PROBATION_AREA_ID      :&#61; funcGetProvTeamProbAreaID(p_provider_team_id);&#10;    END IF;&#10;END procSetTrustStaffTeamArea;&#10;&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--    OFFENDER.current_disposal maintenance subroutines&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;FUNCTION funcGetOffenderCurrentDisposal(p_offender_id NUMBER) RETURN NUMBER&#10;IS&#10;    l_current_disposal NUMBER;&#10;BEGIN&#10;    SELECT NVL(LEAST(COUNT(E.event_id), 1), 0)&#10;    INTO l_current_disposal&#10;    FROM event E, disposal D&#10;    WHERE E.offender_id &#61; p_offender_id&#10;      AND E.soft_deleted &#61; 0&#10;      AND D.event_id &#61; E.event_id&#10;      AND (D.termination_date IS NULL OR D.termination_date &gt; SYSDATE);&#10;    --&#10;    RETURN l_current_disposal;&#10;END funcGetOffenderCurrentDisposal;&#10;&#10;FUNCTION funcGetCurrDispDeferredUpdCNT RETURN NUMBER IS&#10;BEGIN&#10;    RETURN NVL(g_tab_deferred_upd_CURRENT_D.COUNT, 0);&#10;END funcGetCurrDispDeferredUpdCNT;&#10;&#10;PROCEDURE procAddCurrDispDeferred(p_offender_id NUMBER, p_trigger_name VARCHAR2 DEFAULT NULL)&#10;IS&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;procAddCurrDispDeferred&#39;;&#10;    --&#10;    l_key VARCHAR2(100);&#10;BEGIN&#10;    l_key :&#61; TO_CHAR(p_offender_id);&#10;    IF NOT g_tab_deferred_upd_CURRENT_D.EXISTS(l_key) THEN&#10;        procDebug(l_proc || &#39;[&#39; || p_trigger_name || &#39;]: add new offender_id&#61;&#39; || p_offender_id);&#10;        g_tab_deferred_upd_CURRENT_D(l_key) :&#61; &#39;Y&#39;;&#10;    END IF;&#10;END procAddCurrDispDeferred;&#10;&#10;PROCEDURE procUpdateOffCurrDisp_DEFERRED(p_trigger_name VARCHAR2 DEFAULT NULL)&#10;IS&#10;    --&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;procUpdateOffCurrDisp_DEFERRED&#39;;&#10;    --&#10;    l_key         VARCHAR2(100);&#10;    l_offender_id NUMBER;&#10;    --&#10;    ex_mutating_table EXCEPTION;&#10;    PRAGMA EXCEPTION_INIT (ex_mutating_table, -4091);&#10;    --&#10;    l_tab_deferred_upd_CURRENT_D t_tab_deferred_upd;&#10;    --&#10;BEGIN&#10;    IF g_tab_deferred_upd_CURRENT_D.COUNT &gt; 0 THEN&#10;        l_key :&#61; g_tab_deferred_upd_CURRENT_D.FIRST;&#10;        LOOP&#10;            EXIT WHEN empty2null(l_key) IS NULL;&#10;            --&#10;            procDebug(l_proc || &#39;: processing the [&#39; || l_key || &#39;] queue element&#39;);&#10;            --&#10;            BEGIN&#10;                l_offender_id :&#61; TO_NUMBER(l_key);&#10;            EXCEPTION WHEN OTHERS THEN&#10;                l_offender_id :&#61; -1;&#10;            END;&#10;            --&#10;            IF l_offender_id &lt;&#61; 0  THEN&#10;                raise_application_error(-20001, &#39;ERROR in &#39; || l_proc || &#39; [&#39; || l_key || &#39;]: invalid deferred queue element detected&#39;);&#10;            END IF;&#10;            --&#10;            BEGIN&#10;                procSetOffenderCurrDisposal(p_offender_id&#61;&gt;l_offender_id, p_trigger_name &#61;&gt; p_trigger_name);&#10;            EXCEPTION WHEN ex_mutating_table THEN&#10;                procDebug(l_proc || &#39;: failed to process the [&#39; || l_key || &#39;] queue element {&#39; || SQLERRM || &#39;): keeping in the queue&#39;);&#10;                IF NOT l_tab_deferred_upd_CURRENT_D.EXISTS(l_key) THEN&#10;                    l_tab_deferred_upd_CURRENT_D(l_key) :&#61; &#39;Y&#39;;&#10;                END IF;&#10;            END;&#10;            --&#10;            l_key :&#61; g_tab_deferred_upd_CURRENT_D.NEXT(l_key);&#10;        END LOOP;&#10;        --&#10;        g_tab_deferred_upd_CURRENT_D.DELETE;&#10;        --&#10;        IF l_tab_deferred_upd_CURRENT_D.COUNT &gt; 0 THEN&#10;            g_tab_deferred_upd_CURRENT_D :&#61; l_tab_deferred_upd_CURRENT_D;&#10;        END IF;&#10;        --&#10;    END IF;&#10;END procUpdateOffCurrDisp_DEFERRED;&#10;&#10;PROCEDURE procSetOffenderCurrDisposal(p_offender_id NUMBER, p_trigger_name VARCHAR2 DEFAULT NULL)&#10;IS&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;procSetOffenderCurrDisposal&#39;;&#10;    --&#10;    l_current_disposal NUMBER;&#10;    --&#10;    ex_mutating_table EXCEPTION;&#10;    PRAGMA EXCEPTION_INIT (ex_mutating_table, -4091);&#10;    l_err_msg VARCHAR2(4000);&#10;    --&#10;    l_key VARCHAR2(100);&#10;    --&#10;BEGIN&#10;    l_current_disposal :&#61; funcGetOffenderCurrentDisposal(p_offender_id);&#10;    --&#10;    UPDATE offender SET&#10;      current_disposal &#61; l_current_disposal,&#10;      last_updated_datetime &#61; SYSDATE,&#10;      last_updated_user_id &#61; PKG_LOOKUPS.GetUserID(SYS_CONTEXT(&#39;USERENV&#39;, &#39;CLIENT_IDENTIFIER&#39;))&#10;    WHERE offender_id &#61; p_offender_id&#10;      AND NVL(current_disposal, 0) &lt;&gt; l_current_disposal;&#10;    --&#10;    IF SQL%ROWCOUNT &lt;&gt; 0 THEN&#10;        procDebug(l_proc || &#39;(offender_id&#61;&#39; || p_offender_id || &#39;)(trg&#61;&#39; || p_trigger_name || &#39;): set OFFENDER.current_disposal to &#39; || l_current_disposal);&#10;    END IF;&#10;    --&#10;EXCEPTION&#10;    WHEN ex_mutating_table THEN&#10;        procDebug(l_proc || &#39;(offender_id&#61;&#39; || p_offender_id || &#39;)(trg&#61;&#39; || p_trigger_name || &#39;): Adding to the deferred CURRENT_DISPOSAL Updates Queue&#39;);&#10;        procAddCurrDispDeferred(p_offender_id);&#10;    WHEN OTHERS THEN&#10;        l_err_msg :&#61; &#39;ERROR in &#39; || l_proc || &#39;[&#39; || p_offender_id || &#39;]:&#39; || CHR(10) || SQLERRM;&#10;        procDebug(l_err_msg);&#10;        raise_application_error(-20001, l_err_msg);&#10;END procSetOffenderCurrDisposal;&#10;--&#10;--&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--    OFFENDER.current_tier maintenance subroutines&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--&#10;FUNCTION funcGetCurrTierDeferredUpdCNT RETURN NUMBER IS&#10;BEGIN&#10;    RETURN NVL(g_tab_deferred_upd_CURRENT_T.COUNT, 0);&#10;END funcGetCurrTierDeferredUpdCNT;&#10;&#10;PROCEDURE procAddCurrTierDeferred(p_offender_id NUMBER, p_trigger_name VARCHAR2 DEFAULT NULL)&#10;IS&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;procAddCurrTierDeferred&#39;;&#10;    --&#10;    l_key VARCHAR2(100);&#10;BEGIN&#10;    --&#10;    IF p_offender_id IS NULL THEN&#10;        raise_application_error(-20001, &#39;FATAL ERROR in PKG_TriggerSupport.procAddCurrTierDeferred: P_OFFENDER_ID parameter cannot be NULL&#39;);&#10;    END IF;&#10;    --&#10;    l_key :&#61; TO_CHAR(p_offender_id);&#10;    IF NOT g_tab_deferred_upd_CURRENT_T.EXISTS(l_key) THEN&#10;        procDebug(l_proc || &#39;[&#39; || p_trigger_name || &#39;]: add new offender_id&#61;&#39; || p_offender_id);&#10;        g_tab_deferred_upd_CURRENT_T(l_key) :&#61; &#39;Y&#39;;&#10;    END IF;&#10;    --&#10;END procAddCurrTierDeferred;&#10;&#10;PROCEDURE procUpdateOffCurrTier_DEFERRED(p_trigger_name VARCHAR2 DEFAULT NULL)&#10;IS&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;procUpdateOffCurrTier_DEFERRED&#39;;&#10;    --&#10;    l_key         VARCHAR2(100);&#10;    l_offender_id NUMBER;&#10;BEGIN&#10;    IF g_tab_deferred_upd_CURRENT_T.COUNT &gt; 0 THEN&#10;        l_key :&#61; g_tab_deferred_upd_CURRENT_T.FIRST;&#10;        LOOP&#10;            EXIT WHEN empty2null(l_key) IS NULL;&#10;            --&#10;            procDebug(l_proc || &#39;: processing the [&#39; || l_key || &#39;] queue element&#39;);&#10;            --&#10;            BEGIN&#10;                l_offender_id :&#61; TO_NUMBER(l_key);&#10;            EXCEPTION WHEN OTHERS THEN&#10;                l_offender_id :&#61; -1;&#10;            END;&#10;            --&#10;            IF l_offender_id &lt;&#61; 0  THEN&#10;                raise_application_error(-20001, &#39;ERROR in &#39; || l_proc || &#39; [&#39; || l_key || &#39;]: invalid deferred queue element detected&#39;);&#10;            END IF;&#10;            --&#10;            UPDATE offender O SET&#10;              O.current_tier &#61; PKG_Lookups.funcgetTabRecord(&#10;                                   p_table      &#61;&gt; &#39;MANAGEMENT_TIER&#39;,&#10;                                   p_ref_col    &#61;&gt; &#39;offender_id&#39;,&#10;                                   p_ref_val    &#61;&gt; l_offender_id,&#10;                                   p_data_fld   &#61;&gt; &#39;tier_id&#39;,&#10;                                   p_where      &#61;&gt; &#39;soft_deleted &#61; 0&#39;,&#10;                                   p_order_by   &#61;&gt; &#39;date_changed DESC, tier_id DESC&#39;)&#10;--                                ( SELECT MT.tier_id&#10;--                                 FROM management_tier MT&#10;--                                 WHERE MT.offender_id &#61; O.offender_id&#10;--                                   AND MT.date_changed &#61; ( SELECT MAX(date_changed)&#10;--                                                           FROM management_tier MT2&#10;--                                                           WHERE MT2.offender_id &#61; MT.offender_id )&#10;--                                   AND ROWNUM &lt;&#61; 1 )&#10;            WHERE offender_id &#61; l_offender_id;&#10;            --&#10;            l_key :&#61; g_tab_deferred_upd_CURRENT_T.NEXT(l_key);&#10;        END LOOP;&#10;        --&#10;        g_tab_deferred_upd_CURRENT_T.DELETE;&#10;        --&#10;    END IF;&#10;END procUpdateOffCurrTier_DEFERRED;&#10;&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--    CAS Deferred Triggers&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--&#10;PROCEDURE do_CAS_Deferred_tab_delete(p_offender_id NUMBER) IS&#10;BEGIN&#10;    --&#10;    IF g_tab_deferred_upd_CAS.EXISTS(TO_CHAR(p_offender_id)) THEN&#10;        g_tab_deferred_upd_CAS.DELETE(TO_CHAR(p_offender_id));&#10;    END IF;&#10;    --&#10;END do_CAS_Deferred_tab_delete;&#10;--&#10;FUNCTION funcGetCASDeferredUpdCNT RETURN NUMBER IS&#10;BEGIN&#10;    RETURN NVL(g_tab_deferred_upd_CAS.COUNT, 0);&#10;END funcGetCASDeferredUpdCNT;&#10;--&#10;FUNCTION get_CAS_deferred_TAB(p_offender_id NUMBER DEFAULT NULL) RETURN t_tab_CAS_deferred_TYP PIPELINED&#10;IS&#10;    --&#10;    l_key VARCHAR2(255);&#10;    l_rec t_rec_CAS_deferred_TYP;&#10;    --&#10;    PROCEDURE do_parse_key(p_key VARCHAR2) IS&#10;    BEGIN&#10;        BEGIN&#10;            l_rec.offender_id :&#61; TO_NUMBER(PKG_LstUtl.list_num_elem(p_key, &#39;|&#39;, 1));&#10;        EXCEPTION WHEN OTHERS THEN&#10;            l_rec.offender_id :&#61; -1;&#10;        END;&#10;        BEGIN&#10;            l_rec.event_id :&#61; TO_NUMBER(PKG_LstUtl.list_num_elem(p_key, &#39;|&#39;, 2));&#10;        EXCEPTION WHEN OTHERS THEN&#10;            l_rec.event_id :&#61; -1;&#10;        END;&#10;        BEGIN&#10;            l_rec.transfer_id :&#61; TO_NUMBER(PKG_LstUtl.list_num_elem(p_key, &#39;|&#39;, 3));&#10;        EXCEPTION WHEN OTHERS THEN&#10;            l_rec.transfer_id :&#61; -1;&#10;        END;&#10;        BEGIN&#10;            l_rec.transfer_type :&#61; PKG_LstUtl.list_num_elem(p_key, &#39;|&#39;, 4);&#10;        EXCEPTION WHEN OTHERS THEN&#10;            l_rec.transfer_type :&#61; NULL;&#10;        END;&#10;        --&#10;    END do_parse_key;&#10;    --&#10;BEGIN&#10;    --&#10;    l_key :&#61; g_tab_deferred_upd_CAS.FIRST;&#10;    LOOP&#10;        EXIT WHEN empty2null(l_key) IS NULL;&#10;        --&#10;        do_parse_key(l_key);&#10;        --&#10;        PIPE ROW (l_rec);&#10;        --&#10;        l_key :&#61; g_tab_deferred_upd_CAS.NEXT(l_key);&#10;        --&#10;    END LOOP;&#10;    --&#10;END get_CAS_deferred_TAB;&#10;--&#10;PROCEDURE procAddCASDeferred(&#10;    p_offender_id   NUMBER,&#10;    p_event_id      NUMBER DEFAULT NULL,&#10;    p_transfer_id   NUMBER DEFAULT NULL,&#10;    p_transfer_type VARCHAR2 DEFAULT NULL,&#10;    p_trigger_name  VARCHAR2 DEFAULT NULL )&#10;IS&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;procAddCASDeferred&#39;;&#10;    --&#10;    l_key VARCHAR2(100);&#10;    --&#10;BEGIN&#10;    --&#10;    IF p_offender_id IS NULL THEN&#10;        raise_application_error(-20001, &#39;FATAL ERROR in PKG_TriggerSupport.&#39; || l_proc || &#39;: P_OFFENDER_ID parameter cannot be NULL&#39;);&#10;    END IF;&#10;    --&#10;    IF p_transfer_id &gt; 0 THEN&#10;        l_key :&#61;&#10;            TO_CHAR(p_offender_id) || &#39;|&#39; ||&#10;            TO_CHAR(p_event_id)    || &#39;|&#39; ||&#10;            TO_CHAR(p_transfer_id) || &#39;|&#39; ||&#10;            p_transfer_type;&#10;    ELSE&#10;        l_key :&#61; PKG_LstUtl.concat(TO_CHAR(p_offender_id), TO_CHAR(p_event_id), p_delim&#61;&gt;&#39;|&#39;);&#10;    END IF;&#10;    --&#10;    IF NOT g_tab_deferred_upd_CAS.EXISTS(l_key) THEN&#10;        procDebug(l_proc || &#39;[&#39; || p_trigger_name || &#39;]: add new offender_id&#61;&#39; || p_offender_id);&#10;        g_tab_deferred_upd_CAS(l_key) :&#61; &#39;Y&#39;;&#10;    END IF;&#10;    --&#10;END procAddCASDeferred;&#10;--&#10;PROCEDURE procUpdateCAS_DEFERRED(p_trigger_name VARCHAR2 DEFAULT NULL)&#10;IS&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;procUpdateCAS_DEFERRED&#39;;&#10;    --&#10;    l_OM_deferred_flag BOOLEAN :&#61; FALSE;&#10;    --&#10;    l_debug_flag BOOLEAN;&#10;    --&#10;    CURSOR csCAS IS&#10;      SELECT *&#10;      FROM TABLE( PKG_TriggerSupport.get_CAS_deferred_TAB );&#10;    --&#10;    l_tab_cas t_tab_CAS_deferred_TYP;&#10;    l_rec_cas t_rec_CAS_deferred_TYP;&#10;    --&#10;    l_rec t_rec_CAS_deferred_TYP;&#10;    l_tab t_tab_CAS_deferred_TYP :&#61; t_tab_CAS_deferred_TYP();&#10;    --&#10;    PROCEDURE do_init IS&#10;    BEGIN&#10;        --&#10;        l_debug_flag :&#61; (PKG_Lookups.funcgetNDParameterValue(&#39;CAS_DEBUG_FLAG&#39;, &#39;0&#39;) &#61; &#39;1&#39;);&#10;        --&#10;    END do_init;&#10;    --&#10;    PROCEDURE do_debug(p_msg VARCHAR2, p_label VARCHAR2 DEFAULT NULL) IS&#10;    BEGIN&#10;        IF l_debug_flag THEN&#10;            warn( p_msg, l_proc, p_label );&#10;        END IF;&#10;        procDebug(l_proc || &#39;: &#39; || p_msg);&#10;    END do_debug;&#10;    --&#10;    PROCEDURE do_check_OM&#10;    IS&#10;        --&#10;        CURSOR csOT IS&#10;          SELECT PKG_Lookups.funcgetTeamProvider(0, receiving_team_id) AS probation_area_id&#10;          FROM offender_transfer&#10;          WHERE offender_transfer_id &#61; l_rec_cas.transfer_id;&#10;        --&#10;        l_OT_probation_area_id NUMBER;&#10;        --&#10;        CURSOR csOM IS&#10;          SELECT probation_area_id&#10;          FROM offender_manager&#10;          WHERE offender_id &#61; l_rec_cas.offender_id&#10;            AND active_flag &#61; 1;&#10;        --&#10;        l_OM_probation_area_id NUMBER;&#10;        --&#10;    BEGIN&#10;        --&#10;        IF l_rec_cas.transfer_id IS NOT NULL THEN&#10;            OPEN csOT;&#10;            FETCH csOT INTO l_OT_probation_area_id;&#10;            IF csOT%NOTFOUND THEN&#10;                l_OT_probation_area_id :&#61; -1;&#10;            END IF;&#10;            CLOSE csOT;&#10;        ELSE&#10;            l_OT_probation_area_id :&#61; -1;&#10;        END IF;&#10;        --&#10;        OPEN csOM;&#10;        FETCH csOM INTO l_OM_probation_area_id;&#10;        IF csOM%NOTFOUND THEN&#10;            l_OM_probation_area_id :&#61; -1;&#10;        END IF;&#10;        CLOSE csOM;&#10;        --&#10;        IF l_OT_probation_area_id &gt; 0 AND l_OM_probation_area_id &lt;&gt; l_OT_probation_area_id THEN&#10;            --&#10;            do_debug( &#39;INFO: OM_probation_area_id &lt;&gt; OT_probation_area_id condition&#39; );&#10;            --&#10;            l_OM_deferred_flag :&#61; TRUE;&#10;            --&#10;        ELSIF l_OM_probation_area_id &#61; -1 AND p_trigger_name IN (&#39;T_CAS_OFFENDER_MANAGER_AS&#39;, &#39;T_CAS_OFFENDER_AS&#39;) THEN&#10;            --&#10;            do_debug( &#39;INFO: Active OM not found&#39; );&#10;            --&#10;            l_OM_deferred_flag :&#61; TRUE;&#10;            --&#10;        END IF;&#10;        --&#10;    END do_check_OM;&#10;    --&#10;    PROCEDURE do_add_deferred IS&#10;    BEGIN&#10;        l_rec.offender_id   :&#61; l_rec_cas.offender_id;&#10;        l_rec.event_id      :&#61; l_rec_cas.event_id;&#10;        l_rec.transfer_id   :&#61; NULL;&#10;        l_rec.transfer_type :&#61; NULL;&#10;        --&#10;        l_tab.EXTEND;&#10;        l_tab(l_tab.COUNT) :&#61; l_rec;&#10;    END do_add_deferred;&#10;    --&#10;BEGIN&#10;    --&#10;    IF g_VPD_rebuilding_flag THEN&#10;        -- Postpone CAS recalculation until VPD rebuild is completed&#10;        RETURN;&#10;        --&#10;    END IF;&#10;    --&#10;    do_init;&#10;    --&#10;    OPEN csCAS;&#10;    FETCH csCAS BULK COLLECT INTO l_tab_cas;&#10;    CLOSE csCAS;&#10;    --&#10;    do_debug(&#39;start processing the [qty&#61;&#39; || l_tab_cas.COUNT || &#39;][trg&#61;&#39; || p_trigger_name || &#39;] CAS queue&#39; );&#10;    --&#10;    FOR l_i IN 1..l_tab_cas.COUNT LOOP&#10;        --&#10;        l_rec_cas :&#61; l_tab_cas(l_i);&#10;        --&#10;        do_debug(&#39;processing the &#39; ||&#10;            &#39;[offender_id&#61;&#39;   || l_rec_cas.offender_id   || &#39;]&#39; ||&#10;            &#39;[event_id&#61;&#39;      || l_rec_cas.event_id      || &#39;]&#39; ||&#10;            &#39;[transfer_id&#61;&#39;   || l_rec_cas.transfer_id   || &#39;]&#39; ||&#10;            &#39;[transfer_type&#61;&#39; || l_rec_cas.transfer_type || &#39;]&#39; ||&#10;            &#39; queue element&#39; );&#10;        --&#10;        IF l_rec_cas.offender_id &lt;&#61; 0 OR l_rec_cas.event_id &lt;&#61; 0  THEN&#10;            raise_application_error(-20001,&#10;                &#39;ERROR in &#39; || l_proc || &#39; &#39; ||&#10;                &#39;[offender_id&#61;&#39;   || l_rec_cas.offender_id   || &#39;]&#39; ||&#10;                &#39;[event_id&#61;&#39;      || l_rec_cas.event_id      || &#39;]&#39; ||&#10;                &#39;[transfer_id&#61;&#39;   || l_rec_cas.transfer_id   || &#39;]&#39; ||&#10;                &#39;[transfer_type&#61;&#39; || l_rec_cas.transfer_type || &#39;]&#39; ||&#10;                &#39;: invalid deferred queue element detected&#39; );&#10;        END IF;&#10;        --&#10;        l_OM_deferred_flag :&#61; FALSE;&#10;        --&#10;        IF ( l_rec_cas.transfer_id &gt; 0 AND l_rec_cas.transfer_type &#61; &#39;OT&#39; ) OR&#10;           ( p_trigger_name IN (&#39;T_CAS_OFFENDER_MANAGER_AS&#39;, &#39;T_CAS_OFFENDER_AS&#39;) )&#10;        THEN&#10;            -- Check if a correct Active OM hasn&#39;t been added by ND app yet&#10;            do_check_OM;&#10;            --&#10;            IF l_OM_deferred_flag THEN&#10;                -- DST-12499: re-enqueue the CAS waiting list element&#10;                do_debug(&#10;                    &#39;re-enroll the [&#39; ||&#10;                    PKG_LstUtl.concat(TO_CHAR(l_rec_cas.offender_id), TO_CHAR(l_rec_cas.event_id), p_delim&#61;&gt;&#39;|&#39;) ||&#10;                    &#39;] queue element&#39; );&#10;                --&#10;                do_add_deferred;&#10;                --&#10;            END IF;&#10;            --&#10;        END IF;&#10;        --&#10;        IF NOT l_OM_deferred_flag THEN&#10;            PKG_TriggerSupport.procCalculateCAS(p_offender_id&#61;&gt;l_rec_cas.offender_id, p_event_id&#61;&gt;l_rec_cas.event_id);&#10;        END IF;&#10;        --&#10;    END LOOP;&#10;    --&#10;    g_tab_deferred_upd_CAS.DELETE;&#10;    --&#10;    FOR l_i IN 1..l_tab.COUNT LOOP&#10;        --&#10;        l_rec :&#61; l_tab(l_i);&#10;        --&#10;        PKG_TriggerSupport.procAddCASDeferred(l_rec.offender_id, l_rec.event_id);&#10;        --&#10;    END LOOP;&#10;    --&#10;--EXCEPTION WHEN OTHERS THEN&#10;--    --&#10;--    IF l_key IS NOT NULL THEN&#10;--        IF g_tab_deferred_upd_CAS.EXISTS(l_key) THEN&#10;--            g_tab_deferred_upd_CAS.DELETE(l_key);&#10;--        END IF;&#10;--    END IF;&#10;--    --&#10;--    RAISE;&#10;END procUpdateCAS_DEFERRED;&#10;&#10;--&#10;-- Drug Test Profile Context support procedure&#10;--&#10;PROCEDURE procUpdateDrugTestProfileCtx(&#10;    p_offender_id  NUMBER,&#10;    p_ctx_code     VARCHAR2,&#10;    p_table        VARCHAR2 DEFAULT NULL,&#10;    p_cr_user_id   NUMBER   DEFAULT NULL,&#10;    p_cr_datetime  DATE     DEFAULT NULL,&#10;    p_upd_user_id  NUMBER   DEFAULT NULL,&#10;    p_upd_datetime DATE     DEFAULT NULL )&#10;IS&#10;    --&#10;    l_offender_drug_profile_id NUMBER;&#10;    l_context_id               NUMBER;&#10;    --&#10;    l_team_id  NUMBER;&#10;    l_staff_id NUMBER;&#10;    --&#10;BEGIN&#10;    --&#10;    IF PKG_MERGE_OFFENDER.get_merge_running_flag &#61; &#39;Y&#39; THEN&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    SELECT MAX(offender_drug_profile_id) INTO l_offender_drug_profile_id&#10;    FROM offender_drug_profile&#10;    WHERE offender_id &#61; p_offender_id&#10;      AND soft_deleted &#61; 0;&#10;    --&#10;    l_context_id :&#61; PKG_Lookups.funcgetStdRefListID(&#39;DRUG TEST CONTEXT&#39;, p_ctx_code);&#10;    IF l_context_id IS NULL THEN&#10;        raise_application_error(-20001, &#39;ERROR in PKG_TriggerSupport.procUpdateDrugTestProfileCtx: invalid DRUG TEST CONTEXT stdref code value [&#39; || p_ctx_code || &#39;]&#39;);&#10;    END IF;&#10;    --&#10;    IF NVL(l_offender_drug_profile_id, 0) &#61; 0 THEN&#10;        --&#10;        l_offender_drug_profile_id :&#61; offender_drug_profile_id_SEQ.nextval;&#10;        --&#10;        SELECT team_id, allocation_staff_id&#10;        INTO l_team_id, l_staff_id&#10;        FROM offender_manager&#10;        WHERE offender_id &#61; p_offender_id&#10;          AND active_flag &#61; 1&#10;          AND soft_deleted &#61; 0;&#10;        --&#10;        INSERT INTO offender_drug_profile(&#10;          offender_drug_profile_id,&#10;          offender_id,&#10;          --&#10;          context_id,&#10;          --&#10;          assessment_date,&#10;          team_id,&#10;          staff_id,&#10;          --&#10;          created_by_user_id,&#10;          created_datetime,&#10;          last_updated_user_id,&#10;          last_updated_datetime,&#10;          --&#10;          soft_deleted,&#10;          row_version&#10;        ) VALUES (&#10;          l_offender_drug_profile_id,&#10;          p_offender_id,&#10;          --&#10;          l_context_id,&#10;          --&#10;          TRUNC(SYSDATE),&#10;          l_team_id,&#10;          l_staff_id,&#10;          --&#10;          NVL(p_cr_user_id, PKG_Lookups.GetUserID(SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_USER&#39;))),&#10;          NVL(p_cr_datetime, SYSDATE),&#10;          NVL(p_upd_user_id, PKG_Lookups.GetUserID(SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_USER&#39;))),&#10;          NVL(p_upd_datetime, SYSDATE),&#10;          --&#10;          0,&#10;          0 );&#10;        --&#10;    ELSE&#10;        --&#10;        UPDATE offender_drug_profile SET&#10;          context_id &#61; l_context_id,&#10;          --assessment_date,&#10;          --team_id,&#10;          --staff_id,&#10;          --&#10;          last_updated_user_id  &#61; NVL(p_upd_user_id, PKG_Lookups.GetUserID(SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_USER&#39;))),&#10;          last_updated_datetime &#61; NVL(p_upd_datetime, SYSDATE),&#10;          --&#10;          row_version &#61; row_version + 1&#10;        WHERE offender_drug_profile_id &#61; l_offender_drug_profile_id;&#10;        --&#10;    END IF;&#10;    /*&#10;    DST-18833&#10;&#10;    New RQMNT (end date IS NULL And rqmnt_type &#61; Drug Rehabilitation &#39;G&#39;)&#10;&#10;    THEN add/update DRUG_PROFILE:&#10;     - Profile Current Context to: Drug Rehabilitation Requirement (DRR) (Code: DR)&#10;     - Updated By: same User/Time from the Requirement&#10;     (for new record):&#10;     - Created by: same User/Time from the Requirement&#10;     - TEAM_ID and STAFF_ID to match the current offender manager&#10;     - OFFENDER_ID to link the profile to the correct offender.&#10;     - ASSESSMENT_DATE with the current system date (SYSDATE).&#10;&#10;&#10;    DST-18836&#10;&#10;    New LC (end date IS NULL And lc_type &#61; Drug Testing Condition (&#39;NLC12&#39;)&#10;&#10;    THEN add/update DRUG_PROFILE:&#10;     - Profile Current Context to:  Licence Condition (Code: LC)&#10;     - Updated By: same User/Time from the LC&#10;     (for new record):&#10;     - Created by: same User/Time from the Requirement&#10;     - TEAM_ID and STAFF_ID to match the current offender manager&#10;     - OFFENDER_ID to link the profile to the correct offender.&#10;     - ASSESSMENT_DATE with the current system date (SYSDATE).&#10;&#10;&#10;    DST-18837&#10;&#10;    New NSI (end date IS NULL And nsi_type &#61; Intensive Supervision Team Pilot (&#39;PSC&#39;)&#10;&#10;    THEN add/update DRUG_PROFILE:&#10;     - Profile Current Context to:  ISC Standalone Drug Testing (Code: IS)&#10;     - Updated By: same User/Time from the NSI&#10;     (for new record):&#10;     - Created by: same User/Time from the Requirement&#10;     - TEAM_ID and STAFF_ID to match the current offender manager&#10;     - OFFENDER_ID to link the profile to the correct offender.&#10;     - ASSESSMENT_DATE with the current system date (SYSDATE).&#10;&#10;&#10;    DST-18865&#10;&#10;    New NSI (end date IS NULL And nsi_type &#61; Intensive Supervision Team Pilot (&#39;APR01&#39;)&#10;&#10;    THEN add/update DRUG_PROFILE:&#10;     - Profile Current Context to:  Approved Premises - Urine Test (Code: APU)&#10;     - Updated By: same User/Time from the NSI&#10;     (for new record):&#10;     - Created by: same User/Time from the Requirement&#10;     - TEAM_ID and STAFF_ID to match the current offender manager&#10;     - OFFENDER_ID to link the profile to the correct offender.&#10;     - ASSESSMENT_DATE with the current system date (SYSDATE).&#10;&#10;&#10;    DST-18866&#10;&#10;    Existing NSI (end date IS NULL And nsi_type &#61; Intensive Supervision Team Pilot (&#39;APR01&#39;) IS updated with END_DATE (not null)&#10;&#10;    THEN add/update DRUG_PROFILE:&#10;     - Profile Current Context to:  Licence Condition (Code: LC)&#10;     - Updated By: same User/Time from the NSI&#10;     (for new record):&#10;     - Created by: same User/Time from the Requirement&#10;     - TEAM_ID and STAFF_ID to match the current offender manager&#10;     - OFFENDER_ID to link the profile to the correct offender.&#10;     - ASSESSMENT_DATE with the current system date (SYSDATE).&#10;&#10;&#10;    */&#10;END procUpdateDrugTestProfileCtx;&#10;&#10;--&#10;--&#10;--&#10;FUNCTION get_active_flag(p_end_date DATE, p_soft_deleted NUMBER DEFAULT 0) RETURN SMALLINT IS&#10;BEGIN&#10;    IF p_end_date IS NULL /* KF - Removed as causes constraint/design issues. AND NVL(p_soft_deleted, 0) &#61; 0 */ THEN&#10;        RETURN 1;&#10;    ELSE&#10;        RETURN 0;&#10;    END IF;&#10;END get_active_flag;&#10;&#10;FUNCTION get_active_flag_for_manager(p_end_date DATE) RETURN SMALLINT IS&#10;BEGIN&#10;    IF p_end_date IS NULL THEN&#10;        RETURN 1;&#10;    ELSE&#10;        RETURN 0;&#10;    END IF;&#10;END get_active_flag_for_manager;&#10;&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--    CLOB Prefixing subroutines&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;FUNCTION funcGetPrefixedClobDelta(&#10;    p_clob_old        CLOB,&#10;    p_clob_new        CLOB,&#10;    p_check_value     VARCHAR2 DEFAULT NULL,&#10;    p_check_null_flag VARCHAR2 DEFAULT NULL )&#10;RETURN CLOB IS&#10;    --&#10;    l_sysdate DATE :&#61; SYSDATE;&#10;    --&#10;    l_distinguished_name USER_.distinguished_name%TYPE;&#10;    --&#10;    l_pos             INTEGER;&#10;    l_prepend_flag    VARCHAR2(1);&#10;    l_clob_delta      CLOB;&#10;    l_clob_prev       CLOB;&#10;    --&#10;    l_add_prefix_flag BOOLEAN;&#10;    l_prefix          CLOB;&#10;    l_postfix         CLOB;&#10;    l_ret             CLOB;&#10;    --&#10;    CURSOR cs IS&#10;      SELECT&#10;        user_id,&#10;        forename,&#10;        forename2,&#10;        surname,&#10;        distinguished_name,&#10;        CASE WHEN system_user&#61;1 THEN&#10;        PKG_Common.nvl2(&#10;            PKG_LstUtl.concat(&#10;                TRIM(forename ),&#10;                TRIM(forename2),&#10;                TRIM(surname),&#10;                p_delim&#61;&gt;&#39; &#39; ),&#10;            distinguished_name&#10;        ) ELSE&#10;        PKG_Common.nvl2(&#10;            PKG_LstUtl.concat(&#10;                UPPER(SUBSTR(TRIM(forename ), 1, 1)),&#10;                UPPER(SUBSTR(TRIM(forename2), 1, 1)),&#10;                TRIM(surname),&#10;                p_delim&#61;&gt;&#39; &#39; ),&#10;            distinguished_name&#10;        ) END AS user_details&#10;      FROM user_&#10;      WHERE UPPER(distinguished_name) &#61; UPPER(l_distinguished_name);&#10;    --&#10;    l_rec cs%ROWTYPE;&#10;    --&#10;    PROCEDURE do_debug(p_msg CLOB) IS&#10;    BEGIN&#10;        procDebug(&#39;funcGetPrefixedClobDelta: &#39; || p_msg);&#10;    END do_debug;&#10;    --&#10;    FUNCTION empty2null_1(p_str CLOB) RETURN CLOB IS&#10;    BEGIN&#10;        RETURN&#10;            TRIM(REPLACE(&#10;                PKG_Common.empty2null(&#10;                    p_clob                 &#61;&gt; p_str,&#10;                    p_remove_line_ret_flag &#61;&gt; &#39;Y&#39;,&#10;                    p_replace_CR_with      &#61;&gt; PKG_Global.GC_SPG_CR,&#10;                    p_printable_only_flag  &#61;&gt; &#39;Y&#39;,&#10;                    p_clean_notes_flag     &#61;&gt; &#39;Y&#39; ),&#10;              PKG_Global.GC_SPG_CR, CHR(10) ));&#10;    END empty2null_1;&#10;    --&#10;BEGIN&#10;    --&#10;    l_add_prefix_flag :&#61; TRUE;&#10;    --&#10;    IF p_check_null_flag IN (&#39;IS NULL&#39;, &#39;IS NOT NULL&#39;) THEN&#10;        --&#10;        IF p_check_null_flag &#61; &#39;IS NULL&#39; THEN&#10;            l_add_prefix_flag :&#61; ( p_check_value IS NULL );&#10;        ELSIF p_check_null_flag &#61; &#39;IS NOT NULL&#39; THEN&#10;            l_add_prefix_flag :&#61; ( p_check_value IS NOT NULL );&#10;        END IF;&#10;        --&#10;    END IF;&#10;    --&#10;    IF l_add_prefix_flag THEN&#10;        --&#10;        l_distinguished_name :&#61; NVL(SYS_CONTEXT(&#39;USERENV&#39;, &#39;CLIENT_IDENTIFIER&#39;), &#39;DELIUS_SYSTEM_USER&#39;);&#10;        --&#10;        OPEN cs;&#10;        FETCH cs INTO l_rec;&#10;        CLOSE cs;&#10;        --&#10;        do_debug(&#39;Current User: &#39; || l_rec.user_details);&#10;        --&#10;        IF l_rec.user_id &gt; 0 THEN&#10;            --&#10;            IF empty2null_1(p_clob_new) IS NOT NULL THEN&#10;                --&#10;                IF empty2null_1(p_clob_old) IS NULL THEN&#10;                    --&#10;                    l_prepend_flag :&#61; &#39;N&#39;;&#10;                    l_clob_prev    :&#61; NULL;&#10;                    l_clob_delta   :&#61; p_clob_new;&#10;                    --&#10;                ELSE&#10;                    --&#10;                    l_pos :&#61; INSTR(p_clob_new, SUBSTR(p_clob_old, 1, 30000));&#10;                    --&#10;                    IF l_pos &#61; 1 THEN&#10;                        l_prepend_flag :&#61; &#39;N&#39;;&#10;                    ELSIF l_pos &gt; 1 THEN&#10;                        l_prepend_flag :&#61; &#39;Y&#39;;&#10;                    ELSE&#10;                        l_prepend_flag :&#61; NULL;&#10;                    END IF;&#10;                    --&#10;                    IF l_prepend_flag &#61; &#39;Y&#39; THEN&#10;                        l_clob_prev  :&#61; SUBSTR(p_clob_new, l_pos /*, LENGTH(p_clob_old)*/);&#10;                        l_clob_delta :&#61; SUBSTR(p_clob_new, 1, LENGTH(p_clob_new)-LENGTH(p_clob_old));&#10;                    ELSIF l_prepend_flag &#61; &#39;N&#39; THEN&#10;                        l_clob_prev  :&#61; SUBSTR(p_clob_new, 1, LENGTH(p_clob_old));&#10;                        l_clob_delta :&#61; SUBSTR(p_clob_new, LENGTH(p_clob_old)+1);&#10;                    END IF;&#10;                    --&#10;                    l_clob_delta :&#61; empty2null_1(l_clob_delta);&#10;                    --&#10;                    --l_clob_prev  :&#61; SUBSTR(p_clob_new, 1, LENGTH(p_clob_old));&#10;                    --l_clob_delta :&#61; empty2null_1( SUBSTR(p_clob_new, LENGTH(p_clob_old)+1) );&#10;                    --&#10;                END IF;&#10;                --&#10;--                do_debug(&#10;--                    &#39;CLOB Prepend Flag: &#39; || l_prepend_flag || CHR(10) ||&#10;--                    &#39;CLOB Delta: &#39;        || l_clob_delta );&#10;                --&#10;                IF l_clob_delta   IS NULL OR&#10;                   l_prepend_flag IS NULL OR&#10;                   NOT ( l_clob_prev &#61; p_clob_old OR p_clob_old IS NULL )&#10;                THEN&#10;                    l_ret :&#61; p_clob_new;&#10;                ELSE&#10;                    --&#10;                    l_prefix :&#61;&#10;                        PKG_LstUtl.concat_CLOB(&#10;                            &#39;Comment added by&#39;,&#10;                            l_rec.user_details,&#10;                            &#39;on&#39;,&#10;                            TO_CHAR(l_sysdate, &#39;DD/MM/YYYY&#39;),&#10;                            &#39;at&#39;,&#10;                            TO_CHAR(l_sysdate, &#39;HH24:MI&#39;),&#10;                            --&#10;                            p_delim&#61;&gt;&#39; &#39; );&#10;                    --&#10;                    l_postfix :&#61; CASE WHEN empty2null_1(p_clob_old) IS NOT NULL THEN &#39;---------------------------------------------------------&#39; END;&#10;                    --&#10;                    IF l_prepend_flag &#61; &#39;Y&#39; THEN&#10;                        l_ret :&#61;&#10;                            PKG_LstUtl.concat_CLOB(&#10;                                --&#10;                                l_prefix,&#10;                                l_clob_delta,&#10;                                --&#10;                                l_postfix,&#10;                                p_clob_old,&#10;                                --&#10;                                p_delim&#61;&gt;CHR(10) );&#10;                    ELSE&#10;                        l_ret :&#61;&#10;                            PKG_LstUtl.concat_CLOB(&#10;                                --&#10;                                p_clob_old,&#10;                                l_postfix,&#10;                                --&#10;                                l_prefix,&#10;                                l_clob_delta,&#10;                                --&#10;                                p_delim&#61;&gt;CHR(10) );&#10;                    END IF;&#10;                    --&#10;                END IF;&#10;                --&#10;            END IF; --empty2null_1(p_clob_new) IS NOT NULL THEN&#10;            --&#10;        ELSE&#10;            --&#10;            l_ret :&#61; p_clob_new;&#10;            fatal(&#39;Error occured while trying to set ND User Context for [&#39; || l_distinguished_name || &#39;]&#39;, &#39;PKG_TriggerSupport.funcGetPrefixedClobDelta&#39;);&#10;            --&#10;        END IF; --IF l_rec.user_id &gt; 1 THEN&#10;        --&#10;    ELSE&#10;        --&#10;        l_ret :&#61; p_clob_new;&#10;        --&#10;    END IF; --IF l_add_prefix_flag THEN&#10;    --&#10;    RETURN l_ret;&#10;    --&#10;END funcGetPrefixedClobDelta;&#10;--&#10;--&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--    CAS Calculation subroutines (wrappers for the PKG_CAS_SUPPORT subroutines)&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--&#10;PROCEDURE procCalculateCAS(&#10;    p_offender_id           NUMBER,&#10;    p_event_id              NUMBER DEFAULT NULL,&#10;    p_nd_user_flag          VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_automated_flag        VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_create_CAS_staff_team VARCHAR2 DEFAULT NULL,&#10;    p_api_flag              VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_rsr_score             NUMBER   DEFAULT NULL,&#10;    p_rsr_level_id          NUMBER   DEFAULT NULL,&#10;    p_osp_level_i_id        NUMBER   DEFAULT NULL,&#10;    p_osp_level_c_id        NUMBER   DEFAULT NULL,&#10;    -- Two new parameters (new OSP levels from the SNS notification) added as per DST-16367&#10;    p_osp_level_iic_id      NUMBER DEFAULT NULL, /* OSPIndirectIndecentBand*/&#10;    p_osp_level_dc_id       NUMBER DEFAULT NULL  /* OSPDirectContactBand*/ )&#10;IS&#10;    --&#10;    l_SQL VARCHAR2(512);&#10;    --&#10;BEGIN&#10;    --&#10;    l_SQL :&#61;&#10;    --&#10;&#39;BEGIN&#10;    PKG_CAS_SUPPORT.procCalculateCAS(&#10;        :p_offender_id,&#10;        :p_event_id,&#10;        :p_nd_user_flag,&#10;        :p_automated_flag,&#10;        :p_create_CAS_staff_team,&#10;        :p_api_flag,&#10;        :p_rsr_score,&#10;        :p_rsr_level_id,&#10;        :p_osp_level_i_id,&#10;        :p_osp_level_c_id,&#10;        :p_osp_level_iic_id,&#10;        :p_osp_level_dc_id );&#10;END;&#39;;&#10;            --&#10;    EXECUTE IMMEDIATE l_SQL&#10;    USING&#10;      p_offender_id,&#10;      p_event_id,&#10;      p_nd_user_flag,&#10;      p_automated_flag,&#10;      p_create_CAS_staff_team,&#10;      p_api_flag,&#10;      p_rsr_score,&#10;      p_rsr_level_id,&#10;      p_osp_level_i_id,&#10;      p_osp_level_c_id,&#10;      p_osp_level_iic_id,&#10;      p_osp_level_dc_id;&#10;    --&#10;END procCalculateCAS;&#10;--&#10;PROCEDURE procUpdateCAS(&#10;    p_crn                VARCHAR2,&#10;    p_event_number       NUMBER,&#10;    --&#10;    p_rsr_assessor_date  DATE,&#10;    --&#10;    p_rsr_score          NUMBER,&#10;    p_rsr_level_code     VARCHAR2, /*RSR LEVEL*/&#10;    --&#10;    p_osp_score_i        NUMBER,&#10;    p_osp_score_c        NUMBER,&#10;    p_osp_level_i_code   VARCHAR2, /*OSP Level I*/&#10;    p_osp_level_c_code   VARCHAR2, /*OSP Level C*/&#10;    -- Two new parameters (new OSP levels from the SNS notification) added as per DST-16367&#10;    p_osp_level_iic_code VARCHAR2 DEFAULT NULL, /* OSPIndirectIndecentBand */&#10;    p_osp_level_dc_code  VARCHAR2 DEFAULT NULL, /* OSPDirectContactBand    */&#10;    -- DST-19293&#10;    p_rsr_static_flag    VARCHAR2 DEFAULT NULL, /* RSRStaticOrDynamic      */&#10;    p_rsr_band           VARCHAR2 DEFAULT NULL  /* RSRBand                 */ )&#10;IS&#10;    --&#10;    l_SQL VARCHAR2(1024);&#10;    --&#10;BEGIN&#10;    --&#10;    l_SQL :&#61;&#10;    --&#10;&#39;BEGIN&#10;    PKG_CAS_SUPPORT.procUpdateCAS(&#10;        p_crn                &#61;&gt; :p_crn,&#10;        p_event_number       &#61;&gt; :p_event_number,&#10;        --&#10;        p_rsr_assessor_date  &#61;&gt; :p_rsr_assessor_date,&#10;        --&#10;        p_rsr_score          &#61;&gt; :p_rsr_score,&#10;        p_rsr_level_code     &#61;&gt; :p_rsr_level_code,&#10;        --&#10;        p_osp_score_i        &#61;&gt; :p_osp_score_i,&#10;        p_osp_score_c        &#61;&gt; :p_osp_score_c,&#10;        p_osp_level_i_code   &#61;&gt; :p_osp_level_i_code,&#10;        p_osp_level_c_code   &#61;&gt; :p_osp_level_c_code,&#10;        --&#10;        p_osp_level_iic_code &#61;&gt; :p_osp_level_iic_code,&#10;        p_osp_level_dc_code  &#61;&gt; :p_osp_level_dc_code,&#10;        --&#10;        p_rsr_static_flag    &#61;&gt; :p_rsr_static_flag,&#10;        p_rsr_band           &#61;&gt; :p_rsr_band );&#10;END;&#39;;&#10;        --&#10;    EXECUTE IMMEDIATE l_SQL&#10;    USING&#10;      p_crn,&#10;      p_event_number,&#10;      --&#10;      p_rsr_assessor_date,&#10;      --&#10;      p_rsr_score,&#10;      p_rsr_level_code,&#10;      --&#10;      p_osp_score_i,&#10;      p_osp_score_c,&#10;      p_osp_level_i_code,&#10;      p_osp_level_c_code,&#10;      --&#10;      p_osp_level_iic_code,&#10;      p_osp_level_dc_code,&#10;      --&#10;      p_rsr_static_flag,&#10;      p_rsr_band;&#10;    --&#10;END procUpdateCAS;&#10;--&#10;--&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--    VPD &lt;table_name&gt;.ORGANISATIONS field maintenance subroutines&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--&#10;PROCEDURE procAddOffenderToRebuildList(p_offender_id NUMBER, p_new_probation_area_id NUMBER DEFAULT NULL, p_new_external_provider_id NUMBER DEFAULT NULL)&#10;IS&#10;BEGIN&#10;    -- Synchronous rebuild of the ORGANISATIONS fields&#10;    --IF NOT get_VPD_deferred_flag THEN&#10;        SELECT g_tab_offenders_list MULTISET UNION DISTINCT t_tab_ORGANISATIONS(TO_CHAR(p_offender_id))&#10;        INTO g_tab_offenders_list&#10;        FROM dual;&#10;    --END IF;&#10;    --&#10;END procAddOffenderToRebuildList;&#10;--&#10;PROCEDURE procUpdateProbationAreas(&#10;    p_offender_id         NUMBER,&#10;    p_table_name          VARCHAR2,&#10;    p_update_mode         NUMBER,&#10;    p_ORGANISATIONS_NEW t_tab_ORGANISATIONS,&#10;    p_ORGANISATIONS_OLD t_tab_ORGANISATIONS DEFAULT NULL)&#10;IS&#10;    l_proc CONSTANT VARCHAR2(50) :&#61; &#39;PKG_TriggerSupport.procUpdateProbationAreas&#39;;&#10;    --&#10;    l_SQL     VARCHAR2(1024);&#10;    l_rows    NUMBER;&#10;    l_err_msg VARCHAR2(4000);&#10;    --&#10;    l_key             VARCHAR2(100);&#10;    ex_mutating_table EXCEPTION;&#10;    PRAGMA EXCEPTION_INIT (ex_mutating_table, -4091);&#10;    --&#10;BEGIN&#10;    --&#10;    g_VPD_rebuilding_flag :&#61; TRUE;&#10;    --&#10;    l_SQL :&#61; &#39;UPDATE &#39; || p_table_name || &#39; SET&#39; || CHR(10);&#10;    IF p_update_mode &#61; gc_APPEND THEN&#10;        l_SQL :&#61; l_SQL || &#39;  -- Add new areas e.g. {1,2,3} (APPEND) {4,5} &#61; {1,2,3,4,5}&#10;            ORGANISATIONS &#61;&#10;              CAST( CAST(NVL(ORGANISATIONS, t_arr_ORGANISATIONS()) AS t_tab_ORGANISATIONS)&#10;                      MULTISET UNION DISTINCT NVL(:p_ORGANISATIONS_NEW, t_tab_ORGANISATIONS())&#10;                AS t_arr_ORGANISATIONS)&#39;;&#10;    ELSIF p_update_mode &#61; gc_ASSIGN THEN&#10;        l_SQL :&#61; l_SQL || &#39;  -- Replace the whole list with the new values {1,2,3,4,5} (ASSIGN) {8,9} &#61; {8,9}&#10;            ORGANISATIONS &#61; CAST( NVL(:p_ORGANISATIONS_NEW, t_tab_ORGANISATIONS()) AS t_arr_ORGANISATIONS)&#39;;&#10;    ELSIF p_update_mode &#61; gc_REMOVE THEN&#10;        l_SQL :&#61; l_SQL || &#39;  -- Remove exiting area e.g. {1,2,3,4,5} (REMOVE) {3,4} &#61; {1,2,5}&#10;            ORGANISATIONS &#61;&#10;              CAST( CAST(NVL(ORGANISATIONS, t_arr_ORGANISATIONS()) AS t_tab_ORGANISATIONS)&#10;                      MULTISET EXCEPT DISTINCT NVL(:p_ORGANISATIONS_NEW, t_tab_ORGANISATIONS())&#10;                AS t_arr_ORGANISATIONS)&#39;;&#10;    ELSIF p_update_mode &#61; gc_UPDATE THEN&#10;        l_SQL :&#61; l_SQL || &#39;  -- Update exiting area with the new value e.g. {1,2,3,4,5} (UPDATE) (FROM P_ORGANISATIONS_OLD&#61;{3,4} TO P_ORGANISATIONS_NEW &#61; {7,8,9} &#61; {1,2,7,8,9,5}&#10;            ORGANISATIONS &#61;&#10;              CAST( CAST(NVL(ORGANISATIONS, t_arr_ORGANISATIONS()) AS t_tab_ORGANISATIONS)&#10;                      MULTISET EXCEPT DISTINCT NVL(:p_ORGANISATIONS_OLD, t_tab_ORGANISATIONS())&#10;                      MULTISET UNION  DISTINCT NVL(:p_ORGANISATIONS_NEW, t_tab_ORGANISATIONS())&#10;                AS t_arr_ORGANISATIONS)&#39;;&#10;    ELSE&#10;        raise_application_error(-20001, &#39;ERROR in &#39; || l_proc || &#39;: unexpected value for the P_UPDATE_MODE argument [&#39; || p_update_mode || &#39;]&#39;);&#10;    END IF;&#10;    --&#10;    l_SQL :&#61; l_SQL || CHR(10) || &#39;WHERE offender_id &#61; :p_offender&#39;;&#10;    --&#10;    IF p_update_mode &#61; gc_ASSIGN THEN&#10;        l_SQL :&#61; l_SQL || CHR(10) ||&#10;                 &#39;  AND CAST(NVL(ORGANISATIONS, t_arr_ORGANISATIONS()) AS t_tab_ORGANISATIONS) &lt;&gt; NVL(:p_ORGANISATIONS_NEW, t_tab_ORGANISATIONS())&#39;;&#10;        EXECUTE IMMEDIATE l_SQL USING p_ORGANISATIONS_NEW, p_offender_id, p_ORGANISATIONS_NEW;&#10;    ELSIF p_update_mode &#61; gc_APPEND THEN&#10;        l_SQL :&#61; l_SQL || CHR(10) ||&#10;            &#39;  AND ( CAST(NVL(ORGANISATIONS, t_arr_ORGANISATIONS()) AS t_tab_ORGANISATIONS)&#10;                     MULTISET UNION DISTINCT NVL(:p_ORGANISATIONS_NEW, t_tab_ORGANISATIONS())&#10;                   ) &lt;&gt; NVL(:p_ORGANISATIONS_NEW, t_tab_ORGANISATIONS())&#39;;&#10;        EXECUTE IMMEDIATE l_SQL USING p_ORGANISATIONS_NEW, p_offender_id, p_ORGANISATIONS_NEW, p_ORGANISATIONS_NEW;&#10;    ELSIF p_update_mode &#61; gc_UPDATE THEN&#10;        EXECUTE IMMEDIATE l_SQL USING p_ORGANISATIONS_OLD, p_ORGANISATIONS_NEW, p_offender_id;&#10;    ELSE&#10;        EXECUTE IMMEDIATE l_SQL USING p_ORGANISATIONS_NEW, p_offender_id;&#10;    END IF;&#10;    --&#10;    l_rows :&#61; SQL%ROWCOUNT;&#10;    IF l_rows &gt; 0 THEN&#10;        procDebug(&#39;procUpdateProbationAreas(&#39; || p_offender_id || &#39;, &#39; || p_table_name || &#39;): &#39; || l_rows || &#39; rows updated&#39;);&#10;        IF g_VPD_validation_mode THEN&#10;            /*PKG_Debug.*/procDebug(&#10;                p_print_flag &#61;&gt; &#39;Y&#39;,&#10;                p_msg &#61;&gt; &#39;procUpdateProbationAreas: &#39; ||&#10;                         &#39;VPD_REBUILD [&#39; || p_offender_id      || &#39;]&#39; ||&#10;                                     &#39;[&#39; || p_table_name       || &#39;]&#39; ||&#10;                                     &#39;[&#39; || p_update_mode      || &#39;]&#39; ||&#10;                                     &#39;[&#39; || PKG_LstUtl.get_array_2_list(p_ORGANISATIONS_NEW, p_iterator_function&#61;&gt;&#39;PKG_Lookups.funcgetTabRecord_CACHED(p_table&#61;&gt;&#39;&#39;PROBATION_AREA&#39;&#39;, p_ref_col&#61;&gt;&#39;&#39;probation_area_id&#39;&#39;, p_ref_val&#61;&gt;:p_probation_area_id, p_data_fld&#61;&gt;&#39;&#39;CODE&#39;&#39;)&#39;) || &#39;]&#39; ||&#10;                                     &#39;[&#39; || PKG_LstUtl.get_array_2_list(p_ORGANISATIONS_OLD, p_iterator_function&#61;&gt;&#39;PKG_Lookups.funcgetTabRecord_CACHED(p_table&#61;&gt;&#39;&#39;PROBATION_AREA&#39;&#39;, p_ref_col&#61;&gt;&#39;&#39;probation_area_id&#39;&#39;, p_ref_val&#61;&gt;:p_probation_area_id, p_data_fld&#61;&gt;&#39;&#39;CODE&#39;&#39;)&#39;) || &#39;]&#39; ||&#10;                                     &#39;[&#39; || l_rows || &#39; rows updated&#39;             || &#39;]&#39; );&#10;        END IF;&#10;    END IF;&#10;    --&#10;    g_VPD_rebuilding_flag :&#61; FALSE;&#10;    --&#10;    --PKG_Lookups.do_flush_TAB_cache;&#10;    --&#10;EXCEPTION&#10;    WHEN ex_mutating_table THEN&#10;        --&#10;        g_VPD_rebuilding_flag :&#61; FALSE;&#10;        --&#10;        l_key :&#61; p_table_name || &#39;:&#39; || p_offender_id;&#10;        procDebug(&#39;procUpdateProbationAreas(&#39; || l_key || &#39;): Adding to the deferred ORGANISATIONS Updates Queue&#39;);&#10;        IF NOT g_tab_deferred_upd_VPD.EXISTS(l_key) THEN&#10;            g_tab_deferred_upd_VPD(l_key) :&#61; &#39;Y&#39;;&#10;        END IF;&#10;        --&#10;    WHEN OTHERS THEN&#10;        --&#10;        g_VPD_rebuilding_flag :&#61; FALSE;&#10;        --&#10;        l_err_msg :&#61; SUBSTR(&#10;                        &#39;ERROR in &#39; || l_proc || &#39;: &#39; || SQLERRM || CHR(10) ||&#10;                        &#39;[&#39; || p_offender_id      || &#39;]&#39; ||&#10;                        &#39;[&#39; || p_table_name       || &#39;]&#39; ||&#10;                        &#39;[&#39; || p_update_mode      || &#39;]&#39; ||&#10;                        &#39;[&#39; || PKG_LstUtl.get_array_2_list(p_ORGANISATIONS_NEW, p_iterator_function&#61;&gt;&#39;PKG_Lookups.funcgetTabRecord_CACHED(p_table&#61;&gt;&#39;&#39;PROBATION_AREA&#39;&#39;, p_ref_col&#61;&gt;&#39;&#39;probation_area_id&#39;&#39;, p_ref_val&#61;&gt;:p_probation_area_id, p_data_fld&#61;&gt;&#39;&#39;CODE&#39;&#39;)&#39;) || &#39;]&#39; ||&#10;                        &#39;[&#39; || PKG_LstUtl.get_array_2_list(p_ORGANISATIONS_OLD, p_iterator_function&#61;&gt;&#39;PKG_Lookups.funcgetTabRecord_CACHED(p_table&#61;&gt;&#39;&#39;PROBATION_AREA&#39;&#39;, p_ref_col&#61;&gt;&#39;&#39;probation_area_id&#39;&#39;, p_ref_val&#61;&gt;:p_probation_area_id, p_data_fld&#61;&gt;&#39;&#39;CODE&#39;&#39;)&#39;) || &#39;]&#39; || CHR(10) ||&#10;                        l_SQL,&#10;                        1, 4000 );&#10;        raise_application_error(-20001, l_err_msg);&#10;        --&#10;END procUpdateProbationAreas;&#10;--&#10;PROCEDURE procUpdateProbationAreas(p_offender_id NUMBER, p_table_name VARCHAR2) IS&#10;BEGIN&#10;    procUpdateProbationAreas(&#10;        p_offender_id       &#61;&gt; p_offender_id,&#10;        p_table_name        &#61;&gt; p_table_name,&#10;        p_update_mode       &#61;&gt; gc_ASSIGN,&#10;        p_ORGANISATIONS_NEW &#61;&gt; PKG_VpdSupport.funcGetOffProbAreas_NOCACHE(p_offender_id) );&#10;END procUpdateProbationAreas;&#10;--&#10;FUNCTION get_off_area_counter RETURN NUMBER IS&#10;BEGIN&#10;    RETURN g_off_area_counter;&#10;END get_off_area_counter;&#10;--&#10;PROCEDURE inc_off_area_counter IS&#10;BEGIN&#10;    g_off_area_counter :&#61; g_off_area_counter + 1;&#10;END inc_off_area_counter;&#10;--&#10;PROCEDURE procUpdateProbationAreas IS&#10;BEGIN&#10;    IF g_tab_offenders_list.COUNT &gt; 0 THEN&#10;        procDebug(&#39;procUpdateProbationAreas: processing the TAB_OFFENDERS_LIST queue elements&#39;);&#10;        procRebuildOffProbAreas;&#10;        g_off_area_counter :&#61; 0;&#10;        g_tab_offenders_list.DELETE;&#10;    END IF;&#10;END procUpdateProbationAreas;&#10;--&#10;FUNCTION funcGetVpdDeferredUpdatesCNT RETURN NUMBER IS&#10;BEGIN&#10;    RETURN NVL(g_tab_deferred_upd_VPD.COUNT, 0);&#10;END;&#10;&#10;PROCEDURE procUpdateProbAreas_DEFERRED&#10;IS&#10;    l_key         VARCHAR2(100);&#10;    l_pos         NUMBER;&#10;    l_table_name  VARCHAR2(30);&#10;    l_offender_id NUMBER;&#10;BEGIN&#10;    IF funcGetVpdDeferredUpdatesCNT &gt; 0 THEN&#10;        l_key :&#61; g_tab_deferred_upd_VPD.FIRST;&#10;        LOOP&#10;            EXIT WHEN empty2null(l_key) IS NULL;&#10;            --&#10;            procDebug(&#39;procUpdateProbAreas_DEFERRED: processing the [&#39; || l_key || &#39;] deferred queue element&#39;);&#10;            --&#10;            l_pos :&#61; NVL(INSTR(l_key, &#39;:&#39;), 0);&#10;            IF l_pos &#61; 0 THEN&#10;                raise_application_error(-20001, &#39;ERROR in procUpdateProbationAreas_DEFERRED[&#39; || l_key || &#39;]: invalid deferred queue element detected&#39;);&#10;            END IF;&#10;            l_table_name  :&#61; TRIM(SUBSTR(empty2null(TRIM(l_key)), 1, l_pos - 1));&#10;            l_offender_id :&#61; NVL(TO_NUMBER(empty2null(TRIM(SUBSTR(l_key, l_pos + 1)))), 0);&#10;            --&#10;            IF l_offender_id &#61; 0 OR empty2null(l_table_name) IS NULL THEN&#10;                raise_application_error(-20001, &#39;ERROR in procUpdateProbationAreas_DEFERRED[&#39; || l_key || &#39;][&#39; || l_pos || &#39;]: invalid deferred queue element detected&#39;);&#10;            END IF;&#10;            --&#10;            procUpdateProbationAreas(p_offender_id&#61;&gt;l_offender_id, p_table_name&#61;&gt;l_table_name);&#10;            --&#10;            l_key :&#61; g_tab_deferred_upd_VPD.NEXT(l_key);&#10;        END LOOP;&#10;        --&#10;        g_tab_deferred_upd_VPD.DELETE;&#10;    END IF;&#10;END procUpdateProbAreas_DEFERRED;&#10;--&#10;PROCEDURE procUpdateProbationAreas_ALL(p_offender_id NUMBER, p_ORGANISATIONS t_tab_ORGANISATIONS, p_update_mode NUMBER DEFAULT gc_ASSIGN)&#10;IS&#10;    l_proc CONSTANT VARCHAR2(55) :&#61; &#39;PKG_TriggerSupport.procUpdateProbationAreas_ALL&#39;;&#10;    --&#10;    l_i BINARY_INTEGER;&#10;BEGIN&#10;    l_i :&#61; g_tab_vpd_tables.FIRST;&#10;    --FOR l_i IN g_tab_vpd_tables.FIRST .. g_tab_vpd_tables.LAST LOOP&#10;    LOOP&#10;        EXIT WHEN l_i IS NULL;&#10;        --&#10;        procUpdateProbationAreas(&#10;            p_offender_id       &#61;&gt; p_offender_id,&#10;            p_table_name        &#61;&gt; g_tab_vpd_tables(l_i),&#10;            p_update_mode       &#61;&gt; NVL(p_update_mode, gc_ASSIGN),&#10;            p_ORGANISATIONS_NEW &#61;&gt; p_ORGANISATIONS);&#10;        --&#10;        l_i :&#61; g_tab_vpd_tables.NEXT(l_i);&#10;        --&#10;    END LOOP;&#10;END procUpdateProbationAreas_ALL;&#10;--&#10;PROCEDURE procUpdateProbationAreas_ALL(p_offender_id NUMBER)&#10;IS&#10;    l_proc CONSTANT VARCHAR2(55) :&#61; &#39;PKG_TriggerSupport.procUpdateProbationAreas_ALL&#39;;&#10;    --&#10;    l_i      BINARY_INTEGER;&#10;    --&#10;BEGIN&#10;    --&#10;    l_i :&#61; g_tab_vpd_tables.FIRST;&#10;    --FOR l_i IN g_tab_vpd_tables.FIRST .. g_tab_vpd_tables.LAST LOOP&#10;    LOOP&#10;        EXIT WHEN l_i IS NULL;&#10;        procUpdateProbationAreas(p_offender_id&#61;&gt;p_offender_id, p_table_name&#61;&gt;g_tab_vpd_tables(l_i));&#10;        --&#10;        l_i :&#61; g_tab_vpd_tables.NEXT(l_i);&#10;        --&#10;    END LOOP;&#10;END procUpdateProbationAreas_ALL;&#10;--&#10;PROCEDURE procInitVpdTablesInfo IS&#10;BEGIN&#10;    g_tab_vpd_tables.DELETE;&#10;    --&#10;    SELECT DISTINCT table_name&#10;    BULK COLLECT INTO g_tab_vpd_tables&#10;    FROM user_tab_columns TC&#10;    WHERE column_name &#61; &#39;OFFENDER_ID&#39;&#10;      AND table_name NOT IN (&#39;CONTACT&#39;)&#10;      AND EXISTS(&#10;          SELECT 1 FROM user_policies&#10;          WHERE policy_name IN (&#39;FUNCOFFENDERPOLICY&#39;, &#39;FUNCCONTACTPOLICY&#39;)&#10;            AND object_name &#61; TC.table_name)&#10;      AND EXISTS(&#10;          SELECT 1&#10;          FROM user_tab_columns&#10;          WHERE table_name &#61; TC.table_name&#10;            AND column_name &#61; UPPER(&#39;ORGANISATIONS&#39;) )&#10;    ORDER BY 1;&#10;END procInitVpdTablesInfo;&#10;--&#10;--&#10;--&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--    MIS Support subroutines&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--&#10;&#10;-- CDC SET / CLEAR CONTEXT subroutines&#10;FUNCTION procChangeCapture_GetContext RETURN NUMBER IS&#10;BEGIN&#10;    RETURN NVL(G_CDC_CTX, GC_CDC_CTX_NONE);&#10;END procChangeCapture_GetContext;&#10;&#10;PROCEDURE procChangeCapture_SetContext(p_cdc_ctx NUMBER) IS&#10;BEGIN&#10;    IF NVL(p_cdc_ctx, -99) NOT IN (GC_CDC_CTX_NONE, GC_CDC_CTX_RESEED) THEN&#10;        procDebug(&#39;procChangeCapture_SetContext ERROR: invalid p_cdc_ctx value [&#39; || p_cdc_ctx || &#39;]&#39;);&#10;        raise_application_error(-20001, &#39;procChangeCapture_SetContext ERROR: invalid p_cdc_ctx value [&#39; || p_cdc_ctx || &#39;]&#39;);&#10;    END IF;&#10;    --&#10;    G_CDC_CTX :&#61; NVL(p_cdc_ctx, GC_CDC_CTX_NONE);&#10;    --&#10;END procChangeCapture_SetContext;&#10;--&#10;PROCEDURE procSetCDCFlag(p_cdc_flag BOOLEAN) IS&#10;BEGIN&#10;    g_CDC_flag      :&#61; NVL(p_cdc_flag, TRUE);&#10;    g_CDC_flag_INIT :&#61; TRUE;&#10;END procSetCDCFlag;&#10;&#10;PROCEDURE procChangeCapture_InsRecord(&#10;    p_src_table_name VARCHAR2,&#10;    p_src_key_value  VARCHAR2,&#10;    p_src_ROWID      ROWID,&#10;    p_action         VARCHAR2,&#10;    p_row_version    PLS_INTEGER)&#10;IS&#10;BEGIN&#10;    --&#10;    IF NVL(g_CDC_flag, TRUE) &#61; FALSE THEN&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    EXECUTE IMMEDIATE&#10;       &#39;INSERT INTO CHANGE_CAPTURE (&#10;          change_capture_id,&#10;          source_table,&#10;          source_table_key,&#10;          source_table_rowid,&#10;          action,&#10;          processed_flag,&#10;          row_version)&#10;        VALUES (&#10;          CHANGE_CAPTURE_SEQ.nextval,&#10;          :p_source_table,&#10;          :p_source_table_key,&#10;          :p_source_table_rowid,&#10;          :p_action,&#10;          :p_processed_flag,&#10;          :p_row_version)&#39;&#10;      USING&#10;          p_src_table_name,&#10;          NVLSTR(p_src_key_value, &#39;-1&#39;),&#10;          p_src_ROWID,&#10;          -- Switch U-&gt;I when CDC context is set to GC_CDC_CTX_RESEED mode&#10;          CASE&#10;              WHEN p_action &#61; &#39;U&#39; AND procChangeCapture_GetContext &#61; GC_CDC_CTX_RESEED&#10;              THEN &#39;I&#39;&#10;              ELSE p_action&#10;          END,&#10;          -- Set PROCESSED_FLAG to R when CDC context is set to GC_CDC_CTX_RESEED mode&#10;          CASE&#10;              WHEN procChangeCapture_GetContext &#61; GC_CDC_CTX_RESEED&#10;              THEN &#39;R&#39;&#10;              ELSE &#39;N&#39;&#10;          END,&#10;          --&#10;          NVL(p_row_version, 0);&#10;      --&#10;END procChangeCapture_InsRecord;&#10;&#10;--&#10;-- OD (OFFENDER_DELTA) Support subroutines&#10;--&#10;PROCEDURE OD_create_scheduler_job( p_instance_number INTEGER DEFAULT NULL, p_DROP_ONLY_FLAG VARCHAR2 DEFAULT &#39;N&#39; )&#10;IS&#10;    --&#10;    l_job_name          CONSTANT VARCHAR2(30) :&#61; &#39;OFF_DELTA_JOB&#39;;&#10;    l_program_name      CONSTANT VARCHAR2(30) :&#61; &#39;OFF_DELTA_PROGRAM&#39;;&#10;    l_schedule_name     CONSTANT VARCHAR2(30) :&#61; &#39;OFF_DELTA_SCHEDULE&#39;;&#10;    l_schedule_interval CONSTANT INTEGER      :&#61; GREATEST( PKG_Lookups.funcgetNDParameterValue(GC_OFF_DELTA_PURGE_INTERVAL, 24), 1); -- min 1hr&#10;    --&#10;    --PRAGMA AUTONOMOUS_TRANSACTION;&#10;    --&#10;    --&#10;BEGIN&#10;    --&#10;--    OFF_DELTA_stop_workers;&#10;--    DBMS_LOCK.sleep(10);&#10;--    --&#10;    BEGIN&#10;        DBMS_SCHEDULER.drop_job(job_name &#61;&gt; l_job_name, force &#61;&gt; FALSE);&#10;    EXCEPTION WHEN OTHERS THEN&#10;        warn(&#39;Error dropping job [&#39; || l_job_name|| &#39;] &#39; || SQLERRM || &#39;[&#39; || SQLCODE || &#39;]&#39;);&#10;    END;&#10;    --&#10;    BEGIN&#10;        DBMS_SCHEDULER.drop_program(program_name &#61;&gt; l_program_name, force &#61;&gt; FALSE);&#10;    EXCEPTION WHEN OTHERS THEN&#10;        warn(&#39;Error dropping program [&#39;||l_program_name||&#39;] &#39;|| SQLERRM || &#39;[&#39; || SQLCODE || &#39;]&#39;);&#10;    END;&#10;    --&#10;    BEGIN&#10;        DBMS_SCHEDULER.drop_schedule(schedule_name &#61;&gt; l_schedule_name, force &#61;&gt; FALSE);&#10;    EXCEPTION WHEN OTHERS THEN&#10;        warn(&#39;Error dropping schedule [&#39; || l_schedule_name|| &#39;] &#39; || SQLERRM || &#39;[&#39; || SQLCODE || &#39;]&#39;);&#10;    END;&#10;    --&#10;    IF p_DROP_ONLY_FLAG &#61; &#39;Y&#39; THEN&#10;--        OFF_DELTA_clear_stop_flags;&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    DBMS_SCHEDULER.CREATE_SCHEDULE(&#10;        schedule_name   &#61;&gt; l_schedule_name,&#10;        start_date      &#61;&gt; SYSDATE,&#10;        repeat_interval &#61;&gt; &#39;FREQ&#61;HOURLY;INTERVAL&#61;&#39; || l_schedule_interval,&#10;        end_date        &#61;&gt; NULL,&#10;        comments        &#61;&gt; &#39;Offender Delta Data Purge Schedule&#39; );&#10;    --&#10;    IF 1&#61;1 /*SPGConfig.PRFMultiThreadActive*/ THEN&#10;        --&#10;        DBMS_SCHEDULER.create_program(&#10;            program_name        &#61;&gt; l_program_name,&#10;            program_action      &#61;&gt; &#39;PKG_TriggerSupport.od_purge_old_data&#39;,&#10;            program_type        &#61;&gt; &#39;stored_procedure&#39;,&#10;            number_of_arguments &#61;&gt; 0,&#10;            enabled             &#61;&gt; FALSE );&#10;        --&#10;--        DBMS_SCHEDULER.define_program_argument(&#10;--            program_name      &#61;&gt; l_program_name,&#10;--            argument_name     &#61;&gt; &#39;maxthreads_in&#39;,&#10;--            argument_position &#61;&gt; 1,&#10;--            argument_type     &#61;&gt; &#39;NUMBER&#39; );&#10;        --&#10;        DBMS_SCHEDULER.enable(name &#61;&gt; l_program_name);&#10;        --&#10;--  job_name                IN VARCHAR2,&#10;--  program_name            IN VARCHAR2,&#10;--  schedule_name           IN VARCHAR2,&#10;--  job_class               IN VARCHAR2              DEFAULT &#39;DEFAULT_JOB_CLASS&#39;,&#10;--  enabled                 IN BOOLEAN                  DEFAULT FALSE,&#10;--  auto_drop               IN BOOLEAN                  DEFAULT TRUE,&#10;--  comments                 IN VARCHAR2                 DEFAULT NULL,&#10;--  job_style               IN VARCHAR2                 DEFAULT &#39;REGULAR&#39;,&#10;--  credential_name         IN VARCHAR2                 DEFAULT NULL,&#10;--  destination_name        IN VARCHAR2                 DEFAULT NULL);&#10;&#10;        DBMS_SCHEDULER.create_job(&#10;            job_name      &#61;&gt; l_job_name,&#10;            program_name  &#61;&gt; l_program_name,&#10;            schedule_name &#61;&gt; l_schedule_name,&#10;            --job_type      &#61;&gt; &#39;PLSQL_BLOCK&#39;,&#10;            --start_date    &#61;&gt; SYSDATE,&#10;            enabled       &#61;&gt; FALSE,&#10;            auto_drop     &#61;&gt; TRUE,&#10;            comments      &#61;&gt; &#39;Offender Delta Data Purge Job&#39; );&#10;        --&#10;        IF p_instance_number IS NOT NULL THEN&#10;            -- Set job attribute to single instance number&#10;            DBMS_SCHEDULER.set_attribute(&#10;                name      &#61;&gt; l_job_name,&#10;                attribute &#61;&gt; &#39;instance_id&#39;,&#10;                value     &#61;&gt; p_instance_number );&#10;        END IF;&#10;        --&#10;        DBMS_SCHEDULER.set_attribute(&#10;            name      &#61;&gt; l_job_name,&#10;            attribute &#61;&gt; &#39;parallel_instances&#39;,&#10;            value     &#61;&gt; FALSE );&#10;        --&#10;    END IF;&#10;    --&#10;    /* YF: PG version only&#10;    UPDATE PGAGENT.pga_jobstep SET&#10;      jstonerror &#61; &#39;s&#39;&#10;    WHERE jstjobid &#61; ( SELECT jobid FROM PGAGENT.pga_job WHERE jobname &#61; l_job_name );&#10;    */&#10;    --&#10;    COMMIT;&#10;    --&#10;    DBMS_SCHEDULER.enable(l_job_name);&#10;    --&#10;--        OFF_DELTA_clear_stop_flags;&#10;    --&#10;END OD_create_scheduler_job;&#10;--&#10;PROCEDURE OD_config( p_DATA_PURGE_INTERVAL INTEGER DEFAULT NULL, p_DATA_RETENTION INTEGER DEFAULT NULL, p_DATA_PURGE_BATCH_SIZE INTEGER DEFAULT NULL )&#10;IS&#10;    --&#10;    PRAGMA AUTONOMOUS_TRANSACTION;&#10;    --&#10;    PROCEDURE do_set_nd_param(p_param VARCHAR2, p_value NUMBER) IS&#10;    BEGIN&#10;        IF p_value &gt;&#61; 0 THEN&#10;            MERGE INTO ND_PARAMETER t0&#10;            USING (&#10;                    SELECT UPPER(TRIM(p_param)) AS nd_parameter, p_value AS nd_value FROM dual&#10;                  ) t1&#10;            ON (t0.nd_parameter &#61; t1.nd_parameter)&#10;            WHEN MATCHED     THEN UPDATE SET t0.nd_value &#61; t1.nd_value&#10;            WHEN NOT MATCHED THEN INSERT (nd_parameter_id            , nd_parameter   , nd_value) VALUES&#10;                                         (nd_parameter_id_SEQ.nextval, t1.nd_parameter, t1.nd_value);&#10;        END IF;&#10;    END do_set_nd_param;&#10;    --&#10;    PROCEDURE do_set_nd_param(p_param VARCHAR2, p_value_str VARCHAR2) IS&#10;    BEGIN&#10;        IF p_value_str IS NOT NULL THEN&#10;            MERGE INTO ND_PARAMETER t0&#10;            USING (&#10;                    SELECT UPPER(TRIM(p_param)) AS nd_parameter, p_value_str AS nd_value_string FROM dual&#10;                  ) t1&#10;            ON (t0.nd_parameter &#61; t1.nd_parameter)&#10;            WHEN MATCHED     THEN UPDATE SET t0.nd_value_string &#61; t1.nd_value_string&#10;            WHEN NOT MATCHED THEN INSERT (nd_parameter_id            , nd_parameter   , nd_value_string) VALUES&#10;                                         (nd_parameter_id_SEQ.nextval, t1.nd_parameter, t1.nd_value_string);&#10;        END IF;&#10;    END do_set_nd_param;&#10;    --&#10;BEGIN&#10;    --&#10;    do_set_nd_param( GC_OFF_DELTA_PURGE_INTERVAL  , p_DATA_PURGE_INTERVAL   );&#10;    do_set_nd_param( GC_OFF_DELTA_RETENTION       , p_DATA_RETENTION        );&#10;    do_set_nd_param( GC_OFF_DELTA_PURGE_BATCH_SIZE, p_DATA_PURGE_BATCH_SIZE );&#10;    --&#10;    COMMIT;&#10;    --&#10;END OD_config;&#10;--&#10;FUNCTION get_od_data_retention RETURN NUMBER IS&#10;BEGIN&#10;    RETURN NVL(PKG_Lookups.funcgetNDParameterValue(GC_OFF_DELTA_RETENTION, 24*30), 24*30);&#10;END get_od_data_retention;&#10;--&#10;FUNCTION get_od_data_purge_batch_size RETURN NUMBER IS&#10;BEGIN&#10;    RETURN NVL(PKG_Lookups.funcgetNDParameterValue(GC_OFF_DELTA_PURGE_BATCH_SIZE, 100000), 1);&#10;END get_od_data_purge_batch_size;&#10;--&#10;PROCEDURE od_purge_old_data(&#10;  p_retention      NUMBER DEFAULT NULL,&#10;  p_max_batch_size INTEGER DEFAULT NULL )&#10;IS&#10;    --&#10;    l_procedure_name VARCHAR2(30) :&#61; g_procedure_name;&#10;    --&#10;    l_lock_name   VARCHAR2(30) :&#61; &#39;OFF_DELTA_WORKER_LOCK&#39;;&#10;    l_lock_handle VARCHAR2(128);&#10;    l_dummy       PLS_INTEGER;&#10;    --&#10;    PROCEDURE do_allocate_soft_lock IS&#10;    BEGIN&#10;        DBMS_LOCK.allocate_unique(l_lock_name, l_lock_handle);&#10;        l_dummy :&#61; DBMS_LOCK.request(l_lock_handle, DBMS_LOCK.x_mode, DBMS_LOCK.maxwait, FALSE);&#10;    END do_allocate_soft_lock;&#10;    --&#10;    PROCEDURE do_release_soft_lock IS&#10;    BEGIN&#10;        l_dummy :&#61; DBMS_LOCK.release(l_lock_handle);&#10;    END do_release_soft_lock;&#10;    --&#10;    PROCEDURE do_purge_old_data&#10;    IS&#10;        --&#10;        l_procedure_name1 VARCHAR2(30) :&#61; g_procedure_name;&#10;        --&#10;        l_data_retention NUMBER :&#61; NVL( p_retention     , get_od_data_retention        );   -- default 30 days; max 30 days&#10;        l_max_batch_size NUMBER :&#61; GREATEST(NVL( p_max_batch_size, get_od_data_purge_batch_size ), 1);   -- default 100,000 records;&#10;        --&#10;        l_rows     INTEGER :&#61; 0;&#10;        l_rows_tot INTEGER :&#61; 0;&#10;        --&#10;        FUNCTION get_retention_char(p_val NUMBER, p_unit VARCHAR2) RETURN VARCHAR2&#10;        IS&#10;            l_str VARCHAR2(100);&#10;        BEGIN&#10;            l_str :&#61; TO_CHAR(p_val);&#10;            RETURN&#10;                CASE WHEN NOT ( l_str &#61; &#39;0&#39; OR SUBSTR(l_str, 1, 1) &#61; &#39;.&#39; )&#10;                    THEN l_str || p_unit&#10;                END;&#10;        END get_retention_char;&#10;        --&#10;    BEGIN&#10;        --&#10;        g_procedure_name :&#61; &#39;do_purge_old_data&#39;;&#10;        --&#10;        info(&#39;start: data retention &#61; &#39; ||&#10;            PKG_LstUtl.concat(&#10;                get_retention_char(ROUND(l_data_retention*24*60*60, 2), &#39;sec&#39;),&#10;                get_retention_char(ROUND(l_data_retention*24*60   , 2), &#39;min&#39;),&#10;                get_retention_char(ROUND(l_data_retention*24      , 2), &#39;hr&#39;),&#10;                get_retention_char(ROUND(l_data_retention         , 2), &#39;d&#39;),&#10;                p_delim &#61;&gt; &#39; / &#39; )&#10;        );&#10;        --&#10;        LOOP&#10;            --&#10;            DELETE FROM offender_delta&#10;            WHERE created_datetime &lt; SYSDATE - l_data_retention/24&#10;              AND status NOT IN (&#39;CREATED&#39;)&#10;              AND ROWNUM &lt;&#61; 1000 /*l_max_batch_size*/;&#10;            l_rows :&#61; NVL(SQL%ROWCOUNT, 0);&#10;            COMMIT;&#10;            --&#10;            l_rows_tot :&#61; l_rows_tot + l_rows;&#10;            --&#10;            EXIT WHEN l_rows &lt;&#61; 0 OR l_rows_tot &gt;&#61; l_max_batch_size;&#10;            --&#10;        END LOOP;&#10;        --&#10;        info(l_rows_tot || &#39; rows deleted from OFFENDER_DELTA table&#39;);&#10;        --&#10;        g_procedure_name :&#61; l_procedure_name1;&#10;        --&#10;    END do_purge_old_data;&#10;    --&#10;BEGIN&#10;    --&#10;    g_procedure_name :&#61; &#39;od_purge_old_data&#39;;&#10;    --&#10;    do_allocate_soft_lock;&#10;    --&#10;    IF SPGConfig.SPGInfoActive THEN&#10;        PKG_Debug.procrecordDbStats_START;&#10;    END IF;&#10;    --&#10;    do_purge_old_data;&#10;    --&#10;    IF SPGConfig.SPGInfoActive THEN&#10;        info(&#39;OFF_DELTA Worker has completed (&#39; || PKG_Debug.funcgetDbStats || &#39;)&#39;);&#10;    END IF;&#10;    --&#10;    do_release_soft_lock;&#10;    --&#10;    g_procedure_name :&#61; l_procedure_name;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    --&#10;    warn(&#10;        &#39;ERROR [p_retention&#61;&#39; || p_retention || &#39;]: &#39; ||&#10;        SUBSTRB(SQLERRM || CHR(10) || DBMS_UTILITY.format_error_backtrace, 1, 4000) );&#10;    --&#10;    do_release_soft_lock;&#10;    --&#10;    g_procedure_name :&#61; l_procedure_name;&#10;    --&#10;END od_purge_old_data;&#10;--&#10;PROCEDURE od_add_record( p_offender_id NUMBER, p_source_table VARCHAR2, p_source_record_id NUMBER, p_action VARCHAR2 ) IS&#10;BEGIN&#10;    --&#10;    IF PKG_Lookups.funcgetNDParameterValue(&#39;ENABLE_OFFENDER_EVENTS&#39;, 1) &#61; 1 THEN&#10;        --&#10;        INSERT INTO offender_delta(&#10;          /*01*/ offender_delta_id,&#10;          /*02*/ offender_id,&#10;          /*03*/ source_table,&#10;          /*04*/ source_record_id,&#10;          /*05*/ date_changed,&#10;          /*06*/ action,&#10;          /*07*/ status,&#10;          /*08*/ created_datetime,&#10;          /*09*/ last_updated_datetime&#10;        ) VALUES (&#10;          /*01*/ offender_delta_id_SEQ.nextval,&#10;          /*02*/ p_offender_id,&#10;          /*03*/ p_source_table,&#10;          /*04*/ p_source_record_id,&#10;          /*05*/ SYSDATE,&#10;          /*06*/ p_action,&#10;          /*07*/ &#39;CREATED&#39;,&#10;          /*08*/ SYSDATE,&#10;          /*09*/ SYSDATE );&#10;        --&#10;    END IF;&#10;    --&#10;END od_add_record;&#10;&#10;--&#10;--&#10;--&#10;PROCEDURE do_init_vars IS&#10;BEGIN&#10;    G_PDM_VERSION :&#61; PKG_Global.get_PDM_VERSION;&#10;END do_init_vars;&#10;--&#10;--&#10;--&#10;--&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--    PKG Initialisation block&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--&#10;--&#10;BEGIN&#10;    PKG_Global.do_init;&#10;    do_init_vars;&#10;    --&#10;    procInitVpdTablesInfo;&#10;    --&#10;--&#10;--&#10;END pkg_TriggerSupport;</textarea>
                        </div>
                    </div>
                </section>
            </div>
            <!-- /.content-wrapper -->
            <footer class="main-footer">
                <div>
                    <div class="pull-right hidden-xs">
                        <a href="https://github.com/schemaspy/schemaspy" title="GitHub for SchemaSpy"><i class="fa fa-github-square fa-2x"></i></a>
                        <a href="http://stackoverflow.com/questions/tagged/schemaspy" title="StackOverflow for SchemaSpy"><i class="fa fa-stack-overflow fa-2x"></i></a>
                    </div>
                    <strong>Generated by <a href="http://schemaspy.org/" class="logo-text"><i class="fa fa-database"></i> SchemaSpy 6.2.4</a></strong>
                </div>
                <!-- /.container -->
            </footer>
        </div>
        <!-- ./wrapper -->

        <!-- jQuery 2.2.3 -->
        <script src="../bower/admin-lte/plugins/jQuery/jquery-2.2.3.min.js"></script>
        <script src="../bower/admin-lte/plugins/jQueryUI/jquery-ui.min.js"></script>
        <!-- Bootstrap 3.3.5 -->
        <script src="../bower/admin-lte/bootstrap/js/bootstrap.min.js"></script>
        <!-- DataTables -->
        <script src="../bower/datatables.net/jquery.dataTables.min.js"></script>
        <script src="../bower/datatables.net-bs/js/dataTables.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/dataTables.buttons.min.js"></script>
        <script src="../bower/datatables.net-buttons-bs/js/buttons.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.html5.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.print.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.colVis.min.js"></script>
        <!-- SheetJS -->
        <script src="../bower/js-xlsx/xlsx.full.min.js"></script>
        <!-- pdfmake -->
        <script src="../bower/pdfmake/pdfmake.min.js"></script>
        <script src="../bower/pdfmake/vfs_fonts.js"></script>
        <!-- SlimScroll -->
        <script src="../bower/admin-lte/plugins/slimScroll/jquery.slimscroll.min.js"></script>
        <!-- FastClick -->
        <script src="../bower/admin-lte/plugins/fastclick/fastclick.js"></script>
        <!-- Salvattore -->
        <script src="../bower/salvattore/salvattore.min.js"></script>
        <!-- AnchorJS -->
        <script src="../bower/anchor-js/anchor.min.js"></script>
        <!-- CodeMirror -->
        <script src="../bower/codemirror/codemirror.js"></script>
        <script src="../bower/codemirror/sql.js"></script>
        <!-- AdminLTE App -->
        <script src="../bower/admin-lte/dist/js/app.min.js"></script>
        <script src="routine.js"></script>
        <script src="../schemaSpy.js"></script>
    </body>
</html>