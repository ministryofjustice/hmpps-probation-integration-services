<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>TSTNDA.DELIUS_APP_SCHEMA</title>
        <!-- Tell the browser to be responsive to screen width -->
        <meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport">
        <link rel="icon" type="image/png" sizes="16x16" href="../favicon.png">
        <!-- Bootstrap 3.3.5 -->
        <link rel="stylesheet" href="../bower/admin-lte/bootstrap/css/bootstrap.min.css">
        <!-- Font Awesome -->
        <link rel="stylesheet" href="../bower/font-awesome/css/font-awesome.min.css">
        <!-- Ionicons -->
        <link rel="stylesheet" href="../bower/ionicons/css/ionicons.min.css">
        <!-- DataTables -->
        <link rel="stylesheet" href="../bower/datatables.net-bs/css/dataTables.bootstrap.min.css">
        <link rel="stylesheet" href="../bower/datatables.net-buttons-bs/css/buttons.bootstrap.min.css">
        <!-- Code Mirror -->
        <link rel="stylesheet" href="../bower/codemirror/codemirror.css">
        <!-- Fonts -->
        <link href='../fonts/indieflower/indie-flower.css' rel='stylesheet' type='text/css'>
        <link href='../fonts/source-sans-pro/source-sans-pro.css' rel='stylesheet' type='text/css'>

        <!-- Theme style -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/AdminLTE.min.css">
        <!-- Salvattore -->
        <link rel="stylesheet" href="../bower/salvattore/salvattore.css">
        <!-- AdminLTE Skins. Choose a skin from the css/skins
           folder instead of downloading all of them to reduce the load. -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/skins/_all-skins.min.css">
        <!-- SchemaSpy -->
        <link rel="stylesheet" href="../schemaSpy.css">

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
        <script src="../bower/html5shiv/html5shiv.min.js"></script>
        <script src="../bower/respond/respond.min.js"></script>
        <![endif]-->
    </head>
    <!-- ADD THE CLASS layout-top-nav TO REMOVE THE SIDEBAR. -->
    <body class="hold-transition skin-blue layout-top-nav">
        <div class="wrapper">
            <header class="main-header">
                <nav class="navbar navbar-static-top">
                    <div class="container">
                        <div class="navbar-header">
                            <a href="../index.html" class="navbar-brand"><b>TSTNDA</b></a><span class="navbar-brand" style="padding-left: 0">.DELIUS_APP_SCHEMA</span>
                            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse"><i class="fa fa-bars"></i></button>
                        </div>

                        <!-- Collect the nav links, forms, and other content for toggling -->
                        <div class="collapse navbar-collapse pull-left" id="navbar-collapse">
                            <ul class="nav navbar-nav">
                                <li><a href="../index.html">Tables <span class="sr-only">(current)</span></a></li>
                                <li><a href="../columns.html" title="All of the columns in the schema">Columns</a></li>
                                <li><a href="../constraints.html" title="Useful for diagnosing error messages that just give constraint name or number">Constraints</a></li>
                                <li><a href="../relationships.html" title="Diagram of table relationships">Relationships</a></li>
                                <li><a href="../orphans.html" title="View of tables with neither parents nor children">Orphan&nbsp;Tables</a></li>
                                <li><a href="../anomalies.html" title="Things that might not be quite right">Anomalies</a></li>
                                <li><a href="../routines.html" title="Procedures and functions">Routines</a></li>
                            </ul>
                        </div>
                        <!-- /.navbar-collapse -->
                        <!-- Navbar Right Menu -->
                    </div>
                    <!-- /.container-fluid -->
                </nav>
            </header>
            <!-- Main content -->
            <!-- Full Width Column -->
            <div class="content-wrapper">
                <!-- Content Header (Page header) -->
                <section class="content-header">
                    <h1>DELIUS_APP_SCHEMA.C08001_PDT_SUPPORT</h1><br />
                </section>
                <!-- Main content -->
                <section class="content">
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <span class="glyphicon glyphicon-list-alt" aria-hidden="true"></span>
                            <h3 id="Columns" class="box-title">Parameters</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <table id="standard_table" class="table table-bordered table-striped dataTable" role="grid">
                                <thead align='left'>
                                <tr>
                                    <th>Name</th>
                                    <th>Type</th>
                                    <th>Mode</th>
                                </tr>
                                </thead>
                                <tbody>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <i class="fa fa-file-code-o"></i>
                            <h3 id="RoutineDefinition" class="box-title">Definition</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <textarea id="sql-script-codemirror" name="sql-script-codemirror" rows="" style="display: none;">PACKAGE BODY C08001_PDT_SUPPORT&#10;AS&#10;--&#10;--&#10;--&#10;--&#10;&#10;-- SIDV/EIDV related constants&#10;IDV_NATSEP              CONSTANT INTEGER      :&#61; 10 * 10**6;&#10;IDV_AREASEP             CONSTANT INTEGER      :&#61; 30 * 10**6;&#10;ARCD_SUSSEX             CONSTANT VARCHAR2(10) :&#61; &#39;SSX&#39;;&#10;ARCD_LONDON             CONSTANT VARCHAR2(10) :&#61; &#39;LDN&#39;;&#10;ARCD_LONDON_LPA         CONSTANT VARCHAR2(10) :&#61; &#39;LPA&#39;;&#10;ARCD_LINCOLN            CONSTANT VARCHAR2(10) :&#61; &#39;LNS&#39;;&#10;ARCD_MANCHESTER         CONSTANT VARCHAR2(10) :&#61; &#39;MCG&#39;;&#10;ARCD_MANCHESTER_GMP     CONSTANT VARCHAR2(10) :&#61; &#39;GMP&#39;;&#10;&#10;LONDON_ADJUST           CONSTANT INTEGER      :&#61; 15 * 10**6;&#10;&#10;g_label      VARCHAR2(32);&#10;g_code_name  VARCHAR2(100);&#10;G_THREAD_ID INTEGER :&#61; NULL;&#10;&#10;g_initialised_flag    BOOLEAN :&#61; FALSE;&#10;&#10;g_cms                 VARCHAR2(10);&#10;g_arcd                VARCHAR2(10);&#10;&#10;g_sidv                NUMBER;&#10;g_midv                NUMBER;&#10;g_eidv                NUMBER;&#10;g_natsep              NUMBER;&#10;g_probation_area      NUMBER;&#10;&#10;g_max_threads         INTEGER     :&#61; 1;&#10;g_component_code      INTEGER     :&#61; 8001;&#10;g_debug_ready         VARCHAR2(1) :&#61; &#39;Y&#39;;&#10;&#10;-- Global Exceptions&#10;fatal_error_exception       EXCEPTION;&#10;e_mt_fatal_error            EXCEPTION;&#10;illegal_hierarchy_exception EXCEPTION;&#10;recursive_limit_exception   EXCEPTION;&#10;record_mutated_exception    EXCEPTION;&#10;&#10;PRAGMA EXCEPTION_INIT (e_mt_fatal_error, -20001);&#10;&#10;TYPE t_con_rec_TYP IS RECORD(&#10;    owner              VARCHAR2(30),&#10;    constraint_name    VARCHAR2(100),&#10;    con_text           VARCHAR2(4000)&#10;);&#10;TYPE t_con_tab_TYP IS TABLE OF t_con_rec_TYP INDEX BY VARCHAR2(100);&#10;g_con_TAB t_con_tab_TYP;&#10;&#10;g_dest_schema       VARCHAR2(32);&#10;g_pdt_run_seq       INTEGER;&#10;g_pdt_debug_seq     INTEGER;&#10;&#10;TYPE t_pdt_log_rec_TYP IS RECORD(&#10;    pdt_run_seq NUMBER,&#10;    table_name  VARCHAR2(30),&#10;    row_id      ROWID,&#10;    pk_value    VARCHAR2(4000)&#10;);&#10;TYPE t_pdt_log_tab_TYP IS TABLE OF t_pdt_log_rec_TYP;&#10;g_pdt_log_tab t_pdt_log_tab_TYP :&#61; t_pdt_log_tab_TYP();&#10;&#10;TYPE t_hier_rec_TYP IS RECORD(&#10;  table_name   VARCHAR2(30),&#10;  parent_table VARCHAR2(30),&#10;  order_by     INTEGER );&#10;TYPE t_hier_tab_TYP IS TABLE OF t_hier_rec_TYP;&#10;--&#10;TYPE TYP_tab_info_REC IS RECORD (&#10;    table_name    VARCHAR2(30),&#10;    pk_fld_lst    VARCHAR2(1024),&#10;    fld_lst       VARCHAR2(4000),&#10;    fld_lst_1     VARCHAR2(4000),&#10;    child_tables  t_hier_tab_TYP&#10;);&#10;TYPE TYP_tab_info_TAB IS TABLE OF TYP_tab_info_REC INDEX BY VARCHAR2(30);&#10;--&#10;g_tab_info TYP_tab_info_TAB;&#10;&#10;PROCEDURE debugMessage(&#10;    p_msg           VARCHAR2,&#10;    p_code_name     VARCHAR2 DEFAULT NULL,&#10;    p_label         VARCHAR2 DEFAULT NULL,&#10;    p_err_flag      VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_log_msg_flag  VARCHAR2 DEFAULT &#39;N&#39; )&#10;IS&#10;    PRAGMA AUTONOMOUS_TRANSACTION;&#10;    --&#10;    l_sql       VARCHAR2(1024);&#10;    l_debug_id  NUMBER;&#10;    --&#10;BEGIN&#10;    --&#10;    IF g_debug_ready &#61; &#39;Y&#39; THEN&#10;        IF NVL(p_log_msg_flag, &#39;Y&#39;) &#61; &#39;Y&#39; THEN&#10;            l_sql :&#61; &#39;INSERT INTO pdt_debug (debug_seq, debug_date_time, debug_message)&#10;                      VALUES (pdt_debug_seq.NEXTVAL, :debug_date_time, :debug_message)&#39;;&#10;            --&#10;--            IF p_err_flag &#61; &#39;Y&#39; THEN&#10;--                EXECUTE IMMEDIATE l_SQL USING SYSDATE, &#39;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#39;;&#10;--                EXECUTE IMMEDIATE l_SQL USING SYSDATE, &#39;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;   ERROR DETECTED   &#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#39;;&#10;--                EXECUTE IMMEDIATE l_SQL USING SYSDATE, &#39;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#39;;&#10;--            END IF;&#10;            --&#10;            EXECUTE IMMEDIATE l_SQL&#10;            USING&#10;              SYSDATE,&#10;              PKG_LstUtl.add_prefix(&#39;[&#39; || G_THREAD_ID || &#39;] &#39; || p_code_name || &#39;:&#39;, PKG_LstUtl.concat(p_label, p_msg, p_delim &#61;&gt; &#39; - &#39;))&#10;            ;&#10;            --&#10;            COMMIT;&#10;            --&#10;        END IF;&#10;    END IF;&#10;    --&#10;    IF NVL(p_log_msg_flag, &#39;Y&#39;) !&#61; &#39;Y&#39; THEN&#10;        PKG_Debug.procDebug(PKG_LstUtl.add_prefix(p_code_name || &#39;:&#39;, PKG_LstUtl.concat(NVL(p_label, g_label), p_msg, p_delim &#61;&gt; &#39; - &#39;)));&#10;    END IF;&#10;    --&#10;END debugMessage;&#10;&#10;PROCEDURE message(p_msg VARCHAR2) IS&#10;BEGIN&#10;    PKG_Debug.procDebug(&#39;[&#39; || g_label || &#39;] &#39; || p_msg, p_print_flag &#61;&gt; &#39;Y&#39;);&#10;END message;&#10;&#10;PROCEDURE warn(p_err_msg VARCHAR2) IS&#10;BEGIN&#10;    PKG_Debug.procDebug(&#39;WARNING [component&#61;&#39; || g_component_code || &#39;]: &#39; || p_err_msg, p_print_flag &#61;&gt; &#39;Y&#39;);&#10;END warn;&#10;&#10;PROCEDURE raise_error(p_err_msg VARCHAR2, p_proc VARCHAR2, p_label VARCHAR2 DEFAULT NULL) IS&#10;BEGIN&#10;    debugMessage(&#10;        p_proc || &#39; FAILED. [Step: &#39; || NVL(NVL(p_label, g_label), &#39;N/A&#39;) || &#39;]&#39; ||&#10;        &#39;[&#39; || DBMS_UTILITY.format_error_backtrace || &#39;]: &#39; ||&#10;        p_err_msg,&#10;        p_err_flag &#61;&gt; &#39;Y&#39; );&#10;    RAISE_APPLICATION_ERROR(-20001, p_err_msg);&#10;END raise_error;&#10;&#10;FUNCTION get_version RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN GC_VERSION;&#10;END get_version;&#10;&#10;--------------------------------------------------------------------------------&#10;-- Dynamic SQL subroutines                                                    --&#10;--------------------------------------------------------------------------------&#10;--&#10;PROCEDURE exec_sql(&#10;    p_sql VARCHAR2, p_ignore_err_flag VARCHAR2 DEFAULT &#39;N&#39;, p_print_SQL VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_param_1  VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_2 VARCHAR2 DEFAULT &#39;NO_VALUE&#39; , p_param_3  VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_4  VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_5  VARCHAR2 DEFAULT &#39;NO_VALUE&#39;,&#10;    p_param_6  VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_7  VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_8  VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_9  VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_10 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;,&#10;    p_param_11 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_12 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_13 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_14 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_15 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;,&#10;    p_param_16 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_17 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_18 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_19 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_20 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;,&#10;    p_param_21 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_22 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_23 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_24 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_25 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;,&#10;    p_param_26 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_27 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_28 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_29 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_30 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;,&#10;    p_param_31 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_32 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_33 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_34 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_35 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;,&#10;    p_param_36 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_37 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_38 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_39 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_40 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;,&#10;    p_param_41 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_42 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_43 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_44 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_45 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;,&#10;    p_param_46 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_47 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_48 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_49 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_50 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;)&#10;IS&#10;    --&#10;    l_bind_cnt INTEGER :&#61; 0;&#10;    --&#10;    PROCEDURE print_bind_vars(p_trace_level INTEGER DEFAULT 5)&#10;    IS&#10;        l_bind_par_str VARCHAR2(2048);&#10;        PROCEDURE do_add_str(p_str VARCHAR2) IS&#10;        BEGIN&#10;            IF NVL(p_str, &#39;X&#39;) &lt;&gt; &#39;NO_VALUE&#39; THEN&#10;                IF l_bind_par_str IS NOT NULL THEN&#10;                    l_bind_par_str :&#61; SUBSTRB(l_bind_par_str || &#39;,&#39;, 1, 2048);&#10;                END IF;&#10;                l_bind_par_str :&#61; SUBSTRB(l_bind_par_str || p_str, 1, 2048);&#10;            END IF;&#10;        END;&#10;    BEGIN&#10;        IF NVL(p_param_1, &#39;X&#39;) &lt;&gt; &#39;NO_VALUE&#39; THEN&#10;            do_add_str(p_param_1);&#10;            do_add_str(p_param_2);&#10;            do_add_str(p_param_3);&#10;            do_add_str(p_param_4);&#10;            do_add_str(p_param_5);&#10;            do_add_str(p_param_6);&#10;            do_add_str(p_param_7);&#10;            do_add_str(p_param_8);&#10;            do_add_str(p_param_9);&#10;            do_add_str(p_param_10);&#10;            do_add_str(p_param_11);&#10;            do_add_str(p_param_12);&#10;            do_add_str(p_param_13);&#10;            do_add_str(p_param_14);&#10;            do_add_str(p_param_15);&#10;            do_add_str(p_param_16);&#10;            do_add_str(p_param_17);&#10;            do_add_str(p_param_18);&#10;            do_add_str(p_param_19);&#10;            do_add_str(p_param_20);&#10;            do_add_str(p_param_21);&#10;            do_add_str(p_param_22);&#10;            do_add_str(p_param_23);&#10;            do_add_str(p_param_24);&#10;            do_add_str(p_param_25);&#10;            do_add_str(p_param_26);&#10;            do_add_str(p_param_27);&#10;            do_add_str(p_param_28);&#10;            do_add_str(p_param_29);&#10;            do_add_str(p_param_30);&#10;            do_add_str(p_param_31);&#10;            do_add_str(p_param_32);&#10;            do_add_str(p_param_33);&#10;            do_add_str(p_param_34);&#10;            do_add_str(p_param_35);&#10;            do_add_str(p_param_36);&#10;            do_add_str(p_param_37);&#10;            do_add_str(p_param_38);&#10;            do_add_str(p_param_39);&#10;            do_add_str(p_param_40);&#10;            do_add_str(p_param_41);&#10;            do_add_str(p_param_42);&#10;            do_add_str(p_param_43);&#10;            do_add_str(p_param_44);&#10;            do_add_str(p_param_45);&#10;            do_add_str(p_param_46);&#10;            do_add_str(p_param_47);&#10;            do_add_str(p_param_48);&#10;            do_add_str(p_param_49);&#10;            do_add_str(p_param_50);&#10;            --&#10;            IF l_bind_par_str IS NOT NULL THEN&#10;                debugMessage(&#39;SQL bind variables (&#39; || l_bind_cnt || &#39;): &#39; || l_bind_par_str);&#10;            END IF;&#10;        END IF;&#10;    END;&#10;    --&#10;    PROCEDURE print_sql(p_bind_vars VARCHAR2 DEFAULT &#39;N&#39;, p_trace_level INTEGER DEFAULT 5) IS&#10;    BEGIN&#10;        debugMessage(&#39;exec_sql: &#39; || p_sql);&#10;        IF p_bind_vars &#61; &#39;Y&#39; THEN&#10;            print_bind_vars;&#10;        END IF;&#10;    END;&#10;    --&#10;BEGIN&#10;    IF NVL(p_print_SQL, &#39;Y&#39;) &#61; &#39;Y&#39; THEN&#10;        print_sql(&#39;Y&#39;, 5);&#10;    END IF;&#10;    IF p_param_1 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 0;&#10;        EXECUTE IMMEDIATE p_sql;&#10;    ELSIF p_param_2 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 1;&#10;        EXECUTE IMMEDIATE p_sql USING p_param_1;&#10;    ELSIF p_param_3 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 2;&#10;        EXECUTE IMMEDIATE p_sql USING p_param_1, p_param_2;&#10;    ELSIF p_param_4 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 3;&#10;        EXECUTE IMMEDIATE p_sql USING p_param_1, p_param_2, p_param_3;&#10;    ELSIF p_param_5 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 4;&#10;        EXECUTE IMMEDIATE p_sql USING p_param_1, p_param_2, p_param_3, p_param_4;&#10;    ELSIF p_param_6 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 5;&#10;        EXECUTE IMMEDIATE p_sql USING p_param_1, p_param_2, p_param_3, p_param_4, p_param_5;&#10;    ELSIF p_param_7 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 6;&#10;        EXECUTE IMMEDIATE p_sql USING p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6;&#10;    ELSIF p_param_8 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 7;&#10;        EXECUTE IMMEDIATE p_sql USING p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7;&#10;    ELSIF p_param_9 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 8;&#10;        EXECUTE IMMEDIATE p_sql USING p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8;&#10;    ELSIF p_param_10 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 9;&#10;        EXECUTE IMMEDIATE p_sql USING p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9;&#10;    ELSIF p_param_11 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 10;&#10;        EXECUTE IMMEDIATE p_sql USING p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10;&#10;    ELSIF p_param_12 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 11;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11;&#10;    ELSIF p_param_13 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 12;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12;&#10;    ELSIF p_param_14 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 13;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13;&#10;    ELSIF p_param_15 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 14;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14;&#10;    ELSIF p_param_16 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 15;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15;&#10;    ELSIF p_param_17 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 16;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16;&#10;    ELSIF p_param_18 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 17;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17;&#10;    ELSIF p_param_19 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 18;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18;&#10;    ELSIF p_param_20 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 19;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19;&#10;    ELSIF p_param_21 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 20;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20;&#10;    ELSIF p_param_22 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 21;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21;&#10;    ELSIF p_param_23 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 22;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22;&#10;    ELSIF p_param_24 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 23;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23;&#10;    ELSIF p_param_25 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 24;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24;&#10;    ELSIF p_param_26 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 25;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25;&#10;    ELSIF p_param_27 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 26;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26;&#10;    ELSIF p_param_28 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 27;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27;&#10;    ELSIF p_param_29 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 28;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28;&#10;    ELSIF p_param_30 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 29;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28, p_param_29;&#10;    ELSIF p_param_31 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 30;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28, p_param_29, p_param_30;&#10;    ELSIF p_param_32 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 31;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28, p_param_29, p_param_30,&#10;            p_param_31;&#10;    ELSIF p_param_33 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 32;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28, p_param_29, p_param_30,&#10;            p_param_31, p_param_32;&#10;    ELSIF p_param_34 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 33;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28, p_param_29, p_param_30,&#10;            p_param_31, p_param_32, p_param_33;&#10;    ELSIF p_param_35 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 34;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28, p_param_29, p_param_30,&#10;            p_param_31, p_param_32, p_param_33, p_param_34;&#10;    ELSIF p_param_36 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 35;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28, p_param_29, p_param_30,&#10;            p_param_31, p_param_32, p_param_33, p_param_34, p_param_35;&#10;    ELSIF p_param_37 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 36;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28, p_param_29, p_param_30,&#10;            p_param_31, p_param_32, p_param_33, p_param_34, p_param_35, p_param_36;&#10;    ELSIF p_param_38 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 37;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28, p_param_29, p_param_30,&#10;            p_param_31, p_param_32, p_param_33, p_param_34, p_param_35, p_param_36, p_param_37;&#10;    ELSIF p_param_39 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 38;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28, p_param_29, p_param_30,&#10;            p_param_31, p_param_32, p_param_33, p_param_34, p_param_35, p_param_36, p_param_37, p_param_38;&#10;    ELSIF p_param_40 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 39;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28, p_param_29, p_param_30,&#10;            p_param_31, p_param_32, p_param_33, p_param_34, p_param_35, p_param_36, p_param_37, p_param_38, p_param_39;&#10;    ELSIF p_param_41 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 40;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28, p_param_29, p_param_30,&#10;            p_param_31, p_param_32, p_param_33, p_param_34, p_param_35, p_param_36, p_param_37, p_param_38, p_param_39, p_param_40;&#10;    ELSIF p_param_42 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 41;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28, p_param_29, p_param_30,&#10;            p_param_31, p_param_32, p_param_33, p_param_34, p_param_35, p_param_36, p_param_37, p_param_38, p_param_39, p_param_40,&#10;            p_param_41;&#10;    ELSIF p_param_43 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 42;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28, p_param_29, p_param_30,&#10;            p_param_31, p_param_32, p_param_33, p_param_34, p_param_35, p_param_36, p_param_37, p_param_38, p_param_39, p_param_40,&#10;            p_param_41, p_param_42;&#10;    ELSIF p_param_44 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 43;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28, p_param_29, p_param_30,&#10;            p_param_31, p_param_32, p_param_33, p_param_34, p_param_35, p_param_36, p_param_37, p_param_38, p_param_39, p_param_40,&#10;            p_param_41, p_param_42, p_param_43;&#10;    ELSIF p_param_45 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 44;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28, p_param_29, p_param_30,&#10;            p_param_31, p_param_32, p_param_33, p_param_34, p_param_35, p_param_36, p_param_37, p_param_38, p_param_39, p_param_40,&#10;            p_param_41, p_param_42, p_param_43, p_param_44;&#10;    ELSIF p_param_46 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 45;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28, p_param_29, p_param_30,&#10;            p_param_31, p_param_32, p_param_33, p_param_34, p_param_35, p_param_36, p_param_37, p_param_38, p_param_39, p_param_40,&#10;            p_param_41, p_param_42, p_param_43, p_param_44, p_param_45;&#10;    ELSIF p_param_47 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 46;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28, p_param_29, p_param_30,&#10;            p_param_31, p_param_32, p_param_33, p_param_34, p_param_35, p_param_36, p_param_37, p_param_38, p_param_39, p_param_40,&#10;            p_param_41, p_param_42, p_param_43, p_param_44, p_param_45, p_param_46;&#10;    ELSIF p_param_48 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 47;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28, p_param_29, p_param_30,&#10;            p_param_31, p_param_32, p_param_33, p_param_34, p_param_35, p_param_36, p_param_37, p_param_38, p_param_39, p_param_40,&#10;            p_param_41, p_param_42, p_param_43, p_param_44, p_param_45, p_param_46, p_param_47;&#10;    ELSIF p_param_49 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 48;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28, p_param_29, p_param_30,&#10;            p_param_31, p_param_32, p_param_33, p_param_34, p_param_35, p_param_36, p_param_37, p_param_38, p_param_39, p_param_40,&#10;            p_param_41, p_param_42, p_param_43, p_param_44, p_param_45, p_param_46, p_param_47, p_param_48;&#10;    ELSIF p_param_50 &#61; &#39;NO_VALUE&#39; THEN&#10;        l_bind_cnt :&#61; 49;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28, p_param_29, p_param_30,&#10;            p_param_31, p_param_32, p_param_33, p_param_34, p_param_35, p_param_36, p_param_37, p_param_38, p_param_39, p_param_40,&#10;            p_param_41, p_param_42, p_param_43, p_param_44, p_param_45, p_param_46, p_param_47, p_param_48, p_param_49;&#10;    ELSE&#10;        l_bind_cnt :&#61; 50;&#10;        EXECUTE IMMEDIATE p_sql USING&#10;            p_param_1, p_param_2, p_param_3, p_param_4, p_param_5, p_param_6, p_param_7, p_param_8, p_param_9, p_param_10,&#10;            p_param_11, p_param_12, p_param_13, p_param_14, p_param_15, p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;            p_param_21, p_param_22, p_param_23, p_param_24, p_param_25, p_param_26, p_param_27, p_param_28, p_param_29, p_param_30,&#10;            p_param_31, p_param_32, p_param_33, p_param_34, p_param_35, p_param_36, p_param_37, p_param_38, p_param_39, p_param_40,&#10;            p_param_41, p_param_42, p_param_43, p_param_44, p_param_45, p_param_46, p_param_47, p_param_48, p_param_49, p_param_50;&#10;    END IF;&#10;EXCEPTION WHEN OTHERS THEN&#10;    IF NVL(p_ignore_err_flag, &#39;N&#39;) &#61; &#39;Y&#39; THEN&#10;        IF NVL(p_print_SQL, &#39;Y&#39;) &#61; &#39;N&#39; THEN&#10;            print_sql(&#39;Y&#39;, 1);&#10;        END IF;&#10;        debugMessage(&#39;WARNING: exec_sql ERROR: &#39; || SQLERRM);&#10;    ELSE&#10;        IF NVL(p_print_SQL, &#39;Y&#39;) &#61; &#39;N&#39; THEN&#10;            print_sql(&#39;Y&#39;, 1);&#10;        END IF;&#10;        debugMessage(&#39;FAILED: exec_sql ERROR: &#39; || SQLERRM);&#10;        RAISE;&#10;    END IF;&#10;END exec_sql;&#10;--&#10;PROCEDURE exec_sql_atnm(&#10;    p_sql VARCHAR2, p_ignore_err_flag VARCHAR2 DEFAULT &#39;N&#39;, p_print_SQL VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_param_1  VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_2 VARCHAR2 DEFAULT &#39;NO_VALUE&#39; , p_param_3  VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_4  VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_5  VARCHAR2 DEFAULT &#39;NO_VALUE&#39;,&#10;    p_param_6  VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_7  VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_8  VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_9  VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_10 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;,&#10;    p_param_11 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_12 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_13 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_14 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_15 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;,&#10;    p_param_16 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_17 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_18 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_19 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_20 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;,&#10;    p_param_21 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_22 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_23 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_24 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_25 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;,&#10;    p_param_26 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_27 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_28 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_29 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_30 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;,&#10;    p_param_31 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_32 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_33 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_34 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_35 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;,&#10;    p_param_36 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_37 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_38 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_39 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_40 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;,&#10;    p_param_41 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_42 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_43 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_44 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_45 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;,&#10;    p_param_46 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_47 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_48 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_49 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;, p_param_50 VARCHAR2 DEFAULT &#39;NO_VALUE&#39;)&#10;IS&#10;    PRAGMA AUTONOMOUS_TRANSACTION;&#10;BEGIN&#10;    exec_SQL(p_sql, p_ignore_err_flag, p_print_SQL,&#10;        p_param_1 , p_param_2 , p_param_3 , p_param_4 , p_param_5,&#10;        p_param_6 , p_param_7 , p_param_8 , p_param_9 , p_param_10,&#10;        p_param_11, p_param_12, p_param_13, p_param_14, p_param_15,&#10;        p_param_16, p_param_17, p_param_18, p_param_19, p_param_20,&#10;        p_param_21, p_param_22, p_param_23, p_param_24, p_param_25,&#10;        p_param_26, p_param_27, p_param_28, p_param_29, p_param_30,&#10;        p_param_31, p_param_32, p_param_33, p_param_34, p_param_35,&#10;        p_param_36, p_param_37, p_param_38, p_param_39, p_param_40,&#10;        p_param_41, p_param_42, p_param_43, p_param_44, p_param_45,&#10;        p_param_46, p_param_47, p_param_48, p_param_49, p_param_50);&#10;    COMMIT;&#10;END exec_sql_atnm;&#10;--&#10;PROCEDURE create_obj(p_obj_type VARCHAR2, p_obj_name VARCHAR2, p_cr_DDL VARCHAR2, p_drop_obj_flag VARCHAR2 DEFAULT &#39;N&#39;, p_dr_DDL VARCHAR2 DEFAULT NULL)&#10;IS&#10;    l_drop_DDL   VARCHAR2(1024);&#10;    l_obj_exists BOOLEAN;&#10;    --&#10;    FUNCTION object_exists (p_object_type IN VARCHAR2, p_object_name IN VARCHAR2) RETURN BOOLEAN&#10;    IS&#10;        l_obj_cnt INTEGER;&#10;    BEGIN&#10;        SELECT COUNT(1) INTO l_obj_cnt&#10;        FROM user_objects&#10;        WHERE object_type &#61; p_object_type&#10;          AND object_name &#61; p_object_name;&#10;        --&#10;        IF l_obj_cnt &gt; 0 THEN&#10;            RETURN TRUE;&#10;        ELSE&#10;            RETURN FALSE;&#10;        END IF;&#10;        --RETURN PKG_Lookups.object_exists (p_object_type, p_object_name, p_object_owner);&#10;    END object_exists;&#10;    --&#10;BEGIN&#10;    l_obj_exists :&#61; object_exists (p_obj_type, p_obj_name);&#10;    IF NOT l_obj_exists THEN&#10;        exec_SQL(p_cr_DDL, p_print_SQL &#61;&gt; &#39;Y&#39;);&#10;    ELSE&#10;        IF p_drop_obj_flag &#61; &#39;Y&#39; THEN&#10;            l_drop_DDL :&#61; NVL(p_dr_DDL, &#39;DROP &#39; || p_obj_type || &#39; &#39; || p_obj_name);&#10;            exec_SQL(l_drop_DDL, p_print_SQL &#61;&gt; &#39;Y&#39;);&#10;            --&#10;            exec_SQL(p_cr_DDL, p_print_SQL &#61;&gt; &#39;Y&#39;);&#10;        END IF;&#10;    END IF;&#10;    --&#10;END create_obj;&#10;&#10;--##############################################################################&#10;--  1. Function get_probation_area_id&#10;--##############################################################################&#10;FUNCTION get_probation_area_id(p_arcd VARCHAR2) RETURN INTEGER&#10;IS&#10;    l_probation_area_id INTEGER;&#10;BEGIN&#10;    BEGIN&#10;        SELECT probation_area_id INTO l_probation_area_id&#10;        FROM probation_area&#10;        WHERE code &#61; UPPER(p_arcd);&#10;    EXCEPTION&#10;      WHEN NO_DATA_FOUND THEN&#10;        l_probation_area_id :&#61; -1;&#10;      WHEN OTHERS THEN&#10;        l_probation_area_id :&#61; -2;&#10;    END;&#10;    --&#10;    RETURN l_probation_area_id;&#10;END get_probation_area_id;&#10;&#10;FUNCTION get_tmp_table_name(p_table_name VARCHAR2, p_arcd VARCHAR2) RETURN VARCHAR2&#10;IS&#10;    tmp_table VARCHAR2(100);&#10;    l_table   VARCHAR2(100);&#10;BEGIN&#10;    tmp_table :&#61; p_table_name;&#10;    l_table :&#61; SUBSTR(TRIM(PKG_LstUtl.list_last_elem(tmp_table, &#39;.&#39;)), 1, 100);&#10;    RETURN &#39;TMP_&#39; || SUBSTR(l_table, 1, 30-4-3) || &#39;_&#39; || LPAD(get_probation_area_id(p_arcd), 2, &#39;0&#39;);&#10;END get_tmp_table_name;&#10;&#10;--##############################################################################&#10;--  2. Function get_area_component_id&#10;--##############################################################################&#10;FUNCTION get_area_component_id(p_arcd VARCHAR2) RETURN INTEGER&#10;IS&#10;    ret   INTEGER :&#61; 998001;&#10;BEGIN&#10;    ret :&#61; (get_probation_area_id(p_arcd) * 10000) + g_component_code;&#10;    --&#10;    RETURN ret;&#10;END get_area_component_id;&#10;&#10;--##############################################################################&#10;--  2. Function get_natsep&#10;--##############################################################################&#10;FUNCTION get_natsep RETURN INTEGER IS&#10;BEGIN&#10;    g_label       :&#61; &#39;200000&#39;;&#10;    g_code_name   :&#61; &#39;get_natsep&#39;;&#10;    --&#10;    RETURN IDV_NATSEP;&#10;END get_natsep;&#10;&#10;--##############################################################################&#10;--  3. Function get_areasep&#10;--##############################################################################&#10;FUNCTION get_areasep (p_arcd VARCHAR2, p_cms VARCHAR2) RETURN INTEGER&#10;IS&#10;    l_areasep INTEGER;&#10;BEGIN&#10;    g_label        :&#61; &#39;300000&#39;;&#10;    g_code_name    :&#61; &#39;get_areasep&#39;;&#10;&#10;    IF p_arcd &#61; ARCD_SUSSEX THEN&#10;        g_label :&#61; &#39;300005&#39;;&#10;        IF UPPER(p_cms) IN (&#39;CRAMS&#39;, &#39;ICMS&#39;) THEN&#10;            g_label :&#61; &#39;300010&#39;;&#10;            l_areasep :&#61; IDV_AREASEP / 2;&#10;        ELSE&#10;            g_label :&#61; &#39;300015&#39;;&#10;            l_areasep :&#61; -1;&#10;        END IF;&#10;    ELSE&#10;        g_label :&#61; &#39;300020&#39;;&#10;        l_areasep :&#61; IDV_AREASEP;&#10;    END IF;&#10;&#10;    g_label :&#61; &#39;300025&#39;;&#10;    RETURN l_areasep;&#10;END get_areasep;&#10;&#10;--##############################################################################&#10;--  4. Function get_sidv&#10;--##############################################################################&#10;FUNCTION get_sidv(p_arcd VARCHAR2, p_cms VARCHAR2) RETURN INTEGER&#10;IS&#10;    l_cms   VARCHAR2(10);&#10;    l_arcd  VARCHAR2(10);&#10;    l_sidv  INTEGER;&#10;BEGIN&#10;    g_label         :&#61; &#39;400000&#39;;&#10;    g_code_name     :&#61; &#39;get_sidv&#39;;&#10;    --&#10;    l_cms :&#61; UPPER(p_cms);&#10;    l_arcd :&#61; UPPER(p_arcd);&#10;    CASE l_arcd&#10;      WHEN ARCD_LONDON_LPA THEN l_arcd :&#61; ARCD_LONDON;&#10;      WHEN ARCD_MANCHESTER_GMP THEN l_arcd :&#61; ARCD_MANCHESTER;&#10;      ELSE l_arcd :&#61; l_arcd;&#10;    END CASE;&#10;    --&#10;    IF l_arcd &#61; ARCD_SUSSEX THEN&#10;        g_label :&#61; &#39;400005&#39;;&#10;        IF l_cms &#61; &#39;CRAMS&#39; THEN&#10;            g_label :&#61; &#39;400010&#39;;&#10;            l_sidv :&#61; get_natsep + ((get_probation_area_id(l_arcd) - 1) * get_areasep(l_arcd, l_cms) * 2);&#10;        ELSIF l_cms &#61; &#39;ICMS&#39; THEN&#10;            g_label :&#61; &#39;400015&#39;;&#10;            l_sidv :&#61; get_natsep + ((get_probation_area_id(l_arcd) - 1) * get_areasep(l_arcd, l_cms) * 2 + get_areasep(l_arcd, l_cms));&#10;        ELSE&#10;            g_label :&#61; &#39;400020&#39;;&#10;            l_sidv :&#61; -1;&#10;        END IF;&#10;    ELSIF l_arcd &#61; ARCD_LONDON THEN&#10;        g_label :&#61; &#39;400021&#39;;&#10;        l_sidv :&#61; get_natsep + (get_probation_area_id(l_arcd) - 1) * get_areasep(l_arcd, l_cms) - LONDON_ADJUST;&#10;    ELSE&#10;        g_label :&#61; &#39;400025&#39;;&#10;        l_sidv :&#61; get_natsep + ((get_probation_area_id(l_arcd) - 1) * get_areasep(l_arcd, l_cms));&#10;    END IF;&#10;&#10;    g_label :&#61; &#39;400030&#39;;&#10;    RETURN l_sidv;&#10;END get_sidv;&#10;&#10;--##############################################################################&#10;--  5. Function get_eidv&#10;--##############################################################################&#10;FUNCTION get_eidv(p_arcd VARCHAR2, p_cms VARCHAR2) RETURN INTEGER IS&#10;    l_arcd  VARCHAR2(10);&#10;    l_cms   VARCHAR2(10);&#10;    l_eidv  INTEGER;&#10;BEGIN&#10;    g_label         :&#61; &#39;500000&#39;;&#10;    g_code_name     :&#61; &#39;get_eidv&#39;;&#10;    --&#10;    l_cms :&#61; UPPER(p_cms);&#10;    l_arcd :&#61; UPPER(p_arcd);&#10;    CASE l_arcd&#10;      WHEN ARCD_LONDON_LPA THEN l_arcd :&#61; ARCD_LONDON;&#10;      WHEN ARCD_MANCHESTER_GMP THEN l_arcd :&#61; ARCD_MANCHESTER;&#10;      ELSE l_arcd :&#61; l_arcd;&#10;    END CASE;&#10;    --&#10;    IF l_arcd &#61; ARCD_LONDON THEN&#10;        l_eidv :&#61; get_sidv(l_arcd, l_cms) + (get_areasep(l_arcd, l_cms) - 1) + LONDON_ADJUST;&#10;    ELSIF l_arcd &#61; ARCD_LINCOLN THEN&#10;        l_eidv :&#61; get_sidv(l_arcd, l_cms) + (get_areasep(l_arcd, l_cms) - 1) - LONDON_ADJUST;&#10;    ELSE&#10;        l_eidv :&#61; get_sidv(l_arcd, l_cms) + (get_areasep(l_arcd, l_cms) - 1);&#10;    END IF;&#10;    --&#10;    RETURN l_eidv;&#10;END get_eidv;&#10;&#10;--##############################################################################&#10;--  6. Function get_midv&#10;--##############################################################################&#10;FUNCTION get_midv(p_arcd VARCHAR2, p_cms VARCHAR2) RETURN INTEGER&#10;IS&#10;    l_cms   VARCHAR2(10);&#10;    l_arcd  VARCHAR2(10);&#10;BEGIN&#10;    g_label         :&#61; &#39;600000&#39;;&#10;    g_code_name     :&#61; &#39;get_midv&#39;;&#10;    --&#10;    l_cms :&#61; UPPER(p_cms);&#10;    l_arcd :&#61; UPPER(p_arcd);&#10;    CASE l_arcd&#10;      WHEN ARCD_LONDON_LPA THEN l_arcd :&#61; ARCD_LONDON;&#10;      WHEN ARCD_MANCHESTER_GMP THEN l_arcd :&#61; ARCD_MANCHESTER;&#10;      ELSE l_arcd :&#61; l_arcd;&#10;    END CASE;&#10;    --&#10;    RETURN FLOOR(get_sidv(l_arcd, l_cms) + get_eidv(l_arcd, l_cms)) / 2;&#10;END get_midv;&#10;--&#10;FUNCTION get_date_format RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN GC_NLS_DATE_FORMAT;&#10;END get_date_format;&#10;--&#10;PROCEDURE do_init_nls(p_nls_date_format VARCHAR2 DEFAULT NULL)&#10;IS&#10;    l_nls_date_format VARCHAR2(30);&#10;BEGIN&#10;    l_nls_date_format :&#61; NVL(p_nls_date_format, get_date_format);&#10;    EXECUTE IMMEDIATE &#39;ALTER SESSION SET NLS_DATE_FORMAT&#61;&#39;&#39;&#39; || l_nls_date_format || &#39;&#39;&#39;&#39;;&#10;END do_init_nls;&#10;--&#10;PROCEDURE do_init_vars IS&#10;BEGIN&#10;    SELECT VERSION INTO G_PDM_VERSION&#10;    FROM V_ND_PDM_VERSION&#10;    WHERE ROWNUM &lt;&#61; 1;&#10;    --&#10;    IF G_PDM_VERSION &lt; 100 THEN&#10;        G_PDM_VERSION :&#61; G_PDM_VERSION * 100;&#10;    END IF;&#10;END do_init_vars;&#10;--&#10;PROCEDURE Initialise(p_cms VARCHAR2, p_arcd VARCHAR2)&#10;IS&#10;    l_SQL VARCHAR2(4000);&#10;    --&#10;BEGIN&#10;    g_label         :&#61; &#39;140000&#39;;&#10;    g_code_name     :&#61; &#39;Initialise&#39;;&#10;&#10;    IF g_initialised_flag AND g_cms &#61; UPPER(TRIM(p_cms)) AND g_arcd &#61; UPPER(TRIM(p_arcd)) THEN&#10;        RETURN;&#10;    END IF;&#10;&#10;    g_label :&#61; &#39;140001&#39;;&#10;    debugMessage (&#39;Processing against PDM Version: &#39; || G_PDM_VERSION);&#10;&#10;    g_label :&#61; &#39;140002&#39;;&#10;    PKG_VPD_CTX.set_client_identifier(userID &#61;&gt; 1);&#10;&#10;    --&#10;    g_label :&#61; &#39;140003&#39;;&#10;    do_init_NLS;&#10;    g_label :&#61; &#39;140004&#39;;&#10;    g_debug_ready :&#61; &#39;Y&#39;;&#10;&#10;    -- initialise variables&#10;    g_label :&#61; &#39;140010&#39;;&#10;    g_cms   :&#61; UPPER(TRIM(p_cms));&#10;    g_arcd  :&#61; UPPER(TRIM(p_arcd));&#10;&#10;    g_label :&#61; &#39;140040&#39;;&#10;    g_sidv           :&#61; get_sidv(g_arcd, g_cms);&#10;    g_midv           :&#61; get_midv(g_arcd, g_cms);&#10;    g_eidv           :&#61; get_eidv(g_arcd, g_cms);&#10;    g_natsep         :&#61; get_natsep;&#10;    g_probation_area :&#61; get_probation_area_id(g_arcd);&#10;&#10;    g_label :&#61; &#39;140155&#39;;&#10;    debugMessage (&#39;----------------------------------------------------&#39;);&#10;    debugMessage (&#39;l_probation_area &#61;&#61;&gt; &#39; || g_probation_area);&#10;    debugMessage (&#39;sidv &#61;&#61;&gt; &#39; || g_sidv);&#10;    debugMessage (&#39;midv &#61;&#61;&gt; &#39; || g_midv);&#10;    debugMessage (&#39;eidv &#61;&#61;&gt; &#39; || g_eidv);&#10;    debugMessage (&#39;----------------------------------------------------&#39;);&#10;&#10;    g_initialised_flag :&#61; TRUE;&#10;&#10;END Initialise;&#10;&#10;--##############################################################################&#10;--  2. Function local_index_unusable&#10;--##############################################################################&#10;FUNCTION local_index_unusable (p_table_name VARCHAR2, p_arcd VARCHAR2) RETURN INTEGER&#10;IS&#10;    l_sql                             VARCHAR2(1024);&#10;    l_partition_name            VARCHAR2(30);&#10;    l_probation_area_char   CHAR(2);&#10;    l_index_count           INTEGER :&#61; 0;&#10;    --&#10;    err_no_partition        EXCEPTION;&#10;    --&#10;    CURSOR local_index IS&#10;      SELECT ui.table_name, uip.index_name, uip.partition_name&#10;      FROM user_ind_partitions uip&#10;      INNER JOIN user_indexes ui&#10;      ON uip.index_name &#61; ui.index_name&#10;      WHERE ui.table_name &#61; p_table_name&#10;      AND partition_name &#61; l_partition_name&#10;      AND (uip.index_name NOT LIKE &#39;XPK%&#39; AND uip.index_name NOT LIKE &#39;XAK%&#39;);&#10;    --&#10;BEGIN&#10;    --&#10;    l_sql :&#61;  &#39;SELECT DISTINCT SUBSTR(partition_name, 1, LENGTH(partition_name) -2)&#10;               FROM user_ind_partitions&#10;               INNER JOIN user_indexes&#10;               ON user_ind_partitions.index_name &#61; user_indexes.index_name&#10;               AND user_ind_partitions.partition_name NOT LIKE &#39;&#39;SYS%&#39;&#39;&#10;               WHERE user_indexes.table_name &#61; :p_table_name&#39;;&#10;    --&#10;    BEGIN -- get partition name if no partition exit procedure&#10;&#10;      EXECUTE IMMEDIATE l_sql&#10;      into l_partition_name&#10;      USING p_table_name;&#10;&#10;    EXCEPTION WHEN NO_DATA_FOUND THEN&#10;        RAISE err_no_partition;&#10;    WHEN OTHERS THEN&#10;        RAISE;&#10;    END;&#10;&#10;    -- create partion name&#10;    l_probation_area_char :&#61; LPAD(get_probation_area_id(p_arcd),2,0);&#10;    l_partition_name :&#61; l_partition_name || l_probation_area_char;&#10;&#10;    FOR each_index IN local_index -- make each local index partition unusable&#10;    LOOP&#10;      exec_SQL(&#39;ALTER INDEX &#39; || each_index.index_name || &#39; MODIFY PARTITION &#39; || each_index.partition_name || &#39; UNUSABLE&#39;);&#10;      l_index_count :&#61; l_index_count + 1;&#10;    END LOOP;&#10;&#10;    RETURN l_index_count;&#10;&#10;EXCEPTION WHEN err_no_partition THEN&#10;  RETURN l_index_count;&#10;WHEN OTHERS THEN&#10;  RETURN -1;&#10;END local_index_unusable;&#10;&#10;--##############################################################################&#10;--  3. Function local_index_rebuild&#10;--##############################################################################&#10;FUNCTION local_index_rebuild (p_table_name VARCHAR2, p_arcd VARCHAR2, p_logging BOOLEAN DEFAULT TRUE) RETURN INTEGER&#10;IS&#10;    l_sql                             VARCHAR2(1024);&#10;    l_partition_name            VARCHAR2(30);&#10;    l_probation_area_char   CHAR(2);&#10;    l_index_count           INTEGER :&#61; 0;&#10;    --&#10;    err_no_partition        EXCEPTION;&#10;    --&#10;    CURSOR local_index IS&#10;      SELECT ui.table_name, uip.index_name, uip.partition_name&#10;      FROM user_ind_partitions uip&#10;      INNER JOIN user_indexes ui&#10;      ON uip.index_name &#61; ui.index_name&#10;      WHERE ui.table_name &#61; p_table_name&#10;      AND partition_name &#61; l_partition_name&#10;      AND (uip.index_name NOT LIKE &#39;XPK%&#39; AND uip.index_name NOT LIKE &#39;XAK%&#39;);&#10;    --&#10;BEGIN&#10;    l_sql :&#61;  &#39;SELECT DISTINCT SUBSTR(partition_name, 1, LENGTH(partition_name) -2)&#10;               FROM user_ind_partitions&#10;               INNER JOIN user_indexes&#10;               ON user_ind_partitions.index_name &#61; user_indexes.index_name&#10;               AND user_ind_partitions.partition_name NOT LIKE &#39;&#39;SYS%&#39;&#39;&#10;               WHERE user_indexes.table_name &#61; :p_table_name&#39;;&#10;&#10;    BEGIN -- get partition name if no partition exit procedure&#10;        EXECUTE IMMEDIATE l_sql INTO l_partition_name USING p_table_name;&#10;    EXCEPTION WHEN NO_DATA_FOUND THEN&#10;        RAISE err_no_partition;&#10;    WHEN OTHERS THEN&#10;        RAISE;&#10;    END;&#10;&#10;    -- create partion name&#10;    l_probation_area_char :&#61; LPAD(get_probation_area_id(p_arcd),2,0);&#10;    l_partition_name :&#61; l_partition_name || l_probation_area_char;&#10;&#10;    FOR each_index IN local_index -- make each local index partition unusable&#10;    LOOP&#10;      l_sql :&#61; &#39;ALTER INDEX &#39; || each_index.index_name || &#39; REBUILD PARTITION &#39; || each_index.partition_name;&#10;      IF NOT p_logging THEN&#10;          l_sql :&#61; l_sql || &#39; NOLOGGING&#39;;&#10;      END IF;&#10;      exec_SQL(l_sql);&#10;      l_index_count :&#61; l_index_count + 1;&#10;    END LOOP;&#10;    --&#10;    RETURN l_index_count;&#10;    --&#10;EXCEPTION WHEN err_no_partition THEN&#10;    RETURN l_index_count;&#10;WHEN OTHERS THEN&#10;    RETURN -1;&#10;END local_index_rebuild;&#10;--&#10;--&#10;PROCEDURE do_validate_Off_Inst&#10;IS&#10;    --&#10;    TYPE l_cur_TYP IS REF CURSOR;&#10;    cs  l_cur_TYP;&#10;    --&#10;    TYPE l_rec_TYP IS RECORD (&#10;        offender_id     OFFENDER.offender_id%TYPE,&#10;        institution_id  OFFENDER.institution_id%TYPE,&#10;        establishment   OFFENDER.establishment%TYPE&#10;                              );&#10;    TYPE l_tab_TYP IS TABLE OF l_rec_TYP;&#10;    --&#10;    r_updates     l_tab_TYP;&#10;    --&#10;    l_row_count   INTEGER :&#61; 0;&#10;    l_sql         VARCHAR2(3072);&#10;    --&#10;BEGIN&#10;    --&#10;    debugMessage(&#39;Commencing validateOffenderInstitution&#39;);&#10;    --&#10;    l_sql :&#61; &#39;UPDATE offender&#10;                SET institution_id &#61; :institution_id,&#10;                    establishment &#61; :establishment&#10;              WHERE offender_id &#61; :offender_id&#39;;&#10;    --&#10;    OPEN cs FOR&#10;      &#39;SELECT c.offender_id, c.institution_id, c.establishment&#10;      FROM  custody c, disposal d&#10;      WHERE d.soft_deleted &#61; 0&#10;      AND       (d.termination_date IS NULL OR d.termination_date &gt; SYSDATE)&#10;      AND       c.disposal_id &#61; d.disposal_id&#10;      AND       c.soft_deleted &#61; 0&#10;      AND       c.institution_id IS NOT NULL&#10;      AND   c.custody_id BETWEEN &#39; || g_sidv || &#39; AND &#39; || g_eidv || &#39;&#10;      AND NOT EXISTS  ( SELECT 1&#10;                        FROM offender e&#10;                        WHERE e.offender_id &#61; c.offender_id&#10;                        AND e.institution_id &#61; c.institution_id&#10;                        AND e.establishment &#61; c.establishment&#10;                      )&#10;      ORDER BY  d.disposal_date&#39;;&#10;    --&#10;    LOOP&#10;        FETCH cs BULK COLLECT INTO r_updates LIMIT 1000;&#10;        EXIT WHEN r_updates.COUNT &#61; 0;&#10;        --&#10;        FORALL i IN r_updates.FIRST .. r_updates.LAST&#10;        EXECUTE IMMEDIATE l_sql&#10;        USING r_updates(i).institution_id, r_updates(i).establishment, r_updates(i).offender_id;&#10;        --&#10;        l_row_count :&#61; l_row_count + SQL%ROWCOUNT;&#10;    END LOOP;&#10;    --&#10;    CLOSE cs;&#10;    --&#10;    debugMessage (l_row_count || &#39; OFFENDER rows updated&#39;);&#10;    COMMIT;&#10;    --&#10;    debugMessage(&#39;Completed validateOffenderInstitution&#39;);&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    debugMessage(&#39;FAILED [validateOffenderInstitution] ERROR: &#39; || SQLERRM);&#10;    RAISE;&#10;END do_validate_Off_Inst;&#10;--&#10;--&#10;PROCEDURE do_insert_contact_alert(p_cms VARCHAR2, p_arcd VARCHAR2)&#10;IS&#10;    l_sql       VARCHAR2(3072);&#10;    l_row_count INTEGER;&#10;BEGIN&#10;    --&#10;    Initialise(p_cms &#61;&gt; p_cms, p_arcd &#61;&gt; p_arcd);&#10;    --&#10;    l_sql :&#61; &#39;INSERT INTO contact_alert&#10;                (contact_alert_id, offender_id, contact_id, contact_type_id, contact_outcome_type_id, trust_provider_flag, staff_employee_id, trust_provider_team_id, offender_manager_id)&#10;              SELECT contact_alert_id_seq.nextval, c.offender_id, c.contact_id, c.contact_type_id, c.contact_outcome_type_id, om.trust_provider_flag, om.staff_employee_id, om.trust_provider_team_id, om.offender_manager_id&#10;              FROM contact C&#10;              INNER JOIN offender_manager OM&#10;              ON c.offender_id &#61; om.offender_id AND om.active_flag &#61; 1&#10;              WHERE c.alert_active &#61; &#39;&#39;Y&#39;&#39;&#10;              AND   c.contact_id BETWEEN &#39; || g_sidv || &#39; AND &#39; || g_eidv || &#39;&#39;;&#10;    --&#10;    debugMessage(&#39;l_sql &#61;&gt; &#39; || l_sql);&#10;    EXECUTE IMMEDIATE l_sql;&#10;    l_row_count :&#61; SQL%ROWCOUNT;&#10;    --&#10;    debugMessage (l_row_count || &#39; CONTACT_ALERT rows inserted&#39;);&#10;    COMMIT;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    debugMessage(&#39;FAILED [do_insert_contact_alert] ERROR: &#39; || SQLERRM);&#10;    RAISE;&#10;END do_insert_contact_alert;&#10;--&#10;--&#10;PROCEDURE pre_load(p_cms VARCHAR2, p_arcd VARCHAR2) IS&#10;    l_component_id  NUMBER;&#10;    l_area_id       NUMBER;&#10;BEGIN&#10;  -- Initialise(p_cms, p_arcd);&#10;  reset_threads(p_component_id &#61;&gt; get_area_component_id(p_arcd));&#10;  --&#10;  BEGIN&#10;    global_cache_mgr.pdt_active;&#10;  EXCEPTION WHEN OTHERS THEN&#10;    debugMessage(&#39;FAILED PDT_ACTIVE CALL ERROR: &#39; || SQLERRM);&#10;  END;&#10;  --&#10;END pre_load;&#10;--&#10;PROCEDURE post_load(p_cms VARCHAR2, p_arcd VARCHAR2)&#10;IS&#10;  --&#10;  PROCEDURE do_rebuild_VPD_ORGS&#10;  IS&#10;      --&#10;      CURSOR cs IS&#10;        SELECT offender_id&#10;        FROM offender&#10;        WHERE ORGANISATIONS IS NULL&#10;          AND NOT EXISTS(SELECT 1 FROM organisation_offender WHERE offender_id &#61; OFFENDER.offender_id)&#10;        ORDER BY 1;&#10;      --&#10;      l_tab             T_TAB_ORGANISATIONS :&#61; T_TAB_ORGANISATIONS();&#10;      l_offender_id_LST CLOB;&#10;      --&#10;  BEGIN&#10;      --&#10;      UPDATE offender SET organisations &#61; NULL&#10;      WHERE offender_id BETWEEN g_sidv AND g_eidv;&#10;      DELETE FROM organisation_offender&#10;      WHERE offender_id BETWEEN g_sidv AND g_eidv;&#10;      --&#10;      OPEN cs;&#10;      LOOP&#10;          FETCH cs BULK COLLECT INTO l_tab LIMIT 10;&#10;          EXIT WHEN l_tab.COUNT &#61; 0;&#10;          --&#10;          PKG_TriggerSupport.procRebuildOptTables_ALL(&#10;              p_force_flag              &#61;&gt; &#39;Y&#39;,&#10;              p_offender_id_LST         &#61;&gt; PKG_LstUtl.get_array_2_list_CLOB(l_tab),&#10;              p_update_offender_id_flag &#61;&gt; &#39;N&#39; );&#10;&#10;          COMMIT;&#10;      END LOOP;&#10;      CLOSE cs;&#10;      --&#10;      --PKG_TriggerSupport.procRebuildOptTables_ALL(p_force_flag &#61;&gt; &#39;N&#39;);&#10;      --&#10;  END do_rebuild_VPD_ORGS;&#10;  --&#10;BEGIN&#10;  Initialise(p_cms, p_arcd);&#10;  --&#10;  PKG_VPD_CTX.set_client_identifier(userID &#61;&gt; 1);&#10;  --&#10;  debugMessage(&#39;Commence procRebuildCaseloadTable_ALL&#39;);&#10;  PKG_TriggerSupport.procRebuildCaseloadTable_ALL(p_offender_ID_from&#61;&gt;g_sidv, p_offender_ID_to&#61;&gt;g_eidv);&#10;  debugMessage(&#39;Completed procRebuildCaseloadTable_ALL&#39;);&#10;  --&#10;  debugMessage(&#39;Commence do_rebuild_VPD_ORGS&#39;);&#10;  do_rebuild_VPD_ORGS;&#10;  debugMessage(&#39;Completed do_rebuild_VPD_ORGS&#39;);&#10;  --&#10;  debugMessage(&#39;Commence do_update_current_tier&#39;);&#10;  do_update_current_tier(p_cms, p_arcd);&#10;  debugMessage(&#39;Completed do_update_current_tier&#39;);&#10;  --&#10;  --do_validate_Off_Inst;&#10;  --&#10;  debugMessage(&#39;Commence do_insert_contact_alert&#39;);&#10;  do_insert_contact_alert(p_cms, p_arcd);&#10;  debugMessage(&#39;Completed do_insert_contact_alert&#39;);&#10;  --&#10;  debugMessage(&#39;Commence do_table_stats&#39;);&#10;  do_table_stats(p_table&#61;&gt;&#39;ORGANISATION_OFFENDER&#39;);&#10;  do_table_stats(p_table&#61;&gt;&#39;CASELOAD&#39;);&#10;  IF G_PDM_VERSION &gt;&#61; 601 THEN&#10;      do_table_stats(p_table&#61;&gt;&#39;COHORT_DIARY&#39;);&#10;  END IF;&#10;  debugMessage(&#39;Completed do_table_stats&#39;);&#10;  --&#10;  BEGIN&#10;    global_cache_mgr.pdt_inactive;&#10;  EXCEPTION WHEN OTHERS THEN&#10;    debugMessage(&#39;FAILED PDT_INACTIVE CALL ERROR: &#39; || SQLERRM);&#10;  END;&#10;  --&#10;  COMMIT;&#10;  --&#10;END post_load;&#10;--&#10;PROCEDURE pre_load_tab(p_table VARCHAR2, p_cms VARCHAR2 DEFAULT NULL, p_arcd VARCHAR2 DEFAULT NULL) IS&#10;BEGIN&#10;    NULL;&#10;END pre_load_tab;&#10;--&#10;PROCEDURE post_load_tab(p_table VARCHAR2, p_cms VARCHAR2 DEFAULT NULL, p_arcd VARCHAR2 DEFAULT NULL, p_use_tmp_table_flag VARCHAR2 DEFAULT &#39;N&#39;)&#10;IS&#10;    l_tab_list  VARCHAR2(30000);&#10;    l_table     VARCHAR2(100);&#10;    l_tmp_table VARCHAR2(100);&#10;    --&#10;    PROCEDURE do_bulk_load_data(p_source_table VARCHAR2, p_target_table VARCHAR2)&#10;    IS&#10;        l_pk_fld       VARCHAR2(30);&#10;        l_order_by     VARCHAR2(512);&#10;    BEGIN&#10;        IF UPPER(p_target_table) IN (&#39;CONTACT&#39;, &#39;CONTACT_NEW&#39; ) THEN&#10;            l_pk_fld   :&#61; &#39;contact_id&#39;;&#10;            l_order_by :&#61; &#39;offender_id, event_id, lic_condition_id, rqmnt_id, contact_date, contact_start_time&#39;;&#10;        END IF;&#10;        IF p_source_table IS NOT NULL AND p_target_table IS NOT NULL AND l_pk_fld IS NOT NULL AND l_order_by IS NOT NULL THEN&#10;            PDT_bulk_load_data(&#10;                p_table_name    &#61;&gt; p_table,&#10;                p_source_table  &#61;&gt; p_source_table,&#10;                p_target_table  &#61;&gt; p_target_table,&#10;                p_pk_fld        &#61;&gt; l_pk_fld,&#10;                p_order_by      &#61;&gt; l_order_by,&#10;                p_component_id  &#61;&gt; get_area_component_id(p_arcd));&#10;        END IF;&#10;    END do_bulk_load_data;&#10;    --&#10;BEGIN&#10;    l_tab_list :&#61; p_table;&#10;    LOOP&#10;        EXIT WHEN TRIM(l_tab_list) IS NULL;&#10;        --&#10;        l_table :&#61; TRIM(PKG_LstUtl.list_next_elem(l_tab_list, &#39;,&#39;));&#10;        l_table :&#61; TRIM(PKG_LstUtl.list_last_elem(l_table, &#39;.&#39;));&#10;        --&#10;        IF p_use_tmp_table_flag &#61; &#39;Y&#39; AND&#10;           UPPER(l_table) IN (&#39;CONTACT&#39;)&#10;        THEN&#10;            l_tmp_table :&#61; get_tmp_table_name(l_table, p_arcd);&#10;            do_bulk_load_data(l_tmp_table, &#39;CONTACT&#39;);&#10;        END IF;&#10;        --&#10;        IF l_table IS NOT NULL THEN&#10;            do_table_stats(p_table &#61;&gt; l_table);&#10;        END IF;&#10;        --&#10;    END LOOP;&#10;    --&#10;END post_load_tab;&#10;--&#10;--&#10;-- DBMS_STATS subroutines&#10;--&#10;PROCEDURE do_schema_stats(p_options VARCHAR2 DEFAULT &#39;gather auto&#39;, p_cascade IN BOOLEAN DEFAULT TRUE)&#10;IS&#10;  l_proc CONSTANT VARCHAR2(30) :&#61; &#39;do_schema_stats&#39;;&#10;  --&#10;  l_err_code NUMBER;&#10;  l_err_msg VARCHAR2(4096);&#10;  --&#10;BEGIN&#10;  --&#10;  l_err_msg  :&#61; NULL;&#10;  l_err_code :&#61; 0;&#10;  --&#10;  -- Gather auto gathers stale and empty statisics only.&#10;  DBMS_STATS.GATHER_SCHEMA_STATS(&#10;      ownname    &#61;&gt; SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_SCHEMA&#39;),&#10;      options    &#61;&gt; p_options,&#10;      cascade    &#61;&gt; p_cascade );&#10;  --&#10;END do_schema_stats;&#10;--&#10;PROCEDURE do_table_stats(p_table VARCHAR2, p_cascade BOOLEAN DEFAULT TRUE)&#10;IS&#10;  l_proc CONSTANT VARCHAR2(30) :&#61; &#39;do_table_stats&#39;;&#10;  l_index VARCHAR2(32);&#10;  --&#10;  l_err_code NUMBER;&#10;  l_err_msg VARCHAR2(4096);&#10;  --&#10;  CURSOR csIdx IS&#10;    SELECT index_name&#10;    FROM user_indexes&#10;    WHERE table_name &#61; p_table;&#10;  --&#10;  objlist     DBMS_STATS.ObjectTab;&#10;  --&#10;BEGIN&#10;  --&#10;  l_err_msg  :&#61; NULL;&#10;  l_err_code :&#61; 0;&#10;  --&#10;  DBMS_STATS.gather_schema_stats( ownname &#61;&gt; SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_SCHEMA&#39;),&#10;                                  objlist &#61;&gt; objlist,&#10;                                  options &#61;&gt; &#39;LIST STALE&#39;);&#10;  FOR i IN objlist.FIRST .. objlist.LAST&#10;  LOOP&#10;      IF objlist(i).OBJTYPE &#61; &#39;TABLE&#39; AND objlist(i).OBJNAME &#61; p_table THEN&#10;            DBMS_STATS.GATHER_TABLE_STATS(&#10;                                              ownname    &#61;&gt; SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_SCHEMA&#39;),&#10;                                              tabname    &#61;&gt; p_table,&#10;                                              cascade    &#61;&gt; p_cascade,&#10;                                              estimate_percent &#61;&gt; DBMS_STATS.AUTO_SAMPLE_SIZE,&#10;                                              method_opt       &#61;&gt; &#39;for all indexed columns size 1&#39;,&#10;                                              granularity      &#61;&gt; &#39;ALL&#39;&#10;                                              --degree           &#61;&gt; 1&#10;                                          );&#10;          EXIT;&#10;      END IF;&#10;  END LOOP;&#10;  --&#10;EXCEPTION&#10;WHEN OTHERS THEN&#10;    DBMS_STATS.GATHER_TABLE_STATS(&#10;                                      ownname    &#61;&gt; SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_SCHEMA&#39;),&#10;                                      tabname    &#61;&gt; p_table,&#10;                                      cascade    &#61;&gt; p_cascade,&#10;                                      estimate_percent &#61;&gt; DBMS_STATS.AUTO_SAMPLE_SIZE,&#10;                                      method_opt       &#61;&gt; &#39;for all indexed columns size 1&#39;,&#10;                                      granularity      &#61;&gt; &#39;ALL&#39;&#10;                                      --degree           &#61;&gt; 1&#10;                                  );&#10;END do_table_stats;&#10;--&#10;&#10;--&#10;-- POST LOAD subroutines&#10;--&#10;PROCEDURE do_update_current_tier(p_cms VARCHAR2, p_arcd VARCHAR2) IS&#10;BEGIN&#10;  --&#10;  Initialise(p_cms, p_arcd);&#10;  --&#10;  UPDATE Offender O SET&#10;    O.current_tier &#61; ( SELECT   MT.tier_id&#10;                       FROM management_tier MT&#10;                       WHERE MT.offender_id &#61; O.offender_id&#10;                         AND MT.soft_deleted &#61; 0&#10;                         AND MT.date_changed &#61; ( SELECT MAX(date_changed)&#10;                                                 FROM   management_tier MT2&#10;                                                 WHERE MT2.offender_id &#61; MT.offender_id )&#10;                         AND ROWNUM &lt;&#61; 1 )&#10;  WHERE O.offender_id BETWEEN g_sidv AND g_eidv;&#10;  --&#10;END do_update_current_tier;&#10;--&#10;-- PDT_AREA PIPELINED FUNCTION&#10;--&#10;FUNCTION PDT_area RETURN ttab_PDT_AREA PIPELINED&#10;IS&#10;  --&#10;  l_idx INTEGER :&#61; 0;&#10;  l_rec trec_PDT_AREA;&#10;  TYPE ttab IS TABLE OF trec_PDT_AREA INDEX BY BINARY_INTEGER;&#10;  l_tab ttab;&#10;  --&#10;  PROCEDURE do_add_rec(p_arcd VARCHAR2, p_cms VARCHAR2) IS&#10;  BEGIN&#10;      l_rec.arcd :&#61; p_arcd;&#10;      l_rec.cms  :&#61; p_cms;&#10;      --&#10;      l_idx :&#61; l_idx + 1;&#10;      l_tab(l_idx) :&#61; l_rec;&#10;  END do_add_rec;&#10;  --&#10;  PROCEDURE do_init IS&#10;  BEGIN&#10;      do_add_rec(&#39;ASP&#39;, &#39;IIMS&#39;);&#10;      do_add_rec(&#39;BED&#39;, &#39;ICMS&#39;);&#10;      do_add_rec(&#39;CBS&#39;, &#39;ICMS&#39;);&#10;      do_add_rec(&#39;CHS&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;CMB&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;DBS&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;DCP&#39;, &#39;INCASE&#39;);&#10;      do_add_rec(&#39;DPP&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;DRH&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;DRS&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;ESX&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;GCS&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;GWT&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;HBS&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;HFS&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;HPS&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;KNT&#39;, &#39;ICMS&#39;);&#10;      do_add_rec(&#39;LCS&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;LDN&#39;, &#39;DELIUS&#39;);&#10;      do_add_rec(&#39;LNS&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;LTS&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;MCG&#39;, &#39;DELIUS&#39;);&#10;      do_add_rec(&#39;MLW&#39;, &#39;DELIUS&#39;);&#10;      do_add_rec(&#39;MRS&#39;, &#39;DELIUS&#39;);&#10;      do_add_rec(&#39;NBR&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;NFK&#39;, &#39;ICMS&#39;);&#10;      do_add_rec(&#39;NHS&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;NTS&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;SFK&#39;, &#39;ICMS&#39;);&#10;      do_add_rec(&#39;SRY&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;SSX&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;SSX&#39;, &#39;ICMS&#39;);&#10;      do_add_rec(&#39;STF&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;SWS&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;TES&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;TVP&#39;, &#39;ICMS&#39;);&#10;      do_add_rec(&#39;WMP&#39;, &#39;DELIUS&#39;);&#10;      do_add_rec(&#39;WSN&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;WTS&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;WWS&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;YSN&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;YSS&#39;, &#39;CRAMS&#39;);&#10;      do_add_rec(&#39;YSW&#39;, &#39;CRAMS&#39;);&#10;  END do_init;&#10;  --&#10;BEGIN&#10;  do_init;&#10;  FOR l_idx IN 1..l_tab.COUNT LOOP&#10;      PIPE ROW(l_tab(l_idx));&#10;  END LOOP;&#10;END PDT_area;&#10;&#10;-- -----------------------------------&#10;-- Multi-thread Support subroutines --&#10;--------------------------------------&#10;--&#10;-- Dead thread detection support subroutines&#10;--&#10;PROCEDURE get_current_session_details(p_inst_name IN OUT VARCHAR2, p_sid IN OUT NUMBER, p_serial# IN OUT NUMBER)&#10;IS&#10;BEGIN&#10;    EXECUTE IMMEDIATE &#39;SELECT sid, serial#&#10;                        FROM v$session&#10;                        WHERE sid &#61; SYS_CONTEXT(&#39;&#39;USERENV&#39;&#39;, &#39;&#39;SID&#39;&#39;)&#39;&#10;    INTO p_sid, p_serial#;&#10;    --&#10;    EXECUTE IMMEDIATE &#39;SELECT instance_name FROM v$instance&#39;&#10;    INTO p_inst_name;&#10;    --&#10;END get_current_session_details;&#10;--&#10;FUNCTION check_heartbeat(p_component_id NUMBER, p_thread_id NUMBER) RETURN BOOLEAN&#10;IS&#10;    l_sid       NUMBER;&#10;    l_serial#   NUMBER;&#10;    l_inst_id   NUMBER;&#10;    --&#10;    l_heartbeat_int  INTEGER;&#10;    l_heartbeat_flag BOOLEAN :&#61; FALSE;&#10;    l_sid_count      INTEGER;&#10;BEGIN&#10;    EXECUTE IMMEDIATE&#10;       &#39;SELECT /*+PARALLEL(PDT_thread, 1)*/&#10;         (CASE WHEN T.last_heartbeat_dt &gt;&#61; NVL(T.last_heartbeat_check_dt, TO_DATE(&#39;&#39;01/01/1900&#39;&#39;, &#39;&#39;dd/mm/yyyy&#39;&#39;)) THEN 1 ELSE 0 END) HEARTBEAT_FLAG,&#10;         T.sid, T.serial#, I.inst_id&#10;        FROM PDT_thread T, gv$instance I&#10;        WHERE T.component_id  &#61; :p_component_id&#10;          AND T.thread_id     &#61; :p_thread_id&#10;          AND I.instance_name &#61; T.instance_name&#10;          AND ROWNUM &lt;&#61; 1&#39;&#10;    INTO l_heartbeat_int, l_sid, l_serial#, l_inst_id&#10;    USING p_component_id, p_thread_id;&#10;    --&#10;    IF l_heartbeat_int &#61; 1 THEN&#10;        l_heartbeat_flag :&#61; TRUE;&#10;    END IF;&#10;    --&#10;    IF NOT l_heartbeat_flag THEN&#10;        EXECUTE IMMEDIATE &#39;SELECT COUNT(1)&#10;                           FROM gv$session&#10;                           WHERE sid     &#61; :p_sid&#10;                             AND serial# &#61; :p_serial&#10;                             AND inst_id &#61; :p_inst_id&#10;                             AND NVL(UPPER(status), &#39;&#39;X&#39;&#39;) !&#61; &#39;&#39;KILLED&#39;&#39;&#39;&#10;        INTO l_sid_count&#10;        USING l_sid, l_serial#, l_inst_id;&#10;        --&#10;        IF l_sid_count &gt; 0 THEN&#10;            l_heartbeat_flag :&#61; TRUE;&#10;        END IF;&#10;        --&#10;    END IF;&#10;    --&#10;    exec_sql_atnm(&#10;        &#39;UPDATE /*+PARALLEL(PDT_thread, 1)*/ PDT_thread SET last_heartbeat_check_dt &#61; SYSDATE WHERE component_id &#61; :component_id AND thread_id &#61; :thread_id&#39;,&#10;        p_param_1 &#61;&gt; p_component_id,&#10;        p_param_2 &#61;&gt; p_thread_id);&#10;    --&#10;    RETURN l_heartbeat_flag;&#10;    --&#10;END check_heartbeat;&#10;--&#10;PROCEDURE check_heartbeat_ALL(p_component_id INTEGER)&#10;IS&#10;    --&#10;    l_component_id INTEGER;&#10;    l_thread_id    INTEGER;&#10;    --&#10;    TYPE l_cur_TYP IS REF CURSOR;&#10;    cs l_cur_TYP;&#10;    --&#10;BEGIN&#10;    --COMMIT;&#10;    --&#10;    OPEN cs FOR&#10;       &#39;SELECT /*+PARALLEL(PDT_thread, 1)*/ component_id, thread_id&#10;        FROM PDT_thread&#10;        WHERE component_id &#61; :p_component_id&#10;          AND status &#61; 1&#39;&#10;    USING p_component_id;&#10;    LOOP&#10;        FETCH cs INTO l_component_id, l_thread_id;&#10;        EXIT WHEN cs%NOTFOUND;&#10;        --&#10;        IF ( get_thread_status(p_component_id &#61;&gt; l_component_id, p_thread_id &#61;&gt; l_thread_id) &#61; 1 ) AND&#10;           ( NOT check_heartbeat(p_component_id &#61;&gt; l_component_id, p_thread_id &#61;&gt; l_thread_id)   )&#10;        THEN&#10;            update_thread_status( p_component_id &#61;&gt; l_component_id,&#10;                                  p_thread_id &#61;&gt; l_thread_id,&#10;                                  p_status &#61;&gt; 2,&#10;                                  p_err_msg &#61;&gt; &#39;Dead thread detected [&#39; || TO_CHAR(l_component_id) || &#39;:&#39; || TO_CHAR(l_thread_id) || &#39;]&#39;,&#10;                                  p_info_msg  &#61;&gt; &#39;&#39;);&#10;            --&#10;            warn( p_err_msg &#61;&gt; &#39;Dead thread detected [&#39; || TO_CHAR(l_component_id) || &#39;:&#39; || TO_CHAR(l_thread_id) || &#39;]&#39; );&#10;        END IF;&#10;    END LOOP;&#10;    CLOSE cs;&#10;END check_heartbeat_ALL;&#10;--&#10;PROCEDURE create_thread_process(&#10;    p_component_id    INTEGER,&#10;    p_thread_id       INTEGER,&#10;    p_min_id_val      INTEGER,&#10;    p_max_id_val      INTEGER,&#10;    p_program_action  VARCHAR2,&#10;    p_job_name        VARCHAR2 DEFAULT NULL,&#10;    p_thread_label    VARCHAR2 DEFAULT NULL,&#10;    p_instance_number INTEGER  DEFAULT 1 )&#10;IS&#10;    --&#10;    TYPE l_cur_TYP IS REF CURSOR;&#10;    cs l_cur_TYP;&#10;    --&#10;    l_status INTEGER;&#10;    --&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;CREATE_THREAD_PROCESS&#39;;&#10;    l_prog_name VARCHAR2(100);&#10;    l_job_name  VARCHAR2(100);&#10;BEGIN&#10;    --&#10;    g_component_code :&#61; p_component_id;&#10;    --&#10;    IF p_thread_id &lt; 1 THEN&#10;        raise_error(&#39;P_THREAD_ID parameter value must be &gt; than 0&#39;, l_proc);&#10;    END IF;&#10;    --&#10;    -- Check if there are any residual records for the current Thread ID&#10;    --&#10;    OPEN cs FOR&#10;       &#39;SELECT /*+PARALLEL(PDT_thread, 1)*/ status&#10;        FROM PDT_thread&#10;        WHERE component_id &#61; :p_component_id&#10;          AND thread_id &#61; :p_thread_id&#39;&#10;    USING p_component_id, p_thread_id;&#10;    FETCH cs INTO l_status;&#10;    IF cs%NOTFOUND THEN&#10;        l_status :&#61; 0;&#10;    END IF;&#10;    CLOSE cs;&#10;    IF l_status &#61; 1 THEN&#10;        raise_error(&#39;P_THREAD_ID [&#39; || p_thread_id || &#39;] is still running - please check the PDT_THREAD table&#39;, l_proc);&#10;    ELSIF l_status &lt;&gt; 0 THEN&#10;        -- Remove record if status in (2,3)&#10;        exec_SQL_atnm(&#39;DELETE /*+PARALLEL(PDT_thread, 1)*/ FROM PDT_thread WHERE component_id &#61; :p_component_id AND thread_id &#61; :p_thread_id&#39;,&#10;            p_param_1&#61;&gt;p_component_id, p_param_2&#61;&gt;p_thread_id);&#10;    END IF;&#10;    --&#10;    exec_SQL_atnm(&#10;       &#39;INSERT INTO /*+PARALLEL(PDT_thread, 1)*/ PDT_thread (&#10;          component_id,&#10;          thread_id,&#10;          status,&#10;          start_id_val,&#10;          end_id_val,&#10;          num_of_rows,&#10;          start_date,&#10;          finish_date,&#10;          program_action,&#10;          thread_label,&#10;          --&#10;          instance_name,&#10;          sid,&#10;          serial#,&#10;          last_heartbeat_dt&#10;          --&#10;        ) VALUES (&#10;          :p_component_id,&#10;          :p_thread_id,&#10;          1,&#10;          :p_min_id_val,&#10;          :p_max_id_val,&#10;          0,&#10;          SYSDATE,&#10;          NULL,&#10;          SUBSTR(:p_program_action, 1, 4000),&#10;          SUBSTR(:p_thread_label, 1, 100),&#10;          --&#10;          NULL /*instance_name*/,&#10;          NULL /*sid*/,&#10;          NULL /*serial#*/,&#10;          SYSDATE /*last_heartbeat_dt*/ )&#39;,&#10;        --&#10;        p_param_1 &#61;&gt; p_component_id,&#10;        p_param_2 &#61;&gt; p_thread_id,&#10;        p_param_3 &#61;&gt; p_min_id_val,&#10;        p_param_4 &#61;&gt; p_max_id_val,&#10;        p_param_5 &#61;&gt; p_program_action,&#10;        p_param_6 &#61;&gt; p_thread_label&#10;    );&#10;    --&#10;    -- Create DBMS_SCHEDULE job&#10;    l_prog_name :&#61; &#39;PDT_&#39; || p_component_id || &#39;_&#39; || p_thread_id;&#10;    l_job_name  :&#61; l_prog_name;&#10;    IF p_job_name IS NOT NULL THEN&#10;        l_job_name :&#61; SUBSTR(l_job_name || &#39;_&#39; || p_job_name, 1, 30);&#10;    END IF;&#10;    --&#10;    -- Drop the program in case if it does already exist&#10;    BEGIN&#10;       DBMS_SCHEDULER.drop_program(program_name &#61;&gt; l_prog_name, force &#61;&gt; TRUE);&#10;    EXCEPTION WHEN OTHERS THEN&#10;        NULL;&#10;    END;&#10;    -- Drop the job in case if it does already exist&#10;    BEGIN&#10;        DBMS_SCHEDULER.drop_job(job_name &#61;&gt; l_job_name, force &#61;&gt; TRUE);&#10;    EXCEPTION WHEN OTHERS THEN&#10;        NULL;&#10;    END;&#10;&#10;    -- Create the regular job&#10;    DBMS_SCHEDULER.create_job(&#10;        job_name        &#61;&gt; l_job_name,&#10;        job_type        &#61;&gt; &#39;PLSQL_BLOCK&#39;,&#10;        job_action      &#61;&gt; p_program_action,&#10;        comments        &#61;&gt; &#39;C&#39; || p_component_id || &#39; parallel worker (thread# &#39; || p_thread_id || &#39;)&#39;,&#10;        --&#10;        enabled    &#61;&gt; FALSE,&#10;        auto_drop  &#61;&gt; TRUE );&#10;    --&#10;    IF p_instance_number IS NOT NULL THEN&#10;        -- Set job attribute to single instance number&#10;        DBMS_SCHEDULER.set_attribute(&#10;            name      &#61;&gt; l_job_name,&#10;            attribute &#61;&gt; &#39;instance_id&#39;,&#10;            value     &#61;&gt; p_instance_number);&#10;    END IF;&#10;    --&#10;    -- Enable job&#10;    DBMS_SCHEDULER.enable(l_job_name);&#10;    --&#10;END create_thread_process;&#10;--&#10;PROCEDURE update_thread_progress(p_component_id INTEGER, p_thread_id INTEGER, p_rows INTEGER, p_info_msg VARCHAR2 DEFAULT NULL)&#10;IS&#10;    --&#10;    l_inst_name VARCHAR2(30);&#10;    l_sid       NUMBER;&#10;    l_serial#   NUMBER;&#10;    --&#10;BEGIN&#10;    --&#10;    g_component_code :&#61; p_component_id;&#10;    get_current_session_details(l_inst_name, l_sid, l_serial#);&#10;    --&#10;    exec_SQL_atnm(&#10;       &#39;UPDATE /*+PARALLEL(PDT_thread, 1)*/ PDT_thread SET&#10;          num_of_rows       &#61; :p_rows,&#10;          info_message      &#61; :p_info_msg,&#10;          --&#10;          instance_name     &#61; :p_inst_name,&#10;          sid               &#61; :p_sid,&#10;          serial#           &#61; :p_serial,&#10;          last_heartbeat_dt &#61; SYSDATE&#10;          --&#10;        WHERE component_id &#61; :p_component_id&#10;          AND thread_id &#61; :p_thread_id&#39;,&#10;        --&#10;        p_param_1 &#61;&gt; p_rows,&#10;        p_param_2 &#61;&gt; p_info_msg,&#10;        p_param_3 &#61;&gt; l_inst_name,&#10;        p_param_4 &#61;&gt; l_sid,&#10;        p_param_5 &#61;&gt; l_serial#,&#10;        p_param_6 &#61;&gt; p_component_id,&#10;        p_param_7 &#61;&gt; p_thread_id&#10;    );&#10;END update_thread_progress;&#10;--&#10;PROCEDURE reset_threads(p_component_id INTEGER, p_thread_id INTEGER DEFAULT NULL) IS&#10;BEGIN&#10;    g_component_code :&#61; p_component_id;&#10;    exec_SQL_atnm(&#10;       &#39;DELETE /*+PARALLEL(PDT_thread, 1)*/ FROM PDT_thread&#10;        WHERE component_id &#61; :p_component_id AND thread_id &#61; NVL(:p_thread_id, thread_id)&#39;,&#10;        --&#10;        p_param_1 &#61;&gt; p_component_id,&#10;        p_param_2 &#61;&gt; p_thread_id&#10;    );&#10;END reset_threads;&#10;&#10;--&#10;-- This function is in preparation for coding round robin multi-threading&#10;--&#10;-- When called the function will return the next available thread_id which&#10;-- can then be used by the CREATE_THREAD_PROCESS.&#10;-- The function has three exit points&#10;--         1) Thread available&#10;--               returns thread_id&#10;--         2) Timeout&#10;--               returns 0 if processing time exceeds timeout parameter&#10;--         3) Semaphore&#10;--               raises error if &#39;STOP&#39; is committed to PDT_SEMAPHORE table&#10;--&#10;-- The p_wait configuration is the amount of time the functions sleeps between&#10;-- checking for available threads. If p_timeout is set &lt;&#61; 0 then the function&#10;-- will not timeout.&#10;--&#10;FUNCTION get_available_thread(&#10;    p_component_id INTEGER,&#10;    p_wait         INTEGER DEFAULT 10,&#10;    p_timeout      INTEGER DEFAULT 30,&#10;    p_max_threads  INTEGER DEFAULT 0)&#10;RETURN INTEGER&#10;IS&#10;    TYPE l_cur_TYP IS REF CURSOR;&#10;    cs l_cur_TYP;&#10;    --&#10;    l_max_threads       INTEGER;&#10;    l_available_thread  INTEGER :&#61; 0;&#10;    l_thread_count      INTEGER :&#61; 0;&#10;    l_wait              INTEGER;&#10;    l_start             NUMBER;&#10;    --&#10;    l_loop_count        INTEGER :&#61; 0;&#10;    --&#10;BEGIN&#10;    IF p_max_threads &lt;&#61; 0 THEN&#10;        l_max_threads :&#61; get_cpu_count;&#10;    ELSE&#10;        l_max_threads :&#61; LEAST(p_max_threads, get_cpu_count * 4 * get_db_inst_count);&#10;    END IF;&#10;    --&#10;    l_start :&#61; DBMS_UTILITY.get_time;&#10;    l_wait  :&#61; GREATEST(LEAST(60, p_wait), 1);&#10;    --&#10;    EXECUTE IMMEDIATE &#39;SELECT /*+PARALLEL(PDT_thread, 1)*/ COUNT(1) FROM PDT_thread WHERE component_id &#61; :p_component_id&#39;&#10;    INTO l_thread_count USING p_component_id;&#10;    --&#10;    IF l_thread_count &#61; 0 THEN&#10;        l_available_thread :&#61; 1;&#10;    ELSIF l_thread_count &lt; l_max_threads THEN&#10;        l_available_thread :&#61; l_thread_count + 1;&#10;    ELSE&#10;        LOOP&#10;            OPEN cs FOR&#10;               &#39;SELECT /*+PARALLEL(PDT_thread, 1)*/ thread_id&#10;                FROM PDT_thread&#10;                WHERE component_id &#61; :p_component_id&#10;                AND ( ( finish_date IS NULL AND status &lt;&gt; 1 ) OR ( finish_date IS NOT NULL AND status &#61; 2 ) OR ( finish_date IS NOT NULL AND status &#61; 3 ) )&#39;&#10;            USING p_component_id;&#10;            FETCH cs INTO l_available_thread;&#10;            IF cs%NOTFOUND THEN&#10;                l_available_thread :&#61; 0;&#10;            END IF;&#10;            CLOSE cs;&#10;            --&#10;            l_loop_count :&#61; l_loop_count + 1;&#10;            IF MOD(l_loop_count, 10) &#61; 0 THEN&#10;                check_heartbeat_ALL(p_component_id);&#10;            END IF;&#10;            --&#10;            EXIT WHEN l_available_thread &gt; 0;&#10;            --&#10;            -- Wait for a number of seconds (default 10)&#10;            SYS.DBMS_LOCK.sleep(l_wait);&#10;            --&#10;            -- Exit if the semaphore flag is set&#10;            IF check_semaphore(p_component_id, &#39;STOP&#39;) &#61; &#39;Y&#39; THEN&#10;                raise_error(&#39;WARNING: STOP signal has been detected in PDT_SEMAPHORE&#39;, &#39;GET_AVAILABLE_THREAD&#39;);&#10;            END IF;&#10;            --&#10;            -- Exit and return 0 if thread unavailable after timeout (default 30 minutes)&#10;            IF ((DBMS_UTILITY.get_time - l_start) / 100) / 60 &gt; p_timeout AND p_timeout &gt; 0 THEN&#10;                l_available_thread :&#61; -1;&#10;                EXIT;&#10;            END IF;&#10;        END LOOP;&#10;    END IF;&#10;    --&#10;    RETURN l_available_thread;&#10;END get_available_thread;&#10;--&#10;FUNCTION get_thread_status(p_component_id INTEGER, p_thread_id INTEGER) RETURN INTEGER&#10;IS&#10;    TYPE l_cur_TYP IS REF CURSOR;&#10;    cs l_cur_TYP;&#10;    l_status INTEGER;&#10;BEGIN&#10;    --&#10;    g_component_code :&#61; p_component_id;&#10;    --&#10;    OPEN cs FOR&#10;       &#39;SELECT /*+PARALLEL(PDT_thread, 1)*/ status&#10;        FROM PDT_thread&#10;        WHERE component_id &#61; :p_component_id&#10;          AND thread_id &#61; :p_thread_id&#39;&#10;    USING p_component_id, p_thread_id&#10;    ;&#10;    FETCH cs INTO l_status;&#10;    IF cs%NOTFOUND THEN&#10;        l_status :&#61; 2;&#10;    END IF;&#10;    CLOSE cs;&#10;    --&#10;    RETURN l_status;&#10;END get_thread_status;&#10;--&#10;FUNCTION get_num_of_failed_threads(p_component_id INTEGER) RETURN INTEGER&#10;IS&#10;    l_cnt INTEGER;&#10;BEGIN&#10;    g_component_code :&#61; p_component_id;&#10;    --&#10;    EXECUTE IMMEDIATE &#39;SELECT /*+PARALLEL(PDT_thread, 1)*/ COUNT(1) FROM PDT_thread WHERE component_id &#61; :p_component_id AND NVL(status, 2) NOT IN (1, 3)&#39;&#10;    INTO l_cnt USING p_component_id;&#10;    --&#10;    RETURN l_cnt;&#10;END get_num_of_failed_threads;&#10;--&#10;PROCEDURE update_thread_status(p_component_id INTEGER, p_thread_id INTEGER, p_status INTEGER, p_err_msg VARCHAR2 DEFAULT NULL, p_info_msg VARCHAR2 DEFAULT NULL)&#10;IS&#10;    l_inst_name VARCHAR2(30);&#10;    l_sid       NUMBER;&#10;    l_serial#   NUMBER;&#10;BEGIN&#10;    --&#10;    g_component_code :&#61; p_component_id;&#10;    get_current_session_details(l_inst_name, l_sid, l_serial#);&#10;    --&#10;    exec_SQL_atnm(&#10;       &#39;UPDATE /*+PARALLEL(PDT_thread, 1)*/ PDT_thread SET&#10;          status        &#61; :p_status,&#10;          finish_date   &#61; DECODE(:p_status, 1, NULL, SYSDATE),&#10;          error_message &#61; NVL(SUBSTRB(:p_err_msg, 1, 4000), error_message),&#10;          info_message  &#61; NVL(SUBSTRB(:p_info_msg, 1, 4000), info_message),&#10;          --&#10;          instance_name     &#61; :p_inst_name,&#10;          sid               &#61; :p_sid,&#10;          serial#           &#61; :p_serial,&#10;          last_heartbeat_dt &#61; SYSDATE&#10;          --&#10;        WHERE component_id &#61; :p_component_id&#10;          AND thread_id &#61; :p_thread_id&#39;,&#10;        --&#10;        p_param_1 &#61;&gt; p_status,&#10;        p_param_2 &#61;&gt; p_status,&#10;        p_param_3 &#61;&gt; p_err_msg,&#10;        p_param_4 &#61;&gt; p_info_msg,&#10;        p_param_5 &#61;&gt; l_inst_name,&#10;        p_param_6 &#61;&gt; l_sid,&#10;        p_param_7 &#61;&gt; l_serial#,&#10;        p_param_8 &#61;&gt; p_component_id,&#10;        p_param_9 &#61;&gt; p_thread_id );&#10;END update_thread_status;&#10;--&#10;PROCEDURE wait_for_threads_to_finish(p_component_id INTEGER, p_thread_id INTEGER DEFAULT -1, p_wait INTEGER DEFAULT 5)&#10;IS&#10;    --&#10;    l_cnt           INTEGER;&#10;    l_wait          INTEGER;&#10;    l_loop_count    INTEGER;&#10;    l_component_id  NUMBER;&#10;    l_thread_id     NUMBER;&#10;    l_proc          VARCHAR2(30) :&#61; &#39;WAIT_FOR_THREADS_TO_FINISH&#39;;&#10;    l_label         VARCHAR2(10);&#10;    --&#10;BEGIN&#10;    l_label :&#61; &#39;10000&#39;;&#10;    --&#10;    g_component_code :&#61; p_component_id;&#10;    --&#10;    l_cnt :&#61; 0;&#10;    l_loop_count :&#61; 0;&#10;    l_wait :&#61; GREATEST(LEAST(60, p_wait), 1);&#10;    --&#10;    LOOP&#10;        --&#10;        BEGIN&#10;            l_label :&#61; &#39;10000&#39;;&#10;            EXECUTE IMMEDIATE&#10;               &#39;SELECT /*+PARALLEL(PDT_thread, 1)*/ COUNT(1)&#10;                FROM PDT_thread&#10;                WHERE component_id &#61; :p_component_id&#10;                  AND (thread_id &#61; :p_thread_id OR :p_thread_id &#61; -1)&#10;                  AND status &#61; 1&#39;&#10;            INTO l_cnt USING p_component_id, p_thread_id, p_thread_id;&#10;            --&#10;            l_label :&#61; &#39;10010&#39;;&#10;            l_loop_count :&#61; l_loop_count + 1;&#10;            l_label :&#61; &#39;10020&#39;;&#10;            IF MOD(l_loop_count,10) &#61; 0 THEN&#10;                l_label :&#61; &#39;10030&#39;;&#10;                check_heartbeat_ALL(p_component_id);&#10;            END IF;&#10;            --&#10;            l_label :&#61; &#39;10040&#39;;&#10;            EXIT WHEN l_cnt &#61; 0;&#10;        EXCEPTION&#10;            WHEN OTHERS THEN&#10;              SPGCONFIG.debug(&#39;Error raised waiting for threads [pcomponent_id &#61;&gt; &#39; || p_component_id || &#39;][p_thread_id &#61;&gt; &#39; || p_thread_id || &#39;][p_wait &#61;&gt; &#39; || p_wait || &#39;] &#39; || SQLERRM );&#10;        END;&#10;        --&#10;        SYS.DBMS_LOCK.sleep(l_wait);&#10;    END LOOP;&#10;END wait_for_threads_to_finish;&#10;--&#10;PROCEDURE stop_all_threads(p_component_id INTEGER) IS&#10;BEGIN&#10;    --&#10;    g_component_code :&#61; p_component_id;&#10;    --&#10;    exec_SQL_atnm(&#10;       &#39;UPDATE /*+PARALLEL(PDT_thread, 1)*/ PDT_thread SET status &#61; 2, finish_date &#61; SYSDATE WHERE component_id &#61; :p_component_id&#39;,&#10;       p_param_1 &#61;&gt; p_component_id&#10;    );&#10;END stop_all_threads;&#10;--&#10;FUNCTION check_semaphore(p_component_code VARCHAR2, p_signal VARCHAR2 DEFAULT &#39;STOP&#39;) RETURN VARCHAR2&#10;IS&#10;    l_ret VARCHAR2(1);&#10;BEGIN&#10;    EXECUTE IMMEDIATE &#39;SELECT COUNT(1) FROM PDT_semaphore WHERE component_code LIKE UPPER(:p_component_code) AND NVL(signal, &#39;&#39;STOP&#39;&#39;) &#61; :p_signal&#39;&#10;      INTO l_ret&#10;    USING p_component_code, p_signal;&#10;    --&#10;    RETURN NVL(l_ret, 0);&#10;EXCEPTION WHEN OTHERS THEN&#10;    RETURN 0;&#10;END check_semaphore;&#10;--&#10;FUNCTION get_cpu_count RETURN INTEGER IS&#10;BEGIN&#10;    RETURN&#10;        PKG_Lookups.funcgetTabRecord(&#10;            p_table       &#61;&gt; &#39;V$PARAMETER&#39;,&#10;            p_data_fld    &#61;&gt; &#39;NVL(TRIM(value), 1)&#39;,&#10;            p_default_val &#61;&gt; 1,&#10;            p_ref_col     &#61;&gt; &#39;name&#39;,&#10;            p_ref_val     &#61;&gt; &#39;cpu_count&#39; );&#10;END get_cpu_count;&#10;--&#10;FUNCTION get_db_inst_count RETURN INTEGER&#10;IS&#10;BEGIN&#10;    RETURN&#10;        NVL(&#10;            PKG_Lookups.funcgetTabRecord(&#10;                p_table &#61;&gt; &#39;GV$INSTANCE&#39;,&#10;                p_data_fld &#61;&gt; &#39;COUNT(1)&#39;,&#10;                p_ref_col  &#61;&gt; &#39;status&#39;,&#10;                p_ref_val &#61;&gt; &#39;OPEN&#39; ),&#10;            1 );&#10;END get_db_inst_count;&#10;--&#10;PROCEDURE PDT_bulk_load_data(&#10;    p_table_name    VARCHAR2,&#10;    p_source_table  VARCHAR2,&#10;    p_target_table  VARCHAR2,&#10;    p_pk_fld        VARCHAR2,&#10;    p_order_by      VARCHAR2 DEFAULT NULL,&#10;    p_component_id  INTEGER DEFAULT 998001 )&#10;IS&#10;    --&#10;    l_component_id INTEGER :&#61; p_component_id;&#10;    l_max_threads  INTEGER :&#61; get_cpu_count * 2;&#10;    --&#10;    TYPE l_cur_TYP IS REF CURSOR;&#10;    cs l_cur_TYP;&#10;    --&#10;    l_thread_id       INTEGER;&#10;    l_failed_threads  INTEGER;&#10;    l_instance_number INTEGER;&#10;    --&#10;    l_min_id_val INTEGER;&#10;    l_max_id_val INTEGER;&#10;    l_bucket_num INTEGER;&#10;    --&#10;    l_SQL VARCHAR2(32767);&#10;    --&#10;    PROCEDURE do_create_thread_process(p_thread_id INTEGER, p_min_id INTEGER, p_max_id INTEGER, p_instance_number INTEGER)&#10;    IS&#10;    BEGIN&#10;        IF NOT p_thread_id BETWEEN 1 AND l_max_threads THEN&#10;            raise_application_error(-20001, &#39;WARNING: can not create the thread [&#39; || p_thread_id || &#39;] - thread# must be within the [1 .. &#39; || l_max_threads || &#39;] range&#39;);&#10;            RETURN;&#10;        END IF;&#10;        --&#10;        IF p_min_id IS NOT NULL AND p_max_id IS NOT NULL THEN&#10;            create_thread_process(&#10;                p_component_id &#61;&gt; l_component_id,&#10;                p_thread_id    &#61;&gt; p_thread_id,&#10;                p_min_id_val   &#61;&gt; p_min_id,&#10;                p_max_id_val   &#61;&gt; p_max_id,&#10;                p_program_action &#61;&gt;&#10;                   &#39;DECLARE&#10;                        g_thread_id    INTEGER :&#61; &#39; || p_thread_id    || &#39;;&#10;                        g_component_code INTEGER :&#61; &#39; || l_component_id || &#39;;&#10;                        g_limit        INTEGER :&#61; 500;&#10;                        l_rows         INTEGER :&#61; 0;&#10;                        --&#10;                        CURSOR cs IS&#10;                          SELECT &#39; || g_tab_info(p_table_name).fld_lst_1 || &#39;&#10;                          FROM &#39; || p_source_table || &#39;&#10;                          WHERE &#39; || p_pk_fld || &#39; BETWEEN &#39; || p_min_id || &#39; AND &#39; || p_max_id || &#39;&#10;                          ORDER BY &#39; || NVL(p_order_by, p_pk_fld) || &#39;;&#10;                        --&#10;                        TYPE l_tab_typ IS TABLE OF &#39; || p_source_table || &#39;%ROWTYPE;&#10;                        --&#10;                        l_tab l_tab_TYP;&#10;                        l_cnt NUMBER :&#61; 0;&#10;                        l_idx NUMBER :&#61; 0;&#10;                        --&#10;                        PROCEDURE update_thread_status(p_status INTEGER, p_err_msg VARCHAR2 DEFAULT NULL) IS&#10;                        BEGIN&#10;                            C08001_PDT_SUPPORT.update_thread_status(&#10;                                p_component_id &#61;&gt; g_component_code,&#10;                                p_thread_id    &#61;&gt; g_thread_id,&#10;                                p_status       &#61;&gt; p_status,&#10;                                p_err_msg      &#61;&gt; p_err_msg);&#10;                        END update_thread_status;&#10;                        --&#10;                        PROCEDURE update_thread_progress(p_rows INTEGER, p_info_msg VARCHAR2 DEFAULT NULL) IS&#10;                        BEGIN&#10;                            C08001_PDT_SUPPORT.update_thread_progress(&#10;                                p_component_id &#61;&gt; g_component_code,&#10;                                p_thread_id    &#61;&gt; g_thread_id,&#10;                                p_rows         &#61;&gt; p_rows,&#10;                                p_info_msg     &#61;&gt; p_info_msg);&#10;                        END update_thread_progress;&#10;                        --&#10;                    BEGIN&#10;                        update_thread_status(1);&#10;                        OPEN cs;&#10;                        LOOP&#10;                            FETCH cs BULK COLLECT INTO l_tab LIMIT g_limit;&#10;                            EXIT WHEN l_tab.COUNT &#61; 0;&#10;                            --&#10;                            l_cnt :&#61; l_cnt + l_tab.COUNT;&#10;                            --&#10;                            FORALL l_idx IN l_tab.FIRST .. l_tab.LAST&#10;                                INSERT INTO &#39; || p_target_table || &#39;(&#10;                                &#39; || g_tab_info(p_table_name).fld_lst || &#39; )&#10;                                VALUES l_tab(l_idx);&#10;                            COMMIT;&#10;                            --&#10;                            l_rows :&#61; l_rows + l_tab.COUNT;&#10;                            update_thread_progress(l_rows);&#10;                            --&#10;                        END LOOP;&#10;                        CLOSE cs;&#10;                        update_thread_status(3);&#10;                    EXCEPTION WHEN OTHERS THEN&#10;                        update_thread_status(2, &#39;&#39;Fatal error exception: &#39;&#39; || SQLERRM);&#10;                    END;&#39;,&#10;                p_instance_number &#61;&gt; p_instance_number&#10;            );&#10;        ELSE&#10;            raise_application_error(-20001,&#10;                &#39;WARNING: THREAD# &#39; || p_thread_id ||&#10;                &#39; can not be initialised due to incorrect &#39; || UPPER(p_pk_fld) || &#39; values range [&#39; || l_min_id_val || &#39;][&#39; || l_max_id_val || &#39;]&#39;);&#10;        END IF;&#10;        --&#10;    END do_create_thread_process;&#10;    --&#10;BEGIN&#10;    l_SQL :&#61; &#39;SELECT instance_number FROM v$instance&#39;;&#10;    --&#10;    BEGIN&#10;        EXECUTE IMMEDIATE l_SQL INTO l_instance_number;&#10;    EXCEPTION WHEN OTHERS THEN&#10;        raise_application_error(-20001, &#39;Error in PDT_bulk_load_data: &#39; || SQLERRM || CHR(10) || l_SQL);&#10;    END;&#10;    --&#10;    --EXECUTE IMMEDIATE &#39;TRUNCATE TABLE &#39; || p_target_table || &#39; DROP STORAGE&#39;;&#10;    l_SQL :&#61;&#10;       &#39;SELECT MIN(&#39; || p_pk_fld || &#39;) min_id_val, MAX(&#39; || p_pk_fld || &#39;) max_id_val, bucket_num&#10;        FROM (SELECT NTILE(&#39; || l_max_threads || &#39;*25) OVER (ORDER BY &#39; || p_pk_fld || &#39;) AS bucket_num, &#39; || p_pk_fld || &#39; FROM &#39; || p_source_table || &#39; T)&#10;        GROUP BY bucket_num&#10;        ORDER BY bucket_num&#39;;&#10;    --&#10;    BEGIN&#10;        OPEN cs FOR l_SQL;&#10;    EXCEPTION WHEN OTHERS THEN&#10;        raise_application_error(-20001, &#39;ERROR in PDT_bulk_load_data: &#39; || SQLERRM || CHR(10) || l_SQL);&#10;    END;&#10;    LOOP&#10;        FETCH cs INTO l_min_id_val, l_max_id_val, l_bucket_num;&#10;        EXIT WHEN cs%NOTFOUND;&#10;        --&#10;        LOOP&#10;            -- Get next available thread&#10;            l_thread_id :&#61; get_available_thread(&#10;                               p_component_id &#61;&gt; l_component_id,&#10;                               p_wait         &#61;&gt; 5,&#10;                               p_timeout      &#61;&gt; 180,&#10;                               p_max_threads  &#61;&gt; l_max_threads);&#10;            EXIT WHEN l_thread_id &gt; 0;&#10;        END LOOP;&#10;        --&#10;        --message(&#39;CREATE_THREAD_PROCESS(&#39; || l_thread_id || &#39;, &#39; || l_rec.data_mapping_code || &#39;)&#39;);&#10;        do_create_thread_process(l_thread_id, l_min_id_val, l_max_id_val, l_instance_number);&#10;        COMMIT;&#10;        --&#10;        IF l_max_threads &gt; 1 THEN&#10;            l_failed_threads :&#61; get_num_of_failed_threads(p_component_id &#61;&gt; l_component_id);&#10;        ELSE&#10;            l_failed_threads :&#61; 0;&#10;        END IF;&#10;        IF l_failed_threads &gt; 0 THEN&#10;            raise_application_error(-20001, &#39;ERROR: There are &#39; || l_failed_threads || &#39; threads that have failed - please check the PDT_THREAD and PDT_DEBUG tables for more details&#39;);&#10;            EXIT;&#10;        END IF;&#10;        --&#10;    END LOOP;&#10;    CLOSE cs;&#10;    --&#10;    wait_for_threads_to_finish(p_component_id &#61;&gt; l_component_id);&#10;    --&#10;END PDT_bulk_load_data;&#10;--&#10;--&#10;PROCEDURE copy_documents(p_source_schema VARCHAR2, p_source_tns VARCHAR2, p_chunks INTEGER DEFAULT 25, p_parallel_level INTEGER DEFAULT 10, p_disable_constraints VARCHAR2 DEFAULT &#39;N&#39;)&#10;AS&#10;&#10;    l_sql_stmt      VARCHAR2(32767);&#10;    l_task_count    INTEGER;&#10;    l_object_count  INTEGER;&#10;    l_attempts      INTEGER;&#10;    l_return_value  BOOLEAN :&#61; FALSE;&#10;    l_label         VARCHAR2(10) :&#61; &#39;00000&#39;;&#10;    --&#10;    c_task_name   VARCHAR2(30) :&#61; &#39;COPY_DOCUMENTS_&#39; || UPPER(p_source_schema);&#10;    c_db_link     VARCHAR2(30) :&#61; &#39;DAS_TO_&#39; || p_source_schema || &#39;_DBLINK&#39;;&#10;    c_created     INTEGER :&#61; DBMS_PARALLEL_EXECUTE.created;&#10;    c_finished    INTEGER :&#61; DBMS_PARALLEL_EXECUTE.finished;&#10;    c_insert_stmt VARCHAR2(32767)&#10;        :&#61;  &#39;INSERT INTO document (DOCUMENT_ID,&#10;                OFFENDER_ID,&#10;                TABLE_NAME,&#10;                PRIMARY_KEY_ID,&#10;                DOCUMENT,&#10;                LAST_SAVED,&#10;                USER_ID,&#10;                STATUS,&#10;                WORK_IN_PROGRESS,&#10;                SOFT_DELETED,&#10;                PARTITION_AREA_ID,&#10;                ROW_VERSION,&#10;                TRAINING_SESSION_ID,&#10;                ORGANISATIONS)&#10;              SELECT * FROM document@&#39; || c_db_link || &#39;&#10;              WHERE document_id BETWEEN :start_id AND :end_id&#39;;&#10;&#10;    PROCEDURE debugMessage(p_msg VARCHAR2, p_err_flag VARCHAR2 DEFAULT &#39;N&#39;)&#10;    IS&#10;    BEGIN&#10;        C08001_PDT_SUPPORT.debugMessage(  p_msg       &#61;&gt; p_msg,&#10;                                          p_code_name &#61;&gt; c_task_name,&#10;                                          p_label     &#61;&gt; l_label,&#10;                                          p_err_flag  &#61;&gt; p_err_flag);&#10;    END debugMessage;&#10;&#10;    PROCEDURE action_constraints(p_table_name VARCHAR2, p_action VARCHAR2)&#10;    IS&#10;    BEGIN&#10;        FOR each_constraint IN (SELECT constraint_name, &#39;ALTER TABLE &#39; || table_name || &#39; &#39; || p_action || &#39; CONSTRAINT &#39; || constraint_name sql_stmt&#10;                                FROM user_constraints&#10;                                WHERE table_name &#61; p_table_name&#10;                                AND constraint_type IN (&#39;R&#39;))&#10;        LOOP&#10;            BEGIN&#10;                EXECUTE IMMEDIATE each_constraint.sql_stmt;&#10;                debugMessage(each_constraint.constraint_name || &#39; - &#39; || p_action || &#39;D&#39;);&#10;            EXCEPTION&#10;            WHEN OTHERS THEN&#10;                debugMessage(&#39;Failed to &#39; ||  p_action || &#39; constraint [&#39; || each_constraint.constraint_name || &#39;]&#39;);&#10;            END;&#10;        END LOOP;&#10;    END action_constraints;&#10;&#10;    PROCEDURE report(p_task_name VARCHAR2)&#10;    IS&#10;    BEGIN&#10;        FOR each_chunk IN (SELECT  &#39;[chunk_id -&gt; &#39; || chunk_id || &#39;][&#39; ||&#10;                                    &#39;[task_name -&gt; &#39; || task_name || &#39;][&#39; ||&#10;                                    &#39;[status -&gt; &#39; || status || &#39;][&#39; ||&#10;                                    &#39;[start_id -&gt; &#39; || start_id || &#39;][&#39; ||&#10;                                    &#39;[end_id -&gt; &#39; || end_id || &#39;][&#39; ||&#10;                                    &#39;[job_name -&gt; &#39; || job_name || &#39;][&#39; ||&#10;                                    &#39;[start_ts -&gt; &#39; || start_ts || &#39;][&#39; ||&#10;                                    &#39;[end_ts -&gt; &#39; || end_ts || &#39;]&#39; ||&#10;                                    NVL2(error_code, &#39;[error -&gt; &#39; || error_code || &#39; - &#39; || error_message || &#39;]&#39;, &#39;&#39;) debugMessage&#10;                            FROM user_parallel_execute_chunks&#10;                            WHERE task_name &#61; p_task_name&#10;                            ORDER BY chunk_id)&#10;        LOOP&#10;            debugMessage(each_chunk.debugMessage);&#10;            DBMS_OUTPUT.put_line (each_chunk.debugMessage);&#10;        END LOOP;&#10;    END report;&#10;&#10;&#10;BEGIN&#10;    debugMessage(&#39;++++++++++++++++++++++++++++++++++++++++++++++++++&#39;);&#10;    debugMessage(&#39;+++        STARTING DOCUMENT COPY              +++&#39;);&#10;    debugMessage(&#39;+++         &#39; || c_task_name || &#39;              +++&#39;);&#10;    debugMessage(&#39;++++++++++++++++++++++++++++++++++++++++++++++++++&#39;);&#10;    DBMS_OUTPUT.put_line (&#39;Commencing DOCUMENT load - &#39; || c_task_name || &#39; &#39; || sysdate);&#10;&#10;    -- STEP 0 - DISABLE CONSTRAINTS&#10;    l_label :&#61; &#39;00010&#39;;&#10;    IF p_disable_constraints &#61; &#39;Y&#39; THEN&#10;        action_constraints(&#39;DOCUMENT&#39;,&#39;DISABLE&#39;);&#10;    END IF;&#10;&#10;    -- STEP 1 - CREATE DATABASE LINK&#10;    l_label :&#61; &#39;00010&#39;;&#10;    debugMessage(&#39;Creating database link&#39;);&#10;    l_sql_stmt :&#61; &#39;SELECT COUNT(1)&#10;                   FROM user_objects&#10;                   WHERE object_type &#61; &#39;&#39;DATABASE LINK&#39;&#39;&#10;                   AND object_name &#61; :object_name&#39;;&#10;    EXECUTE IMMEDIATE l_sql_stmt&#10;    INTO l_object_count&#10;    USING c_db_link;&#10;&#10;    l_label :&#61; &#39;00020&#39;;&#10;    IF l_object_count &gt; 0 THEN&#10;        BEGIN&#10;          l_label :&#61; &#39;00030&#39;;&#10;           EXECUTE IMMEDIATE &#39;DROP DATABASE LINK &#39; || c_db_link;&#10;        EXCEPTION&#10;        WHEN OTHERS THEN&#10;            debugMessage(&#39;Error: &#39; || SQLERRM);&#10;            RAISE;&#10;        END;&#10;    END IF;&#10;&#10;    l_label :&#61; &#39;00040&#39;;&#10;    l_sql_stmt :&#61; &#39; CREATE DATABASE LINK &#39; || c_db_link || &#39;&#10;                  CONNECT TO &#39; || p_source_schema || &#39; IDENTIFIED BY &#39; || p_source_schema ||&#39;&#10;                  USING &#39;&#39;&#39; || p_source_tns || &#39;&#39;&#39;&#39;;&#10;    BEGIN&#10;        EXECUTE IMMEDIATE l_sql_stmt;&#10;    EXCEPTION&#10;    WHEN OTHERS THEN&#10;        debugMessage(&#39;Error: &#39; || SQLERRM);&#10;        RAISE;&#10;    END;&#10;&#10;    -- STEP 2 - CREATE TASK&#10;    l_label :&#61; &#39;00050&#39;;&#10;    debugMessage(&#39;Creating task [&#39; || c_task_name || &#39;]&#39;);&#10;    l_sql_stmt :&#61; &#39;SELECT COUNT(1) FROM user_parallel_execute_tasks WHERE task_name &#61; :task_name&#39;;&#10;    EXECUTE IMMEDIATE l_sql_stmt&#10;    INTO l_task_count&#10;    USING c_task_name;&#10;&#10;    l_label :&#61; &#39;00060&#39;;&#10;    BEGIN&#10;      IF l_task_count &gt; 0 THEN&#10;          l_label :&#61; &#39;00070&#39;;&#10;          DBMS_PARALLEL_EXECUTE.drop_task ( task_name &#61;&gt; c_task_name);&#10;      END IF;&#10;      l_label :&#61; &#39;00080&#39;;&#10;      DBMS_PARALLEL_EXECUTE.create_task ( task_name &#61;&gt; c_task_name);&#10;    EXCEPTION&#10;    WHEN OTHERS THEN&#10;        debugMessage(&#39;Error: &#39; || SQLERRM);&#10;        RAISE;&#10;    END;&#10;&#10;    -- STEP 3 - CREATE CHUNKS&#10;    l_label :&#61; &#39;00090&#39;;&#10;    debugMessage(&#39;Creating chunks&#39;);&#10;    l_sql_stmt :&#61; &#39; SELECT MIN(document_id) start_id, MAX(document_id) end_id&#10;                    FROM (SELECT NTILE(&#39; || p_chunks || &#39;) OVER (ORDER BY document_id) AS bucket_num, document_id FROM document@&#39; || c_db_link || &#39; T)&#10;                    GROUP BY bucket_num&#10;                    ORDER BY bucket_num&#39;;&#10;&#10;    BEGIN&#10;        DBMS_PARALLEL_EXECUTE.create_chunks_by_sql( task_name &#61;&gt; c_task_name,&#10;                                                    sql_stmt  &#61;&gt; l_sql_stmt,&#10;                                                    by_rowid  &#61;&gt; FALSE);&#10;    EXCEPTION&#10;    WHEN OTHERS THEN&#10;        debugMessage(&#39;Error: &#39; || SQLERRM);&#10;        RAISE;&#10;    END;&#10;&#10;    -- STEP 4 - Execute Threads&#10;    l_label :&#61; &#39;00100&#39;;&#10;    debugMessage(&#39;Executing task&#39;);&#10;    BEGIN&#10;        DBMS_PARALLEL_EXECUTE.run_task( task_name       &#61;&gt; c_task_name,&#10;                                        sql_stmt        &#61;&gt; c_insert_stmt,&#10;                                        language_flag   &#61;&gt; DBMS_SQL.NATIVE,&#10;                                        parallel_level  &#61;&gt; p_parallel_level);&#10;    EXCEPTION&#10;    WHEN OTHERS THEN&#10;        debugMessage(&#39;Error: &#39; || SQLERRM);&#10;        RAISE;&#10;    END;&#10;&#10;    -- STEP 5 - Wait For Threads To Complete&#10;    l_label :&#61; &#39;00110&#39;;&#10;    IF DBMS_PARALLEL_EXECUTE.task_status(task_name &#61;&gt; c_task_name) &#61; c_created THEN&#10;        LOOP&#10;            EXIT WHEN DBMS_PARALLEL_EXECUTE.task_status(task_name &#61;&gt; c_task_name) &#61; c_finished&#10;            OR l_attempts &gt; 1;&#10;            l_attempts :&#61; l_attempts + 1;&#10;            l_label :&#61; &#39;00120&#39;;&#10;            DBMS_PARALLEL_EXECUTE.resume_task(task_name &#61;&gt; c_task_name);&#10;        END LOOP;&#10;    END IF;&#10;&#10;    l_label :&#61; &#39;00130&#39;;&#10;    IF DBMS_PARALLEL_EXECUTE.task_status(task_name &#61;&gt; c_task_name) &#61; c_finished THEN&#10;        l_label :&#61; &#39;00140&#39;;&#10;        l_return_value :&#61; TRUE;&#10;    ELSE&#10;        l_label :&#61; &#39;00150&#39;;&#10;        debugMessage(&#39;Error raised while running threads - check errors&#39;,&#39;Y&#39;);&#10;        raise_error(p_err_msg &#61;&gt; &#39;Error raised while running threads - check errors&#39;, p_proc &#61;&gt; &#39;copy_documents&#39;, p_label &#61;&gt; l_label);&#10;    END IF;&#10;&#10;    l_label :&#61; &#39;00150&#39;;&#10;    IF p_disable_constraints &#61; &#39;Y&#39; THEN&#10;        action_constraints(&#39;DOCUMENT&#39;,&#39;ENABLE&#39;);&#10;    END IF;&#10;&#10;    BEGIN&#10;      l_label :&#61; &#39;00160&#39;;&#10;       EXECUTE IMMEDIATE &#39;DROP DATABASE LINK &#39; || c_db_link;&#10;    EXCEPTION&#10;    WHEN OTHERS THEN&#10;        debugMessage(&#39;Error: &#39; || SQLERRM);&#10;        RAISE;&#10;    END;&#10;&#10;&#10;    l_label :&#61; &#39;00170&#39;;&#10;    report(p_task_name &#61;&gt; c_task_name);&#10;    debugMessage(&#39;Task Complete&#39;);&#10;    debugMessage(&#39;++++++++++++++++++++++++++++++++++++++++++++++++++&#39;);&#10;    debugMessage(&#39;+++        FINISHED DOCUMENT COPY              +++&#39;);&#10;    debugMessage(&#39;++++++++++++++++++++++++++++++++++++++++++++++++++&#39;);&#10;    DBMS_OUTPUT.put_line (&#39;Completed DOCUMENT load - &#39; || c_task_name || &#39; &#39; || sysdate);&#10;    --&#10;EXCEPTION&#10;WHEN OTHERS THEN&#10;    report(p_task_name &#61;&gt; c_task_name);&#10;    raise_error(p_err_msg &#61;&gt; SQLERRM, p_proc &#61;&gt; &#39;copy_documents&#39;, p_label &#61;&gt; l_label);&#10;END copy_documents;&#10;--&#10;--&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;-- PDT DQ subroutines&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--&#10;--&#10;FUNCTION get_con_search_cond(p_owner VARCHAR2, p_con_name VARCHAR2) RETURN VARCHAR2&#10;IS&#10;    l_ret VARCHAR2(32767);&#10;BEGIN&#10;    SELECT search_condition INTO l_ret&#10;    FROM all_constraints&#10;    WHERE owner &#61; UPPER(TRIM(p_owner))&#10;      AND constraint_name &#61; UPPER(TRIM(p_con_name));&#10;    RETURN l_ret;&#10;END get_con_search_cond;&#10;--&#10;FUNCTION get_cons_cols(p_owner VARCHAR2, p_tab VARCHAR2, p_cons_name VARCHAR2, p_show_data_types VARCHAR2 DEFAULT &#39;Y&#39;) RETURN VARCHAR2&#10;IS&#10;    CURSOR cs IS&#10;      SELECT NVL(CC.position, 0) position, CC.column_name, TC.data_type, TC.data_length&#10;      FROM&#10;        all_cons_columns CC,&#10;        all_tab_columns TC&#10;      WHERE CC.owner &#61; p_owner&#10;        AND CC.table_name &#61; p_tab&#10;        AND CC.constraint_name &#61; p_cons_name&#10;        AND TC.owner &#61; CC.owner&#10;        AND TC.table_name &#61; CC.table_name&#10;        AND TC.column_name &#61; CC.column_name&#10;      ORDER BY NVL(CC.position, 0);&#10;    cr cs%ROWTYPE;&#10;    lv_ret VARCHAR2(30000);&#10;BEGIN&#10;    OPEN cs;&#10;    LOOP&#10;        FETCH cs INTO cr;&#10;        EXIT WHEN cs%NOTFOUND;&#10;        SELECT lv_ret || DECODE(lv_ret, NULL, &#39;&#39;, &#39;, &#39;) || cr.column_name ||&#10;               DECODE(p_show_data_types, &#39;Y&#39;, &#39; (&#39; || cr.data_type || &#39; &#39; || cr.data_length || &#39;)&#39;, &#39;&#39;)&#10;        INTO lv_ret&#10;        FROM dual;&#10;    END LOOP;&#10;    CLOSE cs;&#10;    RETURN lv_ret;&#10;END get_cons_cols;&#10;--&#10;FUNCTION get_FK_cols(p_owner VARCHAR2, p_tab VARCHAR2, p_check_table VARCHAR2 DEFAULT &#39;N&#39;) RETURN VARCHAR2&#10;IS&#10;    lv_SQL VARCHAR2(4096);&#10;    TYPE lv_cur_TYP IS REF CURSOR;&#10;    TYPE lv_rec_TYP IS RECORD(&#10;      constraint_name VARCHAR2(30),&#10;      col_list        VARCHAR2(4000),&#10;      R_table_name    VARCHAR2(30),&#10;      R_col_list        VARCHAR2(4000));&#10;    --&#10;    cs    lv_cur_TYP;&#10;    cr     lv_rec_TYP;&#10;    lv_ret VARCHAR2(30000);&#10;    lv_row PLS_INTEGER :&#61; 0;&#10;BEGIN&#10;    lv_SQL :&#61;&#10;       &#39;SELECT&#10;          c.constraint_name,&#10;          C08001_PDT_SUPPORT.get_cons_cols(c.owner, c.table_name, c.constraint_name, &#39;&#39;N&#39;&#39;) col_list,&#10;          c1.table_name R_table_name,&#10;          C08001_PDT_SUPPORT.get_cons_cols(c1.owner, c1.table_name, c1.constraint_name, &#39;&#39;N&#39;&#39;) R_col_list&#10;        FROM&#10;          all_constraints c,&#10;          all_constraints c1&#10;        WHERE c.owner &#61; :p_owner&#10;          AND c.table_name &#61; :p_tab&#10;          AND c.constraint_type &#61; &#39;&#39;R&#39;&#39;&#10;          AND c1.owner &#61; c.r_owner&#10;          AND c1.constraint_name &#61; c.r_constraint_name&#39;;&#10;    IF p_check_table &lt;&gt; &#39;N&#39; THEN&#10;        lv_SQL :&#61; lv_SQL || &#39;&#10;          AND EXISTS(SELECT 1 FROM &#39; || p_check_table || &#39; WHERE table_name &#61; c1.table_name)&#39;;&#10;    END IF;&#10;    --&#10;    lv_SQL :&#61; lv_SQL || &#39;&#10;        ORDER BY 1&#39;;&#10;    --&#10;    OPEN cs FOR lv_SQL USING p_owner, p_tab;&#10;    LOOP&#10;        FETCH cs INTO cr;&#10;        EXIT WHEN cs%NOTFOUND;&#10;        --&#10;        lv_row :&#61; lv_row + 1;&#10;        IF lv_ret IS NOT NULL THEN&#10;            lv_ret :&#61; SUBSTR(lv_ret || CHR(13) || CHR(10), 1, 30000);&#10;        END IF;&#10;        SELECT&#10;          SUBSTR(lv_ret ||&#10;                 lv_row || &#39; &#39; ||&#10;                 DECODE(SUBSTR(cr.constraint_name, 1, 4), &#39;SYS_&#39;, &#39;FK&#39;, cr.constraint_name) || &#39;: &#39; ||&#10;                 &#39;(&#39; || cr.col_list || &#39;)&#39; ||&#10;                 &#39;&lt;-&#39; || cr.R_table_name || &#39;(&#39; || cr.R_col_list || &#39;)&#39;,&#10;          1, 30000)&#10;        INTO lv_ret&#10;        FROM dual;&#10;    END LOOP;&#10;    CLOSE cs;&#10;    RETURN lv_ret;&#10;END get_FK_cols;&#10;--&#10;FUNCTION get_dq_message(p_msg VARCHAR2) RETURN VARCHAR2 RESULT_CACHE&#10;IS&#10;    l_ret VARCHAR2(32767);&#10;    --&#10;    FUNCTION get_FK_con_msg RETURN VARCHAR2&#10;    IS&#10;        l_msg     VARCHAR2(4000);&#10;        l_owner   VARCHAR2(30);&#10;        l_con     VARCHAR2(100);&#10;        l_con_msg VARCHAR2(4000);&#10;        --&#10;        TYPE l_cur_TYP IS REF CURSOR;&#10;        l_cur l_cur_TYP;&#10;        --&#10;        l_con_name     VARCHAR2(40);&#10;        l_table_name   VARCHAR2(40);&#10;        l_col_list     VARCHAR2(1024);&#10;        l_r_table_name VARCHAR2(40);&#10;        l_r_col_list   VARCHAR2(1024);&#10;        --&#10;        l_con_key VARCHAR2(100);&#10;        l_con_rec t_con_rec_TYP;&#10;    BEGIN&#10;        l_msg :&#61; p_msg;&#10;        l_msg :&#61; PKG_LstUtl.list_last_elem(l_msg, &#39;integrity constraint (&#39;);&#10;        l_msg :&#61; PKG_LstUtl.list_next_elem(l_msg, &#39;)&#39;);&#10;        l_owner :&#61; UPPER(TRIM(PKG_LstUtl.list_next_elem(l_msg, &#39;.&#39;)));&#10;        l_con :&#61; UPPER(TRIM(l_msg));&#10;        --&#10;        l_con_key :&#61; l_owner || &#39;.&#39; || l_con;&#10;        IF g_con_TAB.EXISTS(l_con_key) THEN&#10;            l_con_msg :&#61; g_con_TAB(l_con_key).con_text;&#10;        ELSE&#10;            OPEN l_cur FOR&#10;             &#39;SELECT&#10;                c.constraint_name,&#10;                c.table_name,&#10;                C08001_PDT_SUPPORT.get_cons_cols(c.owner, c.table_name, c.constraint_name, &#39;&#39;N&#39;&#39;) col_list,&#10;                c1.table_name R_table_name,&#10;                C08001_PDT_SUPPORT.get_cons_cols(c1.owner, c1.table_name, c1.constraint_name, &#39;&#39;N&#39;&#39;) R_col_list&#10;              FROM&#10;                all_constraints c,&#10;                all_constraints c1&#10;              WHERE c.owner &#61; UPPER(TRIM(:p_owner))&#10;                AND c.constraint_name &#61; UPPER(TRIM(:p_con))&#10;                AND c.constraint_type &#61; &#39;&#39;R&#39;&#39;&#10;                AND c1.owner &#61; c.r_owner&#10;                AND c1.constraint_name &#61; c.r_constraint_name&#39;&#10;            USING l_owner, l_con;&#10;            FETCH l_cur INTO l_con_name, l_table_name, l_col_list, l_r_table_name, l_r_col_list;&#10;            CLOSE l_cur;&#10;            --&#10;            SELECT&#10;              DECODE(SUBSTR(l_con_name, 1, 4), &#39;SYS_&#39;, &#39;FK&#39;, l_con_name) || &#39;: &#39; ||&#10;                  l_table_name || &#39;(&#39; || l_col_list || &#39;)&#39; ||&#10;                  &#39;&lt;-&#39; || l_R_table_name || &#39;(&#39; || l_R_col_list || &#39;)&#39;&#10;            INTO l_con_msg&#10;            FROM dual;&#10;            --&#10;            l_con_rec.owner :&#61; l_owner;&#10;            l_con_rec.constraint_name :&#61; l_con;&#10;            l_con_rec.con_text :&#61; l_con_msg;&#10;            --&#10;            g_con_TAB(l_con_key) :&#61; l_con_rec;&#10;        END IF;&#10;        --&#10;        l_msg :&#61; &#39;Integrity constraint [&#39; || l_owner || &#39;.&#39; || l_con || &#39;] violated - parent key not found: &#39; || l_con_msg;&#10;        --&#10;        RETURN l_msg;&#10;    END get_FK_con_msg;&#10;    --&#10;    FUNCTION get_FK1_con_msg RETURN VARCHAR2&#10;    IS&#10;        l_msg     VARCHAR2(4000);&#10;        l_owner   VARCHAR2(30);&#10;        l_con     VARCHAR2(100);&#10;        l_con_msg VARCHAR2(4000);&#10;        --&#10;        TYPE l_cur_TYP IS REF CURSOR;&#10;        l_cur l_cur_TYP;&#10;        --&#10;        l_con_name     VARCHAR2(40);&#10;        l_table_name   VARCHAR2(40);&#10;        l_col_list     VARCHAR2(1024);&#10;        l_r_table_name VARCHAR2(40);&#10;        l_r_col_list   VARCHAR2(1024);&#10;        --&#10;        l_con_key VARCHAR2(100);&#10;        l_con_rec t_con_rec_TYP;&#10;    BEGIN&#10;        l_msg :&#61; p_msg;&#10;        l_msg :&#61; PKG_LstUtl.list_last_elem(l_msg, &#39; (&#39;);&#10;        l_msg :&#61; PKG_LstUtl.list_next_elem(l_msg, &#39;)&#39;);&#10;        l_owner :&#61; UPPER(TRIM(PKG_LstUtl.list_next_elem(l_msg, &#39;.&#39;)));&#10;        l_con :&#61; UPPER(TRIM(l_msg));&#10;        --&#10;        l_con_key :&#61; l_owner || &#39;.&#39; || l_con;&#10;        IF g_con_TAB.EXISTS(l_con_key) THEN&#10;            l_con_msg :&#61; g_con_TAB(l_con_key).con_text;&#10;        ELSE&#10;            OPEN l_cur FOR&#10;             &#39;SELECT&#10;                c.constraint_name,&#10;                c.table_name,&#10;                C08001_PDT_SUPPORT.get_cons_cols(c.owner, c.table_name, c.constraint_name, &#39;&#39;N&#39;&#39;) col_list,&#10;                c1.table_name R_table_name,&#10;                C08001_PDT_SUPPORT.get_cons_cols(c1.owner, c1.table_name, c1.constraint_name, &#39;&#39;N&#39;&#39;) R_col_list&#10;              FROM&#10;                all_constraints c,&#10;                all_constraints c1&#10;              WHERE c.owner &#61; UPPER(TRIM(:p_owner))&#10;                AND c.constraint_name &#61; UPPER(TRIM(:p_con))&#10;                AND c.constraint_type &#61; &#39;&#39;R&#39;&#39;&#10;                AND c1.owner &#61; c.r_owner&#10;                AND c1.constraint_name &#61; c.r_constraint_name&#39;&#10;            USING l_owner, l_con;&#10;            FETCH l_cur INTO l_con_name, l_table_name, l_col_list, l_r_table_name, l_r_col_list;&#10;            CLOSE l_cur;&#10;            --&#10;            SELECT&#10;              DECODE(SUBSTR(l_con_name, 1, 4), &#39;SYS_&#39;, &#39;FK&#39;, l_con_name) || &#39;: &#39; ||&#10;                  l_table_name || &#39;(&#39; || l_col_list || &#39;)&#39; ||&#10;                  &#39;&lt;-&#39; || l_R_table_name || &#39;(&#39; || l_R_col_list || &#39;)&#39;&#10;            INTO l_con_msg&#10;            FROM dual;&#10;            --&#10;            l_con_rec.owner :&#61; l_owner;&#10;            l_con_rec.constraint_name :&#61; l_con;&#10;            l_con_rec.con_text :&#61; l_con_msg;&#10;            --&#10;            g_con_TAB(l_con_key) :&#61; l_con_rec;&#10;        END IF;&#10;        --&#10;        l_msg :&#61; &#39;Integrity constraint [&#39; || l_owner || &#39;.&#39; || l_con || &#39;] violated - parent key not found: &#39; || l_con_msg;&#10;        --&#10;        RETURN l_msg;&#10;    END get_FK1_con_msg;&#10;    --&#10;    FUNCTION get_PK_con_msg RETURN VARCHAR2&#10;    IS&#10;        l_msg     VARCHAR2(4000);&#10;        l_owner   VARCHAR2(30);&#10;        l_con     VARCHAR2(100);&#10;        l_con_msg VARCHAR2(4000);&#10;        --&#10;        TYPE l_cur_TYP IS REF CURSOR;&#10;        l_cur l_cur_TYP;&#10;        --&#10;        l_con_name     VARCHAR2(40);&#10;        l_table_name   VARCHAR2(40);&#10;        l_col_list     VARCHAR2(1024);&#10;        --&#10;        l_con_key VARCHAR2(100);&#10;        l_con_rec t_con_rec_TYP;&#10;        --&#10;    BEGIN&#10;        l_msg :&#61; p_msg;&#10;        l_msg :&#61; PKG_LstUtl.list_last_elem(l_msg, &#39;unique constraint (&#39;);&#10;        l_msg :&#61; PKG_LstUtl.list_next_elem(l_msg, &#39;)&#39;);&#10;        l_owner :&#61; UPPER(TRIM(PKG_LstUtl.list_next_elem(l_msg, &#39;.&#39;)));&#10;        l_con :&#61; UPPER(TRIM(l_msg));&#10;        --&#10;        l_con_key :&#61; l_owner || &#39;.&#39; || l_con;&#10;        IF g_con_TAB.EXISTS(l_con_key) THEN&#10;            l_con_msg :&#61; g_con_TAB(l_con_key).con_text;&#10;        ELSE&#10;            OPEN l_cur FOR&#10;             &#39;SELECT c.table_name,&#10;                C08001_PDT_SUPPORT.get_cons_cols(c.owner, c.table_name, c.constraint_name, &#39;&#39;N&#39;&#39;) col_list&#10;              FROM all_constraints c&#10;              WHERE c.owner &#61; UPPER(TRIM(:p_owner))&#10;                AND c.constraint_name &#61; UPPER(TRIM(:p_con))&#39;&#10;            USING l_owner, l_con;&#10;            FETCH l_cur INTO l_table_name, l_col_list;&#10;            CLOSE l_cur;&#10;            --&#10;            SELECT DECODE(SUBSTR(l_con_name, 1, 4), &#39;SYS_&#39;, &#39;PK&#39;, l_con_name) || l_table_name || &#39;(&#39; || l_col_list || &#39;)&#39;&#10;            INTO l_con_msg&#10;            FROM dual;&#10;            --&#10;            l_con_rec.owner :&#61; l_owner;&#10;            l_con_rec.constraint_name :&#61; l_con;&#10;            l_con_rec.con_text :&#61; l_con_msg;&#10;            --&#10;            g_con_TAB(l_con_key) :&#61; l_con_rec;&#10;        END IF;&#10;        --&#10;        l_msg :&#61; &#39;Unique constraint [&#39; || l_owner || &#39;.&#39; || l_con || &#39;] violated: &#39; || l_con_msg;&#10;        --&#10;        RETURN l_msg;&#10;    END get_PK_con_msg;&#10;    --&#10;    FUNCTION get_CHK_con_msg RETURN VARCHAR2&#10;    IS&#10;        l_msg     VARCHAR2(4000);&#10;        l_owner   VARCHAR2(30);&#10;        l_con     VARCHAR2(100);&#10;        l_con_msg VARCHAR2(4000);&#10;        --&#10;        l_con_key VARCHAR2(100);&#10;        l_con_rec t_con_rec_TYP;&#10;    BEGIN&#10;        l_msg :&#61; p_msg;&#10;        l_msg :&#61; PKG_LstUtl.list_last_elem(l_msg, &#39;check constraint (&#39;);&#10;        l_msg :&#61; PKG_LstUtl.list_next_elem(l_msg, &#39;)&#39;);&#10;        l_owner :&#61; UPPER(TRIM(PKG_LstUtl.list_next_elem(l_msg, &#39;.&#39;)));&#10;        l_con :&#61; UPPER(TRIM(l_msg));&#10;        --&#10;        l_con_key :&#61; l_owner || &#39;.&#39; || l_con;&#10;        IF g_con_TAB.EXISTS(l_con_key) THEN&#10;            l_con_msg :&#61; g_con_TAB(l_con_key).con_text;&#10;        ELSE&#10;            l_con_msg :&#61; get_con_search_cond(l_owner, l_con);&#10;            --&#10;            l_con_rec.owner :&#61; l_owner;&#10;            l_con_rec.constraint_name :&#61; l_con;&#10;            l_con_rec.con_text :&#61; l_con_msg;&#10;            --&#10;            g_con_TAB(l_con_key) :&#61; l_con_rec;&#10;        END IF;&#10;        --&#10;        l_msg :&#61; &#39;Check constraint [&#39; || l_owner || &#39;.&#39; || l_con || &#39;] violated: &#39; || l_con_msg;&#10;        --&#10;        RETURN l_msg;&#10;    END get_CHK_con_msg;&#10;    --&#10;    FUNCTION get_DUPL_con_msg RETURN VARCHAR2&#10;    IS&#10;        l_msg VARCHAR2(4000);&#10;    BEGIN&#10;        l_msg :&#61; p_msg;&#10;        l_msg :&#61; PKG_LstUtl.list_next_elem(l_msg, &#39; record based on value &#39;);&#10;        RETURN l_msg;&#10;    END get_DUPL_con_msg;&#10;    --&#10;    FUNCTION get_ORPH_con_msg RETURN VARCHAR2&#10;    IS&#10;        l_msg VARCHAR2(4000);&#10;    BEGIN&#10;        l_msg :&#61; p_msg;&#10;        l_msg :&#61; PKG_LstUtl.list_next_elem(l_msg, &#39; record based on value &#39;);&#10;        RETURN l_msg;&#10;    END get_ORPH_con_msg;&#10;    --&#10;    FUNCTION get_ORPH_iwp_msg RETURN VARCHAR2&#10;    IS&#10;        l_msg    VARCHAR2(4000);&#10;        l_prefix VARCHAR2(100);&#10;    BEGIN&#10;        l_msg :&#61; p_msg;&#10;        --l_prefix :&#61; &#39;Orphaned IWP Document:&#39;;&#10;        --l_msg :&#61; TRIM(PKG_LstUtl.list_last_elem(l_msg, l_prefix));&#10;        --l_msg :&#61; TRIM(PKG_LstUtl.list_last_elem(l_msg, &#39; &#39;));&#10;        l_msg :&#61; SUBSTR(l_msg,1,INSTR(l_msg,&#39;:&#39;,1)) || SUBSTR(l_msg, INSTR(l_msg,&#39;[&#39;,-1), INSTR(l_msg, &#39;]&#39;,-1));&#10;        RETURN l_msg;&#10;    END get_ORPH_iwp_msg;&#10;    --&#10;    FUNCTION get_UPWAPP_CONTACT_msg RETURN VARCHAR2&#10;    IS&#10;        l_msg   VARCHAR2(4000);&#10;    BEGIN&#10;        l_msg :&#61; SUBSTR(p_msg, 1, 69);&#10;        --&#10;        RETURN l_msg;&#10;    END get_UPWAPP_CONTACT_msg;&#10;    --&#10;    FUNCTION get_IWPLOAD_msg RETURN VARCHAR2&#10;    IS&#10;        l_msg     VARCHAR2(4000);&#10;        l_first   INTEGER;&#10;        l_second  INTEGER;&#10;    BEGIN&#10;        --&#10;        l_first :&#61; INSTR(p_msg, &#39;-&#39;, 1);&#10;        l_second :&#61; INSTR(p_msg, &#39;-&#39;, -1) + 7;&#10;        --&#10;        l_msg :&#61; SUBSTR(p_msg, l_first, l_second - l_first);&#10;        l_msg :&#61; REPLACE(p_msg, l_msg, &#39;&#39;);&#10;        --&#10;        RETURN l_msg;&#10;    END get_IWPLOAD_msg;&#10;    --&#10;BEGIN&#10;    IF p_msg LIKE &#39;Defaulting whole domain -  Domain:%&#39; THEN&#10;        l_ret :&#61; NULL;&#10;    ELSIF p_msg LIKE &#39;%ORA-%: integrity constraint (%) violated%&#39; THEN&#10;        l_ret :&#61; get_FK_con_msg;&#10;    ELSIF p_msg LIKE &#39;%ORA-% (%) - parent keys not found%&#39; THEN&#10;        l_ret :&#61; get_FK1_con_msg;&#10;    ELSIF p_msg LIKE &#39;Insertion unsuccessful% integrity constraint (%) violated%&#39; THEN&#10;        l_ret :&#61; get_FK_con_msg;&#10;    ELSIF p_msg LIKE &#39;%ORA-%: unique constraint (%) violated%&#39; THEN&#10;        l_ret :&#61; get_PK_con_msg;&#10;    ELSIF p_msg LIKE &#39;%Insertion unsuccessful% unique constraint (%) violated%&#39; THEN&#10;        l_ret :&#61; get_PK_con_msg;&#10;    ELSIF p_msg LIKE &#39;%ORA-%: check constraint (%) violated%&#39; THEN&#10;        l_ret :&#61; get_CHK_con_msg;&#10;    ELSIF p_msg LIKE &#39;%Duplicate Relinker % records found, cannot link % record based on value%&#39; THEN&#10;        l_ret :&#61; get_DUPL_con_msg;&#10;    ELSIF p_msg LIKE &#39;%%Orphan - no % record found, cannot link % record based on value%&#39; THEN&#10;        l_ret :&#61; get_ORPH_con_msg;&#10;    ELSIF p_msg LIKE &#39;Orphaned IWP%&#39; THEN&#10;        l_ret :&#61; get_ORPH_iwp_msg;&#10;    ELSIF p_msg LIKE &#39;Legacy value for CONTACT_OUTCOME_TYPE%&#39; THEN&#10;        l_ret :&#61; get_UPWAPP_CONTACT_msg;&#10;    ELSIF p_msg LIKE &#39;Error opening file -%&#39; THEN&#10;        l_ret :&#61; get_IWPLOAD_msg;&#10;    ELSE&#10;        l_ret :&#61; p_msg;&#10;    END IF;&#10;    --&#10;    l_ret :&#61; REPLACE(l_ret,&#39;&quot;&#39;, &#39;&#39;);&#10;    RETURN l_ret;&#10;END get_dq_message;&#10;--&#10;--&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;-- PDT Enable / Disable VPD Policies private subroutine&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--&#10;-- DELIUS_APP_SCHEMA: disable / enable VPD policies&#10;--&#10;PROCEDURE do_switch_vpd_policies(p_action VARCHAR2, p_target_schema VARCHAR2 DEFAULT GC_SRC_MTC_SCHEMA)&#10;IS&#10;    --&#10;    l_target_schema VARCHAR2(50) :&#61; NVL(p_target_schema, GC_SRC_MTC_SCHEMA);&#10;    l_enable_flag   BOOLEAN      :&#61; TRUE;&#10;    --&#10;    PROCEDURE do_enable_policy(p_obj_name VARCHAR2) IS&#10;    BEGIN&#10;        DBMS_RLS.enable_policy(&#10;          object_schema   &#61;&gt; l_target_schema,&#10;          object_name     &#61;&gt; p_obj_name,&#10;          policy_name     &#61;&gt;&#10;              CASE&#10;                  WHEN UPPER(p_obj_name) IN (&#39;CONTACT&#39;)&#10;                  THEN &#39;funcContactPolicy&#39;&#10;                  ELSE &#39;funcOffenderPolicy&#39;&#10;              END,&#10;          enable &#61;&gt; l_enable_flag&#10;        );&#10;    EXCEPTION WHEN OTHERS THEN&#10;        IF SQLERRM LIKE &#39;ORA-28102: policy does not exist&#39; THEN&#10;            NULL;&#10;        ELSE&#10;            --RAISE;&#10;            raise_error(&#39;ERROR: &#39; || SQLERRM || CHR(10) ||&#10;                &#39;[p_action&#61;&#39; || p_action               || &#39;]&#39; ||&#10;                &#39;[p_target_schema&#61;&#39; || p_target_schema || &#39;]&#39; ||&#10;                &#39;[p_obj_name&#61;&#39; || p_obj_name           || &#39;]&#39;,&#10;                &#39;DO_ENABLE_POLICY&#39;);&#10;        END IF;&#10;    END do_enable_policy;&#10;    --&#10;    PROCEDURE do_enable_vpd_policies(p_enable_flag BOOLEAN) IS&#10;    BEGIN&#10;        l_enable_flag :&#61; p_enable_flag;&#10;        --&#10;        do_enable_policy(&#39;OFFENDER&#39;);&#10;        do_enable_policy(&#39;CASELOAD&#39;);&#10;        do_enable_policy(&#39;CONTACT&#39;);&#10;        do_enable_policy(&#39;COURT_APPEARANCE&#39;);&#10;        do_enable_policy(&#39;APPROVED_PREMISES_REFERRAL&#39;);&#10;        do_enable_policy(&#39;INSTITUTIONAL_REPORT&#39;);&#10;        do_enable_policy(&#39;APPROVED_PREMISES_RESIDENCE&#39;);&#10;        do_enable_policy(&#39;COURT_REPORT&#39;);&#10;        do_enable_policy(&#39;EVENT&#39;);&#10;        do_enable_policy(&#39;ADDITIONAL_IDENTIFIER&#39;);&#10;        do_enable_policy(&#39;ALIAS&#39;);&#10;        do_enable_policy(&#39;ADDRESS_ASSESSMENT&#39;);&#10;        do_enable_policy(&#39;DISABILITY&#39;);&#10;        do_enable_policy(&#39;DOCUMENT&#39;);&#10;        do_enable_policy(&#39;OASYS_ASSESSMENT&#39;);&#10;        do_enable_policy(&#39;OFFENDER_ADDRESS&#39;);&#10;        do_enable_policy(&#39;OFFENDER_TRANSFER&#39;);&#10;        -- PDM TR1&#10;        IF G_PDM_VERSION &gt;&#61; 301 THEN&#10;            do_enable_policy(&#39;ORDER_TRANSFER&#39;);&#10;            do_enable_policy(&#39;LIC_CONDITION_TRANSFER&#39;);&#10;            do_enable_policy(&#39;RQMNT_TRANSFER&#39;);&#10;            do_enable_policy(&#39;NSI&#39;);&#10;            do_enable_policy(&#39;NSI_TRANSFER&#39;);&#10;        END IF;&#10;        -- End of PDM TR1&#10;        -- PDM 501&#10;        IF G_PDM_VERSION &gt;&#61; 501 THEN&#10;            do_enable_policy(&#39;COHORT&#39;);&#10;            do_enable_policy(&#39;COHORT_HISTORY&#39;);&#10;            do_enable_policy(&#39;INSTITUTIONAL_REPORT_TRANSFER&#39;);&#10;            do_enable_policy(&#39;PSS_RQMNT&#39;);&#10;            do_enable_policy(&#39;PSS_RQMNT_TRANSFER&#39;);&#10;        END IF;&#10;        -- End of PDM 501&#10;        do_enable_policy(&#39;PERSONAL_CONTACT&#39;);&#10;        do_enable_policy(&#39;REGISTRATION&#39;);&#10;        do_enable_policy(&#39;RISK_ASSESSMENT&#39;);&#10;        do_enable_policy(&#39;ADDITIONAL_SENTENCE&#39;);&#10;        do_enable_policy(&#39;DISPOSAL&#39;);&#10;        do_enable_policy(&#39;MAIN_OFFENCE&#39;);&#10;        do_enable_policy(&#39;REFERRAL&#39;);&#10;        do_enable_policy(&#39;DRUG_TEST_PROFILE&#39;);&#10;        do_enable_policy(&#39;CUSTODY&#39;);&#10;        do_enable_policy(&#39;DRUGS_TEST&#39;);&#10;        do_enable_policy(&#39;RELEASE&#39;);&#10;        do_enable_policy(&#39;ASSESSMENT&#39;);&#10;        do_enable_policy(&#39;RECALL&#39;);&#10;        do_enable_policy(&#39;DEREGISTRATION&#39;);&#10;        do_enable_policy(&#39;REGISTRATION_REVIEW&#39;);&#10;        do_enable_policy(&#39;DRUG_TEST_RESULT&#39;);&#10;        do_enable_policy(&#39;PROVISION&#39;);&#10;        do_enable_policy(&#39;UPW_APPOINTMENT&#39;);&#10;        do_enable_policy(&#39;LIC_CONDITION&#39;);&#10;        do_enable_policy(&#39;OASYS_SENTENCE_PLAN&#39;);&#10;        do_enable_policy(&#39;OASYS_SP_NEED&#39;);&#10;        do_enable_policy(&#39;OASYS_SP_TEXT&#39;);&#10;        do_enable_policy(&#39;OASYS_SP_WORK_SUMMARY&#39;);&#10;        do_enable_policy(&#39;RQMNT&#39;);&#10;        do_enable_policy(&#39;UPW_DETAILS&#39;);&#10;    END do_enable_vpd_policies;&#10;    --&#10;BEGIN&#10;    --&#10;    do_enable_vpd_policies(NVL(p_action, &#39;ENABLE&#39;) &lt;&gt; &#39;DISABLE&#39;);&#10;    --&#10;END do_switch_vpd_policies;&#10;&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;-- PDT Extract subroutines&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--&#10;PROCEDURE do_check_dest_schema(p_schema VARCHAR2)&#10;IS&#10;    l_cnt INTEGER;&#10;BEGIN&#10;    IF p_schema &#61; GC_SRC_MTC_SCHEMA THEN&#10;        --raise_application_error(-20001, &#39;FATAL error in DO_CHECK_DEST_SCHEMA: &#39; || p_schema || &#39; cannot be set to &#39; || GC_SRC_MTC_SCHEMA);&#10;        NULL;&#10;    ELSE&#10;        SELECT COUNT(1) INTO l_cnt&#10;        FROM all_users&#10;        WHERE username &#61; TRIM(p_schema);&#10;        --&#10;        IF NOT (l_cnt &#61; 1) THEN&#10;            raise_application_error(-20001, &#39;FATAL error in DO_CHECK_DEST_SCHEMA: &#39; || p_schema || &#39; cannot be located in the DBA_USERS system view&#39;);&#10;        END IF;&#10;    END IF;&#10;END do_check_dest_schema;&#10;--&#10;FUNCTION get_dest_tab_name(p_tab_name VARCHAR2, p_schema VARCHAR2 DEFAULT GC_DEST_MTC_SCHEMA) RETURN VARCHAR2&#10;IS&#10;    l_ret    VARCHAR2(100);&#10;    l_schema VARCHAR2(100);&#10;BEGIN&#10;    --&#10;    do_check_dest_schema(p_schema);&#10;    --&#10;    IF p_schema IS NULL THEN&#10;        l_schema :&#61; GC_DEST_MTC_SCHEMA;&#10;    ELSE&#10;        l_schema :&#61; p_schema;&#10;    END IF;&#10;    IF SUBSTR(l_schema, 1, 1) &lt;&gt; &#39;@&#39; THEN&#10;        l_ret :&#61; l_schema || &#39;.&#39; || p_tab_name;&#10;    ELSE&#10;        l_ret :&#61; p_tab_name || l_schema;&#10;    END IF;&#10;    --&#10;    RETURN l_ret;&#10;END get_dest_tab_name;&#10;--&#10;FUNCTION get_src_tab_name(p_tab_name VARCHAR2, p_schema VARCHAR2 DEFAULT GC_SRC_MTC_SCHEMA) RETURN VARCHAR2&#10;IS&#10;    l_ret    VARCHAR2(100);&#10;    l_schema VARCHAR2(100);&#10;BEGIN&#10;    IF p_schema !&#61; GC_SRC_MTC_SCHEMA THEN&#10;        raise_application_error(-20001, &#39;FATAL error in GET_SRC_TAB_NAME: p_schema must be set to &#39; || GC_SRC_MTC_SCHEMA);&#10;    END IF;&#10;    --&#10;    IF p_schema IS NULL THEN&#10;        l_schema :&#61; &#39;STG_SCHEMA&#39;;&#10;    ELSE&#10;        l_schema :&#61; p_schema;&#10;    END IF;&#10;    IF SUBSTR(l_schema, 1, 1) &lt;&gt; &#39;@&#39; THEN&#10;        l_ret :&#61; l_schema || &#39;.&#39; || p_tab_name;&#10;    ELSE&#10;        l_ret :&#61; p_tab_name || l_schema;&#10;    END IF;&#10;    --&#10;    RETURN l_ret;&#10;END get_src_tab_name;&#10;--&#10;PROCEDURE init_tab_info&#10;IS&#10;    --&#10;    CURSOR csTab IS&#10;      WITH T AS (&#10;        SELECT DISTINCT table_name&#10;        FROM TABLE( C08001_PDT_SUPPORT.get_tab_list1 )&#10;      )&#10;      SELECT&#10;        T.table_name,&#10;        PKG_Lookups.funcGetTabPkFields(&#10;            p_table_name &#61;&gt; T.table_name,&#10;            p_delim      &#61;&gt; &#39;,&#39; ) PK_fld_lst,&#10;        PKG_Lookups.funcgetTabRecord(&#10;            p_data_fld  &#61;&gt; &#39;column_name&#39;,&#10;            p_table     &#61;&gt; &#39;user_tab_columns&#39;,&#10;            p_ref_col   &#61;&gt; &#39;table_name&#39;,&#10;            p_ref_val   &#61;&gt; T.table_name,&#10;            p_all_records &#61;&gt; &#39;Y&#39;,&#10;            p_delim       &#61;&gt; &#39;,&#39; ) fld_lst,&#10;        PKG_Lookups.funcgetTabRecord(&#10;            p_data_fld  &#61;&gt;&#10;               &#39;CASE&#10;                  WHEN column_name IN (&#39;&#39;ORGANISATIONS&#39;&#39;) THEN &#39;&#39;NULL AS &#39;&#39; || column_name&#10;                  WHEN data_type IN (&#39;&#39;BLOB&#39;&#39;) AND nullable &#61; &#39;&#39;N&#39;&#39; THEN &#39;&#39;EMPTY_BLOB() AS &#39;&#39; || column_name&#10;                  ELSE column_name&#10;                END&#39;,&#10;            p_table     &#61;&gt; &#39;user_tab_columns&#39;,&#10;            p_ref_col   &#61;&gt; &#39;table_name&#39;,&#10;            p_ref_val   &#61;&gt; T.table_name,&#10;            p_all_records &#61;&gt; &#39;Y&#39;,&#10;            p_delim       &#61;&gt; &#39;,&#39; ) fld_lst_1&#10;      FROM T&#10;      ORDER BY T.table_name;&#10;    --&#10;    crTab          csTab%ROWTYPE;&#10;    l_tab_info_REC TYP_tab_info_REC;&#10;    --&#10;    FUNCTION get_child_tables(p_table VARCHAR2) RETURN t_hier_tab_TYP&#10;    IS&#10;        CURSOR csTabOH IS&#10;          SELECT DISTINCT T.table_name, T.parent_table, T.hier_order_by AS order_by&#10;          FROM  TABLE( C08001_PDT_SUPPORT.get_tab_list1 ) T&#10;          WHERE table_type &#61; &#39;O&#39;&#10;            AND table_name NOT IN ( &#39;CASELOAD&#39;, &#39;COHORT_DIARY&#39;, &#39;CONTACT_ALERT&#39;, &#39;ORGANISATION_OFFENDER&#39; )&#10;            AND NOT ( parent_table &#61; &#39;CONTACT&#39; AND table_name &#61; &#39;CONTACT&#39; )&#10;            --&#10;            AND parent_table &#61; p_table&#10;        ORDER BY T.hier_order_by;&#10;        --&#10;        l_tab t_hier_tab_TYP;&#10;        --&#10;    BEGIN&#10;        OPEN csTabOH;&#10;        FETCH csTabOH BULK COLLECT INTO l_tab;&#10;        CLOSE csTabOH;&#10;        --&#10;        RETURN l_tab;&#10;    END get_child_tables;&#10;    --&#10;    PROCEDURE do_print_tab_hier(p_table VARCHAR2, p_level INTEGER DEFAULT 0, p_order_by INTEGER DEFAULT -1)&#10;    IS&#10;        l_idx   INTEGER;&#10;        l_tab   t_hier_tab_TYP;&#10;    BEGIN&#10;        IF p_level &gt; 10 THEN&#10;            message(&#39;ERROR in DO_PRINT_TAB_HIER: recursive level is &gt; than 10!&#39;);&#10;            RETURN;&#10;        END IF;&#10;        --&#10;        message(&#10;            &#39;[&#39; || p_level || &#39;]&#39; ||&#10;            LPAD(&#39; &#39;, p_level * 2) || RPAD(p_table, 30+4) ||&#10;            &#39;[&#39; || p_order_by || &#39;]&#39;&#10;        );&#10;        l_tab :&#61; g_tab_info(p_table).child_tables;&#10;        FOR l_idx IN 1..l_tab.COUNT LOOP&#10;            do_print_tab_hier(l_tab(l_idx).table_name, p_level + 1, l_tab(l_idx).order_by);&#10;        END LOOP;&#10;    END do_print_tab_hier;&#10;    --&#10;BEGIN&#10;    OPEN csTab;&#10;    LOOP&#10;        FETCH csTab INTO crTab;&#10;        EXIT WHEN csTab%NOTFOUND;&#10;        --&#10;        l_tab_info_REC.table_name :&#61; crTab.table_name;&#10;        l_tab_info_REC.pk_fld_lst :&#61; crTab.pk_fld_lst;&#10;        l_tab_info_REC.fld_lst    :&#61; crTab.fld_lst;&#10;        l_tab_info_REC.fld_lst_1  :&#61; crTab.fld_lst_1;&#10;        --&#10;        l_tab_info_REC.child_tables  :&#61; get_child_tables(crTab.table_name);&#10;        --&#10;        g_tab_info(crTab.table_name) :&#61; l_tab_info_REC;&#10;    END LOOP;&#10;    CLOSE csTab;&#10;    --&#10;    --do_print_tab_hier(&#39;OFFENDER&#39;);&#10;    --&#10;END init_tab_info;&#10;--&#10;PROCEDURE do_alter_tab_col_cons(p_tab VARCHAR2, p_col VARCHAR2, p_enable_disable_flag VARCHAR2, p_owner VARCHAR2 DEFAULT GC_DEST_MTC_SCHEMA)&#10;IS&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;DO_ALTER_TAB_COL_CONS&#39;;&#10;    l_enable_disable_flag VARCHAR2(30);&#10;    --&#10;    CURSOR cs IS&#10;      SELECT&#10;        c.status,&#10;        c.constraint_type,&#10;        c.constraint_name,&#10;        tc.table_name,&#10;        tc.column_name,&#10;        &#39;ALTER TABLE &#39; || c.owner || &#39;.&#39; || tc.table_name || &#39; &#39; || l_enable_disable_flag || &#39; CONSTRAINT &#39; || c.constraint_name exec_SQL&#10;      FROM&#10;        all_constraints c,&#10;        all_cons_columns cc,&#10;        all_tab_columns tc&#10;      WHERE 1&#61;1&#10;        AND c.owner &#61; p_owner&#10;        AND c.table_name &#61; p_tab&#10;        AND tc.column_name &#61; p_col&#10;        AND c.constraint_type NOT IN (&#39;P&#39;)&#10;        AND c.status NOT LIKE l_enable_disable_flag || &#39;_&#39;&#10;        AND cc.owner &#61; c.owner&#10;        AND cc.table_name &#61; c.table_name&#10;        AND cc.constraint_name &#61; c.constraint_name&#10;        AND tc.owner &#61; cc.owner&#10;        AND tc.table_name &#61; cc.table_name&#10;        AND tc.column_name &#61; cc.column_name&#10;        AND tc.owner &#61; cc.owner&#10;      ORDER BY tc.table_name, tc.column_name, c.constraint_type;&#10;    cr cs%ROWTYPE;&#10;BEGIN&#10;    --&#10;    do_check_dest_schema(p_owner);&#10;    --&#10;    l_enable_disable_flag :&#61; UPPER(p_enable_disable_flag);&#10;    IF l_enable_disable_flag NOT IN (&#39;ENABLE&#39;, &#39;DISABLE&#39;) THEN&#10;        raise_error(&#39;Invalid P_ENABLE_DISABLE_FLAG parameter value (must be ENABLE or DISABLE)&#39;, l_proc);&#10;    END IF;&#10;    --&#10;    OPEN cs;&#10;    LOOP&#10;        FETCH cs INTO cr;&#10;        EXIT WHEN cs%NOTFOUND;&#10;        --&#10;        exec_sql(p_sql &#61;&gt; cr.exec_SQL, p_ignore_err_flag &#61;&gt; &#39;N&#39;, p_print_SQL &#61;&gt; &#39;N&#39;);&#10;        --&#10;    END LOOP;&#10;    CLOSE cs;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    IF cs%ISOPEN THEN&#10;        CLOSE cs;&#10;    END IF;&#10;    RAISE;&#10;END do_alter_tab_col_cons;&#10;--&#10;PROCEDURE do_alter_contact_id_FK(p_action VARCHAR2, p_owner VARCHAR2 DEFAULT GC_DEST_MTC_SCHEMA)&#10;IS&#10;    --&#10;    CURSOR cs IS&#10;      SELECT table_name&#10;      FROM all_tab_columns&#10;      WHERE owner &#61; p_owner&#10;        AND column_name &#61; &#39;CONTACT_ID&#39;&#10;        AND table_name NOT IN (&#39;CONTACT&#39;);&#10;    --&#10;    l_table VARCHAR2(30);&#10;    --&#10;BEGIN&#10;    --&#10;    do_check_dest_schema(p_owner);&#10;    --&#10;    OPEN cs;&#10;    LOOP&#10;        FETCH cs INTO l_table;&#10;        EXIT WHEN cs%NOTFOUND;&#10;        --&#10;        do_alter_tab_col_cons(p_tab &#61;&gt; l_table, p_col &#61;&gt; &#39;CONTACT_ID&#39;, p_enable_disable_flag &#61;&gt; p_action, p_owner &#61;&gt; p_owner);&#10;    END LOOP;&#10;    CLOSE cs;&#10;    --&#10;    --do_alter_tab_col_cons(p_tab &#61;&gt; &#39;CONTACT&#39;, p_col &#61;&gt; &#39;LINKED_CONTACT_ID&#39;, p_enable_disable_flag &#61;&gt; p_action, p_owner &#61;&gt; p_owner);&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    IF cs%ISOPEN THEN&#10;        CLOSE cs;&#10;    END IF;&#10;    RAISE;&#10;END do_alter_contact_id_FK;&#10;--&#10;PROCEDURE do_fix_contact_SGC_FK&#10;IS&#10;    --&#10;    CURSOR cs IS&#10;      SELECT table_name&#10;      FROM all_tab_columns TC&#10;      WHERE owner &#61; GC_DEST_MTC_SCHEMA&#10;        AND column_name &#61; &#39;CONTACT_ID&#39;&#10;        AND table_name NOT IN (&#39;CONTACT&#39;, &#39;CONTACT_ALERT&#39;)&#10;        AND EXISTS(&#10;          SELECT 1&#10;          FROM all_tab_columns&#10;          WHERE owner &#61; TC.owner&#10;            AND column_name &#61; &#39;OFFENDER_ID&#39;&#10;            AND table_name &#61; TC.table_name );&#10;    --&#10;    l_table VARCHAR2(30);&#10;    --&#10;    PROCEDURE do_delete_invalid_records(p_table VARCHAR2)&#10;    IS&#10;        TYPE l_tab_TYP IS TABLE OF NUMBER;&#10;        l_tab l_tab_TYP;&#10;        TYPE l_tab_rows_TYP IS TABLE OF ROWID;&#10;        l_tab_rows l_tab_rows_TYP;&#10;    BEGIN&#10;--        EXECUTE IMMEDIATE&#10;--            &#39;DELETE FROM &#39; || get_dest_tab_name(p_table)                        || CHR(10) ||&#10;--            &#39;WHERE contact_id IN (&#39;                                             || CHR(10) ||&#10;--            &#39;  SELECT contact_id FROM &#39; || get_dest_tab_name(p_table)           || CHR(10) ||&#10;--            &#39;  MINUS&#39;                                                           || CHR(10) ||&#10;--            &#39;  SELECT contact_id FROM &#39; || get_dest_tab_name(&#39;CONTACT&#39;) || &#39; )&#39; || CHR(10) ||&#10;--            &#39;RETURNING &#39; || p_table || &#39;_ID INTO :l_tab&#39;&#10;--        RETURNING BULK COLLECT INTO l_tab;&#10;--        --&#10;--        IF l_tab.COUNT &gt; 0 THEN&#10;--            FOR l_i IN l_tab.FIRST..l_tab.LAST LOOP&#10;--                debugMessage(&#10;--                    &#39;[&#39; || p_table || &#39;_ID&#61;&#39; || l_tab(l_i) || &#39;]&#39; || CHR(10) ||&#10;--                    &#39;[MISSING PARENT SGC CONTACT RECORD ERROR][table&#61;&#39; || p_table || &#39;]&#39; );&#10;--            END LOOP;&#10;--        END IF;&#10;        EXECUTE IMMEDIATE&#10;            &#39;SELECT ROWID, &#39; || p_table || &#39;_ID&#39;                                || CHR(10) ||&#10;            &#39;FROM &#39; || get_dest_tab_name(p_table)                               || CHR(10) ||&#10;            &#39;WHERE contact_id IN (&#39;                                             || CHR(10) ||&#10;            &#39;  SELECT contact_id FROM &#39; || get_dest_tab_name(p_table)           || CHR(10) ||&#10;            &#39;  MINUS&#39;                                                           || CHR(10) ||&#10;            &#39;  SELECT contact_id FROM &#39; || get_dest_tab_name(&#39;CONTACT&#39;) || &#39; )&#39;&#10;        BULK COLLECT INTO l_tab_rows, l_tab;&#10;&#10;        --&#10;        FOR l_i IN 1..l_tab.COUNT LOOP&#10;            C08001_PDT_SUPPORT.p_del_rec(&#10;                p_tab_name        &#61;&gt; p_table,&#10;                p_row_id          &#61;&gt; l_tab_rows(l_i),&#10;                --p_column_name     &#61;&gt; p_table || &#39;_ID&#39;,&#10;                p_debug_message   &#61;&gt; &#39;MISSING TOP PARENT SGC CONTACT RECORD ERROR&#39; );&#10;--            debugMessage(&#10;--                &#39;[&#39; || p_table || &#39;_ID&#61;&#39; || l_tab(l_i) || &#39;]&#39; || CHR(10) ||&#10;--                &#39;[MISSING PARENT SGC CONTACT RECORD ERROR][table&#61;&#39; || p_table || &#39;]&#39; );&#10;        END LOOP;&#10;        --&#10;    END do_delete_invalid_records;&#10;    --&#10;BEGIN&#10;    --&#10;    do_check_dest_schema(GC_DEST_MTC_SCHEMA);&#10;    --&#10;    OPEN cs;&#10;    LOOP&#10;        FETCH cs INTO l_table;&#10;        EXIT WHEN cs%NOTFOUND;&#10;        --&#10;        do_delete_invalid_records(p_table &#61;&gt; l_table);&#10;        COMMIT;&#10;    END LOOP;&#10;    CLOSE cs;&#10;    --&#10;--EXCEPTION WHEN OTHERS THEN&#10;--    IF cs%ISOPEN THEN&#10;--        CLOSE cs;&#10;--    END IF;&#10;--    RAISE;&#10;END do_fix_contact_SGC_FK;&#10;--&#10;PROCEDURE do_alter_self_ref_FK(p_action VARCHAR2, p_owner VARCHAR2 DEFAULT GC_DEST_MTC_SCHEMA)&#10;IS&#10;    --&#10;    CURSOR cs IS&#10;      SELECT DISTINCT&#10;        tc.table_name,&#10;        tc.column_name&#10;      FROM&#10;        all_constraints c,&#10;        all_cons_columns cc,&#10;        all_tab_columns tc,&#10;        all_constraints c1&#10;      WHERE 1&#61;1&#10;        AND c.owner &#61; p_owner&#10;        AND c.table_name IN (&#39;CONTACT&#39;, &#39;EVENT&#39;)&#10;        --AND tc.column_name &#61; p_col&#10;        AND c.constraint_type NOT IN (&#39;P&#39;)&#10;        --AND c.status NOT LIKE l_enable_disable_flag || &#39;_&#39;&#10;        AND cc.owner &#61; c.owner&#10;        AND cc.table_name &#61; c.table_name&#10;        AND cc.constraint_name &#61; c.constraint_name&#10;        AND tc.owner &#61; cc.owner&#10;        AND tc.table_name &#61; cc.table_name&#10;        AND tc.column_name &#61; cc.column_name&#10;        AND tc.owner &#61; cc.owner&#10;        --&#10;        AND c1.constraint_name &#61; c.r_constraint_name&#10;        AND c1.owner &#61; c.owner&#10;        AND c1.table_name &#61; c.table_name&#10;      ORDER BY tc.table_name, tc.column_name;&#10;    --&#10;    l_table  VARCHAR2(30);&#10;    l_column VARCHAR2(30);&#10;    --&#10;BEGIN&#10;    --&#10;    do_check_dest_schema(p_owner);&#10;    --&#10;    OPEN cs;&#10;    LOOP&#10;        FETCH cs INTO l_table, l_column;&#10;        EXIT WHEN cs%NOTFOUND;&#10;        --&#10;        do_alter_tab_col_cons(p_tab &#61;&gt; l_table, p_col &#61;&gt; l_column, p_enable_disable_flag &#61;&gt; p_action, p_owner &#61;&gt; p_owner);&#10;    END LOOP;&#10;    CLOSE cs;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    IF cs%ISOPEN THEN&#10;        CLOSE cs;&#10;    END IF;&#10;    RAISE;&#10;END do_alter_self_ref_FK;&#10;--&#10;PROCEDURE do_alter_user_id_FK(p_action VARCHAR2, p_owner VARCHAR2 DEFAULT GC_DEST_MTC_SCHEMA)&#10;IS&#10;    --&#10;    CURSOR cs IS&#10;      SELECT table_name, column_name&#10;      FROM all_tab_columns&#10;      WHERE owner &#61; p_owner&#10;        AND column_name IN ( &#39;STAFF_ID&#39;, &#39;EXTERNAL_PROVIDER_ID&#39;, &#39;PROVIDER_EMPLOYEE_ID&#39; )&#10;        AND table_name IN (&#39;USER_&#39;);&#10;    --&#10;    l_table  VARCHAR2(30);&#10;    l_column VARCHAR2(30);&#10;    --&#10;BEGIN&#10;    --&#10;    do_check_dest_schema(p_owner);&#10;    --&#10;    OPEN cs;&#10;    LOOP&#10;        FETCH cs INTO l_table, l_column;&#10;        EXIT WHEN cs%NOTFOUND;&#10;        --&#10;        do_alter_tab_col_cons(p_tab &#61;&gt; l_table, p_col &#61;&gt; l_column, p_enable_disable_flag &#61;&gt; p_action, p_owner &#61;&gt; p_owner);&#10;    END LOOP;&#10;    CLOSE cs;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    IF cs%ISOPEN THEN&#10;        CLOSE cs;&#10;    END IF;&#10;    RAISE;&#10;END do_alter_user_id_FK;&#10;--&#10;--&#10;PROCEDURE do_disable_tab_indexes(p_table VARCHAR2, p_action VARCHAR2, p_owner VARCHAR2 DEFAULT GC_DEST_MTC_SCHEMA)&#10;IS&#10;    --&#10;    CURSOR cs IS&#10;      SELECT p_owner || &#39;.&#39; || index_name index_name&#10;      FROM all_indexes&#10;      WHERE owner &#61; p_owner&#10;        AND table_name &#61; p_table&#10;        AND index_name LIKE &#39;XIE%&#39;&#10;    ;&#10;    --&#10;    l_idx VARCHAR2(100);&#10;    l_SQL VARCHAR2(1024);&#10;    --&#10;BEGIN&#10;    --&#10;    do_check_dest_schema(p_owner);&#10;    --&#10;    OPEN cs;&#10;    LOOP&#10;        FETCH cs INTO l_idx;&#10;        EXIT WHEN cs%NOTFOUND;&#10;        --&#10;        l_SQL :&#61;&#10;            &#39;ALTER INDEX &#39; || l_idx || &#39; &#39; ||&#10;            CASE&#10;                WHEN UPPER(p_action) IN (&#39;DISABLE&#39;, &#39;UNUSABLE&#39;)&#10;                    THEN &#39;UNUSABLE&#39;&#10;                WHEN UPPER(p_action) IN (&#39;ENABLE&#39;, &#39;REBUILD&#39;)&#10;                    THEN &#39;REBUILD&#39;&#10;            END;&#10;        --&#10;        BEGIN&#10;            EXECUTE IMMEDIATE &#39;BEGIN &#39; || p_owner || &#39;.C08001_PDT_SUPPORT.exec_sql(:p_SQL); END;&#39; USING l_SQL;&#10;        EXCEPTION WHEN OTHERS THEN&#10;            message(&#39;ERROR in DO_DISABLE_TAB_INDEXES&#39; ||&#10;                &#39;[table&#61;&#39; || p_table || &#39;]&#39; ||&#10;                &#39;[action&#61;&#39; || p_action || &#39;]&#39; ||&#10;                &#39;[schema&#61;&#39; || p_owner || &#39;]&#39; ||&#10;                &#39;[idx&#61;&#39; || l_idx || &#39;]:&#39; || CHR(10) || SQLERRM );&#10;            RAISE;&#10;        END;&#10;        --&#10;    END LOOP;&#10;    CLOSE cs;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    IF cs%ISOPEN THEN&#10;        CLOSE cs;&#10;    END IF;&#10;    RAISE;&#10;END do_disable_tab_indexes;&#10;--&#10;PROCEDURE do_disable_tab_triggers(p_table VARCHAR2, p_action VARCHAR2, p_owner VARCHAR2 DEFAULT GC_DEST_MTC_SCHEMA)&#10;IS&#10;    --&#10;    l_SQL VARCHAR2(1024);&#10;    --&#10;BEGIN&#10;    --&#10;    do_check_dest_schema(p_owner);&#10;    --&#10;    l_SQL :&#61;&#10;        &#39;ALTER TABLE &#39; || get_dest_tab_name(p_table, p_owner) || &#39; &#39; ||&#10;        CASE&#10;            WHEN UPPER(p_action) IN (&#39;DISABLE&#39;, &#39;UNUSABLE&#39;)&#10;                THEN &#39;DISABLE&#39;&#10;            WHEN UPPER(p_action) IN (&#39;ENABLE&#39;)&#10;                THEN &#39;ENABLE&#39;&#10;        END ||&#10;        &#39; ALL TRIGGERS&#39;;&#10;    --&#10;    BEGIN&#10;        EXECUTE IMMEDIATE &#39;BEGIN &#39; || p_owner || &#39;.C08001_PDT_SUPPORT.exec_sql(:p_SQL); END;&#39; USING l_SQL;&#10;    EXCEPTION WHEN OTHERS THEN&#10;        message(&#39;ERROR in DO_DISABLE_TAB_TRIGGERS&#39; ||&#10;            &#39;[table&#61;&#39; || p_table || &#39;]&#39; ||&#10;            &#39;[action&#61;&#39; || p_action || &#39;]:&#39; || CHR(10) || SQLERRM );&#10;        RAISE;&#10;    END;&#10;    --&#10;END do_disable_tab_triggers;&#10;--&#10;FUNCTION get_num_of_rows(p_dest_schema VARCHAR2, p_table_name VARCHAR2, p_exclude_non_MTU_rows VARCHAR2 DEFAULT &#39;N&#39;) RETURN NUMBER&#10;IS&#10;    l_proc VARCHAR2(30) :&#61; &#39;GET_NUM_OF_ROWS&#39;;&#10;    --&#10;    TYPE l_cur_TYP IS REF CURSOR;&#10;    l_cur l_cur_TYP;&#10;    l_ret NUMBER;&#10;    l_SQL VARCHAR2(4000);&#10;BEGIN&#10;    IF p_dest_schema IS NOT NULL THEN&#10;        BEGIN&#10;            l_SQL :&#61; &#39;SELECT COUNT(1) FROM &#39; || get_dest_tab_name(p_table_name, p_dest_schema);&#10;            --&#10;            IF p_exclude_non_MTU_rows &#61; &#39;Y&#39; AND p_table_name IN (&#39;ADDRESS&#39;, &#39;CONTACT&#39;) AND SUBSTR(p_dest_schema, 1, 3) &#61; &#39;MTC&#39; THEN&#10;                l_SQL :&#61; l_SQL || &#39; WHERE &#39; || p_table_name || &#39;_ID IN ( SELECT &#39; || p_table_name || &#39;_ID FROM &#39; || p_table_name || &#39;)&#39;;&#10;            END IF;&#10;            --&#10;            OPEN l_cur FOR l_SQL;&#10;            FETCH l_cur INTO l_ret;&#10;            CLOSE l_cur;&#10;        EXCEPTION WHEN OTHERS THEN&#10;            IF l_cur%ISOPEN THEN&#10;                CLOSE l_cur;&#10;            END IF;&#10;            raise_error(&#39;ERROR: &#39; || SQLERRM || CHR(10) || l_SQL, l_proc);&#10;            l_ret :&#61; 0;&#10;        END;&#10;    ELSE&#10;        l_ret :&#61; 0;&#10;    END IF;&#10;    --&#10;    RETURN l_ret;&#10;    --&#10;END get_num_of_rows;&#10;--&#10;--&#10;PROCEDURE do_load_config IS&#10;BEGIN&#10;    message(&#39;WARNING in DO_LOAD_CONFIG: not implemented yet!&#39;);&#10;END do_load_config;&#10;--&#10;--&#10;/*&#10;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#10;  FUNCTION: Returns list of top level Offender records to be migrated to the target MTC STAGING schema&#10;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#10;*/&#10;FUNCTION get_offender_data(&#10;    p_area_list            VARCHAR2 DEFAULT NULL,&#10;    p_crn_list             VARCHAR2 DEFAULT NULL,&#10;    p_old_crn_list         VARCHAR2 DEFAULT NULL,&#10;    p_off_rec_from         INTEGER  DEFAULT 0,&#10;    p_off_rec_to           INTEGER  DEFAULT 0,&#10;    p_where                VARCHAR2 DEFAULT NULL,&#10;    p_data_sample          NUMBER   DEFAULT 100 )&#10;RETURN t_offender_tab_TYP PIPELINED&#10;IS&#10;    --&#10;    l_proc VARCHAR2(32) :&#61; &#39;GET_OFFENDER_DATA&#39;;&#10;    --&#10;    lc_batch_size CONSTANT INTEGER :&#61; 1000;&#10;    --&#10;    l_i     INTEGER;&#10;    l_cnt   INTEGER;&#10;    l_rows  INTEGER :&#61; 0;&#10;    l_tab   t_offender_tab_TYP;&#10;    --&#10;    l_tab_crn       T_TAB_ORGANISATIONS;&#10;    l_tab_old_crn   T_TAB_ORGANISATIONS;&#10;    l_tab_area      T_TAB_ORGANISATIONS;&#10;    --&#10;    l_data_sample  NUMBER;&#10;    --&#10;    l_row          INTEGER :&#61; 0;&#10;    l_rows_scanned INTEGER :&#61; 0;&#10;    --&#10;    l_SQL VARCHAR2(32767);&#10;    --&#10;    TYPE l_cur_TYP IS REF CURSOR;&#10;    l_cur l_cur_TYP;&#10;    --&#10;    --CURSOR l_cur IS&#10;          --AND ( NVL(p_crn_list , &#39;&#39;ALL&#39;&#39;) &#61; &#39;&#39;ALL&#39;&#39; OR ( INSTRB(&#39;&#39;#&#39;&#39; || REPLACE(REPLACE(:p_crn_list , &#39;&#39;,&#39;&#39;, &#39;&#39;#&#39;&#39;), &#39;&#39; &#39;&#39;, &#39;&#39;&#39;&#39;) || &#39;&#39;#&#39;&#39;, &#39;&#39;#&#39;&#39; || T.old_crn   || &#39;&#39;#&#39;&#39;) &gt; 0 ) )&#10;          --AND ( NVL(p_area_list, &#39;&#39;ALL&#39;&#39;) &#61; &#39;&#39;ALL&#39;&#39; OR ( INSTRB(&#39;&#39;#&#39;&#39; || REPLACE(REPLACE(:p_area_list, &#39;&#39;,&#39;&#39;, &#39;&#39;#&#39;&#39;), &#39;&#39; &#39;&#39;, &#39;&#39;&#39;&#39;) || &#39;&#39;#&#39;&#39;, &#39;&#39;#&#39;&#39; || T.area_code || &#39;&#39;#&#39;&#39;) &gt; 0 ) )&#10;    --&#10;BEGIN&#10;    --&#10;    l_tab_area    :&#61; PKG_LstUtl.get_list_2_array(REPLACE(REPLACE(p_area_list    , &#39; &#39;, &#39;&#39;), &#39;;&#39;, &#39;,&#39;));&#10;    l_tab_crn     :&#61; PKG_LstUtl.get_list_2_array(REPLACE(REPLACE(p_crn_list     , &#39; &#39;, &#39;&#39;), &#39;;&#39;, &#39;,&#39;));&#10;    l_tab_old_crn :&#61; PKG_LstUtl.get_list_2_array(REPLACE(REPLACE(p_old_crn_list , &#39; &#39;, &#39;&#39;), &#39;;&#39;, &#39;,&#39;));&#10;    --&#10;    IF NOT NVL(ABS(p_data_sample), 100) BETWEEN 1 AND 100 THEN&#10;        l_data_sample :&#61; 100;&#10;    ELSE&#10;        l_data_sample :&#61; NVL(ABS(p_data_sample), 100);&#10;    END IF;&#10;    --&#10;    l_SQL :&#61;&#10;     &#39;WITH T AS (&#10;        SELECT&#10;          ROWIDTOCHAR(O.rowid)      AS row_id_CHAR,&#10;          O.offender_id,&#10;          PKG_Lookups.funcgetTabRecord(&#10;              p_table   &#61;&gt; &#39;&#39;additional_identifier&#39;&#39;,&#10;              p_data_fld&#61;&gt; &#39;&#39;IDENTIFIER&#39;&#39;,&#10;              p_ref_col &#61;&gt; &#39;&#39;OFFENDER_ID&#39;&#39;,&#10;              p_ref_val &#61;&gt; O.offender_id,&#10;              p_where   &#61;&gt; &#39;&#39;identifier_name_id &#61; 548 AND SUBSTRB(identifier, 1, 3) IN (SELECT code FROM probation_area)&#39;&#39;&#10;          )                         AS old_crn,&#10;          O.crn                     AS crn,&#10;          OM.team_id,&#10;          T.probation_area_id,&#10;          PA.code                   AS area_code,&#10;          --&#10;          DBMS_RANDOM.random                                                     AS random_number,&#10;          ROW_NUMBER() OVER ( PARTITION BY PA.code ORDER BY DBMS_RANDOM.random ) AS random_row_number&#10;        FROM&#10;          offender O&#10;          INNER JOIN offender_manager OM&#10;            ON OM.offender_id &#61; O.offender_id AND OM.active_flag &#61; 1&#10;          INNER JOIN team T&#10;            ON T.team_id &#61; OM.team_id&#10;          INNER JOIN probation_area PA&#10;            ON PA.probation_area_id &#61; T.probation_area_id&#10;        ),&#10;        T_SUMMARY AS (&#10;          SELECT area_code, COUNT(1) AS total_rows&#10;          FROM T&#10;          GROUP BY area_code&#10;        ),&#10;        O AS (&#10;          --&#10;          SELECT DISTINCT&#10;            T.row_id_CHAR,&#10;            T.offender_id,&#10;            T.old_crn,&#10;            T.crn,&#10;            T.team_id,&#10;            T.probation_area_id,&#10;            T.area_code&#10;          FROM T JOIN T_SUMMARY ON T_SUMMARY.area_code &#61; T.area_code&#10;          WHERE 1&#61;1&#10;            AND ( &#39; || CASE WHEN NVL(p_area_list   , &#39;ALL&#39;) !&#61; &#39;ALL&#39; THEN &#39;PKG_LstUtl.get_list_2_array(REPLACE(REPLACE(:p_area_list    , &#39;&#39; &#39;&#39;, &#39;&#39;&#39;&#39;), &#39;&#39;;&#39;&#39;, &#39;&#39;,&#39;&#39;)) MULTISET INTERSECT T_TAB_ORGANISATIONS( T.area_code ) IS NOT EMPTY&#39; ELSE &#39;NVL(:p_area_list   , &#39;&#39;ALL&#39;&#39;) &#61; &#39;&#39;ALL&#39;&#39;&#39; END || &#39; )&#10;            AND ( &#39; || CASE WHEN NVL(p_old_crn_list, &#39;ALL&#39;) !&#61; &#39;ALL&#39; THEN &#39;PKG_LstUtl.get_list_2_array(REPLACE(REPLACE(:p_old_crn_list , &#39;&#39; &#39;&#39;, &#39;&#39;&#39;&#39;), &#39;&#39;;&#39;&#39;, &#39;&#39;,&#39;&#39;)) MULTISET INTERSECT T_TAB_ORGANISATIONS( T.old_crn   ) IS NOT EMPTY&#39; ELSE &#39;NVL(:p_old_crn_list, &#39;&#39;ALL&#39;&#39;) &#61; &#39;&#39;ALL&#39;&#39;&#39; END || &#39; )&#10;            AND ( &#39; || CASE WHEN NVL(p_crn_list    , &#39;ALL&#39;) !&#61; &#39;ALL&#39; THEN &#39;PKG_LstUtl.get_list_2_array(REPLACE(REPLACE(:p_crn_list     , &#39;&#39; &#39;&#39;, &#39;&#39;&#39;&#39;), &#39;&#39;;&#39;&#39;, &#39;&#39;,&#39;&#39;)) MULTISET INTERSECT T_TAB_ORGANISATIONS( T.crn       ) IS NOT EMPTY&#39; ELSE &#39;NVL(:p_crn_list    , &#39;&#39;ALL&#39;&#39;) &#61; &#39;&#39;ALL&#39;&#39;&#39; END || &#39; )&#10;            AND ( &#39; || CASE WHEN NVL(l_data_sample , 100  ) !&#61; 100   THEN &#39;T.random_row_number / T_SUMMARY.total_rows &lt;&#61; :p_data_sample / 100&#39;                                                                                            ELSE &#39;NVL(:p_data_sample , 100    ) &#61; 100&#39;     END || &#39; )&#10;          ORDER BY T.offender_id&#10;        )&#10;        --&#10;        SELECT *&#10;        FROM O&#10;        WHERE &#39; || NVL(p_where, &#39;1&#61;1&#39;)&#10;    ;&#10;    --&#10;    OPEN l_cur FOR l_SQL&#10;    USING&#10;      p_area_list,&#10;      p_old_crn_list,&#10;      p_crn_list,&#10;      l_data_sample;&#10;    --&#10;    LOOP&#10;        --&#10;        FETCH l_cur BULK COLLECT INTO l_tab LIMIT lc_batch_size;&#10;        l_cnt :&#61; NVL(l_tab.COUNT, 0);&#10;        --&#10;        EXIT WHEN ( l_tab.COUNT &#61; 0 ) OR ( check_semaphore(g_component_code, &#39;STOP&#39;) &#61; &#39;Y&#39; );&#10;        --&#10;        g_label :&#61; &#39;100130&#39;;&#10;        FOR l_i IN 1..l_cnt LOOP&#10;            l_rows_scanned :&#61; l_rows_scanned + 1;&#10;            --&#10;            IF (NVL(p_off_rec_from, 0  ) &lt;&#61; 0   OR l_rows_scanned &gt;&#61; p_off_rec_from) AND&#10;               (NVL(p_off_rec_to  , 0  ) &lt;&#61; 0   OR l_rows_scanned &lt;&#61; p_off_rec_to  )&#10;            THEN&#10;                --message(&#39;OFFENDER &#39; || l_row || &#39;: ROWID&#61;&#39; || CHARTOROWID(l_rec.row_id));&#10;                PIPE ROW(l_tab(l_i));&#10;            END IF;&#10;            --&#10;        END LOOP;&#10;        --&#10;        l_rows :&#61; l_rows + l_cnt;&#10;        --&#10;    END LOOP;&#10;    CLOSE l_cur;&#10;--    raise_application_error(-20001,&#10;--      &#39;[rows&#61;&#39;          || l_rows         || &#39;]&#39; ||&#10;--      &#39;[crn_list&#61;&#39;      || p_crn_list     || &#39;]&#39; ||&#10;--      &#39;[old_crn_list&#61;&#39;  || p_old_crn_list || &#39;]&#39; ||&#10;--      &#39;[area_list&#61;&#39;     || p_area_list    || &#39;]&#39; ||&#10;--      &#39;[data_sample&#61;&#39;   || l_data_sample  || &#39;]&#39;);&#10;EXCEPTION WHEN OTHERS THEN&#10;    debugMessage(&#39;ERROR: &#39; || SQLERRM || CHR(10) || l_SQL);&#10;    RAISE;&#10;END get_offender_data;&#10;--&#10;--&#10;--&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--&#10;-- NDelius Offender Tables Hierarchy helper subroutines&#10;--&#10;--&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;--&#10;--&#10;FUNCTION get_tab_list1(p_reverse_order_flag VARCHAR2 DEFAULT &#39;N&#39;) RETURN PKG_DynSQL.ttabTablesHierarchy PIPELINED&#10;IS&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;GET_TAB_LIST1&#39;;&#10;    --&#10;    l_i       INTEGER;&#10;    --&#10;    l_TAB     PKG_DynSQL.ttabTablesHierarchy :&#61; PKG_DynSQL.ttabTablesHierarchy();&#10;    --&#10;BEGIN&#10;    --&#10;    SELECT * BULK COLLECT INTO l_TAB&#10;    FROM TABLE( PKG_Search.get_tab_list(p_reverse_order_flag) );&#10;    --&#10;    FOR l_i IN 1..l_TAB.COUNT LOOP&#10;        PIPE ROW(l_TAB(l_i));&#10;    END LOOP;&#10;END get_tab_list1;&#10;--&#10;FUNCTION get_tab_list(&#10;    p_dest_schema VARCHAR2 DEFAULT NULL,&#10;    p_table_name  VARCHAR2 DEFAULT NULL )&#10;RETURN PKG_DynSQL.ttabTablesHierarchy PIPELINED&#10;IS&#10;    CURSOR csTab IS&#10;        SELECT *&#10;        FROM TABLE( C08001_PDT_SUPPORT.get_tab_list1 )&#10;        WHERE table_name &#61; NVL(p_table_name, table_name)&#10;        ORDER BY&#10;          hier_level,&#10;          parent_table,&#10;          table_name;&#10;    l_tab PKG_DynSQL.ttabTablesHierarchy;&#10;    l_idx INTEGER;&#10;BEGIN&#10;    OPEN csTab;&#10;    FETCH csTab BULK COLLECT INTO l_tab;&#10;    CLOSE csTab;&#10;    --&#10;    FOR l_idx IN 1..l_tab.COUNT LOOP&#10;        IF p_dest_schema IS NOT NULL THEN&#10;            l_tab(l_idx).num_of_rows :&#61; get_num_of_rows(p_dest_schema, l_tab(l_idx).table_name);&#10;        ELSE&#10;            l_tab(l_idx).num_of_rows :&#61; -1;&#10;        END IF;&#10;        PIPE ROW ( l_tab(l_idx) );&#10;    END LOOP;&#10;END get_tab_list;&#10;&#10;/*&#10;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#10;  PROCEDURE: Insert Record into target MTC schema&#10;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#10;*/&#10;PROCEDURE do_flush_pdt_log_cache(p_force BOOLEAN DEFAULT FALSE)&#10;IS&#10;    ex_dml EXCEPTION;&#10;    PRAGMA EXCEPTION_INIT(ex_dml, -24381);&#10;BEGIN&#10;    IF (NOT NVL(p_force, FALSE)) AND g_pdt_log_tab.COUNT &lt; 1000 THEN&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    DECLARE&#10;        l_SQL VARCHAR2(512);&#10;        l_table VARCHAR2(100) :&#61; get_dest_tab_name(&#39;PDT_table_rows&#39;);&#10;        --&#10;        l_i       INTEGER;&#10;        l_err_cnt INTEGER;&#10;        l_err_idx INTEGER;&#10;        l_errm    VARCHAR2(1024);&#10;    BEGIN&#10;        l_SQL :&#61; &#39;INSERT INTO &#39; || l_table || &#39;(pdt_run_seq, table_name, row_id, pk_value) VALUES (:p_run_seq, :p_table_name, :p_rowid, :p_pk_val)&#39;;&#10;        --&#10;        FORALL l_idx IN g_pdt_log_tab.FIRST .. g_pdt_log_tab.LAST SAVE EXCEPTIONS&#10;                EXECUTE IMMEDIATE l_SQL USING&#10;                    g_pdt_log_tab(l_idx).pdt_run_seq,&#10;                    g_pdt_log_tab(l_idx).table_name,&#10;                    g_pdt_log_tab(l_idx).row_id,&#10;                    g_pdt_log_tab(l_idx).pk_value;&#10;        --&#10;    EXCEPTION WHEN OTHERS THEN&#10;        IF SQLCODE &#61; -24381 THEN&#10;            l_err_cnt :&#61; SQL%BULK_EXCEPTIONS.COUNT;&#10;            FOR l_i IN 1..l_err_cnt LOOP&#10;                --&#10;                l_err_idx :&#61; SQL%BULK_EXCEPTIONS(l_i).ERROR_INDEX;&#10;                l_errm    :&#61; SQLERRM(-SQL%BULK_EXCEPTIONS(l_i).ERROR_CODE);&#10;                --&#10;                IF l_errm LIKE &#39;%ORA-%:%unique constraint%violated%&#39; THEN&#10;                    NULL;&#10;                ELSE&#10;                    raise_error(&#39;INSERT current record INTO &#39; || l_table || &#39; &#39; ||&#10;                        &#39;[run_seq&#61;&#39; || g_pdt_log_tab(l_err_idx).pdt_run_seq || &#39;]&#39; ||&#10;                        &#39;[table&#61;&#39;   || g_pdt_log_tab(l_err_idx).table_name  || &#39;]&#39; ||&#10;                        &#39;[row_id&#61;&#39;  || g_pdt_log_tab(l_err_idx).row_id      || &#39;]&#39; ||&#10;                        &#39;[pk&#61;&#39;      || g_pdt_log_tab(l_err_idx).pk_value    || &#39;]&#39; ||&#10;                        &#39;[err&#61;&#39;     || l_errm                               || &#39;]&#39;,&#10;                        &#39;DO_FLUSH_PDT_LOG_CACHE&#39; );&#10;                END IF;&#10;            END LOOP;&#10;        ELSE&#10;            RAISE;&#10;        END IF;&#10;    END;&#10;    --&#10;    g_pdt_log_tab.DELETE;&#10;    --&#10;END do_flush_pdt_log_cache;&#10;--&#10;--&#10;PROCEDURE p_del_rec(&#10;    p_tab_name        VARCHAR2,&#10;    p_row_id          ROWID,&#10;    p_column_name     VARCHAR2 DEFAULT NULL,&#10;    p_debug_message   VARCHAR2 DEFAULT NULL )&#10;IS&#10;--    l_proc VARCHAR2(32) :&#61; &#39;P_DEL_REC&#39;;&#10;--    --&#10;--    recursive_limit_exception EXCEPTION;&#10;--    lc_max_recursion CONSTANT NUMBER :&#61; 100;&#10;--    --&#10;--    TYPE  l_cur_TYP IS REF CURSOR;&#10;--    l_cur l_cur_TYP;&#10;--    --&#10;--    l_SQL        VARCHAR2(10000);&#10;--    --&#10;--    l_tab_idx INTEGER;&#10;--    l_row_idx INTEGER;&#10;--    --&#10;--    l_dest_table VARCHAR2(100);&#10;--    --&#10;--    CURSOR csChldTab(p_parent_table VARCHAR2) IS&#10;--      SELECT table_name&#10;--      FROM all_tab_columns TC&#10;--      WHERE owner &#61; g_dest_schema&#10;--        AND column_name &#61; UPPER(p_parent_table) || &#39;_ID&#39;&#10;--        AND table_name NOT IN (p_parent_table);&#10;--    l_child_table VARCHAR2(30);&#10;--    --&#10;--    TYPE l_tab_TYP IS TABLE OF VARCHAR2(30);&#10;--    l_tab_CHLD l_tab_TYP;&#10;--    --&#10;--    TYPE l_tab_rows_TYP IS TABLE OF ROWID;&#10;--    l_tab_rows l_tab_rows_TYP;&#10;--    --&#10;--    PROCEDURE do_delete_current_record&#10;--    IS&#10;--        l_cols VARCHAR2(4000);&#10;--        l_vals VARCHAR2(4000);&#10;--        l_SQL  VARCHAR2(4000);&#10;--    BEGIN&#10;--        --&#10;--        IF g_tab_info(p_tab_name).pk_fld_lst &#61; NVL(p_column_name, &#39;X&#39;) THEN&#10;--            l_cols :&#61; g_tab_info(p_tab_name).pk_fld_lst;&#10;--        ELSE&#10;--            l_cols :&#61;&#10;--                  PKG_LstUtl.concat(&#10;--                      g_tab_info(p_tab_name).pk_fld_lst,&#10;--                      p_column_name,&#10;--                      p_delim &#61;&gt; &#39;,&#39;);&#10;--        END IF;&#10;--        --&#10;--        l_SQL :&#61;&#10;--           &#39;SELECT SUBSTR(&#39; || REPLACE(l_cols, &#39;,&#39;, &#39;||&#39;&#39;,&#39;&#39;||&#39;) || &#39;, 1, 4000) PK_KEY_VAL&#10;--            FROM &#39; || l_dest_table || &#39;&#10;--            WHERE ROWID &#61; :p_row_id&#39;&#10;--        ;&#10;--        --message(l_sql);&#10;--        --&#10;--        EXECUTE IMMEDIATE l_SQL INTO l_vals USING p_row_id;&#10;--        --&#10;--        debugMessage(&#10;--            CASE WHEN p_debug_message IS NOT NULL THEN &#39;[&#39; || p_debug_message || &#39;]: &#39; END ||&#10;--            &#39;[table&#61;&#39; || l_dest_table       || &#39;]&#39;  ||&#10;--            &#39;[level&#61;&#39; || p_recursive_level  || &#39;]&#39;  ||&#10;--            &#39;[&#39; || l_cols || &#39;&#61;&#39; || l_vals  || &#39;]&#39;&#10;--        );&#10;--        --&#10;----        COMMIT;&#10;--        l_SQL :&#61; &#39;DELETE FROM &#39; || l_dest_table || &#39; WHERE ROWID &#61; :p_row_id&#39;;&#10;--        EXECUTE IMMEDIATE l_SQL  USING p_row_id;&#10;--        --&#10;--        --ROLLBACK;&#10;--        --&#10;--    EXCEPTION WHEN OTHERS THEN&#10;--        ROLLBACK;&#10;--        raise_application_error(-20001, &#39;ERROR in P_DEL_REC.do_delete_current_record &#39; ||&#10;--            --&#39;[SQL: &#39; || l_SQL || &#39;]&#39; || CHR(10) ||&#10;--            &#39;[table&#61;&#39; || l_dest_table             || &#39;]&#39;  ||&#10;--            &#39;[level&#61;&#39; || p_recursive_level        || &#39;]&#39;  ||&#10;--            &#39;[&#39; || l_cols || &#39;&#61;&#39; || l_vals        || &#39;]&#39;  ||&#10;--            &#39;[ERROR: &#39; || get_dq_message(SQLERRM) || &#39;]&#39; );&#10;--    END do_delete_current_record;&#10;--    --&#10;--BEGIN&#10;--    --&#10;--    l_dest_table :&#61; get_dest_tab_name(p_tab_name, g_dest_schema);&#10;--    --&#10;--    IF (p_recursive_level &gt;&#61; lc_max_recursion) THEN&#10;--        debugMessage(&#39;ERROR while trying to DELETE current record FROM &#39; || l_dest_table || &#39;: &#39; ||&#10;--            &#39;Count no. of recursive calls [&#39; || p_recursive_level || &#39;] - must not exceed the maximum of &#39; || lc_max_recursion);&#10;--        RAISE recursive_limit_exception;&#10;--    END IF;&#10;--    --&#10;--    -- Get next dependant table name (new p-table) for p-table from offender hierarchy&#10;--    OPEN csChldTab(p_tab_name);&#10;--    FETCH csChldTab BULK COLLECT INTO l_tab_CHLD;&#10;--    CLOSE csChldTab;&#10;--    --&#10;--    FOR l_tab_idx IN 1..l_tab_CHLD.COUNT&#10;--    LOOP&#10;--        l_SQL :&#61;&#10;--           &#39;SELECT ROWID row_id&#10;--            FROM &#39; || get_dest_tab_name( l_tab_CHLD(l_tab_idx) ) || &#39;&#10;--            WHERE (&#39; || p_tab_name || &#39;_ID ) IN (&#10;--                   SELECT &#39; || p_tab_name || &#39;_ID&#10;--                   FROM &#39; || l_dest_table || &#39;&#10;--                   WHERE ROWID &#61; :p_row_id)&#39;;&#10;--        --&#10;--        BEGIN&#10;--            --message(&#39;bind vars: &#39; || GC_READY_FOR_MIGRATION || &#39;, &#39; || ROWIDTOCHAR(p_row_id));&#10;--            OPEN l_cur FOR l_SQL USING p_row_id;&#10;--            FETCH l_cur BULK COLLECT INTO l_tab_rows;&#10;--            CLOSE l_cur;&#10;--            FOR l_row_idx IN 1..l_tab_rows.COUNT&#10;--            LOOP&#10;----                message(&#39;p_del_rec&#39; ||&#10;----                    &#39;[&#39; || l_tab_CHLD(l_tab_idx)          || &#39;]&#39; ||&#10;----                    &#39;[&#39; || ROWIDTOCHAR(l_tab_rows(l_tab_dep_idx))  || &#39;]&#39; ||&#10;----                    --&#39;[&#39; || l_dep_rec.pk_key_val           || &#39;]&#39; ||&#10;----                    &#39;[&#39; || TO_CHAR(p_recursive_level + 1) || &#39;]&#39; );&#10;----                g_label :&#61; &#39;1075&#39;;&#10;--                --&#10;--                p_del_rec(&#10;--                    p_tab_name        &#61;&gt; l_tab_CHLD(l_tab_idx),&#10;--                    p_row_id          &#61;&gt; l_tab_rows(l_row_idx),&#10;--                    p_column_name     &#61;&gt; p_tab_name || &#39;_ID&#39;,&#10;--                    p_debug_message   &#61;&gt; p_debug_message,&#10;--                    p_recursive_level &#61;&gt; p_recursive_level + 1 );&#10;--                --&#10;--            END LOOP;&#10;--        EXCEPTION&#10;--            WHEN fatal_error_exception THEN&#10;--                RAISE;&#10;--            WHEN recursive_limit_exception THEN&#10;--                raise_error(&#10;--                    &#39;ERROR in P_DEL_REC [&#39; || l_tab_CHLD(l_tab_idx) || &#39;]: recursive call stack has exceeded the maximum limit of &#39; || lc_max_recursion,&#10;--                    &#39;P_DEL_REC&#39; );&#10;--        END;&#10;--        --&#10;--    END LOOP;&#10;--    --&#10;--    do_delete_current_record;&#10;--    --&#10;BEGIN&#10;    PKG_DPA_DELETION.p_del_rec(&#10;        p_tab_name        &#61;&gt; p_tab_name,&#10;        p_row_id          &#61;&gt; p_row_id,&#10;        p_debug_message   &#61;&gt; p_debug_message,&#10;        p_dest_schema     &#61;&gt; USER );&#10;END p_del_rec;&#10;--&#10;PROCEDURE do_insert_current_record(&#10;    p_tab_name    VARCHAR2,&#10;    p_src_table   VARCHAR2,&#10;    p_dest_table  VARCHAR2,&#10;    p_row_id      ROWID,&#10;    p_level       INTEGER,&#10;    p_pk_key_val  VARCHAR2 DEFAULT &#39;NO_VALUE&#39; )&#10;--p_tab_name VARCHAR2, p_row_id ROWID)&#10;IS&#10;    l_proc CONSTANT VARCHAR2(30) :&#61; &#39;DO_INSERT_CURRENT_RECORD&#39;;&#10;    --&#10;    TYPE l_cur_TYP IS REF CURSOR;&#10;    l_cur l_cur_TYP;&#10;    --&#10;    l_SQL         VARCHAR2(32767);&#10;    --&#10;    l_pdt_log_rec t_pdt_log_rec_TYP;&#10;    --&#10;    l_row_id      ROWID;&#10;    l_pk_key_val  VARCHAR2(4000);&#10;    l_m_status    INTEGER;&#10;    l_err_msg     VARCHAR2(1024);&#10;    --&#10;    l_cnt INTEGER;&#10;    --&#10;    l_skip_FLAG BOOLEAN :&#61; FALSE;&#10;    --&#10;BEGIN&#10;    g_label :&#61; &#39;20000&#39;;&#10;    --&#10;    -- Check if current record has not been mutated&#10;    /*&#10;    g_label :&#61; &#39;20020&#39;;&#10;    --&#10;    IF NVL(p_pk_key_val, &#39;NO_VALUE&#39;) &#61; &#39;NO_VALUE&#39; THEN&#10;        l_SQL :&#61; &#39;SELECT COUNT(1) FROM &#39; || p_src_table || &#39; WHERE ROWID &#61; :p_row_id&#39;;&#10;        EXECUTE IMMEDIATE l_SQL INTO l_m_status USING p_row_id;&#10;    ELSE&#10;        l_SQL :&#61;&#10;           &#39;SELECT 1, SUBSTR(&#39; || REPLACE(g_tab_info(p_tab_name).pk_fld_lst, &#39;,&#39;, &#39; || &#39;) || &#39;, 1, 4000) PK_KEY_VAL&#10;            FROM &#39; || p_src_table || &#39;&#10;            WHERE ROWID &#61; :p_row_id&#39;;&#10;        EXECUTE IMMEDIATE l_SQL INTO l_m_status, l_pk_key_val USING p_row_id;&#10;    END IF;&#10;    --&#10;    IF NVL(l_m_status, -1) &lt;&gt; 1 THEN&#10;        l_err_msg :&#61; &#39;FATAL ERROR in &#39; || l_proc || &#39;: table[&#39; || p_src_table || &#39;] has an unexpected MIGRATION_STATUS value [&#39; || l_m_status || &#39;]&#39;;&#10;    ELSIF NVL(p_pk_key_val, &#39;NO_VALUE&#39;) &lt;&gt; &#39;NO_VALUE&#39; AND NVL(l_pk_key_val, &#39;XXX&#39;) &lt;&gt; NVL(p_pk_key_val, &#39;ZZZ&#39;) THEN&#10;        l_err_msg :&#61; &#39;FATAL ERROR in &#39; || l_proc || &#39;: table[&#39; || p_src_table || &#39;] has an unexpected PK Key value [&#39; || l_pk_key_val || &#39;]; expected: [&#39; || p_pk_key_val || &#39;]&#39;;&#10;    END IF;&#10;    IF l_err_msg IS NOT NULL THEN&#10;        raise_error(l_err_msg, l_proc);&#10;        RAISE fatal_error_exception;&#10;    END IF;&#10;    */&#10;    --&#10;    --&#10;    -- Insert Current Record&#10;    g_label :&#61; &#39;20025&#39;;&#10;    --&#10;    IF UPPER(p_tab_name) &lt;&gt; &#39;OFFENDER&#39; THEN&#10;        BEGIN&#10;            l_SQL :&#61; &#39;INSERT INTO &#39; || get_dest_tab_name(&#39;PDT_table_rows&#39;) || &#39;(pdt_run_seq, table_name, row_id, pk_value) VALUES (:p_run_seq, :p_table_name, :p_rowid, :p_pk_val)&#39;;&#10;            EXECUTE IMMEDIATE l_SQL USING&#10;              g_pdt_run_seq,&#10;              p_tab_name,&#10;              p_row_id,&#10;              p_pk_key_val;&#10;        EXCEPTION WHEN OTHERS THEN&#10;            IF SQLERRM LIKE &#39;%ORA-%:%unique constraint%violated%&#39; THEN&#10;                l_skip_FLAG :&#61; TRUE;&#10;            ELSE&#10;                debugMessage(&#39;INSERT current record INTO &#39; || get_dest_tab_name(&#39;PDT_table_rows&#39;) || &#39;: &#39; || SQLERRM, p_err_flag&#61;&gt;&#39;Y&#39;);&#10;                raise_error(SQLERRM, l_proc || &#39;[&#39; || get_dest_tab_name(&#39;PDT_table_rows&#39;) || &#39;]&#39;);&#10;            END IF;&#10;        END;&#10;    END IF;&#10;    --&#10;    --IF NOT l_skip_FLAG THEN&#10;        l_SQL :&#61;&#10;            &#39;INSERT INTO &#39; || p_dest_table || &#39;(&#10;            &#39; || g_tab_info(p_tab_name).fld_lst || &#39;)&#10;             SELECT &#39; || g_tab_info(p_tab_name).fld_lst_1 || &#39;&#10;             FROM &#39; || p_src_table || &#39;&#10;             WHERE ROWID &#61; :p_row_id&#39;;&#10;        EXECUTE IMMEDIATE l_SQL USING p_row_id;&#10;    --END IF;&#10;    /*l_pdt_log_rec.pdt_run_seq :&#61; g_pdt_run_seq;&#10;    l_pdt_log_rec.table_name  :&#61; p_tab_name;&#10;    l_pdt_log_rec.row_id      :&#61; p_row_id;&#10;    l_pdt_log_rec.pk_value    :&#61; p_pk_key_val;&#10;&#10;    g_pdt_log_tab.EXTEND;&#10;    --&#10;    g_pdt_log_tab(g_pdt_log_tab.LAST) :&#61; l_pdt_log_rec;&#10;    do_flush_pdt_log_cache;*/&#10;&#10;EXCEPTION WHEN OTHERS THEN&#10;    IF ( SQLERRM LIKE &#39;%ORA-%:%unique constraint%violated%&#39; ) THEN&#10;        NULL;&#10;--    ELSIF p_dest_table LIKE &#39;%CONTACT&#39; AND SQLERRM LIKE &#39;%integrity constraint%violated - parent key not found%&#39; THEN&#10;--        NULL;&#10;    ELSIF /*p_dest_table NOT LIKE &#39;%CONTACT&#39; AND*/ SQLERRM LIKE &#39;%integrity constraint%violated - parent key not found%&#39; THEN&#10;        debugMessage(&#10;            &#39;[&#39; || g_tab_info(p_tab_name).pk_fld_lst || &#39;&#61;&#39; ||&#10;            CASE&#10;                WHEN p_pk_key_val IS NULL THEN&#10;                    PKG_Lookups.funcgetTabRecord(&#10;                        p_data_fld  &#61;&gt; g_tab_info(p_tab_name).pk_fld_lst,&#10;                        p_table     &#61;&gt; p_src_table,&#10;                        p_ref_col   &#61;&gt; &#39;ROWID&#39;,&#10;                        p_ref_val   &#61;&gt; p_row_id )&#10;                ELSE p_pk_key_val&#10;            END || &#39;]&#39; || CHR(10) ||&#10;            --&#10;            &#39;[rowid&#61;&#39; || ROWIDTOCHAR(p_row_id) || &#39;]&#39; ||&#10;            --&#10;            get_dq_message(SQLERRM) || CHR(10) ||&#10;            --&#10;            &#39;SQL: &#39; || l_SQL,&#10;            &#39;[MISSING PARENT RECORD ERROR][table&#61;&#39; || p_tab_name || &#39;]&#39; );&#10;    ELSIF SQLERRM LIKE &#39;%ORA-01403: no data found%error during execution of trigger%&#39; THEN&#10;        debugMessage(&#10;            &#39;[&#39; || g_tab_info(p_tab_name).pk_fld_lst || &#39;&#61;&#39; ||&#10;            CASE&#10;                WHEN p_pk_key_val IS NULL THEN&#10;                    PKG_Lookups.funcgetTabRecord(&#10;                        p_data_fld  &#61;&gt; g_tab_info(p_tab_name).pk_fld_lst,&#10;                        p_table     &#61;&gt; p_src_table,&#10;                        p_ref_col   &#61;&gt; &#39;ROWID&#39;,&#10;                        p_ref_val   &#61;&gt; p_row_id )&#10;                ELSE p_pk_key_val&#10;            END || &#39;]&#39; || CHR(10) ||&#10;            --&#10;            &#39;[rowid&#61;&#39; || ROWIDTOCHAR(p_row_id) || &#39;]&#39; ||&#10;            --&#10;            SQLERRM || CHR(10) ||&#10;            --&#10;            &#39;SQL: &#39; || l_SQL,&#10;            &#39;[ERROR IN DATABASE TRIGGER]&#39; ||&#10;            &#39;[table&#61;&#39;   || p_tab_name || &#39;]&#39; ||&#10;            &#39;[trigger&#61;&#39; || TRIM(PKG_LstUtl.list_num_tail(SQLERRM, &#39;: error during execution of trigger&#39;, 1)) || &#39;]&#39;&#10;        );&#10;    ELSE&#10;        raise_error(&#10;            &#39;FAILED to INSERT a record FROM &#39; || p_src_table || &#39; WHERE rowid&#61;&#39; || ROWIDTOCHAR(p_row_id) || CHR(10) ||&#10;            SQLERRM || CHR(10) ||&#10;            &#39;SQL: &#39; || l_SQL,&#10;            l_proc || &#39;[&#39; || p_dest_table || &#39;]&#39; );&#10;    END IF;&#10;END do_insert_current_record;&#10;--&#10;PROCEDURE p_ins_rec(&#10;    p_tab_name        VARCHAR2,&#10;    p_row_id          ROWID,&#10;    p_recursive_level INTEGER DEFAULT 1,&#10;    p_pk_key_val      VARCHAR2 DEFAULT &#39;NO_VALUE&#39; )&#10;IS&#10;    l_proc VARCHAR2(32) :&#61; &#39;P_INS_REC&#39;;&#10;    --&#10;    recursive_limit_exception EXCEPTION;&#10;    lc_max_recursion CONSTANT NUMBER :&#61; 100;&#10;    --&#10;    TYPE  l_cur_TYP IS REF CURSOR;&#10;    l_cur l_cur_TYP;&#10;    --&#10;    --l_dep_row_id ROWID;&#10;    TYPE l_dep_rec_TYP IS RECORD(&#10;      row_id     ROWID,&#10;      pk_key_val VARCHAR2(4000));&#10;    l_dep_rec l_dep_rec_TYP;&#10;    --&#10;    TYPE l_tab_dep_rows_TYP IS TABLE OF l_dep_rec_TYP;&#10;    l_tab_dep_rows l_tab_dep_rows_TYP;&#10;    --&#10;    l_SQL        VARCHAR2(32767);&#10;    --&#10;    l_src_table  VARCHAR2(100);&#10;    l_dest_table VARCHAR2(100);&#10;    --&#10;    l_tab_OH  t_hier_tab_TYP;&#10;    l_tab_idx INTEGER;&#10;    --&#10;BEGIN&#10;    l_src_table  :&#61; get_src_tab_name (p_tab_name);&#10;    l_dest_table :&#61; get_dest_tab_name(p_tab_name, g_dest_schema);&#10;    --&#10;    IF (p_recursive_level &gt;&#61; lc_max_recursion) THEN&#10;        debugMessage(&#39;ERROR while trying to INSERT current record INTO &#39; || l_dest_table || &#39; FROM &#39; || l_src_table || &#39;: &#39; ||&#10;            &#39;Count no. of recursive calls [&#39; || p_recursive_level || &#39;] - must not exceed the maximum of &#39; || lc_max_recursion);&#10;        RAISE recursive_limit_exception;&#10;    END IF;&#10;    --&#10;    do_insert_current_record(&#10;        p_tab_name   &#61;&gt; p_tab_name,&#10;        p_src_table  &#61;&gt; l_src_table,&#10;        p_dest_table &#61;&gt; l_dest_table,&#10;        p_row_id     &#61;&gt; p_row_id,&#10;        p_pk_key_val &#61;&gt; p_pk_key_val,&#10;        p_level      &#61;&gt; p_recursive_level );&#10;    --&#10;    -- Get next dependant table name (new p-table) for p-table from offender hierarchy&#10;--    OPEN l_cur_OH;&#10;--    FETCH l_cur_OH BULK COLLECT INTO l_tab_OH;&#10;--    CLOSE l_cur_OH;&#10;    --&#10;    l_tab_OH :&#61; g_tab_info(p_tab_name).child_tables;&#10;    --&#10;    FOR l_tab_idx IN 1..l_tab_OH.COUNT&#10;    LOOP&#10;        l_SQL :&#61;&#10;           &#39;SELECT ROWID row_id, SUBSTR(&#39; || REPLACE(g_tab_info(l_tab_OH(l_tab_idx).table_name).pk_fld_lst, &#39;,&#39;, &#39; || &#39;) || &#39;, 1, 4000) PK_KEY_VAL&#10;            FROM &#39; || get_src_tab_name( l_tab_OH(l_tab_idx).table_name ) || &#39;&#10;            WHERE (&#39; || g_tab_info(l_tab_OH(l_tab_idx).parent_table).pk_fld_lst || &#39;) IN (&#10;                   SELECT &#39; || g_tab_info(l_tab_OH(l_tab_idx).parent_table).pk_fld_lst || &#39;&#10;                   FROM &#39; || get_src_tab_name( l_tab_OH(l_tab_idx).parent_table ) || &#39;&#10;                   WHERE ROWID &#61; :p_row_id)&#39;;&#10;        --&#10;        --message(&#39;P: p_ins_rec - in outer loop - &#39; || &#39;p_row_id&#61;&#39; || p_row_id || &#39; ; Current SQL:&#39; || CHR(10) || l_SQL);&#10;        --&#10;        BEGIN&#10;            --message(&#39;bind vars: &#39; || GC_READY_FOR_MIGRATION || &#39;, &#39; || ROWIDTOCHAR(p_row_id));&#10;            OPEN l_cur FOR l_SQL USING p_row_id;&#10;            FETCH l_cur BULK COLLECT INTO l_tab_dep_rows;&#10;            CLOSE l_cur;&#10;            FOR l_tab_dep_idx IN 1..l_tab_dep_rows.COUNT&#10;            LOOP&#10;                g_label :&#61; &#39;1060&#39;;&#10;                l_dep_rec :&#61; l_tab_dep_rows(l_tab_dep_idx);&#10;                --FETCH l_cur INTO l_dep_row_id;&#10;                --EXIT WHEN l_cur%NOTFOUND;&#10;&#10;                -- New p-table records are already pre-selected for curent Parent record&#10;                -- If new p-table PK value matches p-table PK values&#10;                -- p_ins_rec (new p-table,  PK values)&#10;&#10;                g_label :&#61; &#39;1070&#39;;&#10;                /*message(&#39;p_ins_rec&#39; ||&#10;                    &#39;[&#39; || l_rec_OH.table_name            || &#39;]&#39; ||&#10;                    &#39;[&#39; || ROWIDTOCHAR(l_dep_rec.row_id)  || &#39;]&#39; ||&#10;                    &#39;[&#39; || l_dep_rec.pk_key_val           || &#39;]&#39; ||&#10;                    &#39;[&#39; || TO_CHAR(p_recursive_level + 1) || &#39;]&#39; );&#10;                g_label :&#61; &#39;1075&#39;;*/&#10;                --&#10;                p_ins_rec(&#10;                    p_tab_name        &#61;&gt; l_tab_OH(l_tab_idx).table_name,&#10;                    p_row_id          &#61;&gt; l_dep_rec.row_id,&#10;                    p_pk_key_val      &#61;&gt; l_dep_rec.pk_key_val,&#10;                    p_recursive_level &#61;&gt; p_recursive_level + 1 );&#10;                --&#10;            END LOOP;&#10;        EXCEPTION&#10;            WHEN fatal_error_exception THEN&#10;                RAISE;&#10;            WHEN recursive_limit_exception THEN&#10;                raise_error(&#10;                    &#39;ERROR in P_INS_REC [&#39; || l_tab_OH(l_tab_idx).table_name || &#39;]: recursive call stack has exceeded the maximum limit of &#39; || lc_max_recursion,&#10;                    &#39;P_INS_REC&#39; );&#10;--            WHEN OTHERS THEN&#10;--                raise_error(&#10;--                    &#39;[&#39; || g_label || &#39;]  E: [&#39; || l_tab_OH(l_tab_idx).table_name || &#39;][&#39; || ROWIDTOCHAR(p_row_id) || &#39;][ERROR: &#39; || SQLERRM || &#39;; - SQL: &#39; || l_SQL,&#10;--                    &#39;P_INS_REC&#39; );&#10;        END;&#10;        --CLOSE l_cur;&#10;    END LOOP;&#10;    --&#10;END p_ins_rec;&#10;--&#10;PROCEDURE do_load_data_init(p_dest_schema VARCHAR2 DEFAULT GC_DEST_MTC_SCHEMA, p_run_seq INTEGER DEFAULT -1)&#10;IS&#10;BEGIN&#10;    --&#10;    g_component_code :&#61; 908001;&#10;    g_max_threads  :&#61; LEAST(get_cpu_count * 3, 24);&#10;    --&#10;    IF p_run_seq &gt; 0 THEN&#10;        g_pdt_run_seq :&#61; p_run_seq;&#10;    END IF;&#10;    --&#10;    IF g_debug_ready &#61; &#39;Y&#39; THEN&#10;        EXECUTE IMMEDIATE &#39;SELECT NVL(MAX(debug_seq), 0) FROM pdt_debug&#39; INTO g_pdt_debug_seq;&#10;    ELSE&#10;        g_pdt_debug_seq :&#61; -1;&#10;    END IF;&#10;    --&#10;    do_check_dest_schema(p_dest_schema);&#10;    g_dest_schema :&#61; p_dest_schema;&#10;    global_cache_mgr.pdt_active;&#10;    init_tab_info;&#10;    --&#10;END do_load_data_init;&#10;--&#10;PROCEDURE do_load_offender_data_MT(p_run_seq_id INTEGER, p_thread_id INTEGER DEFAULT -1)&#10;IS&#10;    --&#10;    TYPE l_cur_TYP IS REF CURSOR;&#10;    cs l_cur_TYP;&#10;    --&#10;    l_thread_id       INTEGER;&#10;    l_failed_threads  INTEGER;&#10;    l_instance_number INTEGER;&#10;    --&#10;    l_min_id_val INTEGER;&#10;    l_max_id_val INTEGER;&#10;    --&#10;    l_SQL VARCHAR2(4000);&#10;    --&#10;    PROCEDURE do_load_offenders(p_thread_id1 INTEGER)&#10;    IS&#10;        TYPE l_cur_TYP IS REF CURSOR;&#10;        l_cur l_cur_TYP;&#10;        --&#10;        TYPE l_rec_TYP IS RECORD(&#10;            offender_id NUMBER,&#10;            row_id      ROWID );&#10;        l_rec l_rec_TYP;&#10;        --&#10;        l_rows_processed INTEGER :&#61; 0;&#10;        --&#10;    BEGIN&#10;        --&#10;        update_thread_status(&#10;            p_component_id &#61;&gt; g_component_code,&#10;            p_thread_id    &#61;&gt; p_thread_id1,&#10;            p_status       &#61;&gt; 1,&#10;            p_err_msg      &#61;&gt; NULL);&#10;        --&#10;        OPEN l_cur FOR&#10;           &#39;SELECT TO_NUMBER(pk_value) AS offender_id, row_id&#10;            FROM &#39; || get_dest_tab_name(&#39;PDT_table_rows&#39;) || &#39;&#10;            WHERE pdt_run_seq &#61; :p_run_seq_id&#10;              AND thread_id &#61; :p_thread_id&#10;              AND table_name &#61; &#39;&#39;OFFENDER&#39;&#39;&#10;            ORDER BY 1&#39;&#10;        USING p_run_seq_id, p_thread_id1;&#10;        --&#10;        LOOP&#10;            FETCH l_cur INTO l_rec;&#10;            EXIT WHEN l_cur%NOTFOUND;&#10;            --&#10;            l_rows_processed :&#61; l_rows_processed + 1;&#10;            --&#10;--            message(&#10;--                &#39;p_row_id&#61;&gt;&#39; || l_rec.row_id || &#39;,&#39; ||&#10;--                &#39;p_pk_key_val&#61;&gt;&#39; || l_rec.offender_id&#10;--            );&#10;            --&#10;            p_ins_rec(&#10;                p_tab_name        &#61;&gt; &#39;OFFENDER&#39;,&#10;                p_row_id          &#61;&gt; l_rec.row_id,&#10;                p_pk_key_val      &#61;&gt; l_rec.offender_id,&#10;                p_recursive_level &#61;&gt; 1 );&#10;            --&#10;            IF l_rows_processed MOD 10 &#61; 0 THEN&#10;                update_thread_progress(&#10;                    p_component_id &#61;&gt; g_component_code,&#10;                    p_thread_id    &#61;&gt; p_thread_id1,&#10;                    p_rows         &#61;&gt; l_rows_processed,&#10;                    p_info_msg     &#61;&gt; &#39;Number of offender records loaded:&#39; || l_rows_processed );&#10;                COMMIT;&#10;            END IF;&#10;            --&#10;        END LOOP;&#10;        --&#10;        CLOSE l_cur;&#10;        --&#10;        do_flush_pdt_log_cache(TRUE);&#10;        COMMIT;&#10;        --&#10;        update_thread_progress(&#10;            p_component_id &#61;&gt; g_component_code,&#10;            p_thread_id    &#61;&gt; p_thread_id1,&#10;            p_rows         &#61;&gt; l_rows_processed,&#10;            p_info_msg     &#61;&gt; &#39;Number of offender records loaded:&#39; || l_rows_processed );&#10;        --&#10;        update_thread_status(&#10;            p_component_id &#61;&gt; g_component_code,&#10;            p_thread_id    &#61;&gt; p_thread_id1,&#10;            p_status       &#61;&gt; 3,&#10;            p_err_msg      &#61;&gt; NULL);&#10;        --&#10;    EXCEPTION WHEN OTHERS THEN&#10;        --&#10;        update_thread_status(&#10;            p_component_id &#61;&gt; g_component_code,&#10;            p_thread_id    &#61;&gt; p_thread_id1,&#10;            p_status       &#61;&gt; 2,&#10;            p_err_msg      &#61;&gt; &#39;Fatal error exception: &#39; || SQLERRM);&#10;        --&#10;    END do_load_offenders;&#10;    --&#10;    PROCEDURE do_main_thread&#10;    IS&#10;        TYPE l_rec_TYP IS RECORD(&#10;          thread_id INTEGER,&#10;          min_id    INTEGER,&#10;          max_id    INTEGER);&#10;        TYPE l_tab_TYP IS TABLE OF l_rec_TYP;&#10;        --&#10;        l_tab l_tab_TYP;&#10;        l_i   INTEGER;&#10;    BEGIN&#10;        --&#10;        SELECT instance_number INTO l_instance_number FROM v$instance;&#10;        --&#10;        EXECUTE IMMEDIATE&#10;           &#39;SELECT thread_id, MIN(TO_NUMBER(pk_value)) min_offender_id, MAX(TO_NUMBER(pk_value)) max_offender_id&#10;            FROM &#39; || get_dest_tab_name(&#39;PDT_table_rows&#39;) || &#39;&#10;            WHERE pdt_run_seq &#61; :p_run_seq_id&#10;              AND table_name &#61; &#39;&#39;OFFENDER&#39;&#39;&#10;            GROUP BY thread_id&#39;&#10;        BULK COLLECT INTO l_tab&#10;        USING p_run_seq_id&#10;        ;&#10;        --&#10;        FOR l_i IN 1 .. l_tab.COUNT LOOP&#10;            message(&#39;CREATE_THREAD_PROCESS(&#39; || l_tab(l_i).thread_id || &#39;)&#39;);&#10;            create_thread_process(&#10;                p_component_id    &#61;&gt; g_component_code,&#10;                p_thread_id       &#61;&gt; l_tab(l_i).thread_id,&#10;                p_min_id_val      &#61;&gt; l_tab(l_i).min_id,&#10;                p_max_id_val      &#61;&gt; l_tab(l_i).max_id,&#10;                p_instance_number &#61;&gt; l_instance_number,&#10;                --&#10;                p_program_action &#61;&gt;&#10;                  &#39;BEGIN C08001_PDT_SUPPORT.do_load_offender_data_MT(p_run_seq_id&#61;&gt;&#39; || p_run_seq_id || &#39;, p_thread_id&#61;&gt;&#39; || l_tab(l_i).thread_id || &#39;); END;&#39;&#10;            );&#10;            COMMIT;&#10;        END LOOP;&#10;        --&#10;        wait_for_threads_to_finish(p_component_id &#61;&gt; g_component_code);&#10;        --&#10;        IF g_max_threads &gt; 1 THEN&#10;            l_failed_threads :&#61; get_num_of_failed_threads(p_component_id &#61;&gt; g_component_code);&#10;        ELSE&#10;            l_failed_threads :&#61; 0;&#10;        END IF;&#10;        IF l_failed_threads &gt; 0 THEN&#10;            raise_application_error(-20001, &#39;ERROR: There are &#39; || l_failed_threads || &#39; threads that have failed - please check the PDT_THREAD and PDT_DEBUG tables for more details&#39;);&#10;        END IF;&#10;        --&#10;    END do_main_thread;&#10;    --&#10;BEGIN&#10;    --&#10;    do_load_data_init(p_run_seq &#61;&gt; p_run_seq_id);&#10;    --&#10;    IF p_thread_id &#61; -1 THEN&#10;        do_main_thread;&#10;    ELSIF p_thread_id &gt; 0 THEN&#10;        g_thread_id :&#61; p_thread_id;&#10;        do_load_offenders(p_thread_id);&#10;    END IF;&#10;    --&#10;END do_load_offender_data_MT;&#10;--&#10;PROCEDURE load_data(&#10;    p_dest_schema          VARCHAR2 DEFAULT GC_DEST_MTC_SCHEMA,&#10;    p_clean_data_flag      VARCHAR2 DEFAULT &#39;Y&#39;,&#10;    p_load_data_flag       VARCHAR2 DEFAULT &#39;Y&#39;,&#10;    p_table_type           VARCHAR2 DEFAULT &#39;ALL&#39;,&#10;    p_max_offender_records INTEGER  DEFAULT 0,&#10;    p_area_list            VARCHAR2 DEFAULT NULL,&#10;    p_crn_list             VARCHAR2 DEFAULT NULL,&#10;    p_old_crn_list         VARCHAR2 DEFAULT NULL,&#10;    p_off_rec_from         INTEGER  DEFAULT 0,&#10;    p_off_rec_to           INTEGER  DEFAULT 0,&#10;    p_where                VARCHAR2 DEFAULT NULL,&#10;    p_data_sample          NUMBER   DEFAULT 100 )&#10;IS&#10;    l_proc VARCHAR2(32) :&#61; &#39;LOAD_DATA&#39;;&#10;    --&#10;    l_SQL        VARCHAR2(32767);&#10;    l_table_name VARCHAR2(100);&#10;    --&#10;    l_rows_processed INTEGER :&#61; 0;&#10;    --&#10;    PROCEDURE do_init IS&#10;    BEGIN&#10;        EXECUTE IMMEDIATE &#39;SELECT &#39; || p_dest_schema || &#39;.PDT_table_rows_SEQ.NEXTVAL FROM dual&#39;&#10;        INTO g_pdt_run_seq;&#10;        --&#10;        EXECUTE IMMEDIATE &#39;DELETE FROM &#39; || get_dest_tab_name(&#39;PDT_table_rows&#39;) || &#39; WHERE pdt_run_seq &#61; :p_run_seq&#39;&#10;        USING g_pdt_run_seq;&#10;        --&#10;        do_load_data_init;&#10;    END do_init;&#10;    --&#10;    --&#10;    PROCEDURE do_pre_load(p_area_list VARCHAR2)&#10;    IS&#10;    BEGIN&#10;        do_disable_tab_triggers(&#39;DISPOSAL&#39;, &#39;DISABLE&#39;);&#10;        do_disable_tab_triggers(&#39;EVENT&#39;   , &#39;DISABLE&#39;);&#10;    END do_pre_load;&#10;    --&#10;    PROCEDURE do_post_load(p_area_list VARCHAR2)&#10;    IS&#10;        l_area_list VARCHAR2(4000);&#10;        l_area      VARCHAR2(10);&#10;        --&#10;        PROCEDURE do_load_table(p_table VARCHAR2)&#10;        IS&#10;            TYPE l_cur_TYP IS REF CURSOR;&#10;            TYPE l_tab_TYP IS TABLE OF ROWID;&#10;            --&#10;            l_cur l_cur_TYP;&#10;            l_tab l_tab_TYP;&#10;            --&#10;            l_SQL   VARCHAR2(32767);&#10;            l_idx   NUMBER;&#10;            l_rows  INTEGER :&#61; 0;&#10;            --&#10;            l_src_table  VARCHAR2(100);&#10;            l_dest_table VARCHAR2(100);&#10;            --&#10;        BEGIN&#10;            EXECUTE IMMEDIATE &#39;DELETE FROM &#39; || get_dest_tab_name(p_table);&#10;            message(&#39;DO_POST_LOAD.do_load_table([table&#61;&#39; || p_table || &#39;]): &#39; || SQL%ROWCOUNT || &#39; rows deleted&#39;);&#10;            --&#10;--            l_SQL :&#61;&#10;--               &#39;INSERT /*+APPEND*/ INTO &#39; || get_dest_tab_name(p_table) || &#39;(&#10;--               &#39; || g_tab_info(p_table).fld_lst || &#39;)&#10;--                SELECT &#39; || g_tab_info(p_table).fld_lst_1 || &#39;&#10;--                FROM &#39; || get_src_tab_name(p_table) || &#39;&#10;--                WHERE offender_id IN (&#10;--                      SELECT DISTINCT TO_NUMBER(pk_value) AS offender_id&#10;--                      FROM &#39; || get_dest_tab_name(&#39;PDT_table_rows&#39;) || &#39;&#10;--                      WHERE table_name &#61; &#39;&#39;OFFENDER&#39;&#39;&#10;--                        AND pdt_run_SEQ &#61; :p_run_seq )&#39;;&#10;--            --&#10;--            EXECUTE IMMEDIATE l_SQL USING g_pdt_run_seq;&#10;--            message(&#39;DO_POST_LOAD.do_load_table([table&#61;&#39; || p_table || &#39;]): &#39; || SQL%ROWCOUNT || &#39; rows inserted&#39;);&#10;&#10;            l_SQL :&#61;&#10;               &#39;SELECT ROWID row_id&#10;                FROM &#39; || get_src_tab_name(p_table) || &#39;&#10;                WHERE offender_id IN (&#10;                      SELECT DISTINCT TO_NUMBER(pk_value) AS offender_id&#10;                      FROM &#39; || get_dest_tab_name(&#39;PDT_table_rows&#39;) || &#39;&#10;                      WHERE table_name &#61; &#39;&#39;OFFENDER&#39;&#39;&#10;                        AND pdt_run_SEQ &#61; :p_run_seq )&#39;;&#10;            --&#10;            l_src_table  :&#61; get_src_tab_name (p_table);&#10;            l_dest_table :&#61; get_dest_tab_name(p_table, g_dest_schema);&#10;            --&#10;            OPEN l_cur FOR l_SQL USING g_pdt_run_seq;&#10;            LOOP&#10;                --&#10;                FETCH l_cur BULK COLLECT INTO l_tab LIMIT 1000;&#10;                EXIT WHEN l_tab.COUNT &#61; 0;&#10;                --&#10;                l_rows :&#61; l_rows + l_tab.COUNT;&#10;                --&#10;                FORALL l_idx IN l_tab.FIRST .. l_tab.LAST&#10;                    EXECUTE IMMEDIATE&#10;                       &#39;BEGIN&#10;                            C08001_PDT_SUPPORT.do_insert_current_record(&#10;                                p_tab_name   &#61;&gt; :p_table,&#10;                                p_src_table  &#61;&gt; :p_src_table,&#10;                                p_dest_table &#61;&gt; :p_dest_table,&#10;                                p_row_id     &#61;&gt; :p_row_id,&#10;                                p_level      &#61;&gt; 1 );&#10;                        END;&#39;&#10;                    USING p_table, l_src_table, l_dest_table, l_tab(l_idx);&#10;            --&#10;            END LOOP;&#10;            --&#10;            message(&#39;DO_POST_LOAD.do_load_table([table&#61;&#39; || p_table || &#39;]): &#39; || l_rows || &#39; rows inserted&#39;);&#10;            COMMIT;&#10;            CLOSE l_cur;&#10;            --&#10;        EXCEPTION WHEN OTHERS THEN&#10;            message(&#10;                &#39;ERROR in DO_POST_LOAD.do_load_table([table&#61;&#39; || p_table || &#39;]): &#39; || CHR(10) ||&#10;                SQLERRM || CHR(10) || l_SQL);&#10;            --&#10;            IF l_cur%ISOPEN THEN&#10;                CLOSE l_cur;&#10;            END IF;&#10;            RAISE;&#10;        END do_load_table;&#10;        --&#10;    BEGIN&#10;        l_area_list :&#61; REPLACE(REPLACE(p_area_list, &#39; &#39;, &#39;&#39;), &#39;;&#39;, &#39;,&#39;);&#10;        --&#10;        message(&#39;DO_POST_LOAD(p_area_list&#61;&gt;&#39; || l_area_list || &#39;): STARTED&#39;);&#10;        --&#10;        do_load_table(&#39;CONTACT_ALERT&#39;);&#10;        do_load_table(&#39;CASELOAD&#39;);&#10;        IF G_PDM_VERSION &gt;&#61; 601 THEN&#10;            do_load_table(&#39;COHORT_DIARY&#39;);&#10;        END IF;&#10;        do_load_table(&#39;ORGANISATION_OFFENDER&#39;);&#10;        --&#10;        do_disable_tab_triggers(&#39;DISPOSAL&#39;, &#39;ENABLE&#39;);&#10;        do_disable_tab_triggers(&#39;EVENT&#39;   , &#39;ENABLE&#39;);&#10;        --&#10;        message(&#39;DO_POST_LOAD(p_area_list&#61;&gt;&#39; || l_area_list || &#39;): completed successfully&#39;);&#10;        --&#10;    END do_post_load;&#10;    --&#10;    PROCEDURE do_load_offender_data&#10;    IS&#10;        l_proc VARCHAR2(32) :&#61; &#39;DO_LOAD_OFFENDER_DATA&#39;;&#10;        --&#10;        PROCEDURE do_prepare_offenders_list&#10;        IS&#10;            --&#10;            TYPE l_rec_TYP IS RECORD(&#10;                offender_id NUMBER,&#10;                row_id      ROWID);&#10;            TYPE l_tab_TYP IS TABLE OF l_rec_TYP;&#10;            --&#10;            l_tab l_tab_TYP;&#10;            --&#10;            l_SQL VARCHAR2(32767);&#10;            --&#10;            l_rows INTEGER;&#10;            --&#10;        BEGIN&#10;          l_SQL :&#61;&#10;              &#39;INSERT INTO &#39; || get_dest_tab_name(&#39;PDT_table_rows&#39;) || &#39;(pdt_run_seq, table_name, row_id, pk_value, thread_id)&#10;               WITH O AS (&#10;                 SELECT&#10;                   offender_id,&#10;                   CHARTOROWID(row_id_CHAR) row_id&#10;                 FROM TABLE( C08001_PDT_SUPPORT.get_offender_data(&#10;                                 p_area_list    &#61;&gt; :p_area_list,&#10;                                 p_crn_list     &#61;&gt; :p_crn_list,&#10;                                 p_old_crn_list &#61;&gt; :p_old_crn_list,&#10;                                 p_off_rec_from &#61;&gt; :p_off_rec_from,&#10;                                 p_off_rec_to   &#61;&gt; :p_off_rec_to,&#10;                                 p_where        &#61;&gt; :p_where,&#10;                                 p_data_sample  &#61;&gt; :p_data_sample ) )&#10;                 ORDER BY offender_id )&#10;              SELECT&#10;                :p_seq,&#10;                :p_table,&#10;                O.row_id,&#10;                O.offender_id,&#10;                NTILE(:p_max_threads) OVER(ORDER BY offender_id) AS thread_id&#10;              FROM O&#10;              WHERE ( NVL(:p_max_offender_records, 0) &lt;&#61; 0 OR ROWNUM &lt;&#61; :p_max_offender_records )&#39;&#10;          ;&#10;          --&#10;          EXECUTE IMMEDIATE l_SQL&#10;          USING&#10;            p_area_list,&#10;            p_crn_list,&#10;            p_old_crn_list,&#10;            p_off_rec_from,&#10;            p_off_rec_to,&#10;            p_where,&#10;            p_data_sample,&#10;            --&#10;            g_pdt_run_seq,&#10;            &#39;OFFENDER&#39;,&#10;            g_max_threads,&#10;            p_max_offender_records,&#10;            p_max_offender_records;&#10;          --&#10;          l_rows :&#61; SQL%ROWCOUNT;&#10;          --msassage(l_SQL);&#10;          message(&#39;DO_PREPARE_OFFENDERS_LIST &#39; ||&#10;              &#39;[max_threads&#61;&#39;   || g_max_threads          || &#39;]&#39; ||&#10;              &#39;[areas&#61;&#39;         || p_area_list            || &#39;]&#39; ||&#10;              &#39;[crn_list&#61;&#39;      || p_crn_list             || &#39;]&#39; ||&#10;              &#39;[old_crn_list&#61;&#39;  || p_old_crn_list         || &#39;]&#39; ||&#10;              &#39;[rec_start&#61;&#39;     || p_off_rec_from         || &#39;]&#39; ||&#10;              &#39;[rec_end&#61;&#39;       || p_off_rec_to           || &#39;]&#39; ||&#10;              &#39;[max_rec&#61;&#39;       || p_max_offender_records || &#39;]&#39; ||&#10;              &#39;[where_clause&#61;&#39;  || p_where                || &#39;]&#39; ||&#10;              &#39;[data_sample&#61;&#39;   || p_data_sample          || &#39;]&#39; ||&#10;              &#39;: &#39;              || l_rows                 || &#39; rows inserted&#39; );&#10;          --&#10;          COMMIT;&#10;          --&#10;        END do_prepare_offenders_list;&#10;        --&#10;        PROCEDURE do_disable_indexes&#10;        IS&#10;            CURSOR csTab IS&#10;              SELECT DISTINCT table_name&#10;              FROM TABLE( C08001_PDT_SUPPORT.get_tab_list1(p_reverse_order_flag &#61;&gt; NULL) ) T&#10;              WHERE table_type &#61; &#39;O&#39;&#10;              ORDER BY table_name;&#10;            l_rec csTab%ROWTYPE;&#10;        BEGIN&#10;            OPEN csTab;&#10;            LOOP&#10;                FETCH csTab INTO l_rec;&#10;                EXIT WHEN csTab%NOTFOUND;&#10;                --&#10;                do_disable_tab_indexes(p_table&#61;&gt;l_rec.table_name, p_action&#61;&gt;&#39;DISABLE&#39;, p_owner &#61;&gt; p_dest_schema);&#10;            END LOOP;&#10;            CLOSE csTab;&#10;        END do_disable_indexes;&#10;        --&#10;        PROCEDURE do_enable_indexes&#10;        IS&#10;            CURSOR csTab IS&#10;              SELECT DISTINCT table_name&#10;              FROM TABLE( C08001_PDT_SUPPORT.get_tab_list1(p_reverse_order_flag &#61;&gt; NULL) ) T&#10;              WHERE table_type &#61; &#39;O&#39;&#10;              ORDER BY table_name;&#10;            l_rec csTab%ROWTYPE;&#10;        BEGIN&#10;            OPEN csTab;&#10;            LOOP&#10;                FETCH csTab INTO l_rec;&#10;                EXIT WHEN csTab%NOTFOUND;&#10;                --&#10;                do_disable_tab_indexes(p_table&#61;&gt;l_rec.table_name, p_action&#61;&gt;&#39;ENABLE&#39;, p_owner &#61;&gt; p_dest_schema);&#10;            END LOOP;&#10;            CLOSE csTab;&#10;        END do_enable_indexes;&#10;        --&#10;    BEGIN&#10;        --&#10;        do_switch_vpd_policies(&#39;DISABLE&#39;);&#10;        --&#10;        do_enable_indexes;&#10;        --&#10;        do_alter_contact_id_FK(p_action &#61;&gt; &#39;DISABLE&#39;, p_owner &#61;&gt; p_dest_schema);&#10;        do_alter_self_ref_FK  (p_action &#61;&gt; &#39;DISABLE&#39;, p_owner &#61;&gt; p_dest_schema);&#10;        --do_disable_indexes;&#10;        --&#10;        do_prepare_offenders_list;&#10;        do_load_offender_data_MT(&#10;            p_run_seq_id &#61;&gt; g_pdt_run_seq,&#10;            p_thread_id  &#61;&gt; -1 );&#10;        --&#10;        do_enable_indexes;&#10;        do_fix_contact_SGC_FK;&#10;        do_alter_contact_id_FK(p_action &#61;&gt; &#39;ENABLE&#39;, p_owner &#61;&gt; p_dest_schema);&#10;        do_alter_self_ref_FK  (p_action &#61;&gt; &#39;ENABLE&#39;, p_owner &#61;&gt; p_dest_schema);&#10;        do_switch_vpd_policies(&#39;ENABLE&#39;);&#10;        --&#10;    EXCEPTION WHEN OTHERS THEN&#10;        --&#10;        message(l_proc || &#39; FAILED.&#39;);&#10;        message(&#39;PLSQL backtrace: &#39; || DBMS_UTILITY.format_error_backtrace);&#10;        message(&#39;MT_SQL_ERRM: &#39; || get_dq_message(SQLERRM));&#10;        message(&#39;MT_SQL_RESULT: 1&#39;);&#10;        --&#10;        do_switch_vpd_policies(&#39;ENABLE&#39;);&#10;        --&#10;        RAISE;&#10;    END do_load_offender_data;&#10;    --&#10;    PROCEDURE do_load_ref_data&#10;    IS&#10;        CURSOR csTab IS&#10;          SELECT *&#10;          FROM TABLE( C08001_PDT_SUPPORT.get_tab_list1 ) T&#10;          WHERE table_type &#61; &#39;R&#39;&#10;            --AND EXISTS(SELECT 1 FROM all_tables&#10;            --           WHERE owner &#61; UPPER(p_dest_schema)&#10;            --             AND table_name &#61; T.table_name)&#10;          --ORDER BY row_num&#10;        ;&#10;        l_rec csTab%ROWTYPE;&#10;        --&#10;        l_src_table  VARCHAR2(100);&#10;        l_dest_table VARCHAR2(100);&#10;    BEGIN&#10;        --&#10;        do_alter_user_id_FK(p_action &#61;&gt; &#39;DISABLE&#39;, p_owner &#61;&gt; p_dest_schema);&#10;        --&#10;        OPEN csTab;&#10;        LOOP&#10;            FETCH csTab INTO l_rec;&#10;            EXIT WHEN csTab%NOTFOUND;&#10;            --&#10;            l_src_table  :&#61; get_src_tab_name(l_rec.table_name);&#10;            l_dest_table :&#61; get_dest_tab_name(l_rec.table_name, p_dest_schema);&#10;            exec_SQL(&#10;                &#39;INSERT INTO &#39; || l_dest_table || &#39;(&#10;                &#39; || g_tab_info(l_rec.table_name).fld_lst || &#39;)&#10;                SELECT &#39; || g_tab_info(l_rec.table_name).fld_lst || &#39;&#10;                FROM &#39; || l_src_table,&#10;                &#39;N&#39;, &#39;N&#39; );&#10;            IF SQL%ROWCOUNT &gt; 0 THEN&#10;                message(l_dest_table || &#39;: &#39; || SQL%ROWCOUNT || &#39; rows inserted&#39;);&#10;            END IF;&#10;            COMMIT;&#10;        END LOOP;&#10;        CLOSE csTab;&#10;        --&#10;        do_alter_user_id_FK(p_action &#61;&gt; &#39;ENABLE&#39;, p_owner &#61;&gt; p_dest_schema);&#10;        --&#10;    EXCEPTION WHEN OTHERS THEN&#10;        message(&#10;            l_proc || &#39;.do_load_data_ref has FAILED.&#39; || CHR(10) ||&#10;            &#39;PLSQL backtrace: &#39; || DBMS_UTILITY.format_error_backtrace || CHR(10) ||&#10;            &#39;ERROR while copying data for &#39; || l_dest_table || &#39; table: &#39; || CHR(10) ||&#10;            get_dq_message(SQLERRM));&#10;        RAISE;&#10;    END do_load_ref_data;&#10;    --&#10;BEGIN&#10;    g_label :&#61; &#39;100200&#39;;&#10;    --&#10;    do_init;&#10;    COMMIT;&#10;    --&#10;    message(&#39;+&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;+&#39;);&#10;    message(l_proc ||  &#39; started&#39;);&#10;    message(&#39;+---------------------------------------------------+&#39;);&#10;    message(&#39;VERSION          : &#39; || get_version      );&#10;    message(&#39;NLS_DATE_FORMAT  : &#39; || get_date_format  );&#10;    message(&#39;p_dest_schema    : &#39; || p_dest_schema    );&#10;    message(&#39;p_clean_data_flag: &#39; || p_clean_data_flag);&#10;    message(&#39;p_load_data_flag : &#39; || p_load_data_flag );&#10;    message(&#39;p_table_type     : &#39; || p_table_type     );&#10;    message(&#39;g_pdt_run_seq    : &#39; || g_pdt_run_seq    );&#10;    message(&#39;g_pdt_debug_seq  : &#39; || g_pdt_debug_seq  );&#10;    message(&#39;+---------------------------------------------------+&#39;);&#10;    message(&#39;&#39;);&#10;    --&#10;    IF p_table_type NOT IN (&#39;ALL&#39;, &#39;O&#39;, &#39;R&#39;) THEN&#10;        raise_error(&#39;ERROR: Invalid value for P_TABLE_TYPE[&#39; || p_table_type || &#39;]&#39;, l_proc);&#10;    END IF;&#10;    --&#10;    do_load_data_init(p_dest_schema);&#10;    --&#10;    IF p_clean_data_flag &#61; &#39;Y&#39; THEN&#10;        clean_data(p_table_type, p_dest_schema);&#10;    END IF;&#10;    --&#10;    IF p_load_data_flag &#61; &#39;Y&#39; THEN&#10;        IF p_table_type IN (&#39;ALL&#39;, &#39;R&#39;) THEN&#10;            do_load_ref_data;&#10;        END IF;&#10;        IF p_table_type IN (&#39;ALL&#39;, &#39;O&#39;) THEN&#10;            do_pre_load(p_area_list);&#10;            do_load_offender_data;&#10;            do_post_load(p_area_list);&#10;        END IF;&#10;    END IF;&#10;    global_cache_mgr.pdt_inactive;&#10;    --&#10;    g_label :&#61; &#39;100260&#39;;&#10;    message(&#39;&#39;);&#10;    message(l_proc || &#39; completed successfuly.&#39;);&#10;    message(&#39;-&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;-&#39;);&#10;    message(&#39;&#39;);&#10;    g_label :&#61; &#39;100299&#39;;&#10;    message(&#39;MT_SQL_RESULT: 0&#39;);&#10;    --&#10;--EXCEPTION WHEN OTHERS THEN&#10;--    --&#10;--    message(l_proc || &#39; FAILED.&#39;);&#10;--    message(&#39;PLSQL backtrace: &#39; || DBMS_UTILITY.format_error_backtrace);&#10;--    message(&#39;MT_SQL_ERRM: &#39; || SQLERRM);&#10;--    global_cache_mgr.pdt_inactive;&#10;--    RAISE;&#10;--    --&#10;END load_data;&#10;--&#10;PROCEDURE clean_data(&#10;    p_table_type  VARCHAR2 DEFAULT &#39;ALL&#39;,&#10;    p_dest_schema VARCHAR2 DEFAULT GC_DEST_MTC_SCHEMA )&#10;IS&#10;    l_proc VARCHAR2(32) :&#61; &#39;CLEAN_DATA&#39;;&#10;    --&#10;    l_dest_table  VARCHAR2(100);&#10;    l_row         INTEGER;&#10;    l_row_failed  INTEGER;&#10;    --&#10;    CURSOR csTab IS&#10;      WITH T AS (&#10;        SELECT table_name, hier_level, hier_order_by AS order_by&#10;        FROM TABLE( C08001_PDT_SUPPORT.get_tab_list1(p_reverse_order_flag &#61;&gt; NULL) ) T&#10;        WHERE (p_table_type &#61; &#39;ALL&#39; OR table_type &#61; p_table_type)&#10;        UNION ALL&#10;        SELECT &#39;CONTACT&#39; AS table_name, 1 AS hier_level, 1 AS order_by&#10;        FROM dual&#10;        WHERE ( p_table_type IN (&#39;ALL&#39;, &#39;O&#39;) )&#10;      )&#10;      SELECT *&#10;      FROM T&#10;      ORDER BY hier_level DESC, order_by DESC&#10;      ;&#10;    --&#10;    l_rec csTab%ROWTYPE;&#10;    --&#10;    PROCEDURE disable_triggers IS&#10;    BEGIN&#10;        do_disable_tab_triggers(&#39;DISPOSAL&#39;, &#39;DISABLE&#39;);&#10;        do_disable_tab_triggers(&#39;EVENT&#39;   , &#39;DISABLE&#39;);&#10;    END disable_triggers;&#10;    --&#10;    PROCEDURE enable_triggers IS&#10;    BEGIN&#10;        do_disable_tab_triggers(&#39;DISPOSAL&#39;, &#39;ENABLE&#39;);&#10;        do_disable_tab_triggers(&#39;EVENT&#39;   , &#39;ENABLE&#39;);&#10;    END enable_triggers;&#10;    --&#10;    PROCEDURE do_delete_tab_data(p_tab VARCHAR2)&#10;    IS&#10;        TYPE l_cur_TYP IS REF CURSOR;&#10;        TYPE l_tab_TYP IS TABLE OF ROWID;&#10;        --&#10;        l_cur     l_cur_TYP;&#10;        l_row_id  ROWID;&#10;        l_tab     l_tab_TYP;&#10;        l_idx     INTEGER;&#10;        l_err_cnt INTEGER :&#61; 0;&#10;        --&#10;    BEGIN&#10;        l_row        :&#61; 0;&#10;        l_row_failed :&#61; 0;&#10;        OPEN l_cur FOR &#39;SELECT rowid row_id FROM &#39; || p_tab || &#39; ORDER BY 1&#39;;&#10;        LOOP&#10;            FETCH l_cur BULK COLLECT INTO l_tab LIMIT 1000;&#10;            EXIT WHEN l_tab.COUNT &#61; 0;&#10;            --&#10;            l_row :&#61; l_row + l_tab.COUNT;&#10;            --&#10;            BEGIN&#10;                FORALL l_idx IN l_tab.FIRST .. l_tab.LAST SAVE EXCEPTIONS&#10;                    EXECUTE IMMEDIATE &#39;DELETE FROM &#39; || p_tab || &#39; WHERE rowid &#61; :p_rowid&#39; USING l_tab(l_idx);&#10;            EXCEPTION WHEN OTHERS THEN&#10;                IF SQLCODE &#61; -24381 THEN&#10;                    l_err_cnt :&#61; SQL%BULK_EXCEPTIONS.COUNT;&#10;                    l_row_failed :&#61; l_row_failed + l_err_cnt;&#10;                    l_row :&#61; l_row - l_err_cnt;&#10;                ELSE&#10;                    RAISE;&#10;                END IF;&#10;            END;&#10;            --&#10;            COMMIT;&#10;            --&#10;        END LOOP;&#10;        CLOSE l_cur;&#10;        COMMIT;&#10;    END do_delete_tab_data;&#10;    --&#10;BEGIN&#10;    --&#10;    do_check_dest_schema(p_dest_schema);&#10;    --&#10;    disable_triggers;&#10;    do_alter_user_id_FK(p_action &#61;&gt; &#39;DISABLE&#39;, p_owner &#61;&gt; p_dest_schema);&#10;    --&#10;    OPEN csTab;&#10;    LOOP&#10;        FETCH csTab INTO l_rec;&#10;        EXIT WHEN csTab%NOTFOUND;&#10;        --&#10;        l_dest_table :&#61; get_dest_tab_name(l_rec.table_name, p_dest_schema);&#10;        do_delete_tab_data(l_dest_table);&#10;        IF l_row &gt; 0 THEN&#10;            message(l_dest_table || &#39;: &#39; || l_row || &#39; rows deleted&#39;);&#10;        END IF;&#10;        IF l_row_failed &gt; 0 THEN&#10;            message(l_dest_table || &#39;: &#39; || l_row_failed || &#39; rows FAILED to be deleted&#39;);&#10;        END IF;&#10;    END LOOP;&#10;    CLOSE csTab;&#10;    --&#10;    do_alter_user_id_FK(p_action &#61;&gt; &#39;ENABLE&#39;, p_owner &#61;&gt; p_dest_schema);&#10;    enable_triggers;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    raise_error(&#10;        &#39;ERROR while deleting data from [table&#61;&#39; || l_dest_table || &#39;]&#39; ||&#10;        &#39;[order_by&#61;&#39; || l_rec.order_by || &#39;]&#39;   ||&#10;        --&#39;[row_num&#61;&#39; || l_rec.row_num   || &#39;]: &#39; ||&#10;        SQLERRM,&#10;        l_proc&#10;    );&#10;END clean_data;&#10;--&#10;PROCEDURE truncate_target_off_data&#10;IS&#10;    --&#10;    lc_schema CONSTANT VARCHAR2(30) :&#61; GC_DEST_MTC_SCHEMA;&#10;    --&#10;    PROCEDURE do_schema_cons(p_action VARCHAR2, p_owner VARCHAR2 DEFAULT lc_schema)&#10;    IS&#10;        CURSOR cs IS&#10;          SELECT DISTINCT&#10;            tc.table_name,&#10;            tc.column_name&#10;          FROM&#10;            all_constraints c,&#10;            all_cons_columns cc,&#10;            all_tab_columns tc,&#10;            all_constraints c1&#10;          WHERE 1&#61;1&#10;            AND c.owner &#61; p_owner&#10;            --AND c.constraint_type NOT IN (&#39;P&#39;, &#39;U&#39;)&#10;            AND c.constraint_type IN (&#39;R&#39;)&#10;            AND c.status NOT LIKE p_action || &#39;_&#39;&#10;            AND cc.owner &#61; c.owner&#10;            AND cc.table_name &#61; c.table_name&#10;            AND cc.constraint_name &#61; c.constraint_name&#10;            AND tc.owner &#61; cc.owner&#10;            AND tc.table_name &#61; cc.table_name&#10;            AND tc.column_name &#61; cc.column_name&#10;            AND tc.owner &#61; cc.owner&#10;            --&#10;            AND c1.constraint_name &#61; c.r_constraint_name&#10;            AND c1.owner &#61; c.owner&#10;            --AND c1.table_name &#61; c.table_name&#10;          ORDER BY tc.table_name, tc.column_name;&#10;        --&#10;        l_table  VARCHAR2(30);&#10;        l_column VARCHAR2(30);&#10;        --&#10;    BEGIN&#10;        --&#10;        C08001_PDT_SUPPORT.do_check_dest_schema(p_owner);&#10;        --&#10;        OPEN cs;&#10;        LOOP&#10;            FETCH cs INTO l_table, l_column;&#10;            EXIT WHEN cs%NOTFOUND;&#10;            --&#10;            BEGIN&#10;                C08001_PDT_SUPPORT.do_alter_tab_col_cons(p_tab &#61;&gt; l_table, p_col &#61;&gt; l_column, p_enable_disable_flag &#61;&gt; p_action, p_owner &#61;&gt; p_owner);&#10;            EXCEPTION WHEN OTHERS THEN&#10;                NULL;&#10;            END;&#10;        END LOOP;&#10;        CLOSE cs;&#10;    END do_schema_cons;&#10;    --&#10;    PROCEDURE do_truncate_tab(p_table VARCHAR2, p_owner VARCHAR2 DEFAULT lc_schema) IS&#10;    BEGIN&#10;        --&#10;        C08001_PDT_SUPPORT.do_check_dest_schema(p_owner);&#10;        --&#10;        EXECUTE IMMEDIATE &#39;TRUNCATE TABLE &#39; || p_owner || &#39;.&#39; || p_table || &#39; DROP STORAGE&#39;;&#10;    END do_truncate_tab;&#10;    --&#10;    PROCEDURE do_truncate_O_TABLES&#10;    IS&#10;        CURSOR cs IS&#10;          SELECT DISTINCT T.table_name&#10;          FROM  TABLE( C08001_PDT_SUPPORT.get_tab_list1 ) T&#10;          WHERE table_type &#61; &#39;O&#39;&#10;          ;&#10;        l_table VARCHAR2(30);&#10;    BEGIN&#10;        OPEN cs;&#10;        LOOP&#10;            FETCH cs INTO l_table;&#10;            EXIT WHEN cs%NOTFOUND;&#10;            --&#10;            do_truncate_tab(l_table);&#10;        END LOOP;&#10;        CLOSE cs;&#10;    END do_truncate_O_TABLES;&#10;    --&#10;BEGIN&#10;    do_schema_cons(p_action &#61;&gt; &#39;DISABLE&#39;, p_owner &#61;&gt; lc_schema);&#10;    do_truncate_O_TABLES;&#10;    do_schema_cons(p_action &#61;&gt; &#39;ENABLE&#39;, p_owner &#61;&gt; lc_schema);&#10;END truncate_target_off_data;&#10;--&#10;-- ****************************************** --&#10;-- TRAINING GEN-2 Data re-seeding subroutines --&#10;-- ****************************************** --&#10;--&#10;FUNCTION TRN_imp_tab_info(p_list VARCHAR2, p_table_name VARCHAR2) RETURN VARCHAR2&#10;IS&#10;    l_lst VARCHAR2(30000);&#10;BEGIN&#10;    l_lst :&#61; TRIM(REPLACE(REPLACE(p_list, CHR(9), &#39; &#39;), CHR(13), &#39;&#39;));&#10;    l_lst :&#61; CHR(10) || TRIM(LTRIM(RTRIM(l_lst, CHR(10)), CHR(10))) || CHR(10);&#10;    l_lst :&#61; PKG_LstUtl.list_last_elem(l_lst, CHR(10) || p_table_name || &#39; &#39;);&#10;    l_lst :&#61; PKG_LstUtl.list_next_elem(l_lst, CHR(10));&#10;    --&#10;    RETURN NVL(TRIM( /*p_table_name || &#39;: &#39; ||*/ l_lst ), &#39;-1&#39;);&#10;END TRN_imp_tab_info;&#10;--&#10;FUNCTION TRN_get_fk_fld(p_parent_table VARCHAR2, p_table VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN&#10;        PKG_Lookups.funcgetTabRecord_CACHED_1(&#10;            p_data_fld &#61;&gt;&#10;               &#39;PKG_Lookups.funcgetTabRecord_CACHED_1(&#10;                    p_table      &#61;&gt; &#39;&#39;user_constraints C, user_cons_columns CC, user_tab_columns TC&#39;&#39;,&#10;                    p_ref_col    &#61;&gt; &#39;&#39;1&#39;&#39;, p_ref_val &#61;&gt; &#39;&#39;1&#39;&#39;,&#10;                    p_data_fld   &#61;&gt; &#39;&#39;TC.column_name&#39;&#39;,&#10;                    p_where      &#61;&gt; &#39;&#39;C.constraint_name &#61; :p_con AND cc.table_name &#61; c.table_name AND cc.constraint_name &#61; c.constraint_name AND tc.table_name &#61; cc.table_name AND tc.column_name &#61; cc.column_name&#39;&#39;,&#10;                    p_bind_var1  &#61;&gt; UC.constraint_name,&#10;                    p_order_by   &#61;&gt; &#39;&#39;CC.position&#39;&#39;,&#10;                    p_all_records &#61;&gt; &#39;&#39;Y&#39;&#39;, p_delim &#61;&gt; &#39;&#39;:&#39;&#39; )&#39;,&#10;            p_table     &#61;&gt; &#39;user_constraints UC, user_constraints UC_R&#39;,&#10;            p_ref_col   &#61;&gt; &#39;1&#39;, p_ref_val &#61;&gt; &#39;1&#39;,&#10;            p_where     &#61;&gt;&#10;               &#39;UC_R.constraint_name &#61; UC.R_constraint_name&#10;                AND UC.constraint_type &#61; &#39;&#39;R&#39;&#39;&#10;                AND UC.table_name &#61; :p_table&#10;                AND UC_R.table_name &#61; :p_parent_table&#39;,&#10;            p_bind_var1 &#61;&gt; p_table,&#10;            p_bind_var2 &#61;&gt; p_parent_table,&#10;            --&#10;            p_all_records &#61;&gt; &#39;Y&#39;,&#10;            p_delim       &#61;&gt; &#39;,&#39; );&#10;END TRN_get_fk_fld;&#10;--&#10;PROCEDURE trn_init IS&#10;BEGIN&#10;    --do_load_data_init;&#10;    --GLOBAL_CACHE_MGR.pdt_active;&#10;    --PKG_Lookups.do_flush_TAB_cache;&#10;    init_tab_info;&#10;END trn_init;&#10;--&#10;PROCEDURE trn_pre_load&#10;IS&#10;BEGIN&#10;    --&#10;--    do_disable_tab_triggers(&#39;DISPOSAL&#39;, &#39;DISABLE&#39;, USER);&#10;--    do_disable_tab_triggers(&#39;EVENT&#39;   , &#39;DISABLE&#39;, USER);&#10;    --&#10;    do_switch_vpd_policies( &#39;DISABLE&#39;, p_target_schema&#61;&gt;USER );&#10;    PKG_TriggerSupport.procSetCDCFlag( FALSE );&#10;    --&#10;END trn_pre_load;&#10;--&#10;PROCEDURE trn_alter_tab_check_con(p_table VARCHAR2, p_action VARCHAR2)&#10;IS&#10;BEGIN&#10;  FOR l_rec IN (&#10;    SELECT c.owner, c.table_name, c.constraint_name&#10;    FROM user_constraints C&#10;    WHERE constraint_type &#61; &#39;C&#39;&#10;      AND table_name IN (&#10;          SELECT DISTINCT table_name&#10;          FROM TABLE(C08001_PDT_SUPPORT.get_tab_list1)&#10;          WHERE table_type &#61; &#39;O&#39; )&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;% IS NOT NULL&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;% IN (0, 1)&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;%IN (&#39;&#39;Y&#39;&#39;, &#39;&#39;N&#39;&#39;)&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;%IN (&#39;&#39;N&#39;&#39;, &#39;&#39;Y&#39;&#39;)&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;%IN (&#39;&#39;Y&#39;&#39;,&#39;&#39;N&#39;&#39;)&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;%IN (&#39;&#39;N&#39;&#39;,&#39;&#39;Y&#39;&#39;)&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;%IN (&#39;&#39;Y&#39;&#39;, &#39;&#39;N&#39;&#39;, &#39;&#39;B&#39;&#39;)&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;% IN (&#39;&#39;G&#39;&#39;, &#39;&#39;N&#39;&#39;, &#39;&#39;M&#39;&#39;)&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;% &gt; 0&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;%(%STAFF_ID IS NOT NULL%AND%PROVIDER_EMPLOYEE_ID IS NULL)%(%STAFF_ID IS NULL%AND%PROVIDER_EMPLOYEE_ID IS NOT NULL)%&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;%(%TEAM_ID IS NOT NULL%AND%PROVIDER_TEAM_ID IS NULL)%(%TEAM_ID IS NULL%AND%PROVIDER_TEAM_ID IS NOT NULL)%&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;%IN (&#39;&#39;N&#39;&#39;,&#39;&#39;Y&#39;&#39;,&#39;&#39;U&#39;&#39;)&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;%IN%&#39;&#39;POSITIVE&#39;&#39;%&#39;&#39;NEGATIVE&#39;&#39;)%&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;%(%PROVIDER_EMPLOYEE_ID IS NOT NULL%AND%STAFF_ID IS NULL)%(%PROVIDER_EMPLOYEE_ID IS NULL%AND%STAFF_ID IS NOT NULL)%&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;%TRUST_PROVIDER_TEAM_ID%&#61;%TEAM_ID%TRUST_PROVIDER_TEAM_ID%&#61;%PROVIDER_TEAM_ID%&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;%STAFF_EMPLOYEE_ID%&#61;%STAFF_ID%STAFF_EMPLOYEE_ID%&#61; %ROVIDER_EMPLOYEE_ID%&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;%ENFORCEMENT &#61; 1%ENFORCEMENT IS NULL&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;%INSTITUTION_ID IS NOT NULL AND ESTABLISHMENT &#61; &#39;&#39;Y&#39;&#39;%INSTITUTION_ID IS NULL AND ESTABLISHMENT IS NULL)&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;%IN (&#39;&#39;Positive&#39;&#39;, &#39;&#39;Negative&#39;&#39;, &#39;&#39;Not Tested&#39;&#39;)&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;%IN (&#39;&#39;S&#39;&#39;,&#39;&#39;R&#39;&#39;,&#39;&#39;T&#39;&#39;)&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;%RQMNT_TYPE_MAIN_CATEGORY_ID%IS NOT NULL%AD_RQMNT_TYPE_MAIN_CATEGORY_ID%IS NULL%AD_RQMNT_TYPE_SUB_CATEGORY_ID%IS NULL%AD_RQMNT_TYPE_MAIN_CATEGORY_ID%IS NOT NULL%RQMNT_TYPE_MAIN_CATEGORY_ID%IS NULL%RQMNT_TYPE_SUB_CATEGORY_ID%IS NULL%&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;TABLE_NAME IN (%)&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;%COURT_REPORT_ID IS NOT NULL%INSTITUTIONAL_REPORT_ID IS NULL)%COURT_REPORT_ID IS NULL AND INSTITUTIONAL_REPORT_ID IS NOT NULL)%&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;%ENFORCEMENT &#61; 1 OR ENFORCEMENT IS NULL&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;%ESTABLISHMENT%&#61;%&#39;&#39;Y&#39;&#39;%&#39;&#10;            AND SUBSTR(C08001_PDT_SUPPORT.get_con_search_cond(C.owner, C.constraint_name), 1, 4000) NOT LIKE &#39;%INSTITUTION_ID IS NOT NULL AND ESTABLISHMENT &#61; &#39;&#39;Y&#39;&#39;%INSTITUTION_ID IS NULL AND ESTABLISHMENT IS NULL)%&#39;&#10;  )&#10;  LOOP&#10;      EXECUTE IMMEDIATE &#39;ALTER TABLE &#39; || l_rec.owner || &#39;.&#39; || l_rec.table_name || &#39; &#39; || p_action || &#39; CONSTRAINT &#39; || l_rec.constraint_name;&#10;  END LOOP;&#10;END trn_alter_tab_check_con;&#10;--&#10;PROCEDURE trn_age_dates(&#10;    p_target_area_list     VARCHAR2 DEFAULT &#39;ALL&#39;,&#10;    p_crn_list             VARCHAR2 DEFAULT NULL,&#10;    p_old_crn_list         VARCHAR2 DEFAULT NULL,&#10;    p_where                VARCHAR2 DEFAULT NULL,&#10;    p_age_days             NUMBER )&#10;IS&#10;    --&#10;    CURSOR csCols IS&#10;      WITH TC AS (&#10;          SELECT&#10;            T.table_name,&#10;            PKG_Lookups.funcgetTabRecord(&#10;                p_data_fld    &#61;&gt; &#39;column_name&#39;,&#10;                p_table       &#61;&gt; &#39;user_tab_columns&#39;,&#10;                p_ref_col     &#61;&gt; &#39;table_name&#39;,&#10;                p_ref_val     &#61;&gt; T.table_name,&#10;                p_where       &#61;&gt; &#39;data_type &#61; &#39;&#39;DATE&#39;&#39; AND column_name NOT IN (&#39;&#39;OFFENCE_DATE&#39;&#39;, &#39;&#39;LAST_UPDATED_DATETIME&#39;&#39;, &#39;&#39;CREATED_DATETIME&#39;&#39;, &#39;&#39;CONTACT_START_TIME&#39;&#39;, &#39;&#39;CONTACT_END_TIME&#39;&#39;, &#39;&#39;START_TIME&#39;&#39;, &#39;&#39;END_TIME&#39;&#39;)&#39;,&#10;                p_all_records &#61;&gt; &#39;Y&#39;,&#10;                p_delim       &#61;&gt; &#39;,&#39; ) fld_lst,&#10;            PKG_Lookups.funcgetTabRecord(&#10;                p_data_fld    &#61;&gt; &#39;column_name || &#39;&#39; &#61; &#39;&#39; || column_name || &#39;&#39; + &#39;&#39; ||&#39; || p_age_days,&#10;                p_table       &#61;&gt; &#39;user_tab_columns&#39;,&#10;                p_ref_col     &#61;&gt; &#39;table_name&#39;,&#10;                p_ref_val     &#61;&gt; T.table_name,&#10;                p_where       &#61;&gt; &#39;data_type &#61; &#39;&#39;DATE&#39;&#39; AND column_name NOT IN (&#39;&#39;OFFENCE_DATE&#39;&#39;, &#39;&#39;LAST_UPDATED_DATETIME&#39;&#39;, &#39;&#39;CREATED_DATETIME&#39;&#39;, &#39;&#39;CONTACT_START_TIME&#39;&#39;, &#39;&#39;CONTACT_END_TIME&#39;&#39;, &#39;&#39;START_TIME&#39;&#39;, &#39;&#39;END_TIME&#39;&#39;)&#39;,&#10;                p_all_records &#61;&gt; &#39;Y&#39;,&#10;                p_delim       &#61;&gt; &#39;, &#39; ) fld_upd_lst&#10;          FROM&#10;            ( SELECT DISTINCT table_name FROM TABLE(C08001_PDT_SUPPORT.get_tab_list1) WHERE table_type &#61; &#39;O&#39; ) T&#10;          WHERE 1&#61;1&#10;            AND T.table_name NOT IN (&#39;TRAINING_SESSION_PASSWORD&#39;, &#39;MOST_RECENTLY_VIEWED_OFFENDERS&#39;)&#10;      )&#10;      SELECT&#10;        TC.table_name,&#10;        TC.fld_lst,&#10;        TC.fld_upd_lst&#10;      FROM TC&#10;      WHERE TC.fld_upd_lst IS NOT NULL&#10;        AND EXISTS(&#10;            SELECT 1&#10;            FROM TRAINING_table_rows&#10;            WHERE table_name &#61; TC.table_name )&#10;      ORDER BY table_name&#10;    ;&#10;    --&#10;    l_rec_cols csCols%ROWTYPE;&#10;    --&#10;    l_SQL VARCHAR2(30000);&#10;    --&#10;    l_tab     T_TAB_ORGANISATIONS;&#10;    l_tab_off T_TAB_ORGANISATIONS;&#10;    --&#10;    --&#10;BEGIN&#10;    --&#10;    trn_init;&#10;    --&#10;    SELECT DISTINCT table_name BULK COLLECT INTO l_tab&#10;    FROM TABLE(C08001_PDT_SUPPORT.get_tab_list1)&#10;    WHERE table_type &#61; &#39;O&#39;;&#10;    --&#10;    SELECT DISTINCT offender_id BULK COLLECT INTO l_tab_off&#10;    FROM TABLE( C08001_PDT_SUPPORT.get_offender_data(&#10;                    p_area_list            &#61;&gt; p_target_area_list,&#10;                    p_crn_list             &#61;&gt; p_crn_list,&#10;                    p_old_crn_list         &#61;&gt; p_old_crn_list,&#10;                    p_where                &#61;&gt; PKG_LstUtl.concat(p_where, &#39;area_code NOT IN (&#39;&#39;N00&#39;&#39;, &#39;&#39;C00&#39;&#39;)&#39;, p_delim &#61;&gt; &#39; AND &#39;) ) );&#10;    --&#10;    --EXECUTE IMMEDIATE &#39;SET CONSTRAINTS ALL DEFERRED&#39;;&#10;    FOR l_idx IN 1..l_tab.COUNT LOOP&#10;        trn_alter_tab_check_con(l_tab(l_idx), &#39;DISABLE&#39;);&#10;        do_disable_tab_triggers(l_tab(l_idx), &#39;DISABLE&#39;, SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_SCHEMA&#39;));&#10;    END LOOP;&#10;    --&#10;    OPEN csCols;&#10;    LOOP&#10;        FETCH csCols INTO l_rec_cols;&#10;        EXIT WHEN csCols%NOTFOUND;&#10;        --&#10;        l_SQL :&#61;&#10;            &#39;UPDATE &#39; || l_rec_cols.table_name || &#39; T1 SET&#10;            &#39; || l_rec_cols.fld_upd_lst || &#39;&#10;            WHERE &#39; || PKG_LstUtl.list_num_elem(g_tab_info(l_rec_cols.table_name).pk_fld_lst, &#39;,&#39;, 1 ) || &#39; IN (&#10;              SELECT DISTINCT T.new_pk_value&#10;              FROM TRAINING_table_rows T&#10;              WHERE T.new_offender_id IN (SELECT * FROM TABLE(:p_tab_off))&#10;                AND T.table_name &#61; &#39;&#39;&#39; || l_rec_cols.table_name || &#39;&#39;&#39; /*END_OF_IN_CLAUSE*/ )&#39;;&#10;        EXECUTE IMMEDIATE l_SQL USING /*p_age_days,*/ l_tab_off;&#10;        --&#10;        message(&#39;TRN_AGE_DATES &#39; ||&#10;            &#39;[table&#61;&#39;       || l_rec_cols.table_name  || &#39;]&#39; ||&#10;            &#39;[cols_upd_lst&#61;&#39;|| l_rec_cols.fld_lst     || &#39;]&#39; ||&#10;            &#39;[age_days&#61;&#39;    || p_age_days             || &#39;]&#39; ||&#10;            &#39;[area_lst&#61;&#39;    || p_target_area_list     || &#39;]&#39; ||&#10;            &#39;[crn_lst&#61;&#39;     || p_crn_list             || &#39;]&#39; ||&#10;            &#39;[old_crn_lst&#61;&#39; || p_old_crn_list         || &#39;]&#39; ||&#10;            &#39;[where&#61;&#39;       || p_where                || &#39;]: &#39; ||&#10;            SQL%ROWCOUNT || &#39; rows have been updated&#39;&#10;            --|| CHR(10) || l_SQL&#10;        );&#10;        --&#10;    END LOOP;&#10;    CLOSE csCols;&#10;    --&#10;    EXECUTE IMMEDIATE &#39;SET CONSTRAINTS ALL IMMEDIATE&#39;;&#10;    FOR l_idx IN 1..l_tab.COUNT LOOP&#10;        trn_alter_tab_check_con(l_tab(l_idx), &#39;ENABLE&#39;);&#10;        do_disable_tab_triggers(l_tab(l_idx), &#39;ENABLE&#39;, SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_SCHEMA&#39;));&#10;    END LOOP;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    message(&#39; ERROR in TRN_AGE_DATES: &#39; || SQLERRM || CHR(10) ||&#10;        &#39;[table&#61;&#39;       || l_rec_cols.table_name  || &#39;]&#39; ||&#10;        &#39;[cols_upd_lst&#61;&#39;|| l_rec_cols.fld_lst     || &#39;]&#39; ||&#10;        &#39;[age_days&#61;&#39;    || p_age_days             || &#39;]&#39; ||&#10;        &#39;[area_lst&#61;&#39;    || p_target_area_list     || &#39;]&#39; ||&#10;        &#39;[crn_lst&#61;&#39;     || p_crn_list             || &#39;]&#39; ||&#10;        &#39;[old_crn_lst&#61;&#39; || p_old_crn_list         || &#39;]&#39; ||&#10;        &#39;[where&#61;&#39;       || p_where                || &#39;]&#39; || CHR(10) ||&#10;        l_SQL );&#10;    --&#10;    --EXECUTE IMMEDIATE &#39;SET CONSTRAINTS ALL IMMEDIATE&#39;;&#10;    FOR l_idx IN 1..l_tab.COUNT LOOP&#10;        trn_alter_tab_check_con(l_tab(l_idx), &#39;ENABLE&#39;);&#10;        do_disable_tab_triggers(l_tab(l_idx), &#39;ENABLE&#39;, SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_SCHEMA&#39;));&#10;    END LOOP;&#10;    --&#10;    RAISE;&#10;END trn_age_dates;&#10;--&#10;--&#10;PROCEDURE trn_rebuild_VPD_ORGS(&#10;    p_target_area_list     VARCHAR2 DEFAULT &#39;ALL&#39;,&#10;    p_crn_list             VARCHAR2 DEFAULT NULL,&#10;    p_old_crn_list         VARCHAR2 DEFAULT NULL,&#10;    p_where                VARCHAR2 DEFAULT NULL )&#10;IS&#10;    CURSOR cs IS&#10;      SELECT offender_id&#10;      FROM offender&#10;      WHERE NOT EXISTS( SELECT 1 FROM organisation_offender WHERE offender_id &#61; OFFENDER.offender_id )&#10;      ORDER BY 1;&#10;    --&#10;    l_offender_id INTEGER;&#10;BEGIN&#10;    PKG_VPD_CTX.set_client_identifier(userID &#61;&gt; 1);&#10;    --&#10;    DELETE FROM organisation_offender&#10;    WHERE offender_id IN (&#10;          --SELECT DISTINCT offender_id FROM organisation_offender&#10;          --MINUS&#10;          --SELECT DISTINCT offender_id FROM TABLE( C08001_PDT_SUPPORT.get_offender_data( p_area_list &#61;&gt; &#39;N00,C00&#39; ) )&#10;      SELECT DISTINCT T.new_offender_id&#10;      FROM&#10;        TABLE( C08001_PDT_SUPPORT.get_offender_data(&#10;                   p_area_list            &#61;&gt; p_target_area_list,&#10;                   p_crn_list             &#61;&gt; p_crn_list,&#10;                   p_old_crn_list         &#61;&gt; p_old_crn_list,&#10;                   p_where                &#61;&gt; PKG_LstUtl.concat(p_where, &#39;area_code NOT IN (&#39;&#39;N00&#39;&#39;, &#39;&#39;C00&#39;&#39;)&#39;, p_delim &#61;&gt; &#39; AND &#39;) )&#10;             ) O,&#10;        TRAINING_table_rows T&#10;      WHERE T.old_offender_id &#61; O.offender_id&#10;        AND T.table_name &#61; &#39;OFFENDER&#39; );&#10;    --&#10;    OPEN cs;&#10;    LOOP&#10;        FETCH cs INTO l_offender_id;&#10;        EXIT WHEN cs%NOTFOUND;&#10;        --&#10;        PKG_VPD_CTX.set_table_value(&#39;REBUILD_REQUIRED&#39;,&#39;Y&#39;);&#10;        PKG_TriggerSupport.procRebuildOptTables(p_offenderID &#61;&gt; l_offender_id);&#10;        --COMMIT;&#10;    END LOOP;&#10;    CLOSE cs;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    warn(&#39;FAILED [trn_rebuild_VPD_ORGS] ERROR: &#39; || SQLERRM);&#10;    RAISE fatal_error_exception;&#10;END trn_rebuild_VPD_ORGS;&#10;--&#10;PROCEDURE trn_rebuild_caseload(&#10;    p_target_area_list     VARCHAR2 DEFAULT &#39;ALL&#39;,&#10;    p_crn_list             VARCHAR2 DEFAULT NULL,&#10;    p_old_crn_list         VARCHAR2 DEFAULT NULL,&#10;    p_where                VARCHAR2 DEFAULT NULL )&#10;IS&#10;    l_offender_id      NUMBER;&#10;    --&#10;    CURSOR cs IS&#10;      SELECT DISTINCT T.new_offender_id&#10;      FROM&#10;        TABLE( C08001_PDT_SUPPORT.get_offender_data(&#10;                   p_area_list            &#61;&gt; p_target_area_list,&#10;                   p_crn_list             &#61;&gt; p_crn_list,&#10;                   p_old_crn_list         &#61;&gt; p_old_crn_list,&#10;                   p_where                &#61;&gt; PKG_LstUtl.concat(p_where, &#39;area_code NOT IN (&#39;&#39;N00&#39;&#39;, &#39;&#39;C00&#39;&#39;)&#39;, p_delim &#61;&gt; &#39; AND &#39;) )&#10;             ) O,&#10;        TRAINING_table_rows T&#10;      WHERE T.new_offender_id &#61; O.offender_id&#10;        AND T.table_name &#61; &#39;OFFENDER&#39;;&#10;BEGIN&#10;    OPEN cs;&#10;    LOOP&#10;        FETCH cs INTO l_offender_id;&#10;        EXIT WHEN cs%NOTFOUND;&#10;        --&#10;        PKG_VPD_CTX.set_table_value(&#39;CASELOAD_REBUILD_REQUIRED&#39;,&#39;Y&#39;);&#10;        PKG_TriggerSupport.procRebuildCaseloadTable(p_offender_ID &#61;&gt; l_offender_id);&#10;    END LOOP;&#10;    CLOSE cs;&#10;EXCEPTION WHEN OTHERS THEN&#10;    IF cs%ISOPEN THEN&#10;        CLOSE cs;&#10;    END IF;&#10;    warn(&#39;FAILED [trn_rebuild_caseload] ERROR: &#39; || SQLERRM);&#10;    RAISE fatal_error_exception;&#10;END trn_rebuild_caseload;&#10;--&#10;PROCEDURE trn_insert_contact_alert(&#10;    p_target_area_list     VARCHAR2 DEFAULT &#39;ALL&#39;,&#10;    p_crn_list             VARCHAR2 DEFAULT NULL,&#10;    p_old_crn_list         VARCHAR2 DEFAULT NULL,&#10;    p_where                VARCHAR2 DEFAULT NULL )&#10;IS&#10;    l_sql       VARCHAR2(3072);&#10;    l_row_count INTEGER;&#10;BEGIN&#10;    --&#10;    DELETE FROM contact_alert&#10;    WHERE offender_id IN (&#10;          --SELECT DISTINCT offender_id FROM organisation_offender&#10;          --MINUS&#10;          --SELECT DISTINCT offender_id FROM TABLE( C08001_PDT_SUPPORT.get_offender_data( p_area_list &#61;&gt; &#39;N00,C00&#39; ) )&#10;      SELECT DISTINCT T.new_offender_id&#10;      FROM&#10;        TABLE( C08001_PDT_SUPPORT.get_offender_data(&#10;                   p_area_list            &#61;&gt; p_target_area_list,&#10;                   p_crn_list             &#61;&gt; p_crn_list,&#10;                   p_old_crn_list         &#61;&gt; p_old_crn_list,&#10;                   p_where                &#61;&gt; PKG_LstUtl.concat(p_where, &#39;area_code NOT IN (&#39;&#39;N00&#39;&#39;, &#39;&#39;C00&#39;&#39;)&#39;, p_delim &#61;&gt; &#39; AND &#39;) )&#10;             ) O,&#10;        TRAINING_table_rows T&#10;      WHERE T.old_offender_id &#61; O.offender_id&#10;        AND T.table_name &#61; &#39;OFFENDER&#39; );&#10;    --&#10;    INSERT INTO contact_alert (&#10;      contact_alert_id, offender_id, contact_id,&#10;      contact_type_id, contact_outcome_type_id,&#10;      trust_provider_flag, staff_employee_id, trust_provider_team_id,&#10;      offender_manager_id&#10;    )&#10;    SELECT&#10;      contact_alert_id_SEQ.nextval, c.offender_id, c.contact_id,&#10;      c.contact_type_id, c.contact_outcome_type_id,&#10;      om.trust_provider_flag, om.staff_employee_id, om.trust_provider_team_id,&#10;      om.offender_manager_id&#10;    FROM&#10;      contact C,&#10;      offender_manager OM&#10;    WHERE c.offender_id &#61; om.offender_id&#10;      AND om.active_flag &#61; 1&#10;      AND c.alert_active &#61; &#39;Y&#39;&#10;      AND OM.offender_id IN (&#10;      SELECT DISTINCT T.new_offender_id&#10;      FROM&#10;        TABLE( C08001_PDT_SUPPORT.get_offender_data(&#10;                   p_area_list            &#61;&gt; p_target_area_list,&#10;                   p_crn_list             &#61;&gt; p_crn_list,&#10;                   p_old_crn_list         &#61;&gt; p_old_crn_list,&#10;                   p_where                &#61;&gt; PKG_LstUtl.concat(p_where, &#39;area_code NOT IN (&#39;&#39;N00&#39;&#39;, &#39;&#39;C00&#39;&#39;)&#39;, p_delim &#61;&gt; &#39; AND &#39;) )&#10;             ) O,&#10;        TRAINING_table_rows T&#10;      WHERE T.new_offender_id &#61; O.offender_id&#10;        AND T.table_name &#61; &#39;OFFENDER&#39; );&#10;    --&#10;    l_row_count :&#61; SQL%ROWCOUNT;&#10;    --&#10;    message(l_row_count || &#39; CONTACT_ALERT rows inserted&#39;);&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    warn(&#39;FAILED [trn_insert_contact_alert] ERROR: &#39; || SQLERRM);&#10;    RAISE fatal_error_exception;&#10;END trn_insert_contact_alert;&#10;--&#10;PROCEDURE trn_rebuild_opt_tables(&#10;    p_target_area_list     VARCHAR2 DEFAULT &#39;ALL&#39;,&#10;    p_crn_list             VARCHAR2 DEFAULT NULL,&#10;    p_old_crn_list         VARCHAR2 DEFAULT NULL,&#10;    p_where                VARCHAR2 DEFAULT NULL )&#10;IS&#10;    lc_proc CONSTANT VARCHAR2(30) :&#61; UPPER(&#39;trn_rebuild_opt_tables&#39;);&#10;BEGIN&#10;    --&#10;    PKG_VPD_CTX.set_client_identifier(userID &#61;&gt; 1);&#10;    --&#10;    message(lc_proc || &#39;: Commence procRebuildCaseloadTable_ALL&#39;);&#10;    trn_rebuild_caseload(&#10;        p_target_area_list,&#10;        p_crn_list,&#10;        p_old_crn_list,&#10;        p_where );&#10;    message(lc_proc || &#39;: Completed procRebuildCaseloadTable_ALL&#39;);&#10;    --&#10;    --&#10;    -- YF 2014/03/06: moved into PROCESS_OFFENDER_DATA (@record level)&#10;    message(lc_proc || &#39;: Commence do_insert_contact_alert&#39;);&#10;    trn_insert_contact_alert(&#10;        p_target_area_list,&#10;        p_crn_list,&#10;        p_old_crn_list,&#10;        p_where );&#10;    message(lc_proc || &#39;: Completed do_insert_contact_alert&#39;);&#10;    --&#10;    -- YF 2014/02/18: moved VPD re-build into PROCESS_OFFENDER_DATA (@record level)&#10;    message(lc_proc || &#39;: Commence do_rebuild_VPD_ORGS&#39;);&#10;    PKG_TriggerSupport.procSetVPDRebuildFlag( TRUE );&#10;    trn_rebuild_VPD_ORGS(&#10;        p_target_area_list,&#10;        p_crn_list,&#10;        p_old_crn_list,&#10;        p_where );&#10;    message(lc_proc || &#39;: Completed do_rebuild_VPD_ORGS&#39;);&#10;    --&#10;    do_switch_vpd_policies( &#39;ENABLE&#39;, p_target_schema&#61;&gt;USER );&#10;    PKG_TriggerSupport.procSetCDCFlag( TRUE );&#10;    --&#10;    message(&#39;Commence do_table_stats&#39;);&#10;    C08001_PDT_SUPPORT.do_table_stats(p_table&#61;&gt;&#39;ORGANISATION_OFFENDER&#39;);&#10;    C08001_PDT_SUPPORT.do_table_stats(p_table&#61;&gt;&#39;CASELOAD&#39;);&#10;    IF G_PDM_VERSION &gt;&#61; 601 THEN&#10;        C08001_PDT_SUPPORT.do_table_stats(p_table&#61;&gt;&#39;COHORT_DIARY&#39;);&#10;    END IF;&#10;    message(&#39;Completed do_table_stats&#39;);&#10;  --&#10;END trn_rebuild_opt_tables;&#10;--&#10;PROCEDURE trn_post_load(&#10;    p_target_area_list     VARCHAR2 DEFAULT &#39;ALL&#39;,&#10;    p_crn_list             VARCHAR2 DEFAULT NULL,&#10;    p_old_crn_list         VARCHAR2 DEFAULT NULL,&#10;    p_where                VARCHAR2 DEFAULT NULL,&#10;    p_age_days             NUMBER   DEFAULT 0 )&#10;IS&#10;BEGIN&#10;    --&#10;    message(&#39;TRN_POST_LOAD: STARTED&#39;);&#10;    --&#10;    IF p_age_days &gt; 0 THEN&#10;        trn_age_dates(&#10;            p_target_area_list,&#10;            p_crn_list,&#10;            p_old_crn_list,&#10;            p_where,&#10;            p_age_days );&#10;    END IF;&#10;    --&#10;    trn_rebuild_opt_tables(&#10;        p_target_area_list,&#10;        p_crn_list,&#10;        p_old_crn_list,&#10;        p_where );&#10;    --&#10;    message(&#39;TRN_POST_LOAD: completed successfully&#39;);&#10;    --&#10;END trn_post_load;&#10;--&#10;PROCEDURE trn_load_data(&#10;    p_clean_data_flag      VARCHAR2 DEFAULT &#39;Y&#39;,&#10;    p_load_data_flag       VARCHAR2 DEFAULT &#39;Y&#39;,&#10;    p_table_type           VARCHAR2 DEFAULT &#39;ALL&#39;,&#10;    p_target_area_list     VARCHAR2 DEFAULT &#39;ALL&#39;,&#10;    p_crn_list             VARCHAR2 DEFAULT NULL,&#10;    p_old_crn_list         VARCHAR2 DEFAULT NULL,&#10;    p_where                VARCHAR2 DEFAULT NULL,&#10;    p_age_days             NUMBER   DEFAULT 0 )&#10;IS&#10;    l_proc VARCHAR2(32) :&#61; &#39;TRN_LOAD_DATA&#39;;&#10;    --&#10;    l_SQL        VARCHAR2(32767);&#10;    l_table_name VARCHAR2(100);&#10;    --&#10;    l_rows_processed INTEGER :&#61; 0;&#10;    --&#10;    PROCEDURE trn_ins_rec(&#10;        p_recursive_level         INTEGER,&#10;        p_parent_tab_name         VARCHAR2,&#10;        p_tab_name                VARCHAR2,&#10;        p_row_id                  ROWID,&#10;        p_old_pk_key_val          VARCHAR2,&#10;        --&#10;        p_new_probation_area_id   NUMBER,&#10;        p_new_team_id             NUMBER,&#10;        p_new_staff_id            NUMBER,&#10;        --&#10;        p_old_offender_id         NUMBER,&#10;        p_new_offender_id         NUMBER,&#10;        --&#10;        p_old_parent_pk_key_val   VARCHAR2,&#10;        p_new_parent_pk_key_val   VARCHAR2 )&#10;    IS&#10;        l_proc VARCHAR2(32) :&#61; &#39;TRN_INS_REC&#39;;&#10;        --&#10;        recursive_limit_exception EXCEPTION;&#10;        lc_max_recursion CONSTANT NUMBER :&#61; 100;&#10;        --&#10;        TYPE  l_cur_TYP IS REF CURSOR;&#10;        l_cur l_cur_TYP;&#10;        --&#10;        --l_dep_row_id ROWID;&#10;        TYPE l_dep_rec_TYP IS RECORD(&#10;          row_id     ROWID,&#10;          pk_key_val VARCHAR2(4000));&#10;        l_dep_rec l_dep_rec_TYP;&#10;        --&#10;        TYPE l_tab_dep_rows_TYP IS TABLE OF l_dep_rec_TYP;&#10;        l_tab_dep_rows l_tab_dep_rows_TYP;&#10;        --&#10;        l_SQL        VARCHAR2(32767);&#10;        --&#10;        l_tab_OH  t_hier_tab_TYP;&#10;        l_tab_idx INTEGER;&#10;        --&#10;        l_cnt NUMBER;&#10;        --&#10;        l_new_pk_key_val VARCHAR2(4000);&#10;        --&#10;        PROCEDURE trn_insert_current_record&#10;        IS&#10;            l_proc CONSTANT VARCHAR2(30) :&#61; &#39;TRN_INSERT_CURRENT_RECORD&#39;;&#10;            --&#10;            TYPE l_cur_TYP IS REF CURSOR;&#10;            l_cur l_cur_TYP;&#10;            --&#10;            l_SQL         VARCHAR2(32767);&#10;            --&#10;            l_pdt_log_rec t_pdt_log_rec_TYP;&#10;            --&#10;            l_row_id      ROWID;&#10;            l_pk_key_val  VARCHAR2(4000);&#10;            l_m_status    INTEGER;&#10;            l_err_msg     VARCHAR2(1024);&#10;            --&#10;            l_cnt INTEGER;&#10;            --&#10;            l_new_fld_list   VARCHAR2(20000);&#10;            --&#10;            PROCEDURE do_check_src_record&#10;            IS&#10;                l_old_pk_key_val VARCHAR2(4000);&#10;            BEGIN&#10;                IF NVL(p_old_pk_key_val, &#39;NO_VALUE&#39;) &#61; &#39;NO_VALUE&#39; THEN&#10;                    l_SQL :&#61; &#39;SELECT COUNT(1), NULL FROM &#39; || p_tab_name || &#39; WHERE ROWID &#61; :p_row_id&#39;;&#10;                    EXECUTE IMMEDIATE l_SQL INTO l_m_status, l_old_pk_key_val USING p_row_id;&#10;                ELSE&#10;                    l_SQL :&#61;&#10;                       &#39;SELECT 1, SUBSTR(&#39; || REPLACE(g_tab_info(p_tab_name).pk_fld_lst, &#39;,&#39;, &#39; || &#39;) || &#39;, 1, 4000) PK_KEY_VAL&#10;                        FROM &#39; || p_tab_name || &#39;&#10;                        WHERE ROWID &#61; :p_row_id&#39;;&#10;                    EXECUTE IMMEDIATE l_SQL INTO l_m_status, l_old_pk_key_val USING p_row_id;&#10;                END IF;&#10;                --&#10;                IF NVL(l_m_status, -1) &lt;&gt; 1 THEN&#10;                    l_err_msg :&#61; &#39;FATAL ERROR in &#39; || l_proc || &#39;: table[&#39; || p_tab_name || &#39;] has an unexpected MIGRATION_STATUS value [&#39; || l_m_status || &#39;]&#39;;&#10;                ELSIF NVL(p_old_pk_key_val, &#39;NO_VALUE&#39;) &lt;&gt; &#39;NO_VALUE&#39; AND NVL(l_old_pk_key_val, &#39;XXX&#39;) &lt;&gt; NVL(p_old_pk_key_val, &#39;ZZZ&#39;) THEN&#10;                    l_err_msg :&#61; &#39;FATAL ERROR in &#39; || l_proc || &#39;: table[&#39; || p_tab_name || &#39;] has an unexpected PK Key value [&#39; || l_old_pk_key_val || &#39;]; expected: [&#39; || p_old_pk_key_val || &#39;]&#39;;&#10;                END IF;&#10;                IF l_err_msg IS NOT NULL THEN&#10;                    raise_error(l_err_msg, l_proc);&#10;                    RAISE fatal_error_exception;&#10;                END IF;&#10;            END do_check_src_record;&#10;            --&#10;            PROCEDURE do_ins_log_record&#10;            IS&#10;                --PRAGMA AUTONOMOUS_TRANSACTION;&#10;            BEGIN&#10;                l_SQL :&#61;&#10;                    &#39;INSERT INTO TRAINING_table_rows(&#10;                       training_table_rows_ID, hierarchy_level,&#10;                       parent_table, table_name,&#10;                       new_probation_area_id,&#10;                       old_offender_id, new_offender_id,&#10;                       old_pk_value, new_pk_value,&#10;                       old_fk_key, new_fk_key,&#10;                       new_field_list&#10;                     ) VALUES (&#10;                       TRAINING_table_rows_id_SEQ.nextval, :p_hier_level,&#10;                       :p_parent_table, :p_table_name,&#10;                       :p_new_probation_area_id,&#10;                       :p_old_offender_id, :p_new_offender_id,&#10;                       :p_old_pk_value, :p_new_pk_value,&#10;                       :p_old_fk_key, :p_new_fk_key,&#10;                       :p_new_fld_list&#10;                     )&#39;;&#10;                EXECUTE IMMEDIATE l_SQL USING&#10;                  p_recursive_level,&#10;                  --&#10;                  p_parent_tab_name, p_tab_name,&#10;                  --&#10;                  p_new_probation_area_id,&#10;                  --&#10;                  p_old_offender_id, ( CASE WHEN p_tab_name &#61; &#39;OFFENDER&#39; THEN l_new_pk_key_val ELSE p_new_offender_id END ),&#10;                  --&#10;                  p_old_pk_key_val, l_new_pk_key_val,&#10;                  --&#10;                  p_old_parent_pk_key_val, p_new_parent_pk_key_val,&#10;                  --&#10;                  l_new_fld_list&#10;                ;&#10;                --COMMIT;&#10;            EXCEPTION WHEN OTHERS THEN&#10;--                IF SQLERRM LIKE &#39;%ORA-%:%unique constraint%violated%&#39; THEN&#10;--                    --l_skip_FLAG :&#61; TRUE;&#10;--                    NULL;&#10;--                ELSE&#10;                    debugMessage(&#39;INSERT current record INTO TRAINING_table_rows: &#39; || SQLERRM, p_err_flag&#61;&gt;&#39;Y&#39;);&#10;                    raise_error(SQLERRM, l_proc || &#39;[TRAINING_table_rows]&#39;);&#10;--                END IF;&#10;            END do_ins_log_record;&#10;            --&#10;            PROCEDURE do_ins_target_record&#10;            IS&#10;                --&#10;                FUNCTION trn_substitute_key_values(p_fld_lst VARCHAR2) RETURN VARCHAR2&#10;                IS&#10;                    l_new_lst VARCHAR2(20000);&#10;                    --&#10;                    l_new_pa_code  PROBATION_AREA.code%TYPE;&#10;                    l_private_flag PROBATION_AREA.private%TYPE;&#10;                    --&#10;                    l_staff_fld VARCHAR2(1024);&#10;                    l_team_fld  VARCHAR2(1024);&#10;                    --&#10;                    PROCEDURE do_replace_fld_with_val(p_fld_name VARCHAR2, p_fld_value VARCHAR2) IS&#10;                    BEGIN&#10;                        l_new_lst :&#61;&#10;                            REPLACE(l_new_lst,&#10;                                &#39;,&#39; || UPPER(TRIM(p_fld_name)) || &#39;,&#39;,&#10;                                &#39;,&#39; || p_fld_value || &#39; AS &#39; || LOWER(TRIM(p_fld_name)) || &#39;,&#39; );&#10;                    END do_replace_fld_with_val;&#10;                    --&#10;                BEGIN&#10;                    l_new_lst :&#61; &#39;,&#39; || UPPER(REPLACE(TRIM(p_fld_lst), &#39;, &#39;, &#39;,&#39;)) || &#39;,&#39;;&#10;                    --&#10;                    -- 0. Replace PK key&#10;                    do_replace_fld_with_val(p_tab_name || &#39;_ID&#39;, l_new_pk_key_val);&#10;                    --&#10;                    -- 1. Replace PROBATION_AREA_ID value (if exists)&#10;                    do_replace_fld_with_val(&#39;PROBATION_AREA_ID&#39;, p_new_probation_area_id);&#10;                    --&#10;                    -- 2. Replace &lt;parent table&gt;_ID parent key&#10;                    do_replace_fld_with_val(p_parent_tab_name || &#39;_ID&#39;, p_new_parent_pk_key_val);&#10;                    --&#10;                    -- 3. Replace OFFENDER_ID parent key&#10;                    do_replace_fld_with_val(&#39;OFFENDER_ID&#39;, p_new_offender_id);&#10;                    --&#10;                    -- 4. Replace TEAM_ID and STAFF_ID values (if exists)&#10;                    SELECT&#10;                      C08001_PDT_SUPPORT.TRN_get_fk_fld(&#39;STAFF&#39;, p_tab_name) staff_fld,&#10;                      C08001_PDT_SUPPORT.TRN_get_fk_fld(&#39;TEAM&#39; , p_tab_name) team_fld,&#10;                      PA.code,&#10;                      PA.private&#10;                    INTO l_staff_fld, l_team_fld, l_new_pa_code, l_private_flag&#10;                    FROM probation_area PA&#10;                    WHERE PA.probation_area_id &#61; p_new_probation_area_id;&#10;                    --&#10;                    IF l_staff_fld IS NOT NULL THEN&#10;                        LOOP&#10;                            EXIT WHEN l_staff_fld IS NULL;&#10;                            do_replace_fld_with_val(&#10;                                PKG_LstUtl.list_next_elem(l_staff_fld, &#39;,&#39;),&#10;                                p_new_staff_id );&#10;                        END LOOP;&#10;                    END IF;&#10;                    --&#10;                    IF l_team_fld IS NOT NULL THEN&#10;                        LOOP&#10;                            EXIT WHEN l_team_fld IS NULL;&#10;                            do_replace_fld_with_val(&#10;                                PKG_LstUtl.list_next_elem(l_team_fld, &#39;,&#39;),&#10;                                p_new_team_id );&#10;                        END LOOP;&#10;                    END IF;&#10;                    --&#10;                    -- 5. Last Touch columns&#10;                    do_replace_fld_with_val(&#39;CREATED_DATETIME&#39;     , &#39;SYSDATE&#39;);&#10;                    do_replace_fld_with_val(&#39;LAST_UPDATED_DATETIME&#39;, &#39;SYSDATE&#39;);&#10;                    -- 6. Row Version column&#10;                    do_replace_fld_with_val(&#39;ROW_VERSION&#39;, &#39;0&#39;);&#10;                    --&#10;                    -- 7. CRN column&#10;                    IF p_tab_name &#61; &#39;OFFENDER&#39; THEN&#10;                        do_replace_fld_with_val(&#39;CRN&#39;, &#39;SUBSTR(crn, 1, 1) || LPAD(OFFENDER_CRN_SEQ.nextval, 6, &#39;&#39;0&#39;&#39;)&#39;);&#10;                    END IF;&#10;                    --&#10;                    l_new_lst :&#61; RTRIM(LTRIM(l_new_lst, &#39;,&#39;), &#39;,&#39;);&#10;                    --&#10;                    RETURN l_new_lst;&#10;                END trn_substitute_key_values;&#10;                --&#10;            BEGIN&#10;                --&#10;                l_new_fld_list :&#61; trn_substitute_key_values(g_tab_info(p_tab_name).fld_lst_1);&#10;                --&#10;                debugMessage(&#10;                    &#39;TRN_SUBSTITUTE_KEY_VALUES &#39;                                 ||&#10;                    &#39;[parent_tab&#61;&#39;    || p_parent_tab_name                || &#39;]&#39; ||&#10;                    &#39;[tab&#61;&#39;           || p_tab_name                       || &#39;]&#39; ||&#10;                    &#39;[pa&#61;&#39;            || p_new_probation_area_id          || &#39;]&#39; ||&#10;                    &#39;[old_off_id&#61;&#39;    || p_old_offender_id                || &#39;]&#39; ||&#10;                    &#39;[new_off_id&#61;&#39;    || p_new_offender_id                || &#39;]&#39; ||&#10;                    &#39;[old_fk&#61;&#39;        || p_old_parent_pk_key_val          || &#39;]&#39; ||&#10;                    &#39;[new_fk&#61;&#39;        || p_new_parent_pk_key_val          || &#39;]&#39; ||&#10;                    &#39;[old_pk&#61;&#39;        || p_old_pk_key_val                 || &#39;]&#39; ||&#10;                    &#39;[new_pk&#61;&#39;        || l_new_pk_key_val                 || &#39;]&#39; || CHR(10) ||&#10;                    &#39;[orig_fld_lst&#61;&#39;  || g_tab_info(p_tab_name).fld_lst_1 || &#39;]&#39; || CHR(10) ||&#10;                    &#39;[new_fld_lst&#61;&#39;   || l_new_fld_list                   || &#39;]&#39; );&#10;                --&#10;                l_SQL :&#61;&#10;                    &#39;INSERT INTO &#39; || p_tab_name || &#39;(&#10;                    &#39; || g_tab_info(p_tab_name).fld_lst || &#39;)&#10;                     SELECT &#39; || l_new_fld_list || &#39;&#10;                     FROM &#39; || p_tab_name || &#39;&#10;                     WHERE ROWID &#61; :p_row_id&#39;;&#10;                EXECUTE IMMEDIATE l_SQL USING p_row_id;&#10;                --&#10;            EXCEPTION WHEN OTHERS THEN&#10;                raise_error(&#10;                    &#39;FAILED to INSERT a record INTO &#39; || p_tab_name || &#39; WHERE source_rowid&#61;&#39; || ROWIDTOCHAR(p_row_id) || CHR(10) ||&#10;                    SQLERRM || CHR(10) ||&#10;                    &#39;SQL: &#39; || l_SQL,&#10;                    l_proc || &#39;[&#39; || p_tab_name || &#39;]&#39; );&#10;            END do_ins_target_record;&#10;            --&#10;            PROCEDURE generate_new_pk_values&#10;            IS&#10;                --&#10;                FUNCTION get_tab_seq_name(p_table VARCHAR2) RETURN VARCHAR2 IS&#10;                BEGIN&#10;                    RETURN&#10;                        CASE&#10;                            WHEN p_table &#61; &#39;APPROVED_PREMISES_REFERRAL&#39;     THEN &#39;AP_REFERRAL_ID_SEQ&#39;&#10;                            WHEN p_table &#61; &#39;APPROVED_PREMISES_RESIDENCE&#39;    THEN &#39;AP_RESIDENCE_ID_SEQ&#39;&#10;                            WHEN p_table &#61; &#39;INSTITUTIONAL_REPORT_TRANSFER&#39;  THEN &#39;INSTITUTIONAL_REP_TRANS_ID_SEQ&#39;&#10;                        ELSE&#10;                            p_table || &#39;_ID_SEQ&#39;&#10;                        END;&#10;                END get_tab_seq_name;&#10;                --&#10;                FUNCTION get_new_pk_value RETURN VARCHAR2&#10;                IS&#10;                    l_seq_name VARCHAR2(30);&#10;                    l_new_val VARCHAR2(4000);&#10;                BEGIN&#10;                    l_seq_name :&#61; get_tab_seq_name(p_tab_name);&#10;                    EXECUTE IMMEDIATE &#39;SELECT &#39; || l_seq_name || &#39;.nextval FROM dual&#39;&#10;                    INTO l_new_val;&#10;                    --&#10;                    RETURN l_new_val;&#10;                EXCEPTION WHEN OTHERS THEN&#10;                    raise_error(&#10;                        &#39;FAILED to generate the new PK value for &#39; || p_tab_name || &#39; [pk&#61;&#39; || g_tab_info(p_tab_name).pk_fld_lst || &#39;][seq&#61;&#39; || l_seq_name || &#39;]&#39; || CHR(10) ||&#10;                        SQLERRM || CHR(10) ||&#10;                        &#39;SQL: &#39; || l_SQL,&#10;                        &#39;GET_NEW_PK_VALUE&#39; || &#39;[&#39; || p_tab_name || &#39;]&#39; );&#10;                END get_new_pk_value;&#10;                --&#10;            BEGIN&#10;                --&#10;                l_new_pk_key_val :&#61; NULL;&#10;                --&#10;                IF p_tab_name &#61; &#39;KEY_DATE&#39; THEN&#10;                    l_new_pk_key_val :&#61; p_new_parent_pk_key_val;&#10;                ELSIF p_tab_name &#61; &#39;MANAGEMENT_TIER&#39; THEN&#10;                    l_new_pk_key_val :&#61; p_new_parent_pk_key_val;&#10;                ELSIF p_tab_name &#61; &#39;DRUGS_TEST_PROFILE_DRUG_TYPE&#39; THEN&#10;                    l_new_pk_key_val :&#61; p_new_parent_pk_key_val;&#10;                ELSE&#10;                    l_new_pk_key_val :&#61; get_new_pk_value;&#10;                END IF;&#10;                --&#10;            END generate_new_pk_values;&#10;            --&#10;        BEGIN&#10;            g_label :&#61; &#39;20000&#39;;&#10;            --&#10;            -- Check if current record has not been mutated&#10;            g_label :&#61; &#39;20020&#39;;&#10;            do_check_src_record;&#10;            --&#10;            -- Generate new PK value&#10;            generate_new_pk_values;&#10;            --&#10;            -- Insert Current Record&#10;            g_label :&#61; &#39;20025&#39;;&#10;            do_ins_target_record;&#10;            --&#10;            -- Insert LOG record in TRN_log_records table&#10;            g_label :&#61; &#39;20029&#39;;&#10;            do_ins_log_record;&#10;            --&#10;        END trn_insert_current_record;&#10;        --&#10;    BEGIN&#10;        --&#10;        IF (p_recursive_level &gt;&#61; lc_max_recursion) THEN&#10;            debugMessage(&#39;ERROR while trying to INSERT current record INTO &#39; || p_tab_name || &#39;: &#39; ||&#10;                &#39;Count no. of recursive calls [&#39; || p_recursive_level || &#39;] - must not exceed the maximum of &#39; || lc_max_recursion);&#10;            RAISE recursive_limit_exception;&#10;        END IF;&#10;        --&#10;        -- Prohibited scenario 1: Target PA is in (N00, C00)&#10;        SELECT COUNT(1) INTO l_cnt&#10;        FROM probation_area&#10;        WHERE probation_area_id &#61; p_new_probation_area_id&#10;          AND code IN (&#39;C00&#39;, &#39;N00&#39;);&#10;        --&#10;        IF l_cnt &gt; 0 THEN&#10;            debugMessage(&#39;TRN_INS_REC[&#39; || p_tab_name || &#39;][&#39; || p_old_pk_key_val || &#39;][&#39; || p_new_probation_area_id || &#39;]: the Prohibited scenario 1&#39;);&#10;            RETURN;&#10;        END IF;&#10;        --&#10;        IF p_tab_name &#61; &#39;CONTACT&#39; THEN&#10;            -- Prohibited scenario 2: Source PA (for CONTACT table) is not in (N00, C00)&#10;            SELECT COUNT(1) INTO l_cnt&#10;            FROM contact C, probation_area PA&#10;            WHERE C.contact_id &#61; p_old_pk_key_val&#10;              AND PA.probation_area_id &#61; C.probation_area_id&#10;              AND PA.code NOT IN (&#39;N00&#39;, &#39;C00&#39;)&#10;            ;&#10;            IF l_cnt &gt; 0 THEN&#10;                debugMessage(&#39;TRN_INS_REC[&#39; || p_tab_name || &#39;][&#39; || p_old_pk_key_val || &#39;][&#39; || p_new_probation_area_id || &#39;]: the Prohibited scenario 2&#39;);&#10;                RETURN;&#10;            END IF;&#10;            --&#10;        END IF;&#10;        --&#10;        EXECUTE IMMEDIATE&#10;            &#39;SELECT COUNT(1) FROM TRAINING_table_rows WHERE table_name &#61; :p_table_name AND old_pk_value &#61; :p_pk_value AND new_probation_area_id &#61; :p_probation_area_id&#39;&#10;        INTO l_cnt&#10;        USING&#10;          p_tab_name,&#10;          p_old_pk_key_val,&#10;          p_new_probation_area_id&#10;        ;&#10;        IF l_cnt &gt; 0 THEN&#10;            debugMessage(&#39;TRN_INS_REC[&#39; || p_tab_name || &#39;][&#39; || p_old_pk_key_val || &#39;][&#39; || p_new_probation_area_id || &#39;]: the record has already been created&#39;);&#10;            RETURN;&#10;        END IF;&#10;        --&#10;        EXECUTE IMMEDIATE&#10;            &#39;SELECT COUNT(1) FROM TRAINING_table_rows WHERE table_name &#61; :p_table_name AND new_pk_value &#61; :p_pk_value&#39;&#10;        INTO l_cnt&#10;        USING&#10;          p_tab_name,&#10;          p_old_pk_key_val&#10;        ;&#10;        IF l_cnt &gt; 0 THEN&#10;            debugMessage(&#39;TRN_INS_REC[&#39; || p_tab_name || &#39;][&#39; || p_old_pk_key_val || &#39;]: the record has already been created&#39;);&#10;            RETURN;&#10;        END IF;&#10;        --&#10;        trn_insert_current_record;&#10;        --&#10;        -- Get next dependant table name (new p-table) for p-table from offender hierarchy&#10;        l_tab_OH :&#61; g_tab_info(p_tab_name).child_tables;&#10;        --&#10;        FOR l_tab_idx IN 1..l_tab_OH.COUNT&#10;        LOOP&#10;            IF l_tab_OH(l_tab_idx).table_name NOT IN (&#10;               &#39;MOST_RECENTLY_VIEWED_OFFENDERS&#39;,&#10;               &#39;ORGANISATION_OFFENDER&#39;,&#10;               &#39;CONTACT_ALERT&#39;,&#10;               &#39;CASELOAD&#39;,&#10;               &#39;COHORT_DIARY&#39;,&#10;               &#39;SUBJECT_ACCESS_REPORT&#39;,&#10;               &#39;SUBJECT_ACCESS_REPORT_CONTACT&#39;)&#10;            THEN&#10;                --&#10;                l_SQL :&#61;&#10;                   &#39;SELECT ROWID row_id, SUBSTR(&#39; || REPLACE(g_tab_info(l_tab_OH(l_tab_idx).table_name).pk_fld_lst, &#39;,&#39;, &#39; || &#39;) || &#39;, 1, 4000) PK_KEY_VAL&#10;                    FROM &#39; || l_tab_OH(l_tab_idx).table_name || &#39;&#10;                    WHERE (&#39; || g_tab_info(l_tab_OH(l_tab_idx).parent_table).pk_fld_lst || &#39;) IN (&#10;                           SELECT &#39; || g_tab_info(l_tab_OH(l_tab_idx).parent_table).pk_fld_lst || &#39;&#10;                           FROM &#39; || l_tab_OH(l_tab_idx).parent_table || &#39;&#10;                           WHERE ROWID &#61; :p_row_id)&#39;;&#10;                --&#10;                --message(&#39;P: trn_ins_rec - in outer loop - &#39; || &#39;p_row_id&#61;&#39; || p_row_id || &#39; ; Current SQL:&#39; || CHR(10) || l_SQL);&#10;                --&#10;                BEGIN&#10;                    OPEN l_cur FOR l_SQL USING p_row_id;&#10;                    FETCH l_cur BULK COLLECT INTO l_tab_dep_rows;&#10;                    CLOSE l_cur;&#10;                    FOR l_tab_dep_idx IN 1..l_tab_dep_rows.COUNT&#10;                    LOOP&#10;                        g_label :&#61; &#39;1060&#39;;&#10;                        l_dep_rec :&#61; l_tab_dep_rows(l_tab_dep_idx);&#10;                        --&#10;                        -- New p-table records are already pre-selected for curent Parent record&#10;                        -- If new p-table PK value matches p-table PK values&#10;                        -- p_ins_rec (new p-table,  PK values)&#10;&#10;                        g_label :&#61; &#39;1070&#39;;&#10;                        debugMessage(&#39;trn_ins_rec&#39; ||&#10;                            &#39;[&#39; || TO_CHAR(p_recursive_level + 1) || &#39;]&#39; ||&#10;                            &#39;[&#39; || p_parent_tab_name              || &#39;]&#39; ||&#10;                            &#39;[&#39; || l_tab_OH(l_tab_idx).table_name || &#39;]&#39; ||&#10;                            &#39;[&#39; || ROWIDTOCHAR(l_dep_rec.row_id)  || &#39;]&#39; ||&#10;                            &#39;[old_pk&#61;&#39; || l_dep_rec.pk_key_val    || &#39;]&#39; ||&#10;                            --&#10;                            &#39;[PA&#61;&#39; || p_new_probation_area_id     || &#39;]&#39; ||&#10;                            &#39;[new_team&#61;&#39;  || p_new_team_id        || &#39;]&#39; ||&#10;                            &#39;[new_staff&#61;&#39; || p_new_staff_id       || &#39;]&#39; ||&#10;                            --&#10;                            &#39;[old_off&#61;&#39; || p_old_offender_id      || &#39;]&#39; ||&#10;                            &#39;[new_off&#61;&#39; || ( CASE WHEN p_tab_name &#61; &#39;OFFENDER&#39; THEN l_new_pk_key_val ELSE p_new_offender_id END ) || &#39;]&#39; ||&#10;                            --&#10;                            &#39;[old_fk&#61;&#39; ||  p_old_pk_key_val       || &#39;]&#39; ||&#10;                            &#39;[new_fk&#61;&#39; ||  l_new_pk_key_val       || &#39;]&#39;&#10;                        );&#10;                        --&#10;                        g_label :&#61; &#39;1075&#39;;&#10;                        trn_ins_rec(&#10;                            p_recursive_level       &#61;&gt; p_recursive_level + 1,&#10;                            p_parent_tab_name       &#61;&gt; p_tab_name,&#10;                            p_tab_name              &#61;&gt; l_tab_OH(l_tab_idx).table_name,&#10;                            p_row_id                &#61;&gt; l_dep_rec.row_id,&#10;                            p_old_pk_key_val        &#61;&gt; l_dep_rec.pk_key_val,&#10;                            --&#10;                            p_new_probation_area_id &#61;&gt; p_new_probation_area_id,&#10;                            --&#10;                            p_new_team_id           &#61;&gt; p_new_team_id,&#10;                            p_new_staff_id          &#61;&gt; p_new_staff_id,&#10;                            --&#10;                            p_old_offender_id       &#61;&gt; p_old_offender_id,&#10;                            p_new_offender_id       &#61;&gt; ( CASE WHEN p_tab_name &#61; &#39;OFFENDER&#39; THEN l_new_pk_key_val ELSE p_new_offender_id END ),&#10;                            --&#10;                            p_old_parent_pk_key_val &#61;&gt; p_old_pk_key_val,&#10;                            p_new_parent_pk_key_val &#61;&gt; l_new_pk_key_val );&#10;                        --&#10;                    END LOOP;&#10;                EXCEPTION&#10;                    WHEN fatal_error_exception THEN&#10;                        RAISE;&#10;                    WHEN recursive_limit_exception THEN&#10;                        raise_error(&#10;                            &#39;ERROR in TRN_INS_REC parent_tab&#61;&#39; || p_parent_tab_name || &#39;][tab&#61;&#39; || l_tab_OH(l_tab_idx).table_name || &#39;]: recursive call stack has exceeded the maximum limit of &#39; || lc_max_recursion,&#10;                            &#39;TRN_INS_REC&#39; );&#10;                END;&#10;                --&#10;            END IF;&#10;            --&#10;        END LOOP;&#10;        --&#10;    END trn_ins_rec;&#10;    --&#10;    PROCEDURE trn_load_offender_data&#10;    IS&#10;        l_proc VARCHAR2(32) :&#61; &#39;TRN_LOAD_OFFENDER_DATA&#39;;&#10;        --&#10;        CURSOR cs IS&#10;          WITH O AS (&#10;           SELECT&#10;             offender_id,&#10;             CHARTOROWID(row_id_CHAR) row_id,&#10;             probation_area_code&#10;           FROM TABLE( C08001_PDT_SUPPORT.get_offender_data(&#10;                           p_area_list            &#61;&gt; &#39;N00,C00&#39;,&#10;                           p_crn_list             &#61;&gt; p_crn_list,&#10;                           p_old_crn_list         &#61;&gt; p_old_crn_list,&#10;                           p_where                &#61;&gt; p_where ) )&#10;          ORDER BY offender_id )&#10;          SELECT&#10;            O.row_id,&#10;            O.offender_id,&#10;            O.probation_area_code,&#10;            PA.private AS private_flag,&#10;            OM.team_id,&#10;            OM.allocation_staff_id AS staff_id,&#10;            T.district_id,&#10;            D.code district_code,&#10;            B.borough_id,&#10;            B.code borough_code,&#10;            LDU.local_delivery_unit_id,&#10;            LDU.code local_delivery_unit_code&#10;          FROM&#10;            O,&#10;            offender_manager OM,&#10;            team T,&#10;            borough B,&#10;            district D,&#10;            local_delivery_unit LDU,&#10;            probation_area PA&#10;          WHERE OM.offender_id &#61; O.offender_id&#10;            AND OM.active_flag &#61; 1&#10;            AND T.team_id &#61; OM.team_id&#10;            AND D.district_id &#61; T.district_id&#10;            AND B.borough_id &#61; D.borough_id&#10;            AND LDU.local_delivery_unit_id &#61; T.local_delivery_unit_id&#10;            AND PA.code &#61; O.probation_area_code&#10;        ;&#10;        l_rec cs%ROWTYPE;&#10;        --&#10;        l_SQL VARCHAR2(4000);&#10;        l_rows_processed INTEGER :&#61; 0;&#10;        --&#10;        l_new_team_id     NUMBER;&#10;        l_new_staff_id    NUMBER;&#10;        l_new_district_id NUMBER;&#10;        --&#10;        CURSOR csPA(p_private_flag SMALLINT) IS&#10;          SELECT&#10;            PA.probation_area_id,&#10;            PA.code               AS area_code,&#10;            PA.private            AS private_flag,&#10;            T.code                AS team_code,&#10;            S.officer_code&#10;          FROM&#10;            probation_area PA,&#10;            staff S,&#10;            team T&#10;          WHERE PA.probation_area_id &gt;&#61; 1500001000&#10;            AND PA.code NOT IN (&#39;ZPP&#39;)&#10;            AND PA.code NOT LIKE &#39;_00&#39;&#10;            AND PA.private &#61; p_private_flag&#10;            AND ( NVL(p_target_area_list, &#39;ALL&#39;) &#61; &#39;ALL&#39; OR&#10;                  PKG_LstUtl.get_list_2_array(REPLACE(REPLACE(p_target_area_list, &#39; &#39;, &#39;&#39;), &#39;;&#39;, &#39;,&#39;))&#10;                    MULTISET INTERSECT T_TAB_ORGANISATIONS( PA.code ) IS NOT EMPTY&#10;                )&#10;            AND T.code(+) &#61; PA.code || &#39;UAT&#39;&#10;            AND T.private(+) &#61; PA.private&#10;            AND S.officer_code(+) &#61; PA.code || &#39;UATU&#39;&#10;            AND S.private(+) &#61; PA.private;&#10;        --&#10;        l_rec_PA csPA%ROWTYPE;&#10;        --&#10;        PROCEDURE do_cr_uat_team IS&#10;        BEGIN&#10;            l_new_team_id :&#61; team_id_SEQ.nextval;&#10;            INSERT INTO team (&#10;              team_id,&#10;              code,&#10;              description,&#10;              district_id,&#10;              local_delivery_unit_id,&#10;              telephone,&#10;              unpaid_work_team,&#10;              row_version,&#10;              fax_number,&#10;              contact_name,&#10;              start_date,&#10;              end_date,&#10;              created_datetime,&#10;              created_by_user_id,&#10;              last_updated_datetime,&#10;              last_updated_user_id,&#10;              training_session_id,&#10;              probation_area_id,&#10;              PRIVATE,&#10;              sc_provider_id&#10;            )&#10;            SELECT&#10;              l_new_team_id,&#10;              l_rec_PA.area_code || &#39;UAT&#39; AS team_code,&#10;              T.description,&#10;              D.district_id,&#10;              LDU.local_delivery_unit_id,&#10;              T.telephone,&#10;              T.unpaid_work_team,&#10;              0 row_version,&#10;              T.fax_number,&#10;              T.contact_name,&#10;              T.start_date,&#10;              T.end_date,&#10;              SYSDATE AS created_datetime,&#10;              T.created_by_user_id,&#10;              SYSDATE AS last_updated_datetime,&#10;              T.last_updated_user_id,&#10;              NULL AS training_session_id,&#10;              l_rec_PA.probation_area_id,&#10;              l_rec_PA.private_flag,&#10;              NULL AS sc_provider_id&#10;            FROM&#10;              probation_area PA,&#10;              team T,&#10;              borough B,&#10;              district D,&#10;              local_delivery_unit LDU&#10;            WHERE PA.code &#61; SUBSTR(l_rec_PA.area_code, 1, 1) || &#39;00&#39;&#10;              AND T.probation_area_id &#61; PA.probation_area_id&#10;              AND T.code &#61; PA.code || &#39;UAT&#39;&#10;              AND T.private &#61; PA.private&#10;              AND B.probation_area_id &#61; l_rec_PA.probation_area_id&#10;              AND B.code &#61; l_rec_PA.area_code || &#39;UAT&#39;&#10;              AND D.borough_id &#61; B.borough_id&#10;              AND D.code &#61; l_rec_PA.area_code || &#39;UAT&#39;&#10;              AND LDU.code &#61; l_rec_PA.area_code || &#39;UAT&#39;;&#10;        END do_cr_uat_team;&#10;        --&#10;        PROCEDURE do_cr_uatu_staff IS&#10;        BEGIN&#10;            --&#10;            l_new_staff_id :&#61; STAFF_ID_SEQ.nextval;&#10;            --&#10;            INSERT INTO staff (&#10;              staff_id,&#10;              start_date,&#10;              surname,&#10;              end_date,&#10;              forename,&#10;              row_version,&#10;              forename2,&#10;              staff_grade_id,&#10;              title_id,&#10;              officer_code,&#10;              created_by_user_id,&#10;              last_updated_user_id,&#10;              created_datetime,&#10;              last_updated_datetime,&#10;              training_session_id,&#10;              private,&#10;              sc_provider_id,&#10;              probation_area_id )&#10;            SELECT&#10;              l_new_staff_id,&#10;              S.start_date,&#10;              S.surname,&#10;              S.end_date,&#10;              S.forename,&#10;              0 AS row_version,&#10;              S.forename2,&#10;              S.staff_grade_id,&#10;              S.title_id,&#10;              l_rec_PA.area_code || &#39;UATU&#39; AS officer_code,&#10;              S.created_by_user_id,&#10;              S.last_updated_user_id,&#10;              SYSDATE AS created_datetime,&#10;              SYSDATE AS last_updated_datetime,&#10;              NULL AS training_session_id,&#10;              l_rec_PA.private_flag,&#10;              NULL AS sc_provider_id,&#10;              l_rec_PA.probation_area_id&#10;            FROM&#10;              probation_area PA,&#10;              staff S&#10;            WHERE PA.code &#61; SUBSTR(l_rec_PA.area_code, 1, 1) || &#39;00&#39;&#10;              --AND S.probation_area_id &#61; PA.probation_area_id&#10;              AND S.officer_code &#61; PA.code || &#39;UATU&#39;&#10;              AND S.private &#61; PA.private;&#10;            --&#10;            INSERT INTO staff_team (&#10;              staff_id,&#10;              team_id,&#10;              row_version,&#10;              created_by_user_id,&#10;              created_datetime,&#10;              last_updated_user_id,&#10;              last_updated_datetime,&#10;              training_session_id )&#10;            SELECT&#10;              l_new_staff_id,&#10;              T.team_id,&#10;              0 AS row_version,&#10;              T.created_by_user_id,&#10;              SYSDATE AS created_datetime,&#10;              T.last_updated_user_id,&#10;              SYSDATE AS last_updated_datetime,&#10;              NULL AS training_session_id&#10;            FROM team T&#10;            WHERE T.code &#61; l_rec_PA.area_code || &#39;UAT&#39;&#10;              AND T.private &#61; l_rec_PA.private_flag;&#10;        END do_cr_uatu_staff;&#10;        --&#10;        PROCEDURE do_cr_target_team&#10;        IS&#10;            l_new_borough_id             NUMBER;&#10;            l_new_local_delivery_unit_id NUMBER;&#10;        BEGIN&#10;            --&#10;            l_new_local_delivery_unit_id :&#61;&#10;                PKG_Lookups.funcgetTabRecord_CACHED(&#10;                    p_table       &#61;&gt; &#39;local_delivery_unit LDU1, local_delivery_unit LDU2&#39;,&#10;                    p_data_fld    &#61;&gt; &#39;LDU2.local_delivery_unit_id&#39;,&#10;                    p_default_val &#61;&gt; -1,&#10;                    p_ref_col     &#61;&gt; &#39;LDU1.local_delivery_unit_id&#39;,&#10;                    p_ref_val     &#61;&gt; l_rec.local_delivery_unit_id,&#10;                    p_where       &#61;&gt; &#39;LDU2.code &#61; :p_new_area_code || DECODE(:p_private, 1, &#39;&#39;CRC1&#39;&#39;, &#39;&#39;NPS1&#39;&#39;) /*SUBSTR(LDU1.code, 4)*/&#39;,&#10;                    p_bind_var1   &#61;&gt; l_rec_PA.area_code,&#10;                    p_bind_var2   &#61;&gt; l_rec_PA.private_flag );&#10;            IF l_new_local_delivery_unit_id &#61; -1 THEN&#10;                l_new_local_delivery_unit_id :&#61; local_delivery_unit_id_SEQ.nextval;&#10;                INSERT INTO local_delivery_unit(&#10;                  local_delivery_unit_id,&#10;                  code,&#10;                  description,&#10;                  selectable,&#10;                  row_version,&#10;                  created_datetime,&#10;                  created_by_user_id,&#10;                  last_updated_datetime,&#10;                  last_updated_user_id,&#10;                  training_session_id,&#10;                  probation_area_id )&#10;                SELECT&#10;                  l_new_local_delivery_unit_id                                           AS local_delivery_unit_id,&#10;                  l_rec_PA.area_code || DECODE(l_rec_PA.private_flag, 1, &#39;CRC1&#39;, &#39;NPS1&#39;) AS code,&#10;                  l_rec_PA.area_code || &#39; LDU 1&#39;                                         AS description,&#10;                  selectable,&#10;                  0 AS row_version,&#10;                  SYSDATE AS created_datetime,&#10;                  created_by_user_id,&#10;                  SYSDATE AS last_updated_datetime,&#10;                  last_updated_user_id,&#10;                  NULL AS training_session_id,&#10;                  l_rec_PA.probation_area_id&#10;                FROM local_delivery_unit&#10;                WHERE local_delivery_unit_id &#61; l_rec.local_delivery_unit_id;&#10;            ELSE&#10;                UPDATE local_delivery_unit SET&#10;                    selectable &#61; (select selectable from local_delivery_unit where local_delivery_unit_id &#61; l_rec.local_delivery_unit_id)&#10;                WHERE local_delivery_unit_id &#61; l_new_local_delivery_unit_id;&#10;            END IF;&#10;            --&#10;            l_new_borough_id :&#61;&#10;                PKG_Lookups.funcgetTabRecord_CACHED(&#10;                    p_table       &#61;&gt; &#39;borough B1, borough B2&#39;,&#10;                    p_data_fld    &#61;&gt; &#39;B2.borough_id&#39;,&#10;                    p_default_val &#61;&gt; -1,&#10;                    p_ref_col     &#61;&gt; &#39;B1.borough_id&#39;,&#10;                    p_ref_val     &#61;&gt; l_rec.borough_id,&#10;                    p_where       &#61;&gt; &#39;B2.code &#61; :p_new_area_code || SUBSTR(B1.code, 4)&#39;,&#10;                    p_bind_var1   &#61;&gt; l_rec_PA.area_code );&#10;            IF l_new_borough_id &#61; -1 THEN&#10;                l_new_borough_id :&#61; borough_id_SEQ.nextval;&#10;                INSERT INTO borough(&#10;                  borough_id,&#10;                  code,&#10;                  description,&#10;                  selectable,&#10;                  row_version,&#10;                  created_datetime,&#10;                  created_by_user_id,&#10;                  last_updated_datetime,&#10;                  last_updated_user_id,&#10;                  training_session_id,&#10;                  probation_area_id )&#10;                SELECT&#10;                  l_new_borough_id                                    AS borough_id,&#10;                  l_rec_PA.area_code || SUBSTR(l_rec.borough_code, 4) AS code,&#10;                  DECODE(description,&#10;                      &#39;Default Unallocated Borough&#39;, &#39;Default Unallocated Borough&#39;,&#10;                      l_rec_PA.area_code || &#39; Cluster 1&#39;)             AS description,&#10;                  selectable,&#10;                  0 AS row_version,&#10;                  SYSDATE AS created_datetime,&#10;                  created_by_user_id,&#10;                  SYSDATE AS last_updated_datetime,&#10;                  last_updated_user_id,&#10;                  NULL AS training_session_id,&#10;                  l_rec_PA.probation_area_id&#10;                FROM borough&#10;                WHERE borough_id &#61; l_rec.borough_id;&#10;            ELSE&#10;                UPDATE borough SET&#10;                    selectable &#61; (select selectable from borough where borough_id &#61; l_rec.borough_id)&#10;                WHERE borough_id &#61; l_new_borough_id;&#10;            END IF;&#10;            --&#10;            l_new_district_id :&#61;&#10;                PKG_Lookups.funcgetTabRecord_CACHED(&#10;                    p_table       &#61;&gt; &#39;district D1, district D2&#39;,&#10;                    p_data_fld    &#61;&gt; &#39;D2.district_id&#39;,&#10;                    p_default_val &#61;&gt; -1,&#10;                    p_ref_col     &#61;&gt; &#39;D1.district_id&#39;,&#10;                    p_ref_val     &#61;&gt; l_rec.district_id,&#10;                    p_where       &#61;&gt; &#39;D2.code &#61; :p_new_area_code || DECODE(:p_private, 1, &#39;&#39;CRCA&#39;&#39;, &#39;&#39;NPSA&#39;&#39;) /*SUBSTR(D1.code, 4)*/&#39;,&#10;                    p_bind_var1   &#61;&gt; l_rec_PA.area_code,&#10;                    p_bind_var2   &#61;&gt; l_rec_PA.private_flag);&#10;            IF l_new_district_id &#61; -1 THEN&#10;                l_new_district_id :&#61; district_id_SEQ.nextval;&#10;                INSERT INTO district(&#10;                  district_id,&#10;                  code,&#10;                  description,&#10;                  selectable,&#10;                  borough_id,&#10;                  row_version,&#10;                  created_datetime,&#10;                  created_by_user_id,&#10;                  last_updated_datetime,&#10;                  last_updated_user_id,&#10;                  training_session_id )&#10;                SELECT&#10;                  l_new_district_id                                                                   AS district_id,&#10;                  l_rec_PA.area_code || DECODE(l_rec_PA.private_flag, 1, &#39;CRCA&#39;, &#39;NPSA&#39;)              AS code,&#10;                  l_rec_PA.area_code || &#39; &#39; || DECODE(l_rec_PA.private_flag, 1, &#39;County&#39;, &#39;Division&#39;) AS description,&#10;                  selectable,&#10;                  l_new_borough_id                                                                    AS borough_id,&#10;                  0 AS row_version,&#10;                  SYSDATE AS created_datetime,&#10;                  created_by_user_id,&#10;                  SYSDATE AS last_updated_datetime,&#10;                  last_updated_user_id,&#10;                  NULL AS training_session_id&#10;                FROM district&#10;                WHERE district_id &#61; l_rec.district_id;&#10;            ELSE&#10;                UPDATE district SET&#10;                  borough_id &#61; l_new_borough_id,&#10;                  selectable &#61; ( select selectable from district where district_id &#61; l_rec.district_id )&#10;                WHERE district_id &#61; l_new_district_id;&#10;            END IF;&#10;            --&#10;            l_new_team_id :&#61;&#10;                PKG_Lookups.funcgetTabRecord_CACHED(&#10;                    p_table       &#61;&gt; &#39;team T1, team T2&#39;,&#10;                    p_data_fld    &#61;&gt; &#39;T2.team_id&#39;,&#10;                    p_default_val &#61;&gt; -1,&#10;                    p_ref_col     &#61;&gt; &#39;T1.team_id&#39;,&#10;                    p_ref_val     &#61;&gt; l_rec.team_id,&#10;                    p_where       &#61;&gt; &#39;T2.code &#61; :p_new_area_code || SUBSTR(T1.code, 4) AND T2.private &#61; :p_private&#39;,&#10;                    p_bind_var1   &#61;&gt; l_rec_PA.area_code,&#10;                    p_bind_var2   &#61;&gt; l_rec_PA.private_flag );&#10;            --&#10;            IF l_new_team_id &#61; -1 THEN&#10;                l_new_team_id :&#61; team_id_SEQ.nextval;&#10;                INSERT INTO team (&#10;                  team_id,&#10;                  code,&#10;                  description,&#10;                  district_id,&#10;                  local_delivery_unit_id,&#10;                  telephone,&#10;                  unpaid_work_team,&#10;                  row_version,&#10;                  fax_number,&#10;                  contact_name,&#10;                  start_date,&#10;                  end_date,&#10;                  created_datetime,&#10;                  created_by_user_id,&#10;                  last_updated_datetime,&#10;                  last_updated_user_id,&#10;                  training_session_id,&#10;                  probation_area_id,&#10;                  PRIVATE,&#10;                  sc_provider_id&#10;                )&#10;                SELECT&#10;                  l_new_team_id,&#10;                  l_rec_PA.area_code || SUBSTR(T.code, 4) AS team_code,&#10;                  T.description,&#10;                  l_new_district_id,&#10;                  l_new_local_delivery_unit_id,&#10;                  T.telephone,&#10;                  T.unpaid_work_team,&#10;                  0 row_version,&#10;                  T.fax_number,&#10;                  T.contact_name,&#10;                  T.start_date,&#10;                  T.end_date,&#10;                  SYSDATE AS created_datetime,&#10;                  T.created_by_user_id,&#10;                  SYSDATE AS last_updated_datetime,&#10;                  T.last_updated_user_id,&#10;                  NULL AS training_session_id,&#10;                  l_rec_PA.probation_area_id,&#10;                  l_rec_PA.private_flag,&#10;                  NULL AS sc_provider_id&#10;                FROM&#10;                  team T&#10;                WHERE T.team_id &#61; l_rec.team_id&#10;                ;&#10;            ELSE&#10;                UPDATE team T SET&#10;                  district_id &#61; l_new_district_id,&#10;                  local_delivery_unit_id &#61; l_new_local_delivery_unit_id&#10;                WHERE T.team_id &#61; l_new_team_id;&#10;            END IF;&#10;            --&#10;        END do_cr_target_team;&#10;        --&#10;        PROCEDURE do_cr_target_staff IS&#10;        BEGIN&#10;            l_new_staff_id :&#61;&#10;                PKG_Lookups.funcgetTabRecord_CACHED(&#10;                    p_table       &#61;&gt; &#39;staff S1, staff S2&#39;,&#10;                    p_data_fld    &#61;&gt; &#39;S2.staff_id&#39;,&#10;                    p_default_val &#61;&gt; -1,&#10;                    p_ref_col     &#61;&gt; &#39;S1.staff_id&#39;,&#10;                    p_ref_val     &#61;&gt; l_rec.staff_id,&#10;                    p_where       &#61;&gt; &#39;S2.officer_code &#61; :p_new_area_code || SUBSTR(S1.officer_code, 4) AND S2.private &#61; :p_private&#39;,&#10;                    p_bind_var1   &#61;&gt; l_rec_PA.area_code,&#10;                    p_bind_var2   &#61;&gt; l_rec_PA.private_flag );&#10;            --&#10;            IF l_new_staff_id &#61; -1 THEN&#10;                l_new_staff_id :&#61; STAFF_ID_SEQ.nextval;&#10;                --&#10;                INSERT INTO staff (&#10;                  staff_id,&#10;                  start_date,&#10;                  surname,&#10;                  end_date,&#10;                  forename,&#10;                  row_version,&#10;                  forename2,&#10;                  staff_grade_id,&#10;                  title_id,&#10;                  officer_code,&#10;                  created_by_user_id,&#10;                  last_updated_user_id,&#10;                  created_datetime,&#10;                  last_updated_datetime,&#10;                  training_session_id,&#10;                  private,&#10;                  sc_provider_id,&#10;                  probation_area_id )&#10;                SELECT&#10;                  l_new_staff_id,&#10;                  S.start_date,&#10;                  S.surname,&#10;                  S.end_date,&#10;                  S.forename,&#10;                  0 AS row_version,&#10;                  S.forename2,&#10;                  S.staff_grade_id,&#10;                  S.title_id,&#10;                  l_rec_PA.area_code || SUBSTR(S.officer_code, 4) AS officer_code,&#10;                  S.created_by_user_id,&#10;                  S.last_updated_user_id,&#10;                  SYSDATE AS created_datetime,&#10;                  SYSDATE AS last_updated_datetime,&#10;                  NULL AS training_session_id,&#10;                  l_rec_PA.private_flag,&#10;                  NULL AS sc_provider_id,&#10;                  l_rec_PA.probation_area_id&#10;                FROM&#10;                  staff S&#10;                WHERE S.staff_id &#61; l_rec.staff_id;&#10;                --&#10;                INSERT INTO staff_team (&#10;                  staff_id,&#10;                  team_id,&#10;                  row_version,&#10;                  created_by_user_id,&#10;                  created_datetime,&#10;                  last_updated_user_id,&#10;                  last_updated_datetime,&#10;                  training_session_id )&#10;                SELECT&#10;                  l_new_staff_id,&#10;                  T.team_id,&#10;                  0 AS row_version,&#10;                  T.created_by_user_id,&#10;                  SYSDATE AS created_datetime,&#10;                  T.last_updated_user_id,&#10;                  SYSDATE AS last_updated_datetime,&#10;                  NULL AS training_session_id&#10;                FROM team T&#10;                WHERE T.team_id &#61; l_new_team_id;&#10;                --&#10;            END IF;&#10;            --&#10;        END do_cr_target_staff;&#10;        --&#10;        PROCEDURE do_cr_target_office_loc&#10;        IS&#10;            l_new_office_loc_id NUMBER;&#10;            l_new_team_id1      NUMBER;&#10;        BEGIN&#10;            l_new_office_loc_id :&#61;&#10;                PKG_Lookups.funcgetTabRecord_CACHED(&#10;                    p_table       &#61;&gt; &#39;team_office_location TL1, office_location L1, office_location L2&#39;,&#10;                    p_data_fld    &#61;&gt; &#39;L2.office_location_id&#39;,&#10;                    p_default_val &#61;&gt; -1,&#10;                    p_ref_col     &#61;&gt; &#39;TL1.team_id&#39;,&#10;                    p_ref_val     &#61;&gt; l_rec.team_id,&#10;                    p_where       &#61;&gt; &#39;L1.office_location_id &#61; TL1.office_location_id AND L2.code &#61; :p_new_area_code || SUBSTR(L1.code, 4)&#39;,&#10;                    p_bind_var1   &#61;&gt; l_rec_PA.area_code );&#10;            --&#10;            IF l_new_office_loc_id &#61; -1 THEN&#10;                l_new_office_loc_id :&#61; OFFICE_LOCATION_ID_SEQ.nextval;&#10;                --&#10;                INSERT INTO office_location (&#10;                  office_location_id,&#10;                  code,&#10;                  description,&#10;                  district_id,&#10;                  building_name,&#10;                  building_number,&#10;                  street_name,&#10;                  town_city,&#10;                  county,&#10;                  postcode,&#10;                  start_date,&#10;                  end_date,&#10;                  fax_number,&#10;                  telephone_number,&#10;                  row_version,&#10;                  notes,&#10;                  contact_name,&#10;                  created_datetime,&#10;                  created_by_user_id,&#10;                  last_updated_datetime,&#10;                  last_updated_user_id,&#10;                  training_session_id,&#10;                  probation_area_id,&#10;                  district )&#10;                SELECT&#10;                  l_new_office_loc_id,&#10;                  l_rec_PA.area_code || SUBSTR(L.code, 4) AS office_loc_code,&#10;                  L.description,&#10;                  l_new_district_id,&#10;                  L.building_name,&#10;                  L.building_number,&#10;                  L.street_name,&#10;                  L.town_city,&#10;                  L.county,&#10;                  L.postcode,&#10;                  L.start_date,&#10;                  L.end_date,&#10;                  L.fax_number,&#10;                  L.telephone_number,&#10;                  0 AS row_version,&#10;                  L.notes,&#10;                  L.contact_name,&#10;                  SYSDATE AS created_datetime,&#10;                  L.created_by_user_id,&#10;                  SYSDATE AS last_updated_datetime,&#10;                  L.last_updated_user_id,&#10;                  NULL AS training_session_id,&#10;                  l_rec_PA.probation_area_id,&#10;                  L.district&#10;                FROM&#10;                  team_office_location TL,&#10;                  office_location L&#10;                WHERE TL.team_id &#61; l_rec.team_id&#10;                  AND L.office_location_id &#61; TL.office_location_id&#10;                  AND ROWNUM &#61; 1;&#10;            END IF;&#10;            --&#10;            l_new_team_id1 :&#61;&#10;                PKG_Lookups.funcgetTabRecord_CACHED(&#10;                    p_table       &#61;&gt; &#39;team_office_location&#39;,&#10;                    p_data_fld    &#61;&gt; &#39;team_id&#39;,&#10;                    p_default_val &#61;&gt; -1,&#10;                    p_ref_col     &#61;&gt; &#39;team_id&#39;,&#10;                    p_ref_val     &#61;&gt; l_new_team_id,&#10;                    p_where       &#61;&gt; &#39;office_location_id &#61; :p_office_location_id&#39;,&#10;                    p_bind_var1   &#61;&gt; l_new_office_loc_id );&#10;            --&#10;            IF l_new_team_id1 &#61; 1 THEN&#10;                INSERT INTO team_office_location (&#10;                  team_id,&#10;                  office_location_id,&#10;                  row_version,&#10;                  created_by_user_id,&#10;                  created_datetime,&#10;                  last_updated_user_id,&#10;                  last_updated_datetime,&#10;                  training_session_id )&#10;                SELECT&#10;                  l_new_team_id,&#10;                  l_new_office_loc_id,&#10;                  0 AS row_version,&#10;                  T.created_by_user_id,&#10;                  SYSDATE AS created_datetime,&#10;                  T.last_updated_user_id,&#10;                  SYSDATE AS last_updated_datetime,&#10;                  NULL AS training_session_id&#10;                FROM team T&#10;                WHERE T.team_id &#61; l_new_team_id;&#10;            END IF;&#10;            --&#10;        END do_cr_target_office_loc;&#10;        --&#10;        PROCEDURE do_cr_other_teams&#10;        IS&#10;            CURSOR csT IS&#10;              SELECT&#10;                NULL        AS row_id,&#10;                NULL        AS offender_id,&#10;                PA.code     AS probation_area_code,&#10;                PA.private  AS private_flag,&#10;                T.team_id,&#10;                NULL        AS staff_id,&#10;                T.district_id,&#10;                D.code      AS district_code,&#10;                B.borough_id,&#10;                B.code      AS borough_code,&#10;                LDU.local_delivery_unit_id,&#10;                LDU.code    AS local_delivery_unit_code&#10;              FROM&#10;                team T,&#10;                borough B,&#10;                district D,&#10;                local_delivery_unit LDU,&#10;                probation_area PA&#10;              WHERE 1&#61;1&#10;                AND D.district_id &#61; T.district_id&#10;                AND B.borough_id &#61; D.borough_id&#10;                AND LDU.local_delivery_unit_id &#61; T.local_delivery_unit_id&#10;                AND PA.probation_area_id &#61; T.probation_area_id&#10;                AND PA.code IN (&#39;N00&#39;, &#39;C00&#39;)&#10;                AND ( UPPER(T.description) LIKE UPPER(&#39;%Transfer%&#39;) OR&#10;                      UPPER(T.description) LIKE UPPER(&#39;UPW%&#39;)       OR&#10;                      T.code LIKE &#39;_00IAV&#39; );&#10;            --&#10;        BEGIN&#10;            --&#10;            OPEN csT;&#10;            LOOP&#10;                FETCH csT INTO l_rec;&#10;                EXIT WHEN csT%NOTFOUND;&#10;                --&#10;                OPEN csPA(l_rec.private_flag);&#10;                LOOP&#10;                    FETCH csPA INTO l_rec_PA;&#10;                    EXIT WHEN csPA%NOTFOUND;&#10;                    --&#10;                    do_cr_target_team;&#10;                    do_cr_target_office_loc;&#10;                    --do_cr_target_staff;&#10;                    --&#10;                END LOOP;&#10;                CLOSE csPA;&#10;            END LOOP;&#10;            --&#10;            CLOSE csT;&#10;            --&#10;        END do_cr_other_teams;&#10;        --&#10;        PROCEDURE do_cr_other_staff&#10;        IS&#10;            CURSOR csS IS&#10;              SELECT&#10;                NULL        AS row_id,&#10;                NULL        AS offender_id,&#10;                PA.code     AS probation_area_code,&#10;                PA.private  AS private_flag,&#10;                NULL        AS team_id,&#10;                S.staff_id,&#10;                NULL        AS district_id,&#10;                NULL        AS district_code,&#10;                NULL        AS borough_id,&#10;                NULL        AS borough_code,&#10;                NULL        AS local_delivery_unit_id,&#10;                NULL        AS local_delivery_unit_code&#10;              FROM&#10;                staff S,&#10;                probation_area PA&#10;              WHERE 1&#61;1&#10;                AND PA.code &#61; SUBSTR(S.officer_code, 1, 3)&#10;                AND PA.code IN (&#39;N00&#39;, &#39;C00&#39;)&#10;                AND ( --UPPER(T.description) LIKE UPPER(&#39;%Transfer%&#39;) OR&#10;                      --UPPER(T.description) LIKE UPPER(&#39;UPW%&#39;)       OR&#10;                      S.officer_code LIKE &#39;_00IAVU&#39; );&#10;            --&#10;        BEGIN&#10;            --&#10;            OPEN csS;&#10;            LOOP&#10;                FETCH csS INTO l_rec;&#10;                EXIT WHEN csS%NOTFOUND;&#10;                --&#10;                OPEN csPA(l_rec.private_flag);&#10;                LOOP&#10;                    FETCH csPA INTO l_rec_PA;&#10;                    EXIT WHEN csPA%NOTFOUND;&#10;                    --&#10;                    do_cr_target_staff;&#10;                    --&#10;                END LOOP;&#10;                CLOSE csPA;&#10;            END LOOP;&#10;            --&#10;            CLOSE csS;&#10;            --&#10;        END do_cr_other_staff;&#10;        --&#10;        PROCEDURE do_fix_selectable_flags&#10;        IS&#10;            CURSOR csD IS&#10;                SELECT D1.code AS code1, D1.selectable AS selectable1, D2.code AS code2, D2.selectable AS selectable2&#10;                FROM district D1, district D2&#10;                WHERE ( D1.code like &#39;N00%&#39; OR D1.code like &#39;C00%&#39;)&#10;                  AND D2.code LIKE &#39;%&#39; || SUBSTR(D1.code, 4)&#10;                  AND ( D2.code NOT LIKE &#39;N00%&#39; AND D2.code NOT LIKE &#39;C00%&#39;)&#10;                  AND D2.selectable &lt;&gt; D1.selectable&#10;            ORDER BY 1,3;&#10;            l_rec_D csD%ROWTYPE;&#10;        BEGIN&#10;            OPEN csD;&#10;            LOOP&#10;                FETCH csD INTO l_rec_D;&#10;                EXIT WHEN csD%NOTFOUND;&#10;                --&#10;                UPDATE district SET&#10;                  selectable &#61; l_rec_D.selectable1&#10;                WHERE code &#61; l_rec_D.code2;&#10;            END LOOP;&#10;            CLOSE csD;&#10;        END do_fix_selectable_flags;&#10;        --&#10;    BEGIN&#10;        --&#10;        OPEN cs;&#10;        LOOP&#10;            FETCH cs INTO l_rec;&#10;            EXIT WHEN cs%NOTFOUND;&#10;            --&#10;            l_rows_processed :&#61; l_rows_processed + 1;&#10;            --&#10;            OPEN csPA(l_rec.private_flag);&#10;            LOOP&#10;                FETCH csPA INTO l_rec_PA;&#10;                EXIT WHEN csPA%NOTFOUND;&#10;                --&#10;                IF l_rec_PA.team_code IS NULL THEN&#10;                    do_cr_uat_team;&#10;                END IF;&#10;                IF l_rec_PA.officer_code IS NULL THEN&#10;                    do_cr_uatu_staff;&#10;                END IF;&#10;                --&#10;                do_cr_target_team;&#10;                do_cr_target_office_loc;&#10;                do_cr_target_staff;&#10;                --&#10;                trn_ins_rec(&#10;                    p_recursive_level &#61;&gt; 1,&#10;                    p_parent_tab_name &#61;&gt; &#39;&#39;,&#10;                    p_tab_name        &#61;&gt; &#39;OFFENDER&#39;,&#10;                    p_row_id          &#61;&gt; l_rec.row_id,&#10;                    p_old_pk_key_val  &#61;&gt; l_rec.offender_id,&#10;                    --&#10;                    p_new_probation_area_id &#61;&gt; l_rec_PA.probation_area_id,&#10;                    p_new_team_id           &#61;&gt; l_new_team_id,&#10;                    p_new_staff_id          &#61;&gt; l_new_staff_id,&#10;                    --&#10;                    p_old_offender_id &#61;&gt; l_rec.offender_id,&#10;                    p_new_offender_id &#61;&gt; -1,&#10;                    --&#10;                    p_old_parent_pk_key_val &#61;&gt; NULL,&#10;                    p_new_parent_pk_key_val &#61;&gt; NULL );&#10;                --&#10;            END LOOP;&#10;            CLOSE csPA;&#10;        END LOOP;&#10;        --&#10;        CLOSE cs;&#10;        --&#10;        do_cr_other_teams;&#10;        do_cr_other_staff;&#10;        do_fix_selectable_flags;&#10;        --&#10;        --do_fix_contact_SGC_FK;&#10;        --do_alter_contact_id_FK(p_action &#61;&gt; &#39;ENABLE&#39;, p_owner &#61;&gt; p_dest_schema);&#10;        --do_alter_self_ref_FK  (p_action &#61;&gt; &#39;ENABLE&#39;, p_owner &#61;&gt; p_dest_schema);&#10;        --&#10;--    EXCEPTION WHEN OTHERS THEN&#10;--        --&#10;--        message(l_proc || &#39; FAILED.&#39;);&#10;--        message(&#39;PLSQL backtrace: &#39; || DBMS_UTILITY.format_error_backtrace);&#10;--        message(&#39;MT_SQL_ERRM: &#39; || get_dq_message(SQLERRM));&#10;--        message(&#39;MT_SQL_RESULT: 1&#39;);&#10;--        --&#10;--        RAISE;&#10;    END trn_load_offender_data;&#10;    --&#10;    PROCEDURE trn_load_ref_data IS&#10;    BEGIN&#10;        --&#10;        --************************************--&#10;        --NOT IMPLEMENTED YET!!&#10;        --************************************--&#10;        NULL;&#10;    END trn_load_ref_data;&#10;    --&#10;BEGIN&#10;    g_label :&#61; &#39;100200&#39;;&#10;    --&#10;    trn_init;&#10;    --COMMIT;&#10;    --&#10;    message(&#39;+&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;+&#39;);&#10;    message(l_proc ||  &#39; started&#39;);&#10;    message(&#39;+---------------------------------------------------+&#39;);&#10;    message(&#39;VERSION          : &#39; || get_version      );&#10;    message(&#39;NLS_DATE_FORMAT  : &#39; || get_date_format  );&#10;    message(&#39;p_clean_data_flag: &#39; || p_clean_data_flag);&#10;    message(&#39;p_load_data_flag : &#39; || p_load_data_flag );&#10;    message(&#39;p_table_type     : &#39; || p_table_type     );&#10;    message(&#39;+---------------------------------------------------+&#39;);&#10;    message(&#39;&#39;);&#10;    --&#10;    IF p_table_type NOT IN (&#39;ALL&#39;, &#39;O&#39;, &#39;R&#39;) THEN&#10;        raise_error(&#39;ERROR: Invalid value for P_TABLE_TYPE[&#39; || p_table_type || &#39;]&#39;, l_proc);&#10;    END IF;&#10;    --&#10;    IF p_clean_data_flag &#61; &#39;Y&#39; THEN&#10;        trn_clean_data(&#10;            p_table_type,&#10;            p_target_area_list,&#10;            p_crn_list,&#10;            p_old_crn_list );&#10;    END IF;&#10;    --&#10;    IF p_load_data_flag &#61; &#39;Y&#39; THEN&#10;        --&#10;        IF p_table_type IN (&#39;ALL&#39;, &#39;R&#39;) THEN&#10;            NULL;&#10;            --trn_load_ref_data;&#10;        END IF;&#10;        --&#10;        IF p_table_type IN (&#39;ALL&#39;, &#39;O&#39;) THEN&#10;            trn_pre_load;&#10;            trn_load_offender_data;&#10;            trn_post_load(&#10;                p_target_area_list &#61;&gt; p_target_area_list,&#10;                p_crn_list         &#61;&gt; p_crn_list,&#10;                p_old_crn_list     &#61;&gt; p_old_crn_list,&#10;                p_where            &#61;&gt; p_where,&#10;                p_age_days         &#61;&gt; p_age_days );&#10;        END IF;&#10;        --&#10;    END IF;&#10;    --GLOBAL_CACHE_MGR.pdt_inactive;&#10;    --&#10;    g_label :&#61; &#39;100260&#39;;&#10;    message(&#39;&#39;);&#10;    message(l_proc || &#39; completed successfuly.&#39;);&#10;    message(&#39;-&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;-&#39;);&#10;    message(&#39;&#39;);&#10;    g_label :&#61; &#39;100299&#39;;&#10;    message(&#39;MT_SQL_RESULT: 0&#39;);&#10;    --&#10;--EXCEPTION WHEN OTHERS THEN&#10;--    --&#10;--    message(l_proc || &#39; FAILED.&#39;);&#10;--    message(&#39;PLSQL backtrace: &#39; || DBMS_UTILITY.format_error_backtrace);&#10;--    message(&#39;MT_SQL_ERRM: &#39; || SQLERRM);&#10;--    global_cache_mgr.pdt_inactive;&#10;--    RAISE;&#10;--    --&#10;END trn_load_data;&#10;--&#10;PROCEDURE trn_clean_data(&#10;    p_table_type        VARCHAR2 DEFAULT &#39;ALL&#39;,&#10;    p_target_area_list  VARCHAR2 DEFAULT &#39;ALL&#39;,&#10;    p_crn_list          VARCHAR2 DEFAULT NULL,&#10;    p_old_crn_list      VARCHAR2 DEFAULT NULL )&#10;IS&#10;    l_proc VARCHAR2(32) :&#61; &#39;TRN_CLEAN_DATA&#39;;&#10;    --&#10;    l_row         INTEGER;&#10;    l_row_failed  INTEGER;&#10;    --&#10;    TYPE l_cur_TYP IS REF CURSOR;&#10;    l_cur l_cur_TYP;&#10;    --&#10;    l_SQL             VARCHAR2(4000);&#10;    l_row_id          ROWID;&#10;    l_offender_id     NUMBER;&#10;    l_new_offender_id NUMBER;&#10;    --&#10;    PROCEDURE trn_pre_clean IS&#10;    BEGIN&#10;        do_switch_vpd_policies( &#39;DISABLE&#39;, p_target_schema&#61;&gt;USER );&#10;    END trn_pre_clean;&#10;    --&#10;    PROCEDURE trn_post_clean IS&#10;    BEGIN&#10;        do_switch_vpd_policies( &#39;ENABLE&#39;, p_target_schema&#61;&gt;USER );&#10;    END trn_post_clean;&#10;    --&#10;BEGIN&#10;    --&#10;    l_SQL :&#61;&#10;       &#39;WITH O AS (&#10;          SELECT&#10;            offender_id,&#10;            CHARTOROWID(row_id_CHAR) row_id&#10;          FROM TABLE( C08001_PDT_SUPPORT.get_offender_data(&#10;                          p_area_list            &#61;&gt; :p_target_area_list,&#10;                          p_crn_list             &#61;&gt; :p_crn_list,&#10;                          p_old_crn_list         &#61;&gt; :p_old_crn_list,&#10;                          p_where                &#61;&gt; :p_where ) )&#10;          ORDER BY offender_id&#10;       )&#10;       SELECT DISTINCT O.row_id, O.offender_id, T.new_offender_id&#10;         FROM TRAINING_table_rows T, O&#10;         WHERE T.table_name &#61; &#39;&#39;OFFENDER&#39;&#39;&#10;           AND O.offender_id &#61; T.new_offender_id&#39;&#10;    ;&#10;    --&#10;    trn_pre_clean;&#10;    --&#10;    OPEN l_cur FOR l_SQL&#10;      USING&#10;      p_target_area_list,&#10;      p_crn_list,&#10;      p_old_crn_list,&#10;      /*&#39;( &#39; || ( CASE WHEN NVL(p_where, &#39;ALL&#39;) &#61; &#39;ALL&#39; THEN &#39;1&#61;1&#39; ELSE p_where END ) || &#39; ) AND &#39; || */&#39;area_code NOT IN (&#39;&#39;N00&#39;&#39;, &#39;&#39;C00&#39;&#39;)&#39;&#10;    ;&#10;    LOOP&#10;        FETCH l_cur INTO l_row_id, l_offender_id, l_new_offender_id;&#10;        EXIT WHEN l_cur%NOTFOUND;&#10;        --&#10;        IF l_offender_id &gt; 0 THEN&#10;            C08001_PDT_SUPPORT.p_del_rec(&#10;                p_tab_name        &#61;&gt; &#39;OFFENDER&#39;,&#10;                p_row_id          &#61;&gt; l_row_id,&#10;                p_column_name     &#61;&gt; &#39;OFFENDER_ID&#39;,&#10;                p_debug_message   &#61;&gt; &#39;&#39; );&#10;        END IF;&#10;        --&#10;        EXECUTE IMMEDIATE &#39;DELETE FROM TRAINING_table_rows T WHERE new_offender_id &#61; :p_offender_id&#39;&#10;        USING l_new_offender_id;&#10;        --&#10;    END LOOP;&#10;    CLOSE l_cur;&#10;    --&#10;    trn_post_clean;&#10;    --&#10;    --&#10;    EXECUTE IMMEDIATE &#39;DELETE FROM TRAINING_table_rows T WHERE new_offender_id NOT IN (SELECT offender_id FROM offender)&#39;;&#10;    --&#10;EXCEPTION WHEN OTHERS THEN&#10;    debugMessage(&#39;ERROR in TRN_CLEAN_DATA: &#39; || SQLERRM || CHR(10) || l_SQL);&#10;    trn_post_clean;&#10;    raise_error(&#10;        &#39;ERROR while deleting data for OFFENDER_ID&#61;&#39; || l_offender_id || &#39;]&#39; ||&#10;        SQLERRM,&#10;        l_proc&#10;    );&#10;END trn_clean_data;&#10;--&#10;&#10;--&#10;--&#10;--&#10;--&#10;-- PLSQL package Initialisation block&#10;--&#10;BEGIN&#10;--&#10;--&#10;    do_init_NLS;&#10;    do_init_vars;&#10;--&#10;--&#10;END C08001_PDT_SUPPORT;</textarea>
                        </div>
                    </div>
                </section>
            </div>
            <!-- /.content-wrapper -->
            <footer class="main-footer">
                <div>
                    <div class="pull-right hidden-xs">
                        <a href="https://github.com/schemaspy/schemaspy" title="GitHub for SchemaSpy"><i class="fa fa-github-square fa-2x"></i></a>
                        <a href="http://stackoverflow.com/questions/tagged/schemaspy" title="StackOverflow for SchemaSpy"><i class="fa fa-stack-overflow fa-2x"></i></a>
                    </div>
                    <strong>Generated by <a href="http://schemaspy.org/" class="logo-text"><i class="fa fa-database"></i> SchemaSpy 6.2.4</a></strong>
                </div>
                <!-- /.container -->
            </footer>
        </div>
        <!-- ./wrapper -->

        <!-- jQuery 2.2.3 -->
        <script src="../bower/admin-lte/plugins/jQuery/jquery-2.2.3.min.js"></script>
        <script src="../bower/admin-lte/plugins/jQueryUI/jquery-ui.min.js"></script>
        <!-- Bootstrap 3.3.5 -->
        <script src="../bower/admin-lte/bootstrap/js/bootstrap.min.js"></script>
        <!-- DataTables -->
        <script src="../bower/datatables.net/jquery.dataTables.min.js"></script>
        <script src="../bower/datatables.net-bs/js/dataTables.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/dataTables.buttons.min.js"></script>
        <script src="../bower/datatables.net-buttons-bs/js/buttons.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.html5.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.print.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.colVis.min.js"></script>
        <!-- SheetJS -->
        <script src="../bower/js-xlsx/xlsx.full.min.js"></script>
        <!-- pdfmake -->
        <script src="../bower/pdfmake/pdfmake.min.js"></script>
        <script src="../bower/pdfmake/vfs_fonts.js"></script>
        <!-- SlimScroll -->
        <script src="../bower/admin-lte/plugins/slimScroll/jquery.slimscroll.min.js"></script>
        <!-- FastClick -->
        <script src="../bower/admin-lte/plugins/fastclick/fastclick.js"></script>
        <!-- Salvattore -->
        <script src="../bower/salvattore/salvattore.min.js"></script>
        <!-- AnchorJS -->
        <script src="../bower/anchor-js/anchor.min.js"></script>
        <!-- CodeMirror -->
        <script src="../bower/codemirror/codemirror.js"></script>
        <script src="../bower/codemirror/sql.js"></script>
        <!-- AdminLTE App -->
        <script src="../bower/admin-lte/dist/js/app.min.js"></script>
        <script src="routine.js"></script>
        <script src="../schemaSpy.js"></script>
    </body>
</html>