<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>TSTNDA.DELIUS_APP_SCHEMA</title>
        <!-- Tell the browser to be responsive to screen width -->
        <meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport">
        <link rel="icon" type="image/png" sizes="16x16" href="../favicon.png">
        <!-- Bootstrap 3.3.5 -->
        <link rel="stylesheet" href="../bower/admin-lte/bootstrap/css/bootstrap.min.css">
        <!-- Font Awesome -->
        <link rel="stylesheet" href="../bower/font-awesome/css/font-awesome.min.css">
        <!-- Ionicons -->
        <link rel="stylesheet" href="../bower/ionicons/css/ionicons.min.css">
        <!-- DataTables -->
        <link rel="stylesheet" href="../bower/datatables.net-bs/css/dataTables.bootstrap.min.css">
        <link rel="stylesheet" href="../bower/datatables.net-buttons-bs/css/buttons.bootstrap.min.css">
        <!-- Code Mirror -->
        <link rel="stylesheet" href="../bower/codemirror/codemirror.css">
        <!-- Fonts -->
        <link href='../fonts/indieflower/indie-flower.css' rel='stylesheet' type='text/css'>
        <link href='../fonts/source-sans-pro/source-sans-pro.css' rel='stylesheet' type='text/css'>

        <!-- Theme style -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/AdminLTE.min.css">
        <!-- Salvattore -->
        <link rel="stylesheet" href="../bower/salvattore/salvattore.css">
        <!-- AdminLTE Skins. Choose a skin from the css/skins
           folder instead of downloading all of them to reduce the load. -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/skins/_all-skins.min.css">
        <!-- SchemaSpy -->
        <link rel="stylesheet" href="../schemaSpy.css">

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
        <script src="../bower/html5shiv/html5shiv.min.js"></script>
        <script src="../bower/respond/respond.min.js"></script>
        <![endif]-->
    </head>
    <!-- ADD THE CLASS layout-top-nav TO REMOVE THE SIDEBAR. -->
    <body class="hold-transition skin-blue layout-top-nav">
        <div class="wrapper">
            <header class="main-header">
                <nav class="navbar navbar-static-top">
                    <div class="container">
                        <div class="navbar-header">
                            <a href="../index.html" class="navbar-brand"><b>TSTNDA</b></a><span class="navbar-brand" style="padding-left: 0">.DELIUS_APP_SCHEMA</span>
                            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse"><i class="fa fa-bars"></i></button>
                        </div>

                        <!-- Collect the nav links, forms, and other content for toggling -->
                        <div class="collapse navbar-collapse pull-left" id="navbar-collapse">
                            <ul class="nav navbar-nav">
                                <li><a href="../index.html">Tables <span class="sr-only">(current)</span></a></li>
                                <li><a href="../columns.html" title="All of the columns in the schema">Columns</a></li>
                                <li><a href="../constraints.html" title="Useful for diagnosing error messages that just give constraint name or number">Constraints</a></li>
                                <li><a href="../relationships.html" title="Diagram of table relationships">Relationships</a></li>
                                <li><a href="../orphans.html" title="View of tables with neither parents nor children">Orphan&nbsp;Tables</a></li>
                                <li><a href="../anomalies.html" title="Things that might not be quite right">Anomalies</a></li>
                                <li><a href="../routines.html" title="Procedures and functions">Routines</a></li>
                            </ul>
                        </div>
                        <!-- /.navbar-collapse -->
                        <!-- Navbar Right Menu -->
                    </div>
                    <!-- /.container-fluid -->
                </nav>
            </header>
            <!-- Main content -->
            <!-- Full Width Column -->
            <div class="content-wrapper">
                <!-- Content Header (Page header) -->
                <section class="content-header">
                    <h1>DELIUS_APP_SCHEMA.PKG_COMMON</h1><br />
                </section>
                <!-- Main content -->
                <section class="content">
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <span class="glyphicon glyphicon-list-alt" aria-hidden="true"></span>
                            <h3 id="Columns" class="box-title">Parameters</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <table id="standard_table" class="table table-bordered table-striped dataTable" role="grid">
                                <thead align='left'>
                                <tr>
                                    <th>Name</th>
                                    <th>Type</th>
                                    <th>Mode</th>
                                </tr>
                                </thead>
                                <tbody>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <i class="fa fa-file-code-o"></i>
                            <h3 id="RoutineDefinition" class="box-title">Definition</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <textarea id="sql-script-codemirror" name="sql-script-codemirror" rows="" style="display: none;">PACKAGE BODY PKG_Common&#10;AS&#10;--&#10;--&#10;--&#10;&#10;-- Global Variables&#10;g_nvl2_call_level INTEGER :&#61; 0;&#10;&#10;--&#10;--&#10;--&#10;--&#10;&#10;G_TRACE_LEVEL  INTEGER :&#61; 30;&#10;--&#10;g_label        VARCHAR2(30);&#10;g_output_init  VARCHAR2(1) :&#61; &#39;N&#39;;&#10;g_message      VARCHAR2(30000);&#10;&#10;FUNCTION GC_trace_level RETURN INTEGER IS&#10;BEGIN&#10;    RETURN G_TRACE_LEVEL;&#10;END GC_trace_level;&#10;&#10;FUNCTION get_trace_level RETURN INTEGER IS&#10;BEGIN&#10;    RETURN G_TRACE_LEVEL;&#10;END get_trace_level;&#10;--&#10;PROCEDURE set_trace_level(p_trace_level INTEGER) IS&#10;BEGIN&#10;    G_TRACE_LEVEL :&#61; ABS(NVL(p_trace_level, 5));&#10;END set_trace_level;&#10;&#10;-- Global Functions&#10;PROCEDURE print_message(p_msg VARCHAR2, p_label VARCHAR2 DEFAULT NULL, p_trace_level NUMBER DEFAULT 5, p_log_output_flag VARCHAR2 DEFAULT &#39;O&#39;)&#10;IS&#10;    l_max_len NUMBER :&#61; 254;&#10;    l_len     NUMBER;&#10;    l_pos     NUMBER :&#61; 1;&#10;    l_pos1    NUMBER;&#10;    l_line    VARCHAR2(1024);&#10;    --&#10;    l_message_time_stamp VARCHAR2(64);&#10;    --&#10;BEGIN&#10;    --&#10;    IF NVL(p_trace_level, G_TRACE_LEVEL) &gt; G_TRACE_LEVEL THEN&#10;        RETURN;&#10;    END IF;&#10;    --&#10;    IF NVL(empty2null(g_output_init), &#39;N&#39;) &lt;&gt; &#39;Y&#39; THEN&#10;        g_output_init :&#61; &#39;Y&#39;;&#10;        DBMS_OUTPUT.enable(NULL);&#10;    END IF;&#10;    --&#10;    IF p_log_output_flag &#61; &#39;R&#39; THEN&#10;        DBMS_OUTPUT.put_line(p_msg);&#10;    ELSE&#10;        g_message :&#61; SUBSTR(p_msg, 1, 30000);&#10;        IF p_label IS NOT NULL THEN&#10;            g_label :&#61; p_label;&#10;            g_message :&#61; SUBSTR(&#39;[&#39; || g_label || &#39;] &#39; || g_message, 1, 30000);&#10;        END IF;&#10;        --&#10;        l_len :&#61; NVL(LENGTH(g_message), 0);&#10;        IF l_len &gt; 0 THEN&#10;            LOOP&#10;                EXIT WHEN l_pos &gt; l_len;&#10;                l_pos1 :&#61; INSTR(g_message, GC_CR, l_pos);&#10;                IF l_pos1 &gt; l_pos AND l_pos1 - l_pos &lt;&#61; l_max_len THEN&#10;                    l_line :&#61; SUBSTR(g_message, l_pos, l_pos1 - l_pos);&#10;                    l_pos :&#61; l_pos1 + 1;&#10;                ELSE&#10;                    l_line :&#61; SUBSTR(g_message, l_pos, l_max_len);&#10;                    l_pos :&#61; l_pos + l_max_len;&#10;                END IF;&#10;                DBMS_OUTPUT.put_line(l_line);&#10;            END LOOP;&#10;        ELSE&#10;            DBMS_OUTPUT.put_line(l_line);&#10;        END IF;&#10;    END IF;&#10;    --&#10;END print_message;&#10;&#10;PROCEDURE message(p_msg VARCHAR2, p_trace_level INTEGER DEFAULT 0) IS&#10;BEGIN&#10;    print_message(&#10;        p_msg         &#61;&gt; p_msg,&#10;        p_trace_level &#61;&gt; NVL(p_trace_level, G_TRACE_LEVEL),&#10;        p_label       &#61;&gt; g_label);&#10;END message;&#10;&#10;PROCEDURE raise_error(p_err_msg VARCHAR2, p_proc VARCHAR2, p_label VARCHAR2 DEFAULT NULL)&#10;IS&#10;    l_label VARCHAR2(30);&#10;BEGIN&#10;    IF empty2null(p_label) IS NOT NULL THEN&#10;        l_label :&#61; p_label;&#10;    ELSIF empty2null(g_label) IS NOT NULL THEN&#10;        l_label :&#61; g_label;&#10;    ELSE&#10;        l_label :&#61; &#39;N/A/&#39;;&#10;    END IF;&#10;    --&#10;    message( SUBSTR(p_proc || &#39; FAILED. [Step: &#39; || l_label || &#39;]: &#39; || p_err_msg, 1, 30000), 1);&#10;    RAISE_APPLICATION_ERROR(-20001, p_err_msg);&#10;END raise_error;&#10;--&#10;--&#10;FUNCTION empty2null(p_str VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN CASE WHEN p_str &#61; &#39;&#39; THEN NULL ELSE p_str END;&#10;END empty2null;&#10;--&#10;FUNCTION empty2null(&#10;    p_CLOB                 CLOB,&#10;    p_remove_line_ret_flag VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_replace_CR_with      VARCHAR2 DEFAULT NULL,&#10;    p_printable_only_flag  VARCHAR2 DEFAULT &#39;N&#39;,&#10;    p_clean_notes_flag     VARCHAR2 DEFAULT &#39;N&#39;)&#10;RETURN CLOB&#10;IS&#10;    l_ret CLOB;&#10;BEGIN&#10;    l_ret :&#61; p_CLOB;&#10;    --&#10;    IF p_remove_line_ret_flag &#61; &#39;Y&#39; THEN&#10;        l_ret :&#61; TRIM(LTRIM(RTRIM(TRIM(REPLACE(l_ret, CHR(13), &#39;&#39;)), CHR(10)), CHR(10)));&#10;    END IF;&#10;    --&#10;    IF empty2null(p_replace_CR_with) IS NOT NULL THEN&#10;        l_ret :&#61; REPLACE(l_ret, CHR(10), p_replace_CR_with);&#10;        --l_ret :&#61; REPLACE(l_ret, &#39;/n&#39;   , p_replace_CR_with);&#10;        l_ret :&#61; REPLACE(l_ret, &#39;\n&#39;   , p_replace_CR_with);&#10;    END IF;&#10;    --&#10;    IF p_printable_only_flag &#61; &#39;Y&#39; THEN&#10;        --&#10;        --ORA version&#10;        -- CHR(8211) in PG translates to CHR(14844051) in ORA (&#39;���&#39;)&#10;        /* Test case for PG CHR_8211&#10;        SELECT&#10;          CHR(8211) as chr_1_PG,&#10;          CHR(14844051) as chr_1_ORA,&#10;          ASCII(&#39;-&#39;) AS asc_1,&#10;          ASCII(&#39;���&#39;) AS asc_2,&#10;          REGEXP_REPLACE(&#39;-&#39;, &#39;[^[:print:]]&#39;, &#39;x&#39;) AS regexp0,&#10;          REGEXP_REPLACE(CHR(8211), &#39;[^[:print:]]&#39;, &#39;x&#39;) AS regexp1,&#10;          REGEXP_REPLACE(&#39;���&#39;, &#39;[^[:print:]]&#39;, &#39;x&#39;) AS regexp2,&#10;          REGEXP_REPLACE(CHR(14844051), &#39;[^[:print:]]&#39;, &#39;x&#39;) AS regexp3,&#10;          &#39;--&#39;&#10;        FROM dual;&#10;        */&#10;        --&#10;        l_ret :&#61; REPLACE(l_ret, CHR(8211), &#39;-&#39; ); --/*&#39;���&#39;*/ CHR(14844051));&#10;        --l_ret :&#61; REPLACE(l_ret, CHR(15712189), &#39;&#39;&#39;&#39; );&#10;        l_ret :&#61; REGEXP_REPLACE(l_ret, &#39;[^[:print:]]&#39;, &#39; &#39;, 1, 0);&#10;        --&#10;        --PG version&#10;        /*&#10;        --Replace unprintable &quot;-&quot; character&#10;        l_ret :&#61; REPLACE(l_ret, CHR(8211), &#39;#CHR_8211&#39;);&#10;        l_ret :&#61; REGEXP_REPLACE(l_ret, &#39;[^[:print:]]&#39;, &#39; &#39;, &#39;g&#39;);&#10;        --&#10;        -- Restore unprintable &quot;-&quot; character&#10;        l_ret :&#61; REPLACE(l_ret, &#39;#CHR_8211&#39;, CHR(8211));&#10;        */&#10;        --&#10;    END IF;&#10;&#10;    IF p_clean_notes_flag &#61; &#39;Y&#39; THEN&#10;        l_ret :&#61; REGEXP_REPLACE(l_ret,&#39;(^[[:space:]]*|[[:space:]]*$)&#39;);&#10;    END IF;&#10;    --&#10;    RETURN&#10;        CASE&#10;            WHEN NULLIF(NVL(LENGTH(l_ret),0),0) IS NULL THEN NULL&#10;              /*l_ret IS NULL OR l_ret &#61; &#39;&#39; OR LENGTH(l_ret) &#61; 0 THEN NULL*/&#10;            ELSE l_ret&#10;        END;&#10;END empty2null;&#10;--&#10;FUNCTION is_str_empty(p_str VARCHAR2, p_ignore_spaces_and_zeroes VARCHAR2 DEFAULT &#39;N&#39;) RETURN VARCHAR2&#10;IS&#10;    l_ret VARCHAR2(1);&#10;BEGIN&#10;    l_ret :&#61; &#39;N&#39;;&#10;    IF p_ignore_spaces_and_zeroes &#61; &#39;Y&#39; THEN&#10;        RETURN&#10;            is_str_empty(&#10;                p_str                      &#61;&gt; TRIM(REPLACE(REPLACE(p_str, &#39;:&#39;, &#39;&#39;), &#39;0&#39;, &#39;&#39;)),&#10;                p_ignore_spaces_and_zeroes &#61;&gt; &#39;N&#39;&#10;            );&#10;    ELSE&#10;        -- 1. Check for blank string (CHR(9/10/13) and spaces are ignored)&#10;        IF empty2null(&#10;               LTRIM(&#10;                   REPLACE(&#10;                       REPLACE(&#10;                           REPLACE( p_str, CHR(9), &#39; &#39; ),&#10;                           CHR(13), &#39;&#39; ),&#10;                       CHR(10), &#39;&#39;) )&#10;           ) IS NULL&#10;        THEN&#10;            l_ret :&#61; &#39;Y&#39;;&#10;        END IF;&#10;    END IF;&#10;    --&#10;    RETURN l_ret;&#10;END is_str_empty;&#10;--&#10;PROCEDURE do_compress_spaces(p_list IN OUT VARCHAR2)&#10;IS&#10;    l_pos INTEGER;&#10;BEGIN&#10;    p_list :&#61; REPLACE(TRIM(p_list), CHR(9), &#39; &#39;);&#10;    LOOP&#10;        l_pos :&#61; NVL(INSTR(UPPER(p_list), &#39;  &#39;, 1), 0);&#10;        EXIT WHEN l_pos &lt;&#61; 0;&#10;        --&#10;        p_list :&#61; REPLACE(TRIM(p_list), &#39;  &#39;, &#39; &#39;);&#10;    END LOOP;&#10;END do_compress_spaces;&#10;--&#10;FUNCTION char_2_ascii(p_val VARCHAR2) RETURN VARCHAR2&#10;IS&#10;    l_ret   VARCHAR2(32000);&#10;    l_i     INTEGER;&#10;    l_len   INTEGER;&#10;    l_char  VARCHAR2(1);&#10;    l_ascii INTEGER;&#10;BEGIN&#10;    l_len :&#61; LENGTH(p_val);&#10;    FOR l_i IN 1 .. l_len LOOP&#10;        l_char :&#61; SUBSTR(p_val, l_i, 1);&#10;        l_ascii :&#61; ASCII(l_char);&#10;        IF l_ascii &lt;&#61; 32 THEN&#10;            l_ret :&#61; l_ret || &#39;[chr&#39; || l_ascii || &#39;]&#39;;&#10;        ELSE&#10;            l_ret :&#61; l_ret || l_char;&#10;        END IF;&#10;    END LOOP;&#10;    --&#10;    RETURN l_ret;&#10;END char_2_ascii;&#10;--&#10;FUNCTION char_2_number(p_val VARCHAR2) RETURN NUMBER&#10;IS&#10;    l_val VARCHAR2(4000);&#10;    l_ret NUMBER;&#10;BEGIN&#10;    l_val :&#61; SUBSTR(p_val, 1, 4000);&#10;    do_compress_spaces(l_val);&#10;    l_val :&#61; REPLACE(l_val, &#39; &#39;, &#39;&#39;);&#10;    --&#10;    BEGIN&#10;        IF empty2null(l_val) IS NULL THEN&#10;            l_ret :&#61; NULL;&#10;        ELSE&#10;            l_ret :&#61; TO_NUMBER(l_val);&#10;        END IF;&#10;    EXCEPTION WHEN OTHERS THEN&#10;        l_ret :&#61; NULL;&#10;    END;&#10;    --&#10;    RETURN l_ret;&#10;END char_2_number;&#10;--&#10;FUNCTION number_2_char(p_val NUMBER) RETURN VARCHAR2&#10;IS&#10;    --&#10;    l_ret VARCHAR2(100);&#10;    --&#10;BEGIN&#10;    --&#10;    l_ret :&#61; TO_CHAR(p_val);&#10;    --&#10;    RETURN&#10;        CASE WHEN SUBSTR(l_ret, 1, 1) &#61; &#39;.&#39; THEN &#39;0&#39; END ||&#10;        l_ret;&#10;END number_2_char;&#10;--&#10;FUNCTION bool_2_char(p_val BOOLEAN ) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN&#10;        CASE&#10;            WHEN p_val &#61; TRUE THEN &#39;Y&#39;&#10;            WHEN p_val &#61; FALSE THEN &#39;N&#39;&#10;            ELSE &#39;NULL&#39;&#10;        END;&#10;END bool_2_char;&#10;--&#10;FUNCTION date_2_char(p_val DATE) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN TO_CHAR(p_val, PKG_Global.get_date_format);&#10;END date_2_char;&#10;--&#10;FUNCTION char_2_date(p_val VARCHAR2) RETURN DATE IS&#10;BEGIN&#10;    RETURN TO_DATE(p_val, PKG_Global.get_date_format);&#10;END char_2_date;&#10;--&#10;FUNCTION timestamp_2_char(p_val TIMESTAMP) RETURN VARCHAR2&#10;IS&#10;    --&#10;    l_ret       VARCHAR2(30);&#10;    l_tail      VARCHAR2(30);&#10;    l_precision INTEGER :&#61; PKG_Global.get_timestamp_precision;&#10;    l_delta     INTEGER;&#10;    --&#10;BEGIN&#10;    --&#10;    l_ret :&#61; TO_CHAR(p_val, PKG_Global.get_timestamp_format);&#10;    --&#10;    l_tail :&#61; PKG_LstUtl.list_num_tail(l_ret, &#39;.&#39;, 1);&#10;    l_delta :&#61; LENGTH(l_tail) - l_precision;&#10;    IF l_delta &gt; 0 AND SUBSTR(l_tail, -1*l_delta) &#61; LPAD(&#39;0&#39;, l_delta, &#39;0&#39;) THEN&#10;        l_ret :&#61; SUBSTR(l_ret, 1, LENGTH(l_ret) - l_delta);&#10;    END IF;&#10;    --;&#10;    RETURN l_ret;&#10;END timestamp_2_char;&#10;--&#10;FUNCTION char_2_timestamp(p_val VARCHAR2) RETURN TIMESTAMP IS&#10;BEGIN&#10;    RETURN TO_TIMESTAMP(p_val, PKG_Global.get_timestamp_format);&#10;END char_2_timestamp;&#10;--&#10;FUNCTION xml_2_clob(p_xml XMLTYPE) RETURN CLOB IS&#10;BEGIN&#10;    RETURN&#10;        CASE&#10;            WHEN p_xml IS NULL THEN NULL&#10;            ELSE p_xml.getClobVal()&#10;        END ;&#10;END xml_2_clob;&#10;--&#10;FUNCTION xml_remove_non_printable(p_xml XMLTYPE) RETURN XMLTYPE&#10;IS&#10;    --&#10;    l_xml_clob CLOB;&#10;    l_xml      XMLTYPE;&#10;    --&#10;    PROCEDURE procDebug(p_msg CLOB, p_print_flag VARCHAR2 DEFAULT &#39;N&#39;) IS&#10;    BEGIN&#10;        PKG_Debug.procDebug(&#39;PKG_Common.xml_remove_non_printable: &#39; || p_msg, p_print_flag);&#10;    END procDebug;&#10;    --&#10;BEGIN&#10;    IF p_xml IS NOT NULL THEN&#10;        -- ORA-03001 (&quot;Unimplemented feature&quot; error when converting XMLTYPE to CLOB from table) workaround:&#10;        --   use double XMLTYPE-&gt;CLOB-&gt;XMLTYPE-&gt;CLOB data type conversion&#10;        l_xml_clob :&#61; xml_2_clob(XMLTYPE(p_xml.getClobVal()));&#10;        --&#10;        --procDebug(&#39;BEFORE xml [&#39; || l_xml_clob || &#39;]&#39;);&#10;        --&#10;        l_xml_clob :&#61;&#10;            REPLACE(&#10;                PKG_Common.empty2null(&#10;                    p_CLOB                 &#61;&gt; l_xml_clob,&#10;                    p_remove_line_ret_flag &#61;&gt; &#39;N&#39; /*&#39;Y&#39;*/,&#10;                    p_replace_CR_with      &#61;&gt; PKG_Global.GC_SPG_CR,&#10;                    p_printable_only_flag  &#61;&gt; &#39;Y&#39;,&#10;                    p_clean_notes_flag     &#61;&gt; &#39;N&#39; /*&#39;Y&#39;*/ ),&#10;                PKG_Global.GC_SPG_CR, CHR(10) /*CHR(38) || &#39;#10;&#39;*/ );&#10;        --&#10;        --procDebug(&#39;AFTER xml [&#39; || l_xml_clob || &#39;]&#39;);&#10;        --&#10;    ELSE&#10;        l_xml_clob :&#61; NULL;&#10;    END IF;&#10;    --&#10;    IF l_xml_clob IS NOT NULL THEN&#10;        l_xml :&#61; XMLTYPE(l_xml_clob);&#10;    ELSE&#10;        l_xml :&#61; NULL;&#10;    END IF;&#10;    --&#10;    RETURN l_xml;&#10;END xml_remove_non_printable;&#10;--&#10;FUNCTION clob_compare(p_clob1 CLOB, p_clob2 CLOB) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN CASE WHEN p_clob1 &#61; p_clob2 THEN &#39;Y&#39; ELSE &#39;N&#39; END;&#10;END clob_compare;&#10;--&#10;FUNCTION get_duration_sec(p_date1 DATE, p_date2 DATE) RETURN NUMBER&#10;IS&#10;    --l_duration INTERVAL;&#10;    l_ret NUMBER;&#10;BEGIN&#10;    IF p_date2 IS NULL OR p_date1 IS NULL THEN&#10;        l_ret :&#61; NULL;&#10;    ELSE&#10;        /*&#10;        l_duration :&#61; p_date2 - p_date1;&#10;        l_ret :&#61; (EXTRACT (EPOCH  FROM l_duration));&#10;        */&#10;        l_ret :&#61; (p_date2 - p_date1) * 24 * 60 * 60;&#10;    END IF;&#10;    --&#10;    RETURN l_ret;&#10;END get_duration_sec;&#10;--&#10;FUNCTION get_duration(p_date1 DATE, p_date2 DATE) RETURN NUMBER&#10;IS&#10;BEGIN&#10;    RETURN get_duration_sec(p_date1, p_date2) / 60 / 60 / 24;&#10;END get_duration;&#10;--&#10;--&#10;-------------------------------------------------------------------------------&#10;--&#10;-- Custom NVL function&#10;--&#10;-------------------------------------------------------------------------------&#10;--&#10;PROCEDURE do_check_nv2_callstack(p_inc VARCHAR2 DEFAULT &#39;Y&#39;)&#10;IS&#10;    lc_max_level CONSTANT INTEGER :&#61; 10;&#10;    l_proc       CONSTANT VARCHAR2(30) :&#61; &#39;DO_CHECK_NV2_CALLSTACK&#39;;&#10;BEGIN&#10;    IF p_inc &#61; &#39;Y&#39; THEN&#10;        g_nvl2_call_level :&#61; GREATEST(0, g_nvl2_call_level + 1);&#10;    ELSE&#10;        g_nvl2_call_level :&#61; GREATEST(0, g_nvl2_call_level - 1);&#10;    END IF;&#10;    --&#10;    IF g_nvl2_call_level &gt; lc_max_level THEN&#10;        raise_error(&#39;ERROR: An implicit recursion for the NVL2 function detected: &#39; || DBMS_UTILITY.format_call_stack, l_proc);&#10;    END IF;&#10;END do_check_nv2_callstack;&#10;&#10;FUNCTION get_date_priv(p_date DATE) RETURN DATE&#10;IS&#10;  l_date DATE;&#10;BEGIN&#10;    IF p_date IS NULL THEN&#10;        l_date :&#61; NULL;&#10;    ELSE&#10;        IF empty2null( LTRIM(REPLACE(REPLACE(TO_CHAR(p_date), &#39;:&#39;, &#39;&#39;), &#39;0&#39;, &#39;&#39;)) ) IS NULL THEN&#10;            l_date :&#61; NULL;&#10;        ELSE&#10;            l_date :&#61; p_date;&#10;        END IF;&#10;    END IF;&#10;    RETURN l_date;&#10;END get_date_priv;&#10;--&#10;FUNCTION get_least_priv(p_val1 DATE, p_val2 DATE) RETURN DATE IS&#10;BEGIN&#10;    RETURN LEAST(p_val1, NVL(p_val2, p_val1));&#10;END get_least_priv;&#10;--&#10;FUNCTION get_greatest_priv(p_val1 DATE, p_val2 DATE) RETURN DATE IS&#10;BEGIN&#10;    RETURN GREATEST(p_val1, NVL(p_val2, p_val1));&#10;END get_greatest_priv;&#10;--&#10;FUNCTION nvl2(&#10;    p_val1 BOOLEAN             , p_val2 BOOLEAN             , p_val3 BOOLEAN DEFAULT NULL, p_val4 BOOLEAN DEFAULT NULL, p_val5 BOOLEAN DEFAULT NULL,&#10;    p_val6 BOOLEAN DEFAULT NULL, p_val7 BOOLEAN DEFAULT NULL, p_val8 BOOLEAN DEFAULT NULL, p_val9 BOOLEAN DEFAULT NULL, p_val10 BOOLEAN DEFAULT NULL,&#10;    p_ignore_spaces_and_zeroes VARCHAR2 DEFAULT &#39;N&#39;&#10;) RETURN BOOLEAN&#10;IS&#10;    l_ret BOOLEAN;&#10;BEGIN&#10;    do_check_nv2_callstack(&#39;Y&#39;);&#10;    --&#10;    IF    p_val1 IS NOT NULL THEN l_ret :&#61; p_val1;&#10;    ELSIF p_val2 IS NOT NULL THEN l_ret :&#61; p_val2;&#10;    ELSIF p_val3 IS NOT NULL THEN l_ret :&#61; p_val3;&#10;    ELSIF p_val4 IS NOT NULL THEN l_ret :&#61; p_val4;&#10;    ELSIF p_val5 IS NOT NULL THEN l_ret :&#61; p_val5;&#10;    ELSIF p_val6 IS NOT NULL THEN l_ret :&#61; p_val6;&#10;    ELSIF p_val7 IS NOT NULL THEN l_ret :&#61; p_val7;&#10;    ELSIF p_val8 IS NOT NULL THEN l_ret :&#61; p_val8;&#10;    ELSIF p_val9 IS NOT NULL THEN l_ret :&#61; p_val9;&#10;    ELSE                          l_ret :&#61; p_val10;&#10;    END IF;&#10;    --&#10;    do_check_nv2_callstack(&#39;N&#39;);&#10;    --&#10;    RETURN l_ret;&#10;END nvl2;&#10;&#10;FUNCTION nvl2(&#10;    p_val1 VARCHAR2             , p_val2 VARCHAR2             , p_val3 VARCHAR2 DEFAULT NULL, p_val4 VARCHAR2 DEFAULT NULL, p_val5 VARCHAR2 DEFAULT NULL,&#10;    p_val6 VARCHAR2 DEFAULT NULL, p_val7 VARCHAR2 DEFAULT NULL, p_val8 VARCHAR2 DEFAULT NULL, p_val9 VARCHAR2 DEFAULT NULL, p_val10 VARCHAR2 DEFAULT NULL,&#10;    p_ignore_spaces_and_zeroes VARCHAR2 DEFAULT &#39;N&#39;)&#10;RETURN VARCHAR2&#10;IS&#10;    l_ret VARCHAR2(32000);&#10;BEGIN&#10;    do_check_nv2_callstack(&#39;Y&#39;);&#10;    --&#10;    IF    is_str_empty(p_val1, p_ignore_spaces_and_zeroes) &#61; &#39;N&#39; THEN l_ret :&#61; p_val1;&#10;    ELSIF is_str_empty(p_val2, p_ignore_spaces_and_zeroes) &#61; &#39;N&#39; THEN l_ret :&#61; p_val2;&#10;    ELSIF is_str_empty(p_val3, p_ignore_spaces_and_zeroes) &#61; &#39;N&#39; THEN l_ret :&#61; p_val3;&#10;    ELSIF is_str_empty(p_val4, p_ignore_spaces_and_zeroes) &#61; &#39;N&#39; THEN l_ret :&#61; p_val4;&#10;    ELSIF is_str_empty(p_val5, p_ignore_spaces_and_zeroes) &#61; &#39;N&#39; THEN l_ret :&#61; p_val5;&#10;    ELSIF is_str_empty(p_val6, p_ignore_spaces_and_zeroes) &#61; &#39;N&#39; THEN l_ret :&#61; p_val6;&#10;    ELSIF is_str_empty(p_val7, p_ignore_spaces_and_zeroes) &#61; &#39;N&#39; THEN l_ret :&#61; p_val7;&#10;    ELSIF is_str_empty(p_val8, p_ignore_spaces_and_zeroes) &#61; &#39;N&#39; THEN l_ret :&#61; p_val8;&#10;    ELSIF is_str_empty(p_val9, p_ignore_spaces_and_zeroes) &#61; &#39;N&#39; THEN l_ret :&#61; p_val9;&#10;    ELSE  l_ret :&#61; p_val10;&#10;    END IF;&#10;    --&#10;    do_check_nv2_callstack(&#39;N&#39;);&#10;    --&#10;    RETURN RTRIM(l_ret);&#10;END nvl2;&#10;--&#10;FUNCTION nvlstr(p_str1 VARCHAR2, p_str2 VARCHAR2) RETURN VARCHAR2 IS&#10;BEGIN&#10;    RETURN NVL(empty2null(p_str1), empty2null(p_str2));&#10;END nvlstr;&#10;--&#10;FUNCTION nvl2(&#10;    p_val1 DATE             , p_val2 DATE             , p_val3 DATE DEFAULT NULL, p_val4 DATE DEFAULT NULL, p_val5 DATE DEFAULT NULL,&#10;    p_val6 DATE DEFAULT NULL, p_val7 DATE DEFAULT NULL, p_val8 DATE DEFAULT NULL, p_val9 DATE DEFAULT NULL, p_val10 DATE DEFAULT NULL)&#10;RETURN DATE&#10;IS&#10;    l_val1 DATE;&#10;    l_val2 DATE;&#10;    l_val3 DATE;&#10;    l_val4 DATE;&#10;    l_val5 DATE;&#10;    l_val6 DATE;&#10;    l_val7 DATE;&#10;    l_val8 DATE;&#10;    l_val9 DATE;&#10;    l_val10 DATE;&#10;    l_ret  DATE;&#10;    --&#10;BEGIN&#10;    do_check_nv2_callstack(&#39;Y&#39;);&#10;    --&#10;    l_val1 :&#61; get_date_priv(p_val1);&#10;    l_val2 :&#61; get_date_priv(p_val2);&#10;    l_val3 :&#61; get_date_priv(p_val3);&#10;    l_val4 :&#61; get_date_priv(p_val4);&#10;    l_val5 :&#61; get_date_priv(p_val5);&#10;    l_val6 :&#61; get_date_priv(p_val6);&#10;    l_val7 :&#61; get_date_priv(p_val7);&#10;    l_val8 :&#61; get_date_priv(p_val8);&#10;    l_val9 :&#61; get_date_priv(p_val9);&#10;    l_val10 :&#61; get_date_priv(p_val10);&#10;    --&#10;    IF    l_val1 IS NOT NULL THEN l_ret :&#61; l_val1;&#10;    ELSIF l_val2 IS NOT NULL THEN l_ret :&#61; l_val2;&#10;    ELSIF l_val3 IS NOT NULL THEN l_ret :&#61; l_val3;&#10;    ELSIF l_val4 IS NOT NULL THEN l_ret :&#61; l_val4;&#10;    ELSIF l_val5 IS NOT NULL THEN l_ret :&#61; l_val5;&#10;    ELSIF l_val6 IS NOT NULL THEN l_ret :&#61; l_val6;&#10;    ELSIF l_val7 IS NOT NULL THEN l_ret :&#61; l_val7;&#10;    ELSIF l_val8 IS NOT NULL THEN l_ret :&#61; l_val8;&#10;    ELSIF l_val9 IS NOT NULL THEN l_ret :&#61; l_val9;&#10;    ELSE                          l_ret :&#61; l_val10;&#10;    END IF;&#10;    --&#10;    do_check_nv2_callstack(&#39;N&#39;);&#10;    --&#10;    RETURN l_ret;&#10;END nvl2;&#10;--&#10;FUNCTION nvl2(&#10;    p_val1 NUMBER             , p_val2 NUMBER             , p_val3 NUMBER DEFAULT NULL, p_val4 NUMBER DEFAULT NULL, p_val5 NUMBER DEFAULT NULL,&#10;    p_val6 NUMBER DEFAULT NULL, p_val7 NUMBER DEFAULT NULL, p_val8 NUMBER DEFAULT NULL, p_val9 NUMBER DEFAULT NULL, p_val10 NUMBER DEFAULT NULL,&#10;    p_ignore_zeroes VARCHAR2 DEFAULT &#39;N&#39;)&#10;RETURN NUMBER&#10;IS&#10;    l_dummy NUMBER :&#61; -9999999999999999999999999999999999.99;&#10;    l_ret NUMBER;&#10;BEGIN&#10;    --&#10;    IF NVL(empty2null(p_ignore_zeroes), &#39;N&#39;) &#61; &#39;Y&#39; THEN&#10;        l_dummy :&#61; 0;&#10;    END IF;&#10;    --&#10;    do_check_nv2_callstack(&#39;Y&#39;);&#10;    --&#10;    IF    NVL(p_val1, l_dummy) &lt;&gt; l_dummy THEN l_ret :&#61; p_val1;&#10;    ELSIF NVL(p_val2, l_dummy) &lt;&gt; l_dummy THEN l_ret :&#61; p_val2;&#10;    ELSIF NVL(p_val3, l_dummy) &lt;&gt; l_dummy THEN l_ret :&#61; p_val3;&#10;    ELSIF NVL(p_val4, l_dummy) &lt;&gt; l_dummy THEN l_ret :&#61; p_val4;&#10;    ELSIF NVL(p_val5, l_dummy) &lt;&gt; l_dummy THEN l_ret :&#61; p_val5;&#10;    ELSIF NVL(p_val6, l_dummy) &lt;&gt; l_dummy THEN l_ret :&#61; p_val6;&#10;    ELSIF NVL(p_val7, l_dummy) &lt;&gt; l_dummy THEN l_ret :&#61; p_val7;&#10;    ELSIF NVL(p_val8, l_dummy) &lt;&gt; l_dummy THEN l_ret :&#61; p_val8;&#10;    ELSIF NVL(p_val9, l_dummy) &lt;&gt; l_dummy THEN l_ret :&#61; p_val9;&#10;    ELSE                          l_ret :&#61; p_val10;&#10;    END IF;&#10;    --&#10;    do_check_nv2_callstack(&#39;N&#39;);&#10;    --&#10;    RETURN l_ret;&#10;END nvl2;&#10;--&#10;FUNCTION nvl2(&#10;    p_val1 t_tab_ORGANISATIONS             , p_val2 t_tab_ORGANISATIONS             , p_val3 t_tab_ORGANISATIONS DEFAULT NULL, p_val4 t_tab_ORGANISATIONS DEFAULT NULL, p_val5 t_tab_ORGANISATIONS DEFAULT NULL,&#10;    p_val6 t_tab_ORGANISATIONS DEFAULT NULL, p_val7 t_tab_ORGANISATIONS DEFAULT NULL, p_val8 t_tab_ORGANISATIONS DEFAULT NULL, p_val9 t_tab_ORGANISATIONS DEFAULT NULL, p_val10 t_tab_ORGANISATIONS DEFAULT NULL)&#10;RETURN t_tab_ORGANISATIONS&#10;IS&#10;    l_ret  t_tab_ORGANISATIONS;&#10;BEGIN&#10;    do_check_nv2_callstack(&#39;Y&#39;);&#10;    --&#10;    IF    p_val1 IS NOT NULL THEN l_ret :&#61; p_val1;&#10;    ELSIF p_val2 IS NOT NULL THEN l_ret :&#61; p_val2;&#10;    ELSIF p_val3 IS NOT NULL THEN l_ret :&#61; p_val3;&#10;    ELSIF p_val4 IS NOT NULL THEN l_ret :&#61; p_val4;&#10;    ELSIF p_val5 IS NOT NULL THEN l_ret :&#61; p_val5;&#10;    ELSIF p_val6 IS NOT NULL THEN l_ret :&#61; p_val6;&#10;    ELSIF p_val7 IS NOT NULL THEN l_ret :&#61; p_val7;&#10;    ELSIF p_val8 IS NOT NULL THEN l_ret :&#61; p_val8;&#10;    ELSIF p_val9 IS NOT NULL THEN l_ret :&#61; p_val9;&#10;    ELSE                          l_ret :&#61; p_val10;&#10;    END IF;&#10;    --&#10;    do_check_nv2_callstack(&#39;N&#39;);&#10;    --&#10;    RETURN l_ret;&#10;END nvl2;&#10;--&#10;FUNCTION nvl2(&#10;    p_val1 t_arr_ORGANISATIONS             , p_val2 t_arr_ORGANISATIONS             , p_val3 t_arr_ORGANISATIONS DEFAULT NULL, p_val4 t_arr_ORGANISATIONS DEFAULT NULL, p_val5  t_arr_ORGANISATIONS DEFAULT NULL,&#10;    p_val6 t_arr_ORGANISATIONS DEFAULT NULL, p_val7 t_arr_ORGANISATIONS DEFAULT NULL, p_val8 t_arr_ORGANISATIONS DEFAULT NULL, p_val9 t_arr_ORGANISATIONS DEFAULT NULL, p_val10 t_arr_ORGANISATIONS DEFAULT NULL)&#10;RETURN t_arr_ORGANISATIONS&#10;IS&#10;    l_ret  t_arr_ORGANISATIONS;&#10;BEGIN&#10;    do_check_nv2_callstack(&#39;Y&#39;);&#10;    --&#10;    IF    p_val1 IS NOT NULL THEN l_ret :&#61; p_val1;&#10;    ELSIF p_val2 IS NOT NULL THEN l_ret :&#61; p_val2;&#10;    ELSIF p_val3 IS NOT NULL THEN l_ret :&#61; p_val3;&#10;    ELSIF p_val4 IS NOT NULL THEN l_ret :&#61; p_val4;&#10;    ELSIF p_val5 IS NOT NULL THEN l_ret :&#61; p_val5;&#10;    ELSIF p_val6 IS NOT NULL THEN l_ret :&#61; p_val6;&#10;    ELSIF p_val7 IS NOT NULL THEN l_ret :&#61; p_val7;&#10;    ELSIF p_val8 IS NOT NULL THEN l_ret :&#61; p_val8;&#10;    ELSIF p_val9 IS NOT NULL THEN l_ret :&#61; p_val9;&#10;    ELSE                          l_ret :&#61; p_val10;&#10;    END IF;&#10;    --&#10;    do_check_nv2_callstack(&#39;N&#39;);&#10;    --&#10;    RETURN l_ret;&#10;END nvl2;&#10;--&#10;FUNCTION get_least(p_val1 DATE, p_val2 DATE, p_val3 DATE DEFAULT NULL)&#10;RETURN DATE IS&#10;    l_ret DATE;&#10;BEGIN&#10;    l_ret :&#61; get_least_priv(p_val1, p_val2);&#10;    l_ret :&#61; get_least_priv(l_ret, p_val3);&#10;    --&#10;    RETURN l_ret;&#10;END get_least;&#10;--&#10;FUNCTION get_greatest(p_val1 DATE, p_val2 DATE, p_val3 DATE DEFAULT NULL)&#10;RETURN DATE IS&#10;    l_ret DATE;&#10;BEGIN&#10;    l_ret :&#61; get_greatest_priv(p_val1, p_val2);&#10;    l_ret :&#61; get_greatest_priv(l_ret, p_val3);&#10;    --&#10;    RETURN l_ret;&#10;END get_greatest;&#10;--&#10;--&#10;--&#10;FUNCTION funcMultisetExcept(p_set1 t_tab_ORGANISATIONS, p_set2 t_tab_ORGANISATIONS) RETURN t_tab_ORGANISATIONS&#10;IS&#10;    TYPE l_tab_TYP IS TABLE OF VARCHAR2(1) INDEX BY VARCHAR2(100);&#10;    l_tab l_tab_TYP;&#10;    --&#10;    l_set t_tab_ORGANISATIONS;&#10;    l_cnt INTEGER :&#61; 0;&#10;BEGIN&#10;    IF p_set1 IS NOT NULL AND p_set2 IS NOT NULL THEN&#10;        --&#10;        FOR l_idx IN 1..p_set2.COUNT LOOP&#10;            l_tab(p_set2(l_idx)) :&#61; &#39;Y&#39;;&#10;        END LOOP;&#10;        --&#10;        l_set :&#61; t_tab_ORGANISATIONS();&#10;        FOR l_idx IN 1..p_set1.COUNT LOOP&#10;            IF NOT l_tab.EXISTS(p_set1(l_idx)) THEN&#10;                l_set.EXTEND;&#10;                l_cnt :&#61; l_cnt + 1;&#10;                l_set(l_cnt) :&#61; p_set1(l_idx);&#10;            END IF;&#10;        END LOOP;&#10;    END IF;&#10;    --&#10;    RETURN l_set;&#10;END funcMultisetExcept;&#10;--&#10;FUNCTION funcMultisetIntersect(p_set1 t_tab_ORGANISATIONS, p_set2 t_tab_ORGANISATIONS) RETURN t_tab_ORGANISATIONS&#10;IS&#10;    l_res t_tab_ORGANISATIONS;&#10;BEGIN&#10;    WITH T AS (&#10;      SELECT * FROM TABLE(p_set1)&#10;      INTERSECT&#10;      SELECT * FROM TABLE(p_set2) )&#10;    SELECT * BULK COLLECT INTO l_res&#10;    FROM T;&#10;    --&#10;    RETURN l_res;&#10;EXCEPTION WHEN NO_DATA_FOUND THEN&#10;    RETURN t_tab_ORGANISATIONS();&#10;END funcMultisetIntersect;&#10;--&#10;FUNCTION funcMultisetIntersectIsEmpty(p_set1 t_tab_ORGANISATIONS, p_set2 t_tab_ORGANISATIONS) RETURN SMALLINT&#10;IS&#10;    lc_TRUE  CONSTANT SMALLINT :&#61; 1;&#10;    lc_FALSE CONSTANT SMALLINT :&#61; 0;&#10;    --&#10;    l_tab  t_tab_ORGANISATIONS;&#10;BEGIN&#10;    --&#10;    l_tab :&#61; funcMultisetIntersect(p_set1, p_set2);&#10;    --&#10;    RETURN (&#10;        CASE&#10;            WHEN l_tab.COUNT &gt; 0&#10;              THEN lc_FALSE&#10;              ELSE lc_TRUE&#10;        END );&#10;    --&#10;EXCEPTION WHEN NO_DATA_FOUND THEN&#10;    RETURN lc_TRUE;&#10;END funcMultisetIntersectIsEmpty;&#10;&#10;FUNCTION compare_vals(p_val1 SMALLINT, p_val2 BOOLEAN) RETURN BOOLEAN&#10;IS&#10;BEGIN&#10;    RETURN ( (CASE WHEN p_val1 &#61; 1 THEN &#39;Y&#39; ELSE &#39;N&#39; END) &#61; (CASE WHEN p_val2 THEN &#39;Y&#39; ELSE &#39;N&#39; END) );&#10;END compare_vals;&#10;--&#10;FUNCTION compare_vals(p_val1 BOOLEAN, p_val2 SMALLINT) RETURN BOOLEAN&#10;IS&#10;BEGIN&#10;    RETURN ( (CASE WHEN p_val1 THEN &#39;Y&#39; ELSE &#39;N&#39; END) &#61; (CASE WHEN p_val2 &#61; 1 THEN &#39;Y&#39; ELSE &#39;N&#39; END) );&#10;END compare_vals;&#10;--&#10;FUNCTION get_session_name RETURN VARCHAR2 IS&#10;BEGIN&#10;    -- ORA&#10;    RETURN SYS_CONTEXT(&#39;USERENV&#39;, &#39;CLIENT_INFO&#39;);&#10;    --RETURN REPLACE(SYS._UNIQUE_SESSION_NAME, &#39;$&#39;, &#39;_&#39;);&#10;END get_session_name;&#10;--&#10;FUNCTION get_session_id RETURN VARCHAR2 IS&#10;BEGIN&#10;    -- ORA&#10;    RETURN SYS_CONTEXT(&#39;USERENV&#39;, &#39;SID&#39;);&#10;    -- PG&#10;    --RETURN RTRIM(SUBSTR(SYS._UNIQUE_SESSION_NAME, INSTR(SYS._UNIQUE_SESSION_NAME, &#39;$&#39;, 1)+1), &#39;$&#39;);&#10;END get_session_id;&#10;--&#10;FUNCTION bin2dec (binval IN CHAR) RETURN NUMBER&#10;IS&#10;  i                 NUMBER;&#10;  digits            NUMBER;&#10;  result            NUMBER :&#61; 0;&#10;  current_digit     CHAR(1);&#10;  current_digit_dec NUMBER;&#10;BEGIN&#10;  digits :&#61; LENGTH(binval);&#10;  FOR i IN 1..digits&#10;  LOOP&#10;     current_digit :&#61; SUBSTR(binval, i, 1);&#10;     current_digit_dec :&#61; TO_NUMBER(current_digit);&#10;     result :&#61; (result * 2) + current_digit_dec;&#10;  END LOOP;&#10;  RETURN result;&#10;END bin2dec;&#10;--&#10;FUNCTION dec2bin (N IN NUMBER) RETURN VARCHAR2&#10;IS&#10;  binval VARCHAR2(64);&#10;  N2     NUMBER :&#61; N;&#10;BEGIN&#10;  WHILE ( N2 &gt; 0 )&#10;  LOOP&#10;     binval :&#61; MOD(N2, 2) || binval;&#10;     N2 :&#61; TRUNC( N2 / 2 );&#10;  END loop;&#10;  RETURN binval;&#10;END dec2bin;&#10;--&#10;--&#10;/*&#10;FUNCTION regexp_like(p_string VARCHAR2, p_pattern VARCHAR2, p_opt VARCHAR2) RETURN BOOLEAN&#10;DETERMINISTIC&#10;AS&#10;    l_cnt NUMBER;&#10;BEGIN&#10;    --&#10;    SELECT COUNT(1) INTO l_cnt&#10;    FROM ( SELECT regexp_matches(p_string, p_pattern, p_opt || &#39;g&#39;) );&#10;    --&#10;    --dbms_output.put_line(&#39;l_cnt&#61;&#39; || l_cnt);&#10;    --&#10;    RETURN ( l_cnt &gt; 0 );&#10;END regexp_like;&#10;*/&#10;&#10;--&#10;--&#10;--&#10;--&#10;--&#10;BEGIN&#10;--&#10;--&#10;    PKG_Global.do_init;&#10;--&#10;--&#10;END PKG_Common;</textarea>
                        </div>
                    </div>
                </section>
            </div>
            <!-- /.content-wrapper -->
            <footer class="main-footer">
                <div>
                    <div class="pull-right hidden-xs">
                        <a href="https://github.com/schemaspy/schemaspy" title="GitHub for SchemaSpy"><i class="fa fa-github-square fa-2x"></i></a>
                        <a href="http://stackoverflow.com/questions/tagged/schemaspy" title="StackOverflow for SchemaSpy"><i class="fa fa-stack-overflow fa-2x"></i></a>
                    </div>
                    <strong>Generated by <a href="http://schemaspy.org/" class="logo-text"><i class="fa fa-database"></i> SchemaSpy 6.2.4</a></strong>
                </div>
                <!-- /.container -->
            </footer>
        </div>
        <!-- ./wrapper -->

        <!-- jQuery 2.2.3 -->
        <script src="../bower/admin-lte/plugins/jQuery/jquery-2.2.3.min.js"></script>
        <script src="../bower/admin-lte/plugins/jQueryUI/jquery-ui.min.js"></script>
        <!-- Bootstrap 3.3.5 -->
        <script src="../bower/admin-lte/bootstrap/js/bootstrap.min.js"></script>
        <!-- DataTables -->
        <script src="../bower/datatables.net/jquery.dataTables.min.js"></script>
        <script src="../bower/datatables.net-bs/js/dataTables.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/dataTables.buttons.min.js"></script>
        <script src="../bower/datatables.net-buttons-bs/js/buttons.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.html5.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.print.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.colVis.min.js"></script>
        <!-- SheetJS -->
        <script src="../bower/js-xlsx/xlsx.full.min.js"></script>
        <!-- pdfmake -->
        <script src="../bower/pdfmake/pdfmake.min.js"></script>
        <script src="../bower/pdfmake/vfs_fonts.js"></script>
        <!-- SlimScroll -->
        <script src="../bower/admin-lte/plugins/slimScroll/jquery.slimscroll.min.js"></script>
        <!-- FastClick -->
        <script src="../bower/admin-lte/plugins/fastclick/fastclick.js"></script>
        <!-- Salvattore -->
        <script src="../bower/salvattore/salvattore.min.js"></script>
        <!-- AnchorJS -->
        <script src="../bower/anchor-js/anchor.min.js"></script>
        <!-- CodeMirror -->
        <script src="../bower/codemirror/codemirror.js"></script>
        <script src="../bower/codemirror/sql.js"></script>
        <!-- AdminLTE App -->
        <script src="../bower/admin-lte/dist/js/app.min.js"></script>
        <script src="routine.js"></script>
        <script src="../schemaSpy.js"></script>
    </body>
</html>