input {
    sqs {
        id => "poll-for-changes"
        queue => "${CONTACT_SQS_QUEUE_NAME}"
        endpoint => "${SQS_ENDPOINT:https://sqs.eu-west-2.amazonaws.com}"
        region => "eu-west-2"
    }
}

filter {
    json {
        id => "parse-nested-json"
        source => "Message"
    }
    mutate { add_field => { "[@metadata][crn_lowercase]" => "%{crn}" } }
    mutate { lowercase => [ "[@metadata][crn_lowercase]" ] }
    http {
        id => "check-semantic-index-exists"
        url => "${SEARCH_INDEX_HOST}/contact-semantic-search-%{[@metadata][crn_lowercase]}"
        verb => "HEAD"
        target_body => "[@metadata][semantic_index_check_response_body]"
    }
    mutate { add_field => { "[@metadata][semantic_index_check]" => "%{tags}" } }
    mutate { remove_field => ["tags"] }
    # If CRN-specific index does not exist, create and populate it
    if ("_httprequestfailure" in [@metadata][semantic_index_check]) {
        # Create the index
        http {
            id => "create-semantic-index"
            url => "${SEARCH_INDEX_HOST}/contact-semantic-search-%{[@metadata][crn_lowercase]}"
            verb => "PUT"
            target_body => "[@metadata][semantic_index_creation_response_body]"
        }
        # Ignore failures creating the index - this can happen when processing two events for the same CRN
        mutate { remove_field => ["tags"] }
        # Get all contact ids for CRN
        jdbc_streaming {
            id => "load-all-contact-ids-for-crn"
            jdbc_driver_library => "/etc/logstash/ojdbc11.jar"
            jdbc_driver_class => "Java::oracle.jdbc.driver.OracleDriver"
            jdbc_connection_string => "${JDBC_CONNECTION_STRING}"
            jdbc_user => "${JDBC_USER}"
            jdbc_password => "${JDBC_PASSWORD}"
            jdbc_validate_connection => true
            jdbc_validation_timeout => 120
            statement => "
                select contact_id
                from contact join offender on offender.offender_id = contact.offender_id
                where crn = ? and contact.soft_deleted = 0
            "
            use_prepared_statements => true
            prepared_statement_name => "search_indexer_contact_incremental_ids"
            prepared_statement_bind_values => ["%{crn}"]
            target => "contact_ids"
            tag_on_default_use => []
        }
        # Split contact ids into separate events
        split {
            id => "split-contact-ids"
            field => "contact_ids"
        }
        mutate { remove_field => [ "sourceId" ] }
        mutate { add_field => { "sourceId" => "%{[contact_ids][contact_id]}" } }
        mutate { convert => { "sourceId" => "integer" } }
        # Continue down the pipeline for each contact id...
    }
     jdbc_streaming {
         id => "load-db-record"
         jdbc_driver_library => "/etc/logstash/ojdbc11.jar"
         jdbc_driver_class => "Java::oracle.jdbc.driver.OracleDriver"
         jdbc_connection_string => "${JDBC_CONNECTION_STRING}"
         jdbc_user => "${JDBC_USER}"
         jdbc_password => "${JDBC_PASSWORD}"
         jdbc_validate_connection => true
         jdbc_validation_timeout => 120
         statement => "${INCREMENTAL_STATEMENT_SQL}"
         use_prepared_statements => true
         prepared_statement_name => "search_indexer_contact_incremental"
         prepared_statement_bind_values => ["%{sourceId}", "%{sourceId}", "%{sourceId}", "%{sourceId}"]
         target => "db"
         tag_on_default_use => []
     }
     prune { whitelist_names => ["sourceId", "db", "tags", "Message"] }
     if [db][0][json] {
         json {
             id => "parse-db-json"
             source => "[db][0][json]"
         }
         mutate { add_field => { "[@metadata][action]" => "index" } }
     } else {
         mutate { add_field => { "[@metadata][action]" => "delete" } }
     }
     if ![tags] or ![tags][0] {
         mutate { remove_field => ["db", "Message", "MessageAttributes"] }
     }
}

output {
    if ![tags] or ![tags][0] {
        opensearch {
            id => "index-into-primary"
            hosts => ["${SEARCH_INDEX_HOST}"]
            index => "${CONTACT_INDEX_PREFIX}-primary"
            document_id => "%{sourceId}"
            action => "%{[@metadata][action]}"
            validate_after_inactivity => 0
        }
        opensearch {
            id => "index-into-standby"
            hosts => ["${SEARCH_INDEX_HOST}"]
            index => "${CONTACT_INDEX_PREFIX}-standby"
            document_id => "%{sourceId}"
            action => "%{[@metadata][action]}"
            validate_after_inactivity => 0
        }
        opensearch {
            id => "index-into-semantic-search"
            hosts => ["${SEARCH_INDEX_HOST}"]
            index => "contact-semantic-search-%{[@metadata][crn_lowercase]}"
            document_id => "%{sourceId}"
            action => "%{[@metadata][action]}"
            validate_after_inactivity => 0
        }
    } else {
        stdout {
            id => "log-failure"
            codec => "json"
        }
    }
}